---
title: Interview-Review
tags:
  - 面试
date: 2020-03-25
top: true
---

面试复习内容主要分为以下几个部分：

* [Android](#android)
* [Java基础](#Java基础)
* [计算机网络](#计算机网络)
* [操作系统](#操作系统)
* [数据库](#数据库)
* [数据结构](#数据结构)
* [算法面试](#算法面试)

<!-- more -->

## Android

Android主要分为以下几个部分：

* [Activity](#Activity)
* [Fragment](#Fragment)
* [Service](Service)
* [Broadcast Receiver](#broadcastreceiver)
* [Content Provider](#contentprovider)
* [数据存储](#数据存储)
* [Bitmap](#bitmap)
* [Handler](#handler)
* [AsyncTask](#asynctask)
* [View](#view)
* [Animation](#animation)
* [Window](#window)
* [布局](#布局)
* [事件](#事件)
* [设计模式](#设计模式)

### Activity

#### Activity生命周期

* 启动Activity：`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`，进入运行状态；
* Activity退居后台（Home或者启动了新的Activity）：`onPause()`$\longrightarrow$`onStop()`；
* Activity返回前台：`onRestart()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`;
* 如果Acitivity后台期间内存不足，再次启动时就会重新执行启动流程；
* 锁屏：`onPause()`$\longrightarrow$`onStop()`；
* 解锁：`onStart()`$\longrightarrow$`onResume()`；

**具体方法介绍**：
* `onCreate()`：在每个Activity中都会重写这个方法，它会在活动第一次被创建的时候调用；
* `onStart()`：这个方法由不可见变为可见时调用；
* `onResume()`：这个方法在Activity准备好和用户进行交互时调用。**此时的活动肯定位于活动返回栈的栈顶，并且处于运行状态；
* `onPause()`：这个方法是当系统准备启动或者恢复另一个活动的时候调用。通常会在这个方法里释放一些非常消耗CPU的资源等；
* `onStop()`：这个方法在完全不可见的时候调用；
* `onDestroy()`：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态；
* `onRestart()`：这个方法在活动由停止状态变为运行状态之前调用，即活动被重新启动了

![](https://s1.ax1x.com/2020/05/01/JO9941.png)

**三个时期**：

* **完整生存期**：活动在`onCreate()`到`onDestroy()`方法之间所经历的就是**完整生存期**。一般情况下，一个活动会在`onCreate()`方法中完成各种初始化操作，而在`onDestroy()`方法中完成释放内存的操作；
* **可见生存期**：活动在`onStart()`到`onStop()`方法之间所经历的就是**可见生存期**。**可见生存期的**的意思就是活动对于用户总是可见的（即使有可能与用户无法交互）；
* **前台生存期**：活动在`onResume()`和`onPause()`方法之间的就是时期就是**前台生存期**。在**前台生存期**内，活动总是处于运行状态的，即此时的活动是可以和用户进行交互的。

##### 横竖屏切换时Activity的生命周期变化

这需要判断`AndroidManifest.xml`中是否设置了`configChanges`属性。而`configChanges`常用的属性有：
* `orientation`：屏幕在纵向和横向间旋转
* `keyboardHidden`：键盘显示或者隐藏
* `screenSize`：屏幕大小改变了

**`AndroidManifest`没有设置`configChanges`属性**

如果是从**竖屏启动切换横屏**：

**竖屏启动**：`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`**切换横屏**：`onPause()`$\longrightarrow$`onSavedInstanceState()`$\longrightarrow$`onStop()`$\longrightarrow$`onDestroy()`$\longrightarrow$`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onRestoreInstanceState()`$\longrightarrow$`onResume()`$\longrightarrow$`onPause()`$\longrightarrow$`onStop()`$\longrightarrow$`onDestroy()`（Android6.0、7.0、8.0适用）

如果是从**横屏启动切换竖屏**：

生命周期与**从竖屏启动切换横屏一样**。

**总结**：如果没有设置`configChanges`属性的话，在Android6.0、7.0、8.0的手机上表现是一样的。首先是正常地走一遍流程（在`onPause()`之后会有`onSavedInstanceState()`），然后重新创建之后在`onStart()`之后会有`onRestoreInstanceState()`。

**`AndroidManifest`设置了`android:configChanges="orientation"`**

如果是从**竖屏启动切换横屏**：

**Android 6.0 竖屏启动**：`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`**切换横屏**：`onPause()`$\longrightarrow$`onSavedInstanceState()`$\longrightarrow$`onStop()`$\longrightarrow$`onDestroy()`$\longrightarrow$`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onRestoreInstanceState()`$\longrightarrow$`onResume()`$\longrightarrow$`onPause()`$\longrightarrow$`onStop()`$\longrightarrow$`onDestory()`

**Android 7.0 竖屏启动**：`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`**切换横屏**：`onConfigurationChanged()`$\longrightarrow$`onPause()`$\longrightarrow$`onSavedInstanceState()`$\longrightarrow$`onStop()`$\longrightarrow$`onDestroy()`$\longrightarrow$`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onRestoreInstanceState()`$\longrightarrow$`onResume()`$\longrightarrow$`onPause()`$\longrightarrow$`onStop()`$\longrightarrow$`onDestroy()`

**Android 8.0 竖屏启动**：`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`**切换横屏**：`onConfigurationChanged()`

**总结**：在设置了`configChanges`属性为`orientation`之后，Android 6.0的生命周期与没有设置是一样的。而Android 7.0则会先多回调一个`onConfigurationChanged()`方法，剩下的流程一样。Android 8.0则只是回调了`onConfigurationChanged()`方法，并没有走Activity生命周期的方法。

如果是从**横屏启动切换竖屏**：

生命周期与**从竖屏启动切换横屏一样**。

`AndroidManifest`设置了`android:configChanges="orientation|keyboardHidden|screenSize"`

**竖屏启动**：`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`**切换横屏**：`onConfigurationChanged()`（Android6.0、7.0、8.0适用）

**总结**：当设置了`android:configChanges="orientation|keyboardHidden|screenSize`时，就不会调用Activity其它生命周期的方法，只会调用`onConfigurationChanged()`方法。

**`AndroidManifest`设置了`android:configChanges="orientation|screenSize"`**

与`orientation|keyboardHidden|screenSize`相同，只回调`onConfigurationChanged()`方法。

**`AndroidManifest`设置了`android:configChanges="orientation|ke yboardHidden"`**

与只设置了`orientation`的相同，Android 6.0、7.0会回调生命周期的方法，Android 8.0则只回调`onConfigurationChanged()`方法。

**总结（不同手机系统系统可能会有略微差异）**

1. 不设置`configChanges`属性是不会回调`onConfigurationChanged()`方法的，且切屏的时候会回调生命周期的方法；
2. 只有设置了`orientation`和`screenSize`才会保证不会调用生命周期的方法，且切屏的时候只会回调`onConfigurationChanged()`方法；
3. 如果设置了`orientation`而没有设置`screenSize`，那么切屏就会调用`onConfigurationChanged()`方法，但仍然会走生命周期；

##### Activity A启动了Activity B，它们的生命周期的变化

1. **启动Activity A**

   `onCreate()`创建活动A，`onStart()`显示在屏幕上，`onResume()`处于运行状态；

2. **在Activity A中启动Activity B**

   活动A被暂停，使用`onPause()`进入暂停状态；`onCreate()`创建活动吧B，`onStart()`显示活动B在屏幕上，`onResume()`让活动B进入运行状态；活动A经过`onStop()`进入停止状态；

3. **从Activity B中返回Activity A（比如按物理返回键）**

   活动B用`onPause()`方法进入暂停状态；活动A被重启，使用`onRestart()`方法从停止状态进入活动状态，调用`onStart()`方法使活动A显示在屏幕上，`onResume()`方法进入运行状态；活动B被`onStop()`方法进入停止状态，最后使用`onDestroy()`方法销毁；

4. **继续按物理返回键**

   活动A用`onPause()`方法暂停，然后用`onStop()`方法停止，最后用`onDestroy()`方法被销毁；

##### `onSaveInstanceState`和`onRestoreInstanceState`调用的过程和时机

* **调用时机**：Activity的异常情况下（例如转动屏幕或者被系统回收）的情况下，会调用到`onSaveInstanceState`和`onRestoreInstanceState`。如果是单独按Home或者启动新Activity仍然会单独触发`onSaveInstanceState`调用。
* **调用过程**：在**异常情况**下，会在**调用`onStop()`方法之前，调用`onSaveInstanceState`方法保存；而新的Activity重建时，就可以通过`onRestoreInstanceState`方法取出之前保存的数据并恢复，`onRestoreInstanceState`的调用时机在`onCreate()`之后。

##### 优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态

#### Activity四种启动模式

##### standard标准模式

是默认启动的模式，每次都会新创建一个实例对象；每次发送的Intent都会创建一个新的Activity（`onCreate()`$\longrightarrow$`onStart()`$\longrightarrow$`onResume()`），并且将其放入返回栈栈顶。这样每次都新建一个实例的话太浪费。

##### singleTop栈顶复用模式

如果在返回栈顶发现了相同的实例则重用，不会新建；否则就新建并压入栈顶；同时Activity的`onNewIntent()`方法会被回调。在这个模式下，我们必须同时在`onCreate()`和`onNewIntent()`两个方法中处理好传入的Intent

##### singleTask栈内复用模式

如果在整个返回栈中发现了相同的实例，就将其最上面的任务终止并移除，重用该实例，同时回调`onNewIntent()`方法；否则新建实例并压入栈；

##### singleInstance单实例模式

允许不同的应用，进程线程等共用一个实例，无论如何应用调用该实例都会重用；即持有这个Activity的Task不能再有其它Activity的实例了；

例如，如果从这个Activity中启动另外一个不同的Activity，将会自动创建一个新的Task来存放新的Activity；如果从一个已经存在许多Activity的的Task中调用启动模式是`singleInstance`的Activity，这个新的Activity同样会被放在一个新的Task中。

##### `onNewIntent()`调用时机

如果一个Activity的启动模式是`singleTop`、`singleTask`、`singleInstance`，在复用Activity时就会在调用`onStart()`方法之前调用`onNewIntent()`方法。**作用**就是让已经创建的Activity处理新的Intent。

##### Activity的启动过程

### Fragment

#### Fragment的生命周期

![](https://s1.ax1x.com/2020/05/01/JOCbOU.png)

**具体方法介绍**：

1. `onAttach()`：完成Fragment与Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作；
2. `onCreate()`：完成Fragment的初始化；
3. `onCreateView()`：加载View布局，绑定布局文件；
4. `onActivityCreated()`：与Fragment绑定的Activity已经执行完成了`onCreate()`，可以与Activity进行交互操作；
5. `onStart()`：Fragment变为可见状态；
6. `onResume()`：Fragment变为可交互状态；
7. `onPause()`：Fragment变为不可交互状态（不代表是不可见）；
8. `onSaveInstanceState()`：保存当前Fragment的状态，记录一些数据；
9. `onStop()`：Fragment变为不可见状态；
10. `onDestroyView()`：销毁Fragment的有关视图，但并未和Activity解绑，还可以通过`onCreateView()`重新创建视图；
11. `onDestroy()`：销毁Fragment时调用；
12. `onDetach()`：解除和Activity的绑定，是Fragment销毁的最后一步。

添加Fragment可以分为**静态添加**和**动态添加***两类。**静态添加**是指在XML中直接Fragment，缺点是添加之后不能删除。一般推荐是在代码中FragmentManager中使用一系列的`FragmentTransaction`事务操作动态控制。
* add
* remove
* show
* hide
* replace
* replace+addToBackStack
* detach

#### Activity与Fragment的异同

* 相同点：Activity与Fragment都可以包含布局，都有自己的生命周期；
* 不同点：因为Fragment是依附在Activity上的，多了一些和宿主Activity相关的生命周期方法，例如`onAttch()`、`onActivityCreated()`、`onDetach()`等；Fragment的生命周期方法都是由宿主Activity而不是由操作系统调用的，Activity中的生命周期方法都是是`protected`，而Fragment的生命周期方法都是`public`，因为Activity需要调用Fragment这些方法并管理它。

#### Activity和Fragment的关系

* Fragment的出现是为了解决Android碎片化，可以作为Activity界面的组成部分，可以在Activity运行中实现动态地加入、移除和交换；
* 一个Activity可以同时出现多个Fragment，而一个Fragment也可以在多个Activity中使用；
* Activity中的`FragmentManager`负责调用队列中Fragment的生命周期方法；

### Service

#### Service的两种启动方式和生命周期

Service有两种启动方式，一种是通过`startService()`来启动的，另一种是通过`bindService()`来启动的；

![](https://s1.ax1x.com/2020/05/01/JO9lgf.png)

##### 通过`startService()`来启动（各自飞）

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2018053114134692.jpg)

**使用方法**：

1. 定义一个类，并继承Service
2. 在`AndroidManifest.xml`文件中配置此Service
3. 使用Context的`startService(Intent)`方法来启动此Service
4. 不使用该服务时，调用`stopService(Intent)`方法停止此Service（当使用IntentService时调用`stopSelf`方法）

> 如果服务已经开启，就不会重复地执行`onCreate()`方法，而是调用`onStart()`或者`onStartCommand()`方法。服务停止时就调用`onDestroy()`方法。

**特点**：

* 一旦服务开启了，就与开启者没有任何关系了
* 开启者退出之后，服务还是可以在后台长期运行的（前提是没有调用`stopService(Intent)方法`）
* 开启者不能调用服务里面的方法

##### 通过`bindService()`来启动（共存亡）

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20180531142740474.jpg)

**使用方法**：
1. 定义一个类，并继承Service
2. 在`AndroidManifest.xml`文件中配置此Service
3. 使用Context的`bindService(Intent, ServiceConnection, int)方法来启动此Service`
4. 不使用该服务时，调用`unbindService(ServiceConnection)方法停止此Service`

> 绑定服务是不会调用`onStart()`或者`onStartCommand()`方法的。

**特点**：
* 使用`onBind()`的方式开启服务绑定服务，如果调用者销毁，服务也会被销毁
* 绑定者可以调用服务内部的方法

##### 如果一个Service既被`startService()`启动又被`bindService()`启动，生命周期是怎么样的（或者问如何把Service停止）

1. `startService()`和`bindService()`可以同时启动同一Service，执行时会回调对应的`onStartCommand()`或者`onBind()`方法，但是`onCreate()`方法只会被执行一次，不会被重复执行；
2. 在停止Service时，既需要调用`stopService()`方法，又需要调用`unBindService()`方法，没有先后顺序要求，只有两个方法都执行完毕之后，才会执行Service的`onDestroy()`方法，`onDestroy()`方法只会被执行一次（最后一个`stopService`或者`unBindService`方法会导致Service执行`onDestroy()`）。

##### Service的生命方法运行在哪个线程中

Service默认运行在主线程中，所以其生命方法也是运行在主线程中。如果需要在Service中进行耗时的操作，那必须另起线程或者使用IntentService，否则会引起ANR。

#### IntentService与Service的区别

* Service默认运行在主线程中，如果需要耗时的操作，就必须开启子线程；而IntentService可用于长时间的任务，通常不会与主线程通信。如果需要通信，可以使用主线程处理程序或者广播意图。另一种使用情况是需要回调（意图触发任务）。
* Service是由`startService()`方法触发，而IntentService是使用Intent触发的，产生了一个新的工作线程，并且在这个线程上调用了`onHandlerIntent()`方法。
* Service和IntentService可以从任何线程，活动或其它应用程序组件中触发
* Service在后台运行，但是是在应用程序的主线程运行；IntentService在单独的工程线程中运行；
* Service可能会阻止应用程序的主线程；IntentService不能并行执行任务，所以所有连续的Intent都将进入工程线程的消息队列并将按顺序执行；
* 如果使用Service，是调用`stopSelf()`或者`stopService()`来结束它的工作；而IntentService会在处理完所有启动请求后停止服务，不必调用方法；

**IntentService的优点**：
* 会创建独立的工作线程来处理所有的Intent请求；
* 会创建独立的工作线程来处理`onHandleIntent()`方法实现的代码，无需处理多线程问题；
* 在所有请求处理完成后，IntentService会自动停止；
* 为Service的`onBind()`方法提供默认实现，返回`null`；
* 为Service的`onStartCommand()`方法提供默认实现，将请求Intent添加到队列中；
* IntentService不会阻塞UI线程；
* IntentService若未执行完成上一次的任务，不会重新开启一个线程，而是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用`stopSelf()`方法

#### 如何保证Service不被杀死（如何提高Service的优先级）

1. **在`onStartCommand()`方法中返回`START_STICKY`**。这种情况下，当内存不足需要回收该Service时，系统会将该Service标记为`started`状态，并在合适的时机重新调用`onStartCommand()`方法重新启动该Service，这种情况下不会保留`onStartCommand()`方法中的`intent`对象（`intent`对象为`null`）。如果需要在重启Service时保留`onStartCommand()`中的`intent`对象，就可以返回`START_REDELIVER_INTENT`，此时则会保留`intent`最近一次的值，并传入到`onStartCommand()`方法中。
2. **提高该Service在所有Service中的优先级**。可以在`AndroidManifest.xml`中为每一个Service都配置一个优先级`android:priority`，数值越大，优先级就越高。
3. **将Service设置为前台Service**。因为Service是默认在后台运行的，但调用`Service.startForeground()`就可以将该Service设置为前台Service，从而提高Service的优先级。当系统的进程空间紧张时，会按照进程优先级依次回收，Android系统的进程优先级如下：
   1. 前台进程（foreground_app）
   2. 可见进程（visible_app）
   3. 次要服务进程（secondary_app）
   4. 后台进程（hidden_app）
   5. 内容提供者进程（content_provider）
   6. 空进程（empty_app）
4. **在Service的`onDestroy()`方法里发送一个自定义广播**，在广播的`onReceiver()`里重新启动该Service。
5. **监听开机广播，开机时自动启动Service**。

#### Service与Activity如何实现通信

可以通过`bindService()`的方式。先在Activity里实现一个ServiceConnection接口，并将该接口传递给`bindService()`方法，在ServiceConnection接口的`onServiceConnected()`方法里执行相关操作。

#### 常用的系统Service

|       传入的Name        |     返回的对象      |          说明          |
| :---------------------: | :-----------------: | :--------------------: |
|     WINDOW_SERVICE      |    WindowManager    |   管理打开的窗口程序   |
| LAYOUT_INFLATER_SERVICE |   LayoutInflater    |  取得XML里定义的View   |
|    ACTIVITY_SERVICE     |   ActivityManager   | 管理应用程序的系统状态 |
|      POWER_SERVICE      |    PowerManager     |        电源服务        |
|      ALARM_SERVICE      |    AlarmManager     |        闹钟服务        |
|  NOTIFICATION_SERVICE   | NotificationManager |       状态栏服务       |
|    KEYGUARD_SERVICE     |   KeyguardManager   |       键盘锁服务       |

### BroadcastReceiver

> 广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。例如，在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接受系统的广播让应用程序作出相应的处理。

#### 动态注册和静态注册的区别

* **静态注册**：在`AndroidManifest.xml`中进行注册。常驻系统，不受组件生命周期的影响。即便应用退出了，广播还是可以被接收、耗电、占内存等；
* **动态注册**：在代码中使用`IntentFilter`进行注册。非常驻系统，跟随组件的生命变化，组件结束了广播就结束了。在组件结束前，需要先移除广播，否则容易造成内存泄漏。动态注册的广播永远要快于静态注册的广播，不论静态注册的优先级多高。

#### 广播的各种形式

* **普通广播**：使用`sendBroadcast()`发送，是最常用的广播。一种**完全异步**执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接受到这条广播信息，因此它们接受的先后是随机的；
* **有序广播**：使用`sendOrderedBroadcast()`，发送出去的广播会被接收者按照顺序接收，而广播接收者按照优先级Priority属性值从大到小排序（优先级相同，则动态注册的广播优先）。是一种**同步执行**的广播，在广播发出之后，同一时刻就只有一个广播接收器能够收到这条广播信息；
* **本地广播**：发出的广播只能够在应用程序的**内部**进行传递，并且广播接收器也只能本应用程序发出的广播；
* **粘性广播**：这种类型的广播会一直逗留，当有匹配该广播的接收器被注册后，该接收器就会收到这条广播。

### ContentProvider

> ContentProvider（内容提供者）是Android的四大组件之一，管理Android以结构化的方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口给**其它应用程序**调用。不同的应用程序之间进行数据共享，它还可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄漏风险。

* ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做**进程间数据共享**。
* ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。
* ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。

### 数据存储

#### Android中提供哪些数据持久存储的方法

* 文件存储
* SharedPreference存储
* 数据库存储
* ContentProvider存储
* 网络存储

##### 文件存储

文件存储是通过文件的方式将数据不做任何处理的存储进文件系统中，适合一些简单的文本数据或者二进制数据。主要是通过文件IO流的存储提供了`FileInputStream()`和`FileOutputStream()`方法来存储和提取文件中的数据。

##### SharedPreferences存储

SharedPreferences的存储数据和读取数据十分简单，提供了`get`和`put`方法。

##### 数据库存储

Android自身就支持SQLite这种轻量级的数据库。

##### ContentProvider存储

##### 网络存储

#### SharedPreferences适用情形？使用中需要注意什么？

#### SQLite的事务处理？是如何做的？

### Bitmap

#### 图片框架的三级缓存机制

1. **内存缓存**（优先加载，速度最快）：首次加载的时候通过网络加载，获取图片，然后保存到内存中和本地中；之后运行时，优先访问内存中的图片缓存；
2. **本地缓存**（次优先加载，速度快）：如果内存中没有，则访问本地的图片；
3. **网络缓存**（最后加载，速度慢，浪费流量）：如果本地还没有，就有可能是第一次访问，所以进行网络请求；

**三级缓存的原理**：内存作为一级缓存，本地作为二级缓存，网络加载为最后。其中，内存使用LruCache，其内部通过`LinkedHashMap`来持有外界缓存对象的强引用；对于本地缓存，使用DiskLruCache。而加载图片的时候，首先使用LRU方式进行寻找，找不到指定内容，就按照三级缓存的策略，再进行本地搜索，最后进行网络加载。

#### LRU算法的原理

LRU（Least Recently Used）算法的核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。主要是通过两种方式：

* LruCache（内存缓存）：LruCache类是一个线程安全的泛型类：内部采用一个`LinkedHashMap`以强引用的方式存储外界的缓存对象，并提高`get`和`put`方法来完成缓存的获取和添加操作，当缓存满了就会移除较早使用的缓存对象，再添加新的
* DiskLruCache（磁盘缓存）：通过将缓存对象写入文件系统从而实现缓存效果

#### Android中缓存更新策略

### Handler

* 主线程（UI线程）：当程序第一次启动时，Android会同时启动一个主线程，主要负责处理与UI系相关的事件；
* Message：Handler用来接收和处理的消息对象（Bean对象），作用是通信时相关信息的存放和传递；
* ThreadLocal：是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。作用简要来说就是负责存储和获取本线程的Looper；
* MessageQueue：采用单链表的数据结构来存储消息列表，用来存放通过Handler发送过来的Message，按照先进先出的方式执行；
* Handler：就是Message的主要处理者，负责发送Message到消息队列和处理Looper分派过来的Message；
* Looper：扮演Message Queue和Handler之间的一个桥梁的角色。它循环取出Message Queue中的Message，将取出的Message交付给相应的Handler；

#### Handler消息传递机制

#### 一个Thread可以有几个Looper？几个Handler？

#### 如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？

#### 为什么在子线程中创建Handler会抛出异常

#### 主线程的Looper是轮询死循环为何没有阻塞主线程

#### 使用Handler的`postDelay()`后消息队列会发生什么变化

#### Message可以如何创建？哪种效果更好，为什么？

### AsyncTask

#### AsyncTask相比Handler有什么优点和缺点

#### 使用AsyncTask需要注意什么

#### AsyncTask中使用的线程池大小

#### HandlerThread有什么特点

#### 快速实现子线程使用Handler

#### 线程池的好处、原理、类型

#### ThreadPoolExecutor的工作策略

### View

#### View的绘制流程

1. 测量——`onMeasure()`：决定View的大小
2. 布局——`onLayout()`：决定View在ViewGroup中的位置
3. 绘制——`onDraw()`：绘制这个View

#### 自定义View（需要注意什么）

##### 实现步骤

* 继承View类或者其子类
* 重写View中的一些函数
* 为自定义View类增加属性（两种方式）
* 绘制控件（导入布局）
* 响应用户事件
* 定义回调函数


#### View的滑动方式

##### 通过View本身提供的`scrollTo`/`scrollBy`方法

这个方法移动的是View的内容，而View本身不移动。

`scrollTo`和`scrollBy`也是有区别的。`scrollBy`内部调用了`scrollTo`，它是基于当前位置的**相对滑动**；而`scrollTo`是**绝对滑动**，因此如果利用相同输入参数多次调用`scrollTo()`方法，由于View初始位置是不变的，只会出现一次View滚动的效果而不是多次的。

##### 通过动画给View施加平移效果实现滑动

只是通过动画的方式移动View的影像，然而View本身位置不发生改变

##### 通过改变View的LayoutParams使View重新布局实现滑动

```Java
MarginLayoutParams params = mButton.getLayoutParams();
params.width += 10;
params.height += 10;
mButton.requestLayout();
mButton.setLayoutParams(params);
```

##### 三种方法的使用对比

* `scrollTo`/`scrollBy`：操作简单，适合对View内容的滑动；
* 动画：操作简单，主要适合于没有交互的View和实现复杂的动画效果；
* 改变布局参数：操作稍微复杂，适合有交互的View

##### 如何解决View的滑动冲突

首先判断是什么原因引起的View滑动冲突。

* 对于由于外部滑动和内部滑动**方向不一致**导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件；
* 对于由于外部滑动方向和内部滑动**方向一致**导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件何时让内部View拦截事件；

* **外部拦截法**：时间都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截；具体方法需要重写父容器的`onInterceptTouchEvent`方法，在内部做出相应的拦截；
* **内部拦截法**：父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法是配合`requestDisallowInterceptTouchEvent`方法。

#### View的事件分发机制

事件的分发机制由三个重要想法来共同完成：`dispatchTouchEvent`、`onInterceptTouchEvent`、`onTouchEvent`。

* **事件分发**：`public boolean dispatchTouchEvent(MotionEvent event)`

    用来进行事件的**分发（传递）**。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前的`onTouchEvent`和下级View的`dispatchTouchEvent`影响，表示是否消耗了当前事件；

* **事件拦截**：`public boolean onInterceptTouchEvent(MotionEvent event)`

    用来判断是否**拦截**某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件；

* **事件响应**：`public boolean onTouchEvent(MotionEvent event)`

    在`dispatchTouchEvent`方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件。

**三者的关系可以用以下伪代码表示**：
```Java
public boolean dispatchTouchEvent(MotionEvent event) {
    boolean consume = false;
    if (onInterceptTouchEvent(event)) {
        consume = onTouchEvent(event);
    } else {
        consume = child.dispatchTouchEvent(event);
    }

    return consume;
}
```

#### View的工作原理

View的工作流程就是先measure测量，用于确定View的宽高，再layout布局，用于确定View的最终宽高和四个顶点的位置，最后使用draw绘制，用于将View绘制到屏幕上。

#### View和ViewGroup的区别

#### 非UI线程可以更新UI吗

其实是非UI线程是可以刷新UI的。前提是**它要拥有自己的ViewRoot，即更新UI的线程和创建ViewRoot的线程是同一个**，或者**在执行`checkThread()`方法之前去更新UI**。

因为在访问UI时，ViewRootImpl会调用`checkThread()`方法去检查当前访问UI的线程是哪一个，如果不会UI线程就会抛出异常。

```Java
void checkThread() {
    if (mThread != Thread.currentThread()) {
        throw new CalledFromWrongThreadException (
            "Only the original thread that created a view hierarchy can touch its views."
        )
    }
}
```

ViewRootImpl的创建是在`onResume()`方法回调之后，而在执行`onCreate()`方法的时候还没有创建ViewRootImpl，就无法去检查当前线程。但是一般情况下，我们不会在`onCreate()`方法中做更新UI的操作.

#### MotionEvent是什么？包含几种事件？什么时候会产生？

### Animation

#### Android中有哪几种类型的动画

* **View动画（View Animation）/ 补间动画（Tween Animation）**：对View进行平移、缩放、旋转和透明度变化的动画，不能真正地改变View的位置
* **逐帧动画（Drawable Animation）**：是View动画的一种，它会按照顺序播放一组预先定义好的图片
* **属性动画（Property Animation）**：通过不断的改变View的属性，不断地重绘而形成动画效果

#### View动画和属性动画的区别

|         | View动画 | 属性动画 |
| :-----: | :-------------: | :----: |
| 动画实现 | 通过不断的**图形变换**（TranslateAnimation，ScaleAnimation，RotateAnimation，AlphaAnimation） | 通过动态改变**对象属性**（ValueAnimator，ObjectAnimator，AnimatorSet） |
| 作用对象 |       View对象        |   任何对象   |
| 存放位置 |       `res/anim/`    |   `res/animator/`   |
| 状态变化 |       未真正改变view的位置   |   真正地改变了view的位置   |

> View动画改变的只是View的显示，而没有改变View的响应区域；而属性动画会通过反射技术来获取和执行属性的`get`、`set`方法，从而改变了对象位置的属性值。

#### 帧动画在使用时需要注意到什么

使用帧动画时注意不能使用尺寸过大的图片，否则容易造成OOM。

#### 属性动画中插值器和估值器的作用

##### 插值器（Interpoloator）

* 定义：一个接口
* 作用：设置属性值从初始值过渡到结束值的**变化规律**（确定了动画效果变化的模式，如匀速变化、加速变化、减速变化等）
* 使用方法：可以在XML和Java代码中设置

##### 估值器（TypeEvaluator）

* 定义：一个接口
* 作用：设置属性值从初始值过渡到结束值的**变化具体数值**（估值器决定了具体的变化数值）

### Window

#### Activity、View、Window之间的关系

Activity是界面载体，可以展示页面；而View实际上是一个个视图，这些视图可以搭载在一个Layout文件上，通过Activity的`setContentView()`方法传递给Activity；Window是一个窗体，每个Activity对应一个Window，通常在代码中通过`getWindow()`方法获取它。

> 每个Activity包含了一个Window对象，这个对象是由PhoneWindow实现的。PhoneWindow将内部的DecorView作为了一个应用窗口的根View，这个DecorView又把屏幕划分为了两个区域：一个是ActionBar（TitleBar），一个是ContentView。我们平时编写的XML文件布局就是展示在ContentView中。

![](https://s1.ax1x.com/2020/05/02/JjBNu9.png)

#### Window有哪几种类型

* **应用Window**：对应一个Activity
* **子Window**：不能单独存在，需附属特定的父Window。比如Dialog。
* **系统Window**：需要申明权限才可以创建，比如Toast

Window是分层的，层级大的会覆盖在层级小的Window上面，对应的是`WindowManager.LayoutParams`的`type`参数。

| Window | 层级 |
| :--------------: | :-------------: |
| 应用Window |       1~99        |
| 子Window |       1000~1999        |
| 系统Window |       2000~2999        |

### 布局

#### 六大布局

* LinearLayout
* RelativeLayout
* TableLayout
* FrameLayout
* AbsoluteLayout
* GridLayout

#### ConstraintLayout

#### RecyclerView

* LayoutManager：负责Item视图的布局的显示管理
* ItemDecoration：给每一个item视图添加子View（例如可以添加分割线）
* ItemAnimator：负责处理数据添加或者删除时的动画效果
* Adapter：为每一项item创建视图。一是根据不同的ViewType创建与之相应的item布局，二是访问数据集合并将数据绑定到正确的View上
* ViewHolder：承载item视图的子布局
* Recycler：负责处理View的缓存

**方法的作用**：

```Java
// 创建Item视图，并返回给相应的ViewHolder
public ViewHolder onCreateViewHolder(ViewGroup parent, int viewType)

// 绑定数据到正确的Item视图上
public void onBindViewHolder(ViewHolder holder, int position)

// 返回该Adapter所持有的Item数量
public int getItemCount()

// 用来获取当前项Item，即position参数是哪种类型的布局
public int getItemViewType(int position)
```

##### 如何理解adapter订阅者模式

##### ViewHolder的作用

##### 如何理解ViewHolder的复用

##### 什么时候停止调用onCreateViewHolder

##### LayoutManager的作用是什么

##### LayoutManager的样式有哪些

##### 上拉加载的功能是如何做的

##### 添加滚动监听事件需要注意什么

##### 网格布局上拉加载如何优化

##### 如何理解RecyclerView三级缓存是如何实现的

##### RecyclerView滑动卡顿的原因有哪些？如何解决？

##### RecyclerView常见的优化有哪些？

### 事件

### 设计模式

#### 六大原则

* **单一职责原则**：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。

    > There should never be more than one reason for a class to change.

    不同的类具有不同的职责，各司其职。如果一个类拥有了两种职责，那么就最好将其分为两个类。

* **里氏替换原则（Liskov Substitution Principle）**：所有引用基类的地方必须能够透明地使用其子类的对象。

    > Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.

    它是开闭原则的具体实现手段之一。里氏替换原则的核心是**抽象**，而抽象又依赖于**继承**这个特性。继承的优点有：1. 代码重用，减少创建类的成本，每个子类拥有父类的属性和方法；2. 子类和父类基本相似，但是又于父类有区别；3. 提高代码的可拓展性。继承的缺点有：1. 继承是侵入性的，只要继承了就必须拥有父类的所有属性和方法；2. 可能会造成子类代码的冗余，灵活性降低，因为子类必须拥有父类所有的属性和方法。里氏替换原则和开闭原则是相互依赖的，通过里式替换来达到对扩展的开发，对修改的关闭效果。

* **依赖倒转原则（Dependence Inversion Principle）**：高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。

    > High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depends upon details. Details should depend upon abstractions.

    在Java中，**抽象**是指接口或者抽象类（Abstract），两者都是不可以被实例化的（不能被new）；而**细节**指的是具体的实现类，实现接口或者抽象类，是可以被实例化的。高层模块指的就是调用端，低层模块就是具体的实现类。所以依赖倒转原则在Java中的表现就是，模块间的依赖通过抽象产生，实现类之间是不会产生依赖关系的，其依赖关系是通过接口或者抽象类产生的。如果类与类之间直接依赖细节，那么可能会直接耦合。需要修改时，就会同时修改依赖者的代码，限制了可拓展性。

* **接口隔离原则（Interface Segregation Principle）**：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上

    > The dependency of one class to another one should depend on the smallest possible interface.

    接口隔离原则的建立最小的接口是指建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量要少。即为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有的依赖它的类调用。需要注意以下几点：
    * 接口尽量要小，但是也有限度。对接口进行细化可以提高程序设计的灵活性；但是如果太小了，则会造成接口数量过多，设计复杂化；
    * 为依赖接口的类定制服务，只暴露给调用的类需要的方法，它不需要的方法则隐蔽起来。这样才能建立最小的依赖关系；
    * 提高内聚，减少对外交互。接口方法尽量少用`public`修饰，接口是对外的承诺，承诺越少对系统开发越有利，变更风险也会越少。

* **迪米特原则（Law of Demeter，最少知道原则）**：一个对象应该对其它对象保持最少的了解，即一个软件实体应当尽可能少地与其它实体发生相互作用

    > Only talk to your immediate friends.

    一个类应该对自己需要耦合或者调用的类了解最少，类的内部如何实现与调用者或者依赖关系越密切，耦合度就越大。当一个类发生变化时，对另外一个类的影响也越大。即**低耦合、高内聚**。

    * 在类的划分上，应当尽量创建松耦合的类。类之间的耦合度越低，当一个类修改时，就不会对关联的类造成太大的波及；
    * 在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；
    * 在对其它类的引用上，一个类对其它对象的引用应当降到最低；

* **开放封闭原则（Open Close Principle）**：对扩展开放，对修改关闭

    > Software entities like classes, modules and functions should be open for extension but closed for modifications.

    即**类、模块、函数等应该是可以拓展的，但是不可修改**。开闭原则指导我们，当软件发生变化时，应该尽量通过**拓展**的方式来实现变化，而不是通过**修改**已有代码来实现（OCP原则并不是说绝对不可以修改原始的类）。

* **合成复用原则（六大原则之外）**：尽量使用对象组合，而不是继承来达到复用的目的。

    合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。即首先考虑组合/聚合，可以使系统更灵活，降低类与类之间的耦合度，其次才考虑继承。在使用继承时，也要严格遵循里氏替换原则。

#### 23种设计模式

23种设计模式分为三大类（分类不同版本有不同的数量）：

* **创建型模式（6种）**：单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式

    > 创建型模式对类的实例化过程进行了抽象，能够将模块中对象的创建和对象的使用分离。为了使结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚具体的细节，使整个系统的设计更加符合单一职责原则。

* **结构型模式（6种）**：外观模式、适配器模式、桥接模式、代理模式、装饰者模式、享元模式

    > 结构型模式描述如何将类或者对象结合在一起形成更大的结构。

* **行为型模式（11种）**：职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式

    > 行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象之间的职责，并研究系统在运行时实例对象之间的交互。

具体的23种设计模式详见[Java基础部分的设计模式分析](#designpattern)

#### MVC与MVP与MVVM

## Java基础

### 面向对象和面向过程的区别

* **面向过程：面向过程比面向对象的性能更高**。因为类调用时需要实例化，开销比较大。但是，面向过程没有面向对象易维护、易复用、易拓展。
* **面向对象：易维护、易复用、易拓展**。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

### JVM、JDK和JRE

#### JVM

Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

##### 字节码

> 在 Java 中，JVM可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。

##### Java程序从源代码到运行的步骤

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67.png)

##### JVM内存是如何划分的

##### 谈谈垃圾回收机制。为什么引用计数器判定对象是否回收不可行？

##### 有哪些垃圾回收算法

##### 工作内存和主内存的关系。在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施

##### JVM、Dalvik、ART的区别

#### JDK和JRE

JDK是Java Development Kit，是Java SDK。它拥有JRE的一切，还有编译器（javac）和工具（例如javadoc）。**它能够创建和编译程序。**

JRE是Java运行时的环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令等。**但它不能用于创建新程序**。

#### 类加载的全过程是怎样的，什么是双亲委派模型

### Java和C++的区别

* 都是面向对象的语言，都支持封装、继承和多 态
* Java**不提供指针**来直接访问内存，程序内存会更加安全
* Java的类是**单继承**的，C++支持**多重继承**；Java的接口可以多继承
* Java有自动内存管理机制

### 重载和重写的区别

#### 重载

发生在同一类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。简单的说，就是**多个方法有相同的名字、不同的参数**，便产生了重载。

#### 重写

重写是子类对父类的允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为`private`则子类不能重写该方法。

### 三大特性：封装 继承 多态

#### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。

#### 继承

继承是使用已存在的类的定义作为基础建立类的技术，新的类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

* 子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。
* 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
* 子类可以用自己的方式实现父类的方法。

#### 多态

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中可以有两种形式实现多态：**继承**和**接口**。

------

继承、封装、多态三个特性是基于抽象的。

### 基本数据类型

Java的基本数据类型包括`byte`、`int`、`char`、`long`、`float`、`double`、`boolean`、`short`。

所以`String`不是基本的类型。

### 接口和抽象类的区别

1. 接口的方法默认是`public`，所有方法在接口中不能实现，而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其它变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可以通过`extends`关键字扩展多个接口。
4. 接口方法默认修饰符是`public`，抽象方法可以有`public`、`protected`和`default`这些修饰符（不能使用`private`关键字修饰）

### String StringBuffer StringBuilder的区别

#### 可变性

`String`类中是使用`final`关键字修饰字符数组来保存字符串，所以`String`对象是不可变的。`StringBuilder`与`StringBuffer`都继承自`AbstractStringBuilder`类，在`AbstractStringBuilder`中没有用`final`关键字修饰，所以这两种对象是可变的。

#### 线程安全性

`String`中的对象是不可变的，也可以理解为常量，线程安全。`StringBuffer`对方法添加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的。`StringBuilder`并没有对方法进行加同步锁，所以是**非线程安全**的。

#### 性能

每次对`String`类型进行改变时，都会生成一个新的`String`对象，然后将指针指向新的`String`对象。

`StringBuffer`每次都会对`StringBuffer`对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用`StringBuilder`相比使用`StringBuffer`能获得10%~15%左右的性能提升，但是要冒线程不安全的风险。

#### 总结

1. 操作**少量数据**：适用`String`
2. **单线程**操作字符串缓冲区下操作大量数据：适用`StringBuilder`
3. **多线程**操作字符串缓冲区下操作大量数据：适用`StringBuffer`

### 自动装箱与拆箱

* **装箱**：将基本类型用它们对应的引用类型包装起来；
* **拆箱**：将包装类型转换为基本数据类型；

### 成员变量和局部变量的区别

1. **语法形式**：成员变量是**属于类**的，而局部变量是在**方法中定义的变量**或者是**方法的参数**；成员变量可以被`public`、`private`、`static`等修饰符修饰，而局部变量不能被访问控制修饰符及`static`所修饰；但是它们都能被`final`修饰符修饰。
2. **变量在内存中的存储方式**：如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的；如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. **变量在内存中的生存时间**：成员变量是对象的一部分，随着对象的创建而存在；而局部变量会随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（如果被`final`修饰，则必须显式赋值），而局部变量不会自动赋值。

### 构造方法的作用和特性

构造方法的主要作用是完成对类对象的初始化工作。

#### 特性

1. 名字与类名相同。
2. 没有返回值，但是也不能用`void`声明构造函数。
3. 生成类的对象时自动执行，无需调用。

### 静态方法和实例方法的不同

1. 在外部调用**静态方法**时，可以使用`类名.方法名`的方式，也可以使用`对象名.方法名`的方式。而实例方法只能后面这种方式，即需要创建新对象而静态方法不需要。
2. 静态方法在访问本类的成员时，只能允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。

### `==`与`equals`

**==**：判断两个对象的地址是否相等，即判断**两个对象是否是同一个对象**。

**equals()**：判断两个对象是否相等，但有两种使用情况：

* 如果类没有覆盖`equals()`方法，则通过`equals()`比较该类的两个对象时，等价于通过`==`比较这两个对象。
* 如果类覆盖了`equals()`方法，一般都覆盖`equals()`方法来比较两个对象的内容是否相等，若相等则直接返回`true`。

### final关键字

`final`关键字主要用在三个地方：变量、方法、类。

1. 如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用`final`修饰一个类时，表明这个类不能被继承。`final`类中的所有成员方法都会被隐式的指定为`final`方法。
3. 使用`final`的原因有两个。一个是把方法锁定，以防任何继承类来修改它的含义。所以类中所有的`private`方法都被隐式的指定为`final`；第二个原因是效率。

### static关键字

`static`关键字主要有以下四种使用场景：

1. **修饰成员变量和成员方法**：被`static`修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以直接通过类名调用。被`static`声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。调用格式：`类名.静态变量名`和`类名.静态方法名()`。
2. **静态代码块**：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，静态代码块只执行一次。
3. **静态内部类（`static`只能修饰内部类）**：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用意味：1. 它的创建是不需要依赖外围类的创建；2. 它不能使用任何外围类的非`static`成员变量和方法。
4. **静态导包（用来导入类中的静态资源）**：格式为`import static`，这个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

#### 静态代码块

静态代码块的格式是

```java
static {
    // 语句体;
    i = 3;
}
```

一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中的出现的先后顺序依次执行它们，每个代码块只会被执行一次。

静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。

### this和super关键字

`this`关键字用于引用类的当前实例，此关键字是可选的，使用此关键字可能会使代码更易读或易懂。

`super`关键字用于从子类访问父类的变量和方法。

* 使用`super()`调用父类中的其它构造方法时，该语句必须处于首行，否则编译器会报错。另外，`this`调用本类中的其它构造方法时，也要放在首行。
* `this`、`super`不能用在`static`方法中。

### 异常处理

在`Java`中，所有的异常都有一个共同的祖先`java.lang`包中的`Throwable`类。`Throwable`有两个重要的子类：`Exception`（异常）和`Error`（错误），二者都是`Java`异常处理的重要子类，各自包含大量的子类。异常和错误的区别：异常能被程序本身处理，错误是无法处理的。

#### Error（错误）

**是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误表示代码运行时JVM（Java虚拟机）出现的问题，例如JVM不再有继续执行操作所需的内存资源时，将出现`OutOfMemoryError`。这些错误表示故障是发生于虚拟机自身或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（`Virtual MachineError`）、类定义错误（`NoClassDefFoundError`）等。这些错误在运行前是不可查的。

#### Exception（异常）

**是程序本身可以处理的异常**。`Exceptiton`类有一个重要的子类`RuntimeException`。除此之外，还有`NullPointerException`和`ArrayIndexOutOfBoundsException`等。

#### Throwable类常用方法

* `public string getMessage()`：返回异常发生时的简要描述
* `public string toString()`：返回异常发生时的详细信息
* `public string getLocalizedMessage()`：返回异常对象的本地化信息。如果`Throwable`的子类有覆盖这个方法，则可以生成本地化信息。如果子类没有覆盖这个方法，则方法返回的信息与`getMessage()`返回的结果相同
* `public void printStackTrace()`：在控制台上打印`Throwable`对象封装的异常信息

#### 总结

* **try块**：用于捕获异常，其后可以接多个**catch块**或者不接。如果其后没有**catch块**，则必须跟一个**finally块**。
* **catch块**：用于处理`try`捕获到的异常。
* **finally块**：无论是否捕获或处理异常，**finally块**里的语句都会被执行。如果在**try块**或者**catch块**中有`return`语句，则在`return`返回之前执行**finally语句**。

有四种特殊情况下，`finally`块不会执行：

1. 在`finally`语句块第一行发生了异常。
2. 在前面的代码中使用了`System.exit()`退出程序。
3. 程序所在的线程死亡。
4. 关闭CPU。

### hashCode与equals

`hashCode()`的作用是获取哈希码，也称为散列码；它实际上是返回一个`int`整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在JDK的`Object.java`中，意味着Java的任何类都包含`hashCode()`函数。`hashCode()`在散列表中才有用，在其它情况下没用。在散列表中`hashCode()`的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

1. 如果两个对象相等，则`hashCode`也一定是相同的
2. 如果两个对象相等，则对两个对象分别调用`equals()`方法都返回`true`
3. 两个对象有相同的`hashCode`值，也不一定是相等的
4. `equals`方法被覆盖过，则`hashCode`方法也必须被覆盖
5. `hashCode()` 的默认行为是对堆上的对象产生独特值。如果没有重写` hashCode()`，则该 `class `的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

### Collections工具类和Arrays工具类常见方法

#### Collections工具类常用方法：

1. 排序
2. 查找，替换操作
3. 同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包的并发集合）

##### 排序操作

```java
void reverse(List list)	// 反转
void shuffle(List list) // 随机排序
void sort(List list) // 按自然排序的升序排序
void sort(List list, Comparator c) // 定制排序，由Comparator控制排序逻辑
void swap(List list, int i, int j) // 交换两个索引位置的元素
void rotate(List list, int distance) // 旋转。当distance为正数时，将list后distatnce个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面。
```

##### 查找，替换操作

```java
int binarySearch(List list, Object key) // 对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)	// 根据元素的自然顺序，返回最大元素
int max(Collection coll, Comparator c) // 根据定制排序，返回最大元素，排序规则由Comparatator类控制
void fill(List list, Object obj) // 用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o) // 统计元素出现个数
int indexOfSubList(List list, List target) // 统计target在list中第一次出现的索引
boolean replaceAll(List list, Object oldVal, Object newVal) // 用新元素替换旧元素
```

##### 同步控制

因为`HashSet`、`TreeSet`、`ArrayList`、`LinkedList`、`HashMap`、`TreeMap`都是线程不安全的。`Collections`提供了多个`synchronizedXxx()`静态方法可以把它们包装成线程同步的集合。

**最好不要使用下面这些方法，因为效率非常低**。

```java
synchronizedCollection(Collection<T> c);
synchronizedList(List<T> list);
synchronizedMap(Map<K, V>, m);
synchronizedSet(Set<T> s);
```

#### Arrays类的常见操作

1. 排序：`sort()`
2. 查找：`binarySearch()`
3. 比较：`equals()`
4. 填充：`fill()`
5. 转列表：`asList()`
6. 转字符串：`toString()`
7. 赋值：`copyOf()`

### Java中的IO流

#### 分类

* 按照流的流向分，可以分为**输入流**和**输出流**；
* 按照操作单元分，可以分为**字节流**和**字符流**；
* 按照流的角色分，可以分为**节点流**和**处理流**；

Java的IO流中的类都是从4个抽象类基类中派生出来的。

* `InputStream/Reader`：所有的输入流的基类，前者是**字节输入流**，后者是**字符输入流**。
* `OutputStream/Writer`：所有的输出流的基类，前者是**字节输出流**，后者是**字符输出流**。

### 泛型

如果一个方法接收`List<Object>`作为形式参数，那么如果尝试将`List<String>`的对象作为实际参数传进去，就会发现无法通过编译。尽管`String`是`Object`的子类，但是实际上会**产生隐含的类型转换问题**，所以编译器是禁止这样的行为的。

#### 类型擦除

在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数会被编译器在编译的时候去掉，这个过程就叫做**类型擦除**。比如，`List<String>`和`List<Object>`等类型在编译之后都会变成`List`。JVM看到的只有`List`，而由泛型附加的类型信息对于JVM来说是不可见的。

#### 通配符

在使用泛型类的时候，既可以指定一个具体的类型，如`List<String>`就声明了具体类型是`String`类型；但也可以通过通配符`?`来表示未知类型，如`List<?>`就表示了`List`中包含的元素类型是未知的，也就意味着所有类型都是可以的。

但注意`List<?>`并不等同于`List<Object>`。因为`List<Object>`确定了`List`中包含的是`Object`及其子类，在使用的时候都可以通过`Object`来进行引用，而`List<?>`其中包含的元素是不确定的。如果其包含的是`String`类型的，那往里添加`Integer`类型的元素就是错误的。

在某些情况下，可以使用**上下界**来限制未知类型的范围。如通过`List<? extends Number>`来说明`List`中可能包含的元素类型是`Number`及其子类。而`List<? super Number>`则说明`List`中包含的是`Number`及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。

### 23种设计模式<span id="designpattern">

#### 单例模式

单例模式下，对应类只能生成一个实例。但是也有很多种不同的写法。

##### 饿汉模式

```Java
public class Singleton {
    private static Singleton instance = new Singleton();

    private Singleton() {

    }

    public static Singleton getInstance() {
        return instance;
    }
}
```

这种方式在类加载时就完成了初始化操作，所以类加载速度慢，但是获取对象的速度快。这种方式基于类加载机制，避免了多线程的同步问题，但是也不能确定有其它的方式或者其它的静态方法会导致类加载。此时的初始化`instance`是没有达到**懒加载**的效果的。

##### 懒汉模式（线程不安全）

```Java
public class Singleton {
    private static Singleton instance;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

懒汉模式使用了懒加载的模式，申明了一个静态对象，只在用户第一次调用时需要初始化。虽然节约了资源，但是第一次加载时仍需要实例化，速度稍慢，而且**在多线程下不能工作**。因为当有多个线程并行调用`getInstance()`的时候，就会创建多个实例了。

##### 懒汉模式（线程安全）

```Java
public class Singleton {
    private static Singleton instance;
    private Singleton() {

    }

    public static synchronized Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton();
        }
        return instance;
    }
}
```

为了解决线程不安全的问题，就是将整个`getInstance()`方法设置为同步（`synchronized`）。这种写法能够在多线程中很好的工作，但是每次调用`getInstance()`方法时都需要进行同步，会造成不必要的同步开销。因为在任何时候都只能有一个线程调用`getInstance()`方法。但是大部分时候我们是用不到同步的，只需要在第一次调用时用到，所以**不建议使用这种方式**。

##### 双重检验锁模式（double checked locking pattern）

```Java
public class Singleton {
    private static Singleton instance;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

DCL模式是一种使用同步块加锁的方法，在`getSingleton()`方法中对`instance`进行了两次判空，第一次是为了不必要的同步，第二次是在`instance == null`的情况下才创建实例。之所以还要在同步块内再检验一次，就是因为可能会有多个线程一起进入同步块外的`if`，如果不进行二次检验就会生成多个实例了。

但是上面这段代码仍然有问题。主要是`instance = new Singleton()`这句代码，**并非是一个原子操作**。在JVM中,这句代码会执行下面三个操作:

* 给`instance`分配内存
* 调用`Singleton`的构造函数来初始化成员变量
* 将`instance`对象指向分配的内存空间（执行完这步后`instance`就为非空了）

但是在JVM的即时编译器中存在指令重排序的优化，即第二步和第三步的顺序不能保证谁先执行。解决方法就是**将`instance`变量声明成`volatile`就可以了**。因为`volatile`是可以禁止指令重排序优化。

```Java
public class Singleton {
    private volatile static Singleton instance;

    private Singleton() {

    }

    public static Singleton getInstance() {
        if (instance == null) {
            synchronized(Singleton.class) {
                if (instance == null) {
                    instance = new Singleton();
                }
            }
        }
        return instance;
    }
}
```

使用`volatile`的DCL模式的优点是资源利用率高，第一次执行`getInstance()`时，单例对象才会被实例化，效率高。缺点是第一次加载时反应会慢一些。

##### 静态内部类单例模式

```Java
public class Singleton() {
    private Singleton() {

    }

    public static Singleton getInstance() {
        return SingletonHolder.sInstance;
    }

    private static class SingletonHolder {
        private static final Singleton sInstance = new Singleton();
    }
}
```

这种方法也是《Effect Java》推荐使用的。在第一次加载`Singleton`类时并不会初始化`sInstance`，只有第一次调用`getInstance()`方法的时候虚拟机加载`SingletonHolder`并初始化`sInstance`。这样首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于`getInstance()`方法没有任何线程锁定，因此其性能不会造成任何影响。

由于`SingletonHolder`是私有的，除了`getInstance()`方法之外没有方法能够访问它，所以它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。

##### 枚举单例

```Java
public enum Singleton {
    INSTANCE;
}
```

用枚举实现单例的方式十分简单。默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，而且能够防止反序列化导致创建新的对象。但是大部分应用开发很少使用到枚举，因为可读性不是很高，不建议使用。

##### 使用容器实现单例模式

```Java
public class SingletonManager {
    private static Map<String, Object> objMap = new HashMap<String, Object>();

    private Singleton() {

    }

    public static void registerService(String key, Objectinstance) {
        if (!objMap.containsKey(key)) {
            objMap.put(key, instance);
        }
    }

    public static ObjectgetService(String key) {
        return objMap.get(key);
    }
}
```

使用`SingletonManager`将多种单例统一管理，使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现的细节，降低了耦合度。

#### 简单工厂模式

简单工厂模式（Simple Factory Pattern），又称为静态工厂方法（Static Factory Method）模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。它专门定义了一个类来负责创建其它类的实例，被创建的实例通常都会具有共同的父类。

之所以要使用简单工厂模式，是因为要把“产品”和“生产”完全分开。用户只需要知道自己要使用哪些产品，以及如何使用产品即可，而产品的生产则由工厂来完成。因为不同的产品可能仅仅是因为某些参数的不同而作用于不同的场景，所以工厂只需要根据传进来的不同的参数去生产具体的产品给消费者使用。

简单工厂模式包含以下角色：

* Factory（工厂角色）：工厂角色负责实现创建所有实例的内部逻辑
* Product（抽象产品角色）：抽象产品角色是所创建的所有产品（实例）的父类，负责描述所有产品（实例）共有的公共接口
* ConcreteProduct（具体产品角色）：具体产品角色是这个角色的具体类的实例，是抽象产品角色根据不同参数的具体实现

（或者让Product作为具体的产品角色，AbstractProduct作为抽象产品角色）。

![YpjgMt.jpg](https://s1.ax1x.com/2020/05/04/YpjgMt.jpg)

简单工厂模式的优点：

* 简单工厂模式实现了对于责任的分割，提供了专门的工厂类用于创建对象，而客户端免除了直接创建产品对象的责任，而是仅仅消费产品；
* 客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类对应的参数即可；
* 可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，一定程度上提高了系统的灵活性；
* **从产品的角度上**符合“开闭原则”

简单工厂模式的缺点：

* 因为工厂类集中了所有的产品创建的逻辑，如果一旦不能正常工作，整个系统都会受到影响；
* 使用简单工厂模式会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度；
* 系统扩展困难，一旦添加新的产品就要修改工厂类的逻辑，**从工厂的角度上**是不符合“开闭原则”的；
* 简单工厂模式由于使用了静态工厂方法，造成了工厂角色无法形成基于继承的结构；

适用场景：

* 工厂类负责创建的对象比较少的情况。因为创建的对象较少，就不会造成工厂方法中的业务逻辑太过复杂；
* 客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。

#### 工厂方法模式

工厂方法模式（Factory Method Pattern）又称为工厂模式，从名字就可以看出相对于简单工厂模式，工厂模式会更复杂一些。在该模式中，工厂父类负责定义创建产品对象的公共接口，而工厂实现类则负责生成具体的产品对象。抽象产品类和具体产品类的逻辑则与简单工厂模式一致。

工厂方法模式包含以下角色：

* Product（抽象产品）：定义具体产品的公共接口；
* ConcreteProduct（具体产品）：继承抽象产品类，定义生产的具体产品；
* Factory（抽象工厂）：定义具体工厂的公共接口；
* ConcreteFactory（具体工厂）：定义创建对应具体产品实例的方法；

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/FactoryMethod.jpg)

工厂模式的优点：

* 更加符合“开闭原则”：当新增一种产品时，只需要增加响应的具体产品类和具体工厂类，抽象工厂和抽象产品无需修改；
* 符合“单一职责原则”：每个具体工厂类都只负责创建对应的产品；
* 不适用静态工厂方法：可以形成基于继承的结构

工厂模式可以说是简单工厂模式的一种抽象和拓展，在保留了简单工厂的封装有点的同时，让扩展变得更简单，实现了继承的结构，增加了多态性的体现。

工厂模式缺点：

* 添加新产品时，既要增加新的具体产品类，又要增加新的具体工厂类，系统类的个数成对增加，增加了系统的复杂度；
* 考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到OOM、反射等技术，增加了实现难度；
* 一个具体工厂类只能对应一个产品；
* 如果需要更换产品而不是新增产品，就仍然需要修改实例化的具体工厂类；

适用场景：

* 当一个类希望通过子类来指定创建对象
* 当一个类不知道它所需要的对象的类
* 将创建对象的任务委托给多个具体工厂类的某一个，客户端在使用时可以无须关心是哪一个具体工厂类创建了该产品，需要时再动态指定即可，可以将具体工厂类的类名存储在配置文件或者数据库中

#### 抽象工厂模式

抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。

因为工厂模式中，每个工厂只能创建一个类，十分浪费；抽象工厂就解决了这个问题。抽象工厂中每个工厂都可以创建多种类的产品。

抽象工厂模式包含以下角色：

* 抽象产品族：描述了抽象产品的公共接口；
* 抽象产品：描述了具体产品的公共接口；
* 具体产品：描述了具体产品；
* 抽象工厂：描述了具体工厂的公共接口；
* 具体工厂：描述了具体工厂；

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01ZDViNjUyOTRhYzE5MjQ2LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA.jpeg)

具体代码如下所示：

```Java
// 创建抽象产品族类，定义抽象产品的公共接口
abstract class AbstractProduct {
    public abstract void show();
}

// 创建抽象产品类，定义具体产品的公共接口
abstract class ContainerProduct extends AbstractProduct {
    @Override
    public abstract void show();
}

// 创建抽象产品类，定义具体产品的公共接口
abstract class MouldProduct extends AbstractProduct {
    @Override
    public abstract void show();
}

// 创建具体产品类，定义生产的具体产品
// 容器A类
class ContainerProduct A extends ContainerProduct {
    @Override
    public void show() {
        System.out.println("生产出了容器产品A");
    }
}

// 容器B类
class ContainerProductB extends ContainerProduct{
    @Override
    public void Show() {
        System.out.println("生产出了容器产品B");
    }
}

// 模具A类
class MouldProductA extends MouldProduct{
    @Override
    public void Show() {
        System.out.println("生产出了模具产品A");
    }
}

// 模具B类
class MouldProductB extends MouldProduct{
    @Override
    public void Show() {
        System.out.println("生产出了模具产品B");
    }
}

// 创建抽象工厂类，定义具体工厂的公共接口
abstract class Factory {
    public abstract Product ManufactureContainer();
    public abstract Product ManufactureMould();
}

// 创建具体工厂类，定义工厂创建具体产品实例的方法
// 生产A产品的工厂
class FactoryA extends Factory {
    @Override
    public Product ManufactureContainer() {
        return new ContainerProductA();
    }

    @Override
    public Product ManufactureMould() {
        return new MouldProductA();
    }
}

// 生产B产品的工厂
class FactoryB extends Factory {
    @Override
    public Product ManufactureContainer() {
        return new ContainerProductB();
    }

    @Override
    public Product ManufactureMould() {
        return new MouldProductB();
    }
}

// 具体实现类（调用类）
public class AbstractFactoryPattern {
    public static void main(String[] args) {
        FactoryA mFactoryA = new FactoryA();
        FactoryB mFactoryB = new FactoryB();
        //A厂当地客户需要容器产品A
        mFactoryA.ManufactureContainer().Show();
        //A厂当地客户需要模具产品A
        mFactoryA.ManufactureMould().Show();

        //B厂当地客户需要容器产品B
        mFactoryB.ManufactureContainer().Show();
        //B厂当地客户需要模具产品B
        mFactoryB.ManufactureMould().Show();
    }
}
```

抽象工厂模式的优点：

* 降低耦合：抽象工厂模式将具体产品的创建放在了具体工厂的子类中
* 更符合“开闭原则”：新增一种产品时，则需要增加新的具体产品类和相应的工厂子类即可。

抽象工厂模式的缺点：

* 很难支持产品的变化：因为抽象工厂接口中已经确定了可以被创建的产品集合，所以如果需要添加新产品的话，就必须去修改抽象工厂的接口，这样就违背了“开闭原则”。

#### 建造者模式

> 建造者模式（Builder Pattern）是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

通俗的说话就是，建造者模式就是如何一步步构建一个包含多个组成部件的对象，相同的构建过程却可以创建出不同的产品。它允许用户只通过指定复杂对象的类型和内容就可以构建它们，而不要知道内部的具体构建细节。

建造者模式包含以下角色：

* Builder：抽象建造者。给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口是独立于应用程序的商业逻辑的。它必须实现接口要求的两种方法。一个是建造方法`buildPart()`，一个是返回结构方法`getResult()`。
* ConcreteBuilder：具体建造者。这个角色的任务在于实现抽象建造者Builder声明的接口，给出一步步完成创建产品实例的操作；在建造过程完成后，提供产品的实例。
* Director：导演者。这个角色负责调用较早者角色以创建产品对象。这个角色不了解任何关于产品的知识，只是负责调用。
* Product：产品。产品就是被建造的对象。

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Builder.jpg)

比如以下一个例子可以用于描述KFC如何创建套餐的。KFC套餐是一个复杂的对象，它一般包含主食（如汉堡、鸡翅等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分。那么服务员这个对象就要根据客户的需要，负责组装这些套餐返回给顾客。

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/KFCBuilder.jpg)

在上面这个模型中，KFCWaiter就是导演者角色。它并不知道具体的主食、饮料等是如何做出来，只负责组装（调用Builder对象），然后与客户端交流。MealBuilder在这里就是抽象建造者对象，里面的`getMeal()`方法就是从SubMealBuilder这个具体建造者对象得到建造好的产品。Meal是Product对象。

建造者模式的优点：

* 在建造者模式中，客户端是不知道产品内部组成的细节的，它只与Director交互。通过将产品与产品本身的创建过程解耦，使得相同的创建过程却可以创建出不同的产品对象；
* 同样的，每一个具体建造者也是相对独立的。用户可以使用不同的具体建造者建造出不同的产品对象；
* 可以更加精细地控制产品的创建过程；
* 增加新的具体建造者是无需修改原有类库的代码的，符合**开闭原则**。

建造者模式的缺点：

* 所创建的产品一般具有较多的共同点（如上面例子中饮料的可乐、果汁等）。如果产品之间差异性很大的话，就不适用于建造者模式（因为使用范围受到一定的限制）；
* 如果产品的内部变化很复杂，就需要定义很多的具体建造类来实现这种变化，一个是不能满足的，这样系统会很庞大。

#### 原型模式

原型模式是通过给定一个原型对象来指明所有创建的对象的类型，然后用这个原型对象提供的复制方法创建出更多同类型的对象。

即原型模式要求对象实现一个可以克隆自身的接口（类型）。这样一来，通过原型实例创建新的对象，就不需要关心这个实例本身的类型，只需要实现克隆自身的方法，也无需再去通过`new`去创建。

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/1332722887_7899.jpg)

原型对象主要就是用于对象的复制，其核心就是上图中的原型类Prototype。Prototype类需要具备以下两个条件：

* 实现`Cloneable`接口。它的作用是在运行时通知虚拟机可以安全地实现此接口的类上使用`clone`方法。在JVM中，只有实现了这个接口的类才可以被拷贝；
* 重写Object类中的`clone`方法。

总之，原型模式十分简单易理解，实现一个接口，重写一个方法就实现了原型模式。在实际应用中，原型模式很少单独出现，经常与其它模式混用，其原型类Prototype也常用抽象类来替代。

```Java
class Prototype implements Cloneable {
    public Prototype clone() {
        Prototype prototype = null;
        try {
            prototype = (Prototype) super.clone();
        } catch (CloneNotSupportException e) {
            e.printStackTrace();
        }
        return prototype;
    }
}

class ConcretePrototype extends Prototype {
    public void show() {
        System.out.println("原型模式实现类");
    }
}

public class Client {
    public static void main(String[] args) {
        ConcretePrototype cp = new ConcretePrototype();
        for (int i = 0; i < 5; i++) {
            ConcretePrototype clonecp = (ConcretePrototype) cp.clone();
            clonecp.show();
        }
    }
}
```

原型模式的优点：

* 简化对象的创建；
* 使用原型模式创建对象比直接`new`一个对象的性能要好得多，因为`clone`方法是一个本地方法。

使用原型模式的注意事项：

* 使用原型模式复制对象不会调用类的构造方法
* 深拷贝与浅拷贝。Object类的`clone`方法只会拷贝对象中的基本数据类型，对于数组、容器对象、引用对象等都不会去拷贝，所以是浅拷贝。

___

#### 外观模式

#### 适配器模式

适配器模式（Adapter Pattern），将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，别名为包装器（Wrapper）。

适配器模式包含以下角色：

* Target：目标抽象类
* Adapter：适配器类
* Adaptee：适配者类
* Client：客户类

有两种适配器模式，一种是类的适配器模式，一种是对象的适配器模式。它们都是把适配的类的API转换成目标类的API。

##### 类的适配器模式

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0yNGM2YmY0NGRhMWI3OWFkLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA.jpeg)

从上图可以看出，Target目标类想要调用`Request`方法，但是适配者类Adaptee是没有这个方法的，那么就需要中间有一个适配器类Adapter，把Adaptee的API与Target的API衔接起来（通过继承Adaptee，实现Target接口）。

```Java
public interface Target {
    public void Request();
}

public class Adaptee {
    public void SpecificRequest() {

    }
}

public class Adapter extends Adaptee implements Target {
    @Override
    public void Request() {
        this.SpecificRequest();
    }
}

public class AdapterPattern {
    public static void main(String[] args) {
        Target mAdapter = new Adapter();
        mAdapter.Request();
    }
}
```

##### 对象的适配器模式

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jNzM2NDE2Zjc4YTViMmQ1LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA.jpeg)

对象的适配器模式就是把**继承**改在了Adapter的内部去实现。

```Java
public interface Target {
    public void Request();
}

public class Adaptee {
    public void SpecificRequest() {

    }
}

public class Adapter implements Target {
    private Adaptee adaptee;

    public Adapter(Adaptee adaptee) {
        this.adaptee = adaptee;
    }

    @Override
    public void Request() {
        this.adaptee.SepcificRequest();
    }
}

public class AdapterPattern {
    public static void main(String[] args) {
        Target mAdapter = new Adapter(new Adaptee());
        mAdapter.Request();
    }
}
```

---

适配器模式的优点：

* 将目标类Target与适配者类Adaptee解耦，中间通过一个适配器类Adapter完成；
* 增加了类的透明性和复用性；
* 灵活性和拓展性非常好
* **类适配器模式**：由于适配器类Adater是适配者类Adaptee的子类，所以在适配器类Adapter还可以重写适配者Adaptee的一些方法，灵活性很强；
* **对象适配器模式**：一个对象适配器可以把不同的适配者Adaptee适配到同一个目标，即把适配者类Adaptee和它的子类都适配到目标接口Target。

适配器模式的缺点：

因为Java等语言不支持多继承，所以一次最多只能适配一个适配者类Adaptee。

#### 桥接模式

#### 代理模式

#### 装饰者模式

#### 享元模式

___

#### 职责链模式

#### 命令模式

#### 解释器模式

#### 迭代器模式

#### 中介者模式

#### 备忘录模式

#### 观察者模式

#### 状态模式

#### 策略模式

#### 模板方法模式

#### 访问者模式

## 计算机网络

1. **HTTP和HTTPS的区别**

    * **开销**：HTTPS协议需要到CA申请证书或者自制证书
    * **安全性**：HTTP的信息是明文传输，是简单无状态的；HTTPS则是具有安全性的SSL加密传输，HTTPS协议是由SSL+HTTP协议构建的，可进行加密传输、身份认证的网络协议，比HTTP协议安全
    * **资源消耗**HTTP是直接与TCP进行数据传输；HTTPS运行在SSL/TSL之上，SSL/TSL运行在TCP之上，需要消耗更多的CPU和内存资源；
    * **端口不同**：HTTP用到的端口是80（需要国内备案），HTTPS用到的端口是443

2. **HTTP2与HTTP1.x相比的新特性**

    * HTTP2使用新的二进制格式传输，HTTP1.x使用文本（字符串）传输。二进制协议解析起来更高效

    * HTTP2支持多路复用，即连接共享，即每一个`request`都是用作连接共享机制的。

        > 在HTTP1.x协议中，「浏览器客户端在同一时间，针对同一域名下的请求有一定的数量限制。超过限制数目的请求会被阻塞」。HTTP2的多路复用（Multiplexing）允许同时超过单一的HTTP2连接发起多重的请求-响应消息。

        ![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/http16.jpg)

    * HTTP2头部压缩，通过`gzip`和`compress`压缩头部然后再发送，既避免了重复`header`的传输，又减小了需要传输的大小
    * HTTP2支持服务器推送

3. **HTTP2和HTTPS的关系**

4. **什么是数字签名和数字证书**

    * **数字签名**：为了避免数据在传输过程中被替换（例如被黑客修改了报文内容），所以需要发送端发送一个数字签名，即把数据的摘要消息进行加密，比如使用MD5进行加密，得到一个数字签名，然后把这个数字签名和数据一起发送。然后接收端把收到的数据摘要部分进行MD5（相同加密算法）进行加密，如果加密后的结果和数字签名是一样的，就说明数据是正确的真实的。
    * **数字证书**：因为在对称加密中，发送端和接收端双方都是使用公钥进行解密的。**数字签名可以保证数据不被替换**，但是不能保证公钥不被替换。因为数据是通过公钥加密的，如果公钥被替换了，那么数据也可以被伪造。所以我们要确保公钥也是真的。那么，CA证书机构会负责颁发一个证书，里面的公钥保证是真的，用户在请求服务器时，服务器将证书发给用户，而这个证书是由系统内置证书备案的，就能保证证书里的公钥是真的。

5. **对称加密与非对称加密**

    对称密钥加密指的是使用同一个密钥进行加密和解密，这种方法存在的问题就是密钥如何安全地发送给对方。

    非对称加密是指使用一对非对称密钥，即公钥和私钥。公钥是可以任意发布的，但是私钥只有自己知道。发送方使用接收方的公钥进行加密处理，接收方收到加密信息后，使用自己的私钥进行解密。

    因为非对称加密的方式只会发送公钥而不会发送用来解密的私钥，所以可以保证安全性。但是相比对称加密，它的速度非常慢。所以，我们仍然使用对称加密来传送消息，但对称加密所使用的密钥可以通过非对称加密的方式发送出去。

6. **TCP与UDP的区别**

    * TCP是面向连接的，UDP是无连接的；
    * TCP传输性可靠，UDP传输性不可靠；
    * TCP以**字节流**的形式传输，UDP以**数据报文段**的形式传输；
    * TCP传输效率慢，UDP传输效率快；
    * TCP所需资源多，UDP所需资源少；
    * TCP首部字节是20-60，UDP首部字节是8；
    * TCP应用于要求通信数据可靠的场景，例如文件传输，邮件传输等；UDP则要求通信速度较快的场景，如域名转换，直播等；
    * TCP的可靠性是通过顺序编号和确认（ACK）来实现的。

7. **TCP协议的可靠性是如何保证的**

    * **数据包校验**：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不做任何响应，这样TCP发送数据端就会超时而重发数据；
    * **对失序的数据报重排序**：既然TCP报文段作为IP数据报来传输，因为IP数据报到达时可能会失效，所以TCP报文段的到达也可能会失序。所以TCP会对失序数据进行重新排序，然后再上交给应用层；
    * **丢弃重复数据**
    * **应答机制**：当TCP收到发自TCP连接另外一端的数据，它将发送一个确认（不是立即发送）；
    * **超时重发**：当TCP发出一个段后，会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到这个确认，就需要重新发送这个报文段；
    * **流量控制**：TCP连接的每一方都有固定大小的缓冲空间。TCP接收端只需要另一端（发送端）发送接收端的缓冲区能够容纳得下的数据，这样做可以防止较快主机致使较慢主机的缓冲区溢出，这就是所谓的流量控制（TCP使用的流量控制协议是可变大小的滑动窗口协议）。

8. **TCP和UDP对应的常见应用层协议**

    * TCP对应的应用层协议有：
      * FTP：定义了文件传输协议
      * SMTP：定义了简单邮件传输协议
      * POP3：POP3是用于接收邮件的，和SMTP对应
      * HTTP：从Web服务器传输超文本到本地浏览器的传送协议
    * UDP对应的应用层协议有：
      * DNS：用于域名解析服务，将域名地址转换为IP地址
      * SNMP：简单网络管理协议
      * TFTP：简单文件传输协议

9.  **为什么TCP连接需要三次握手？为什么要四次挥手？画出全过程，并标注ack确认号和seq序列号的值**

10. **保活计时器的作用**

    除了时间等待计时器之外，TCP还有一个保活计时器。比如，一个客户与服务器建立了TCP连接，如果这时突然客户端主机发生故障，那么服务器也不应该再白白等待下去，所以需要使用到保活计时器。

    服务器每次收到一次客户的数据，就要重新设置保活计时器，时间通常设置是两个小时。如果在这个时间内都没有收到客户端的数据，服务端就会发送一个探测报文段（每隔75秒发送一次）。若连续发送10次后都没有收到客户端的响应，服务端就会认为客户端出现了故障，从而关闭连接。

11. **TCP的拥塞处理**

    拥塞控制和流量控制的不同的，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器以及与降低网络传输性能相关的所有因素；流量控制是指点对点通信量的控制，是一个端到端的问，它的作用是抑制发送端发送数据的速率，以便使接收端来得及接收。

    **拥塞**是指在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，那么网络的性能就会变坏。为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）的状态变量，拥塞控制窗口的大小取决于网络的拥塞程度，并且可以动态变化。发送方的发送窗口会从拥塞窗口和接收方的接收窗口这两者中取较小的那个。

    TCP的拥塞控制采用了四种算法：**慢开始**、**拥塞避免**、**快重传和快恢复**。在网络层也可以使路由器采用适当的分组丢弃策略，以减少网络拥塞的发生；

    * **慢开始**：当主机开始发送数据时，如果立即把大量的数据字节同时注入到网络，很有可能会引起网络阻塞。所以，较好的方法是先探测一下，即由小到大逐渐增大发送窗口（逐渐增大拥塞窗口数值）。例如，cwnd的初始值为1，每经过一个传播轮次，cwnd加倍。
    * **拥塞避免**：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加。
    * **快重传和快恢复**：快重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。如果没有FRR，那么如果数据包丢失了，TCP就会使用定时器要求传输暂停；而如果有了FRR，当接收方收到了不按顺序的数据段，就会立即给发送发发送一个**重复确认**，当发送方收到了三个重复确认，就会假定这个数据报丢失了，并立即重传这些丢失的数据段。所以，有了FRR，就不会因为暂停而耽误重传要求。当单个数据包丢失时，FRR十分有效；当多个数据包在短时间内丢失，FRR不能很有效地工作；

12. **HTTP方法有哪些**

    * GET：获取资源，网络中绝大部分请求都会GET请求；
    * HEAD：获取报文首部，使用和GET相似，但是不会返回报文的实体主体部分；
    * POST：传输实体主体；
    * PUT：上传文件，不带有验证机制，所有任何人都能上传文件，存在安全性问题，一般不推荐使用该方法；
    * PATCH：对资源进行部分修改。PUT也可以修改资源，但是是完全替代，而PATCH允许部分修改；
    * OPTIONS：查询指定的URL支持的方法；
    * CONNECT：要求与代理服务器通信时建立隧道；使用SSL和TLS协议把通信内容加密后经网络隧道传输；
    * TRACE：追踪路径，服务器会把通信路径返回给客户端

13. **HTTP中，POST与GET的区别**

    * 用途不同：GET是从服务器上获取数据，POST向服务器传送数据；
    * 数据传输方式不同：GET请求通过URL传输数据，POST通过**请求体**传输数据（先发送请求头再发请求体，实际上是两次请求）；
    * 传输数据量限制不同：GET传送的数据量小，不能大于2KB（因为浏览器对URL的长度有限制）；POST传送的数据量大，一般默认为不受限制；
    * GET的数据在URL中，通过历史记录或缓存可以很容易查到数据信息；POST的数据在请求主体内，所以有一定的安全性保证
    * GET是安全且幂等（同一个请求方法执行多次和仅执行一次的效果完全相同）；POST是非安全非幂等（每次请求对资源的改变并不是相同的），所以GET不会改变服务器上的资源，而POST会对服务器资源进行改变；

14. **HTTP的长连接和短连接分别是什么**

    HTTP的长连接和短连接实际上是TCP的长连接和短连接。

    * **长连接**：HTTP1.1规定了默认保持长连接，也称为**持久连接**。当数据传输完成后保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。但是长连接不是永久的连接，它有一个保持时间。使用长连接的HTTP协议，会在响应头加入这行代码：`Connection:keep-alive`
    * **短连接**：在HTTP/1.0中，默认使用短连接。浏览器和服务器每进行一次HTTP操作，就要建立一个连接，但任务结束就会中断这个连接

    使用长连接的好处：

    * 同一个客户端可以使用这个长连接处理其他请求，避免HTTP重新连接和断开消耗时间；
    * 服务器可以利用这个连接**主动推送**消息到客户端

15. **DNS是什么，DNS协议的原理**

    DNS的全程是Domain Name System或者Domain Name Service，主要作用就是将网址（域名）解析成电脑可以理解的IP地址，这个过程就是DNS域名解析（一个域名往往对应多个DNS地址）。

16. **DNS的解析过程**

    1. 输入`www.baidu.com`这个域名，操作系统会先检查自己本地的hosts文件中是否已经有这个网址映射关系，如果有，就先调用这个已存在的IP地址映射去完成域名解析；
    2. 如果本地hosts文件中没有这个域名的映射，则查找本地DNS解析器缓存中是否有这个网址的映射，如果有就返回这个完成域名解析；
    3. 如果hosts和本地DNS解析器缓存里都没有这个域名的映射，那么就会找本地DNS服务器，此服务器收到查询请求时，如果要查询的域名包含在本地配置区域资源中，就返回解析结果给客户机，完成域名解析（此解析具有权威性）；
    4. 如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址的映射关系，就调用这个进行IP地址映射，完成域名解析（此解析不具有权威性）；
    5. 如果本地DNS服务器本地区域资源和缓存解析都失败了，就让根DNS服务解析，如果自己无法解析，就联系下一级顶级域DNS服务器查询，如果还无法解析就联系下一级次级域名解析，如果还无法解析就使用下一级——主机名（host），又称三级域名进行解析，直到找个这个域名的主机为止。

    **另外一种表述方法是**：
    1. 发起基于域名的请求后，首先检查**本地缓存**（浏览器缓存$\longrightarrow$操作系统的hosts文件）；
    2. 如果**本地缓存**有，直接返回目标IP地址，否则将域名解析请求发送给**本地DNS服务器**；
    3. 如果**本地DNS服务器**中有，直接返回目标IP地址；如果没有，**本地DNS服务器**将解析请求发送给**根DNS服务器**;
    4. **根DNS服务器**会返回给**本地DNS服务器**一个所查询的**TLD服务器（顶级域名服务器）**地址列表；
    5. **本地DNS服务器**再向上一步返回的**TLD服务器**发送请求，**TLD服务器**查询并返回域名对应的域名对应的**权威域名服务器**的地址；
    6. **本地DNS服务器**再向上一步返回的**权威域名服务器**发送请求，**权威域名服务器**会查询存储的域名和IP的映射关系表，将IP连同一个`TTL`（过期时间）值返回给**本地DNS服务器**；
    7. **本地DNS服务器**会将IP和主机名的映射保存起来，保存时间由`TTL`来控制；
    8. **本地DNS服务器**把解析的结果返回给用户，用户根据`TTL`值缓存在**本地系统缓存**中，域名解析过程结束。

    **递归查询与迭代查询**：
    1. 主机向本地域名服务器的查询一般都是采用递归查询（客户端只发出一次请求，要求对方给出最终结果）。递归查询时，返回的结果只有两种：查询成功或者查询失败；
    2. 本地域名服务器向根域名服务器的查询时迭代查询（客户端发出了一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它那得到最终结果，即根域名服务器$\rightarrow$顶级域服务器$\rightarrow$次级域服务器$\rightarrow$主机名host）。迭代查询（又称重指引）时，返回的是最佳的查询点或者主机地址。

17. **浏览器输入一个URL后发生了什么（从输入网址到获得页面的过程）**

    1. **DNS解析**：浏览器会查询DNS，获取该域名（URL）对应的IP地址；具体过程包括了浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地的DNS服务器进行查询等；
       1. 首先向本地DNS服务器查询缓存。本地DNS服务器会让根DNS服务器查询，如果不知道就再向顶级域DNS服务器查询，如果还不知道就再向权威DNS服务器查询；(一个域名为`www.baidu.com.`，根域名就是最后的`.`，只是因为每个域名都有根域名，所以通常省略了；根域名的下一级是顶级域名，比如`.com`，`.org`等；再下一级就是次级域名，比如`.baidu`；再下一级就是主机名（host）了，比如`www`，这个又称为三级域名)。所以，整个解析流程就是**分级查询**；
       2. 这里查询使用了**递归查询**和**迭代查询**
    2. **TCP连接**：浏览器获得了域名对应的IP地址之后，浏览器就会向服务器请求建立连接，发起三次握手；
    3. **发送HTTP请求**：TCP连接建立之后，浏览器会向服务器发送HTTP请求；
    4. **服务器处理请求并返回HTTP报文**：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；
    5. **浏览器解析渲染界面**：浏览器解析并渲染视图，如果有对js、css和图片等静态资源的引用，就重复上述步骤并向服务器请求这些资源；浏览器会根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。
    6. **连接结束**

18. **HTTP响应码（状态码）**
    - 1XX：Informational（信息性状态码），表示请求已经被收到了，需要进一步的处理才能完成；
    - 2XX：Success（成功状态码），成功处理请求；
    - 3XX：Redirection（重定向状态码），重定向使用Location指向的资源或者缓存中的资源；
    - 4XX：Client Error（客户端错误状态码），客户端出现错误，请求失败；
    - 5XX：Server Error（服务端错误状态码），服务端出现错误，请求失败

    **常见状态码**：
    * 100：Continue，表示到目前为止都很正常，客户端可以继续发送请求；
    * 200：OK，请求正确；
    * 301：Moved Permanently，永久性重定向；
    * 302：Found，临时性重定向；
    * 400：Bad Request，请求报文中存在语法错误；
    * 403：Forbidden，请求被拒绝；
    * 404：Not Found；
    * 500：Internal Server Error，服务器正在执行请求时发生错误；

19. **cookie/session的区别**
    - cooike数据保存在用户的浏览器上（临时文件夹中），session数据保存在服务器上；
    - cookie是以明文的方式存放在客户端的，不是很安全，别人可以通过分析存在在本地的cookie来进行COOKIE诈骗；
    - cookie会传递消息给服务器；session本身存放在服务器中，不会有传送流量；
    - 生命周期：
        - cookie的生命周期是累加的，从创建时开始计时，20分钟后生命周期结束
        - session的生命周期是间隔的，创建后20分钟内没有访问session就会被销毁；但如果20分钟内访问了session，就又要重新计算session的生命周期；
    - session是一定时间内会存储在服务器中。当访问增多时会增加服务器的性能消耗，此时就可以考虑使用cookie；
    - cookie为多个用户浏览器共享，session为一个用户浏览器独享；

20. **OSI和TCP/IP的网络模型，路由器和交换机位于哪一层**

    **OSI七层模型**由上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。

    * 物理层：网卡、网线、集线器（采用广播的形式来传输信息）、中继器、调制解调器等
    * 数据链路层：网桥、交换机（用来进行报文交换，能够进行地址学习，采用存储转发的形式来交换报文）等
    * 网络层：路由器（一个作用是连通不同的网络，另一个作用是选择信息传送的线路）
    * 传输层以以上：网关工作

    所以，路由器位于OSI七层模型的第三层，网络层；二层交换机位于OSI的第二层数据链路层，三层交换机位于OSI的第三层网络层，因为其具有路由功能；

    **TCP/IP四层模型**由上到下分别是：应用层、传输层（TCP和UDP协议）、网络层（整个TCP/IP协议栈的核心，定义了IP协议）和网络接口层。

21. **IP地址的分类**

    IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址；

    每个IP地址包括两个标识码（ID）：网络ID和主机ID。**同一个物理网络下的所有主机都使用同一个网络ID，而网络上的一个主机（网络工作站、服务器和路由器等）则有一个主机ID与其对应**。

    A~E类地址的特点如下：
    * A类地址：以0开头，第一个字节范围是：0~127
    * B类地址：以10开头，第一个字节范围是：128~191
    * C类地址：以110开头，第一个字节范围是：192~223
    * D类地址：以1110开头，第一个字节范围是：224~239
    * E类地址：以1111开头，保留地址

22. **私有IP地址的范围**
    - A类私有IP地址：**10.0.0.0~10.255.255.255**
    - B类私有IP地址：**172.16.0.0~172.31.255.255**
    - C类私有IP地址：**192.168.0.0~192.168.255.255**

23. **为什么有了MAC地址还有IP地址**

    * 每台主机在出厂时都一个唯一的MAC地址，但是IP地址的分配是根据网络的拓扑结构，得以保证路由选择方案建立在网络所处的拓扑位置基础而不是设备制造商的基础上
    * 使用IP地址更方便传输数据。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的

24. **五层网络协议体系结构的理解和每一层对应的网络协议有哪些**

    * **应用层**的任务是通过应用进程之间的监护来完成特定的网络应用。应用层的协议有域名系统DNS，超文本传输协议HTTP，文本传输协议FTP，支持电子邮件的SMTP协议，安全外壳协议SSH等；
    * **传输层**的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。传输层的协议有传输控制协议TCP和用户数据报协议UDP；
    * **网络层**的任务就是选择合适的网间路由和交换结点，确保数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据封装成分组和包进行传送。网络层使用IP协议，所以分组也叫IP数据报，简称数据报。网络层的协议有网际协议IP协议和地址转换协议ARP等；
    * **数据链路层**：在两个相邻节点之间传送数据时，数据链路层将网络层传下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。帧中包含了数据和必要的控制信息（同步信息，地址信息，差错控制等）。控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束，还可以让接收端检测帧中是否有差错，如果有，就丢弃。数据链路层的协议主要有自动重传请求协议ARQ和点对点协议PPP等；
    * **物理层**：在物理层上所传送的数据单位是比特。它的作用是实现相邻计算机之间比特流的透明传送。

25. **停止等待协议的理解**
    停止等待协议是为了实现可靠传输的，它的基本原理就是每发送完一个分组就停止发送，等待对方确认，收到确认再发送下一个分组；在停止等待协议中，若接收方收到了重复的分组，就丢弃该分组，但同时还要发送确认。主要包括几种情况：无差错情况、超时重传、确认丢失和确认迟到。

26. **ARQ协议**
    * **自动重传请求ARQ协议**：停止等待协议中有一个超时重传的情况，指只要超过一段时间仍然没有收到确认，就会重传前面发送过的分组（默认之前发送的那个分组已经丢失了）。所以，每个发送完一个分组都要设置一个超时计时器，其重传时间会设置得比分组传输的平均往返时间要更长（如果更短，就可能是传输还有到达，不可取）。这种自动重传的方式就叫做**自动重传请求ARQ**。
    * **连续ARQ协议**：连续ARQ协议是用来提高信道利用率的。发送方维持一个发送窗口，位于发送窗口内的分组都可以连续发送出去，不需要等待对方确认。而接收方则采用累计确认，对按序到达的最后一个分组发送确认，就能表明这个分组之前的所有分组（包括这个分组）都已经正确收到了。


## 操作系统

1. **操作系统的四个特性**：

    1. 并发：同一段时间内多个程序执行
    2. 共享：系统中的资源可以被内存中多个并发执行的进线程共同使用
    3. 虚拟：通过时分复用以及空分复用技术实现把一个物理实体虚拟为多个
    4. 异步：系统中的进程以走走停停的方式执行，且以一种不可预知的速度推进

2. **进程和线程的区别**

   * 进程是具有一定功能的程序关于某个数据集合上的一次运行活动，是系统进行资源调度和分配的一个独立单位；
    * 线程是进程的实体，是CPU调度和分派的基本单位，它是比进程更小的独立运行的基本单位（线程不拥有资源）；
    * 一个进程可以有多个线程，多个线程也可以并发执行；

3. **线程同步的方式有哪些**

    * 互斥量（CMutex）：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权利。因为互斥对象可以保证公共资源不会被多个线程同时访问；
    * 信号量（CSemphore）：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量；
    * 事件（信号）：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作

4. **进程的通信方式有哪些**

    主要分为：管道（普通管道PIPE、流管道（s_pipe）、命名管道（name_pipe））、系统IPC（包括消息队列、信号量、共享存储）、SOCKET

    * 管道是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程；
    * 命名管道是一种半双工的通信方式，它允许无亲缘关系的进程间进行通信；
    * 信号量是一个计数器，用来控制多个进程对资源的访问，通常作为一种锁机制；
    * 消息队列是消息的链表，存放在内核中并由消息队列标识符标识；
    * 信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；
    * 共享内存就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问；
    * 套接字（SOCKET）也是一种进程间通信机制，与其它通信机制不同的是，**它可用于不同进程间的进程通信**。

5. **什么是缓冲区溢出？有什么危害？其原因是什么？**

    缓冲区溢出（Buffer Overflow）是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上；

    危害：

    * 程序崩溃，导致拒绝额外服务；
    * 跳转并且执行一段恶意代码

    原因：造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入

6. **什么是死锁？死锁产生的四个条件？**

    在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它们持有的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。即**两个或者多个进程因争夺资源而造成的无限期的阻塞、相互等待的一种状态**。

    死锁产生的四个条件（有任一条件不成立都不会产生死锁）：

    * 互斥条件：一个资源一次只能被一个进程使用
    * 请求与保持条件：一个进程因请求资源而被阻塞时，又对已有的资源保持不放
    * 不剥夺条件：进程获得的资源，在未完全使用之前，不能强行剥夺
    * 循环等待条件：若干进程之间形成一种头尾相接的环形等待资源关系

7. **进程有哪几种状态**

    * 就绪状态（Ready）：当进程已获得除处理机以外的所需资源，等待分配处理机资源，只要获得处理机便可立即执行
    * 运行状态（Running）：已获得处理机，占用处理机资源运行，处于此状态的进程数小于等于CPU数
    * 阻塞状态（Blocked）：进程等待某种条件，在条件满足之前无法执行，放弃处理机处于阻塞状态

    就绪$\rightarrow$ 执行：处于就绪状态的进程，当进程调度程序为之分配了处理机后，就会从就绪状态变成执行状态；

    执行$\rightarrow$ 就绪：处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而就不得不让出处理机，进程从执行状态转变成就绪状态；

    执行$\rightarrow$ 阻塞：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态

    阻塞$\rightarrow$ 就绪：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态

8. **分页和分段有什么区别**

   **分页**：用户程序的地址空间被划分为若干固定大小的区域，称为“**页**”。相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。

   **分段**：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段的单位，段与段在内存中可以不相连接，这样也实现了离散分配。

   * 段是信息的**逻辑单位**，它是根据用户的需要划分的，因此段对用户是可见的；页是信息的**物理单位**，是为了管理主存的方便而划分的，对用户是透明的；
   * 段的大小是不固定的，由完成它的功能决定；页的大小是固定的，由系统决定；
   * 段向用户提供二维地址空间；页向用户提供的是一维地址空间；
   * 段是信息的逻辑单位，便于存储保护和信息的共享；页的保护和共享受到限制

   **抽象的比喻**：用一个笔记本（100页纸）去上课做笔记，课程有语数英三门课。那么记笔记的方式有两种：

   * **分段管理**：从笔记本的第1页开始记笔记，事先规划好，比如2~30页做语文笔记，30~70页做数学笔记，70~100页做英语笔记。最后在第一张纸（第1页）上做个列表，记录三门课笔记的页数范围。这就是**分段管理**，第1页叫段表。
   * **分页管理**：因为课是交叉上的，即这节课语文课，下节课可能是英语课。所以就有可能将各笔记连接起来记。第2页是语文，第3页是英语，第4页是数学，然后又是语文，这样交叉记笔记。然后在第1页做一个目录，记录语文的笔记在哪几页，数学的在哪几页。这种做法就是分页管理器，第1页就叫做页表。

9. **常用的页面置换算法**

   * **先进先出算法**：最简单粗暴的一种置换算法，没有考虑页面访问的频率信息。**每次都是淘汰最早调入的页面**。
   * **最佳置换算法**：是一种只具有理论意义的算法。策略是**将当前页面中在未来最长时间内不会被访问的页面置换出去**。
   * **最近最久未使用置换算法（LRU）**：算法会赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间间隔t，每次置换的时候就把t值最大的页面置换出去（可以通过寄存器或者栈的方式来实现）。
   * **最近未使用置换算法（NRU）**：也叫**时钟算法clock**。页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为0，那么就置换，否则就将其置为0，循环，知道遇到一个访问位为0的页面。
   * **改进型clock算法**：在时钟算法clock的基础上，再添加一个**修改位**。替换时，根据访问位和修改位综合判断。优先替换访问位和修改位都为0的页面，其次是替换访问位为0修改位为1的页面。
   * **最少使用算法（LFU）**：设置寄存器记录页面被访问次数，每次置换的时候都置换当前访问次数最少的页面。

10. **操作系统中进程调度策略有哪几种**

11. **进程同步有哪几种机制**



12. **死锁的处理基本策略和常用方法**

    解决死锁的常用策略：鸵鸟策略、预防策略、避免策略、检测与检测策略

    解决死锁的基本方法：预防死锁、避免死锁、检测死锁、解除死锁

    1. **预防死锁**：

        * <font color="red">破坏互斥条件</font>：允许进程同时访问某些资源，即资源一次性分配。（因为有的资源是不允许被同时访问的，所以这种方法有时没有实用价值）。

        * <font color="red">破坏请求和等待的条件</font>：实行资源的预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，这个进程就暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将它所申请的资源都全部分配给该进程。这样这个运行的进程已占有了它所需的全部资源，又不会再去申请资源，所以就不会发生死锁现象。

            **缺点**：

            * 在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源是多少。因为进程在执行是动态的，是不可预测的；
            * 资源利用率低。因为无论这个进程申请的资源何时才要用到，一个进程也只有在占有所需的全部资源后才能执行。也就是说，即使有些资源仅仅被该进程只使用一次，也只能等到该进程结束后才能释放，这就会出现长期占有资源却不利用的情况，是一种资源的极大浪费；
            * 降低了进程的并发性。因为资源是有限的，再加上又存在浪费，所以这样能分配到全部资源的进程个数就少了。

        * <font color="red">破坏了不可剥夺的条件</font>：即允许进程强行从占有者那里夺取资源。即当一个进程已占有了某些资源，它申请新的资源失败了或者不能立即满足的话，就必须释放锁占有的全部资源。它将所释放的资源分配给其它进程，就相当于它的进程占有的资源被其它资源强行占有了（实现很困难，会降低系统性能）。

        * <font color="red">破坏环路等待条件</font>：采用**资源有序分配**的方法。即把资源事先分类编号，按编号分配，使得资源在使用时不会形成环路。要求所有进程对资源的请求必须严格按照资源序号递增的顺序申请。

            **缺点**：

            * 限制了进程对资源的请求，同时给系统中所有资源合理地编号也很困难，会增加系统的开销；
            * 为了遵循按照编号去申请的次序，暂不使用的资源也需要提前申请，这样会增加进程对资源的占用时间；

    2. **避免死锁**：

        因为**预防死锁**的几个策略都会严重的损害系统性能，所以在避免死锁这块要添加较弱的限制，从而获得较满意的系统性能。

        由于在避免死锁的策略中，可以**允许进程动态地申请资源**。所以，系统在进行资源分配之前可以预先计算好资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，就让**进程等待**。最有代表性的避免死锁算法是**银行家算法**。

        **银行家算法**：

        由Dijstra首先提出并解决的。TODO

    3. **检测死锁**：

        首先为每个进程和每个资源指定一个唯一的号码；然后建立<font color="red">资源分配表</font>和<font color="red">进程等代表</font>。例如：

    4. **解除死锁**：

        当发现有进程死锁后，就可以立即把它从死锁状态中解脱出来。常用的方法有：

        * **剥夺资源**：从其他进程剥夺足够数量的资源给死锁进程，就可以接触死锁状态
        * **撤销进程**：可以直接撤销死锁进程或者撤销代价最下的进程，直至有足够的资源可用让死锁状态消除为止；（<font color="red">代价</font>是指优先级、运行代价、进程的重要性和价值等）

## 数据库

### 存储过程

存储过程就像编程语言中的函数一样，封装了代码（PLSQL、T-SQL）。

#### 优点：

* 能够将代码封装起来
* 保存在数据库之中
* 让编程语言进行调用
* 存储过程是一个预编译的代码块，执行效率比较高
* 一个存储过程替代大量T_SQL语句，可以降低网络通信量，提高通信速率

#### 缺点：

* 每个数据库的存储过程几乎都是不一样的，十分难以维护
* 业务逻辑放在数据库上，比较难迭代

### 触发器

#### 作用

触发器是一种特殊的存储过程，主要是通过**事件**来触发而被执行的。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。触发器不能由用户显示调用，而是只有当出发时间发生并且被捕捉到后，才会被触发。

#### 语句

```SQL
// 创建触发器
create trigger trigger_name
trigger_time
trigger_event on tbl_name
for each row
trigger_stmt
```

* `trigger_name`：标识触发器名称，由用户自定义
* `trigger_time`：标识触发器的时机，取值可以是`before`和`after`
* `tbl_name`：标识建立触发器的表名，即在哪张表上建立触发器
* `trigger_stmt`：触发器的程序体，可以是一句SQL语句或者用`begin`和`end`包含的多条SQL语句，即触发后会执行的操作

可以建立6种触发器：`before insert`、`before update`、`before delete`、`after insert`、`after update`、`after delete`。

```SQL
// 查看触发器
select * from information_schema.`triggers`;
// 或者（[]代表可省略）
show triggers [from schema_name];

// 删除触发器
drop trigger trigger_name;
```

`schema_name`在这里指数据库名称，`trigger_name`是触发器名称。

### 三个范式

#### 第一范式1NF

> **字段是最小的单元不可再分**。

例如，学生信息组成了学生信息表，由年龄、性别、学号、名字等组成。这些字段都是不可再分的，所以就是满足第一范式的。

#### 第二范式2NF

> 第二范式首先是满足第一范式的，然后表中的字段必须完全依赖于全部的主键而非部分的主键。

即其它字段组成的记录和这个主键表示的都是同一个东西，而主键是唯一的，它们这些字段都只需要依赖于这个主键。

比如，一个学号为1的学生，他年龄23，女，姓名X。在这行记录中，学号就是这个学生的主键，年龄、性别、姓名等其它字段都是依赖于学号这个主键的。

#### 第三范式3NF

> 第三范式是满足第二范式的，非主键外的所有字段必须互不依赖。

即数据只会在一个存储，不会重复地出现在多张表中，这样就消除了传递依赖。

比如，大学里有很多不同的学院（计算机学院、软件学院、商学院等）。那个学院信息列表可以由以下字段组成：学院编号，院长，学院名称，学院介绍等。在这个记录中，学院编号就是学院这张表的主键。那么学生信息表中，就不能再添加学院编号，院长，学院简介等属性，否则就重复。就会发生**非主键外的字段形成了依赖关系**，也就是学院表中的一些非主键的属性和学生表有依赖关系了。这是不行的，正确的做法是：学生表中只能增加一个学院表的主键，即学院编号字段。

#### 视图

> 视图是一种基于数据表的虚表。

* 视图是一张虚表
* 视图建立在已有表的基础之上，视图赖以建立的这些表就叫做基表
* **向视图提供数据内容的语句为`SELECT`语句，可以将视图理解为存储起来的SELECT语句**
* 视图向用户提供基表数据的另一钟表现形式
* 视图没有存储真正的数据，真正的数据是存储在基表中
* 我们可以操作视图，但是操作视图最终还是会转化成操作基表
* 一个基表可以有0个或者多个视图

因为在查询时会编写很长的SQL语句，而视图是基于查询的一种虚表，视图可以将查询出来的数据进行封装，在使用时就会非常方便。

使用视图可以专注逻辑，但不会提高查询的效率。

### SQL语句种类

* DDL(Data Definition Language)：数据定义语言，定义对数据库对象（库、表、列、索引）的操作，比如有`create`、`drop`、`alter`、`rename`、`truncate`等命令；
* DML(Data Manipulation Language)：数据操作语言，定义对数据库记录的操作，代表指令有`insert`、`delete`、`update`、`select`等命令；
* DCL(Data Control Language)：数据控制语言，定义对数据库、表、字段、用户的访问权限和安全级别。代表指令有`grant`、`revoke`、`commit`、`rollback`、`savepoint`等命令。

### DEOP、DELETE和TRUNCATE的区别

`drop table`：

1. 属于DDL
2. 不可回滚
3. 不可以接`where`
4. 表的内容和结构都被删除
5. 删除的速度快

`truncate table`：

1. 属于DDL
2. 不可回滚
3. 不可以接`where`
4. 只删除表的内容
5. 删除的速度快

`delete from`：

1. 属于DML
2. 可以回滚
3. 可以接`where`
4. 表的结构还在，表的内容是否在要取决于`where`执行的情况
5. 删除的速度慢，需要逐行删除

**使用场景**：

* 当不再需要一张表的时候，就用`drop`命令
* 只想删除表中部分数据行时，用`delete`命令，并且需要带上`where`子句
* 保留表的结构但是删除所有的数据要用`truncate`命令

### 索引

> 索引（index）是一种快速查询表中内容的机制，类似于字典的目录。它运用在表中的某些字段上，但存储时，独立于表之外。它是用于提高数据库表数据访问速度的数据库对象。

* 索引可以避免全盘扫描。多数查询可以仅扫描少量索引页及数据页，而不是遍历所有数据页。
* 对于非聚集索引，有些查询甚至不用访问数据页。
* 对于聚集索引，可以避免数据插入操作集中于表的最后一个数据页。
* 在某些情况下，查询甚至可以不用访问数据页。

#### 特点
* 索引一旦建立，Oracle系统会对其自动维护，而且由Oracle系统决定何时使用索引
* 用户不用在查询语句中指定要使用哪个索引
* **在定义了`primary key`或者`unique`约束后，系统会自动在相应的列上创建索引**
* 用户可以根据自己需求，对指定的单个字段或者多个字段，添加索引

#### 分类
* **唯一索引**：唯一索引不允许两行具有相同的索引值
* **主键索引**：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引会要求主键中的每个值都是唯一的，并且不能为空
* **聚集索引**（Clustered）：表中各行的物理顺序与键值的逻辑（索引）的顺序是相同的，每个表中只能有一个
* **非聚集索引**（Non-Clustered）：非聚集索引指定了表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，而索引中包含了指向数据存储位置的指针。数量可以有多个，但是要小于249个

#### 优缺点
* 索引加快了数据库的检索速度（显而易见）
* 索引降低了插入、删除、修改等维护任务的速度（因为大部分数据更新的时候，同时也需要更新索引，所以会导致数据库系统更新数据的性能下降）
* 唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能
* 索引需要占物理和数据空间

#### 语法

##### 创建索引
```SQL
// 普通索引
alter table table_name add index index_name (column_list);
// 唯一索引
alter table table_name add unique (column_list);
// 主键索引
alter table table_name add primary key (column_list);
```
创建索引的方式包括普通索引、`unique`索引和`primary key`索引，`table_name`是要增加索引的表名，`column_list`是指出对哪些列要进行索引，如果是多列时，各列之间用逗号分隔。索引名`index_name`是可选的，如果缺醒，MySQL会根据第一个索引列赋一个名称。
```SQL
create index index_name on table_name (column_list);
create unique index index_name on table_name (column_list);
```
这同样是一种创建索引的方法，与`alter`语句具有相同的含义，索引名是不可选的。除此之外，**不能用`create index`语句创建`primary key`索引**。

##### 删除索引
```SQL
drop index index_name on table_name;
alter table table_name drop index index_name;
alter table table_name drop primary key;
```
在前两句中，是使用不同的命令删除了`table_name`中的索引`index_name`，而最后一句则是删除`primary key`的索引中才会使用。如果没有创建`primary key`索引，但是表具有一个或多个`unique`索引，就删除第一个`unique`索引。

#### 场景

**需要创建索引的场景**：
* 表经常要进行`select`操作
* 表很大（很多记录），记录的内容分布范围也很广
* 列名经常在`where`子句或者连接条件中出现

**不需要创建索引的场景**：
* 表经常要进行`insert`、`update`或`delete`操作
* 表很小，记录很少
* 列名不经常在`where`子句或者连接条件中出现

#### 创建索引的注意事项

* 非空字段：
* 取值离散大的字段：
* 索引字段越小越好：

### 事务

> 数据库事务（transaction）是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。

#### 四个特性

##### 原子性（Atomicity）

原子性是指**事务中一个不可再分割的工作单元，事务中的操作要么全部执行，要么全部不执行**。要么全部提交成功，要么全部失败回滚。即对于一个事务来说，不能只执行其中的一部分操作。

##### 一致性（Consistency）

一致性是指**在事务开始之前和事务结束之后，数据库的完整性约束都没有遭到破坏**。数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。

比如A给B转账，不论转账是否成功，A和B两人的存款总额是不会发生变化的。

##### 隔离性（Isolation）

**当多个事务同时并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行结果**。

##### 持久性（Durability）

**该事务对数据库所做的更改持久地保存在数据库之中，并不会发生回滚**。即完成的事务是永久的部分，对系统的影响是永久存在的。

#### 事务隔离级别

数据库定义了四个隔离级别：
* Serializable（序列化）：Serializable是最高的事务隔离级别，花销也最高，性能很低，一般很少使用。在该级别下，事务顺序执行，可以避免脏读、不可重复读和幻读。
* Repeatable read（重复读）：可以避免不可重复读，但有可能出现脏读和幻读。例如，只要事务开始，就不能再对该记录进行修改，所以会发生不可重复读。（MySQL默认隔离级别就是Repeatable read）
* Read committed（读提交）：避免了脏读，但是有可能会发生不可重复读和幻读。（SQL Server和Oracle的默认级别就是Read committed）。
* Read uncommitted（读未提交）：脏读、不可重复读和幻读都可能发生。

分别对应`Connection`类中的四个常量：
* `TRANSACTION_SERIALIZABLE`
* `TRANSACTION_REPEATABLE_READ`
* `TRANSACTION_READ_COMMITTED`
* `TRANSACTION_READ_UNCOMMITTED`

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :-------------: | :----: | :------: |
| Serializable     |       ❎        |   ❎   |    ❎    |
| Repeatable read  |       ❎        |   ✅   |    ✅    |
| Read committed   |       ❎        |   ✅   |    ✅    |
| Read uncommitted |       ✅        |   ✅   |    ✅    |

<center>✅：可能出现❎：不会出现</center>

##### 隔离级别与锁的关系

##### 脏读

> 一个事务读取到另外一个事务未提交的数据。

比如，A向B转账，A已经执行了转账语句，但是A还没有提交事务，这时候B读取数据时发现自己账户余额已经变多了。如果B通知A已经收到钱后，A又执行回滚事务（rollback），那么B再查看账户就会发现余额没有变多。

##### 不可重复读

> 一个事务读取到另外一个事务已经提交的数据，即一个事务可以看到其它事务所做的修改。

例如，A查询数据库，而B修改了数据库的数据，这就会导致A多次查询数据库的结果都不一样。这就发生了在一个事务内多次读到的数据是不一样的，就称为不可重复读。

##### 幻读（虚读）

> 一个事务读取到了别的事务插入的数据，导致前后读取不一致。

例如，事务A对一个表中的所有数据都进行了修改，同时，事务B向这个表插入了一行新的数据，那么操作事务A的用户就发现有一行新的数据没有修改到，前后读取不一致，仿佛产生了幻觉，叫做幻读（虚读）。

##### 总结

脏读是不可容忍的，不可重复读和幻读在一定情况下是可以的。

### 数据库的乐观锁和悲观锁

**乐观锁和悲观锁是并发控制主要采用的技术手段**。

* 悲观锁：假如会发生并发冲突，就屏蔽一切可能会违反数据完整性的操作
  * **在查询完数据后就把事务锁起来，直到提交事务**
  * 实现方式：使用数据库中的锁机制
* 乐观锁：假如不会发送并发冲突，只在提交操作时检查是否会违反数据完整性
  * **在修改数据的时候把事务锁起来，通过`version`的方式来进行锁定**
  * 实现方式：使用`version`版本或者时间戳

### 超键、候选键、主键、外键

* 超键（super key）：在关系中能唯一标识元组的属性集称为关系模式的超键。
* 候选键（candidate key）：不含有多余属性的超键叫做候选键，即最小的超键，没有冗余元素
* 主键（primary key）：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合叫做主键。一个数据列只能有一个主键，且主键的取值不能为空
* 外键（foreign key）：在一个表中，存在另一个表的主键，就叫做这个表的外键

假如有以下两个表：

学生表（学号，身份证号，姓名，性别，老师编号）；老师表（老师编号，姓名，性别）。

**超键**：因为超键的定义是关系中能够唯一标识的属性，所以对于学生表来说，**学号**和**身份证号**是可以表示学生的（都是唯一的），所以超键就是含有**学号**和**身份证号**的任意组合。比如：`(学号)`、`(学号，姓名)`、`(身份证号，性别)`等等。

**候选键**：候选键属于超键，是最小的超键，所以对于学生表而言的候选键为：**学号**和**身份证号**。

**主键**：主键就是候选键中的一个（当然有时候选键只有一个），是人为规定的。例如，我们通常设置学号为主键。

**外键**：外键就是两个表之间的连接。例如，在学生表中有一个字段是老师编号，而老师编号又是老师表中的主键，那么老师编号这个字段就是学生表中的外键。

### SQL约束

* 空值约束`not null`：用于控制字段内容一定不为空
* 唯一约束`unique`：控制字段不能重复，一个表中可以多个`unique`约束
* 主键约束`primary key`：用于控制字段内容不能重复，但是每个表中只能出现一个
* 外键约束`foreign key`：用于与另一张表相关联，是能确认另一张表记录的字段，用于保持数据的一致性
* 检查约束`check`：用于控制字段的值范围
* 默认值约束`default`：用于向列中插入默认值。如果没有规定其它的值，那么会将默认值添加到所有的新纪录

### 内连接、外连接、全连接

#### 内连接

内连接语句的关键字是`inner`、`join`、`on`。执行语句例如：`select * from a_table a inner join b_table b on a.a_id = b.b_id;`。

即匹配两张表中相关联的记录，也就是两张表中都有的记录，返回两个表的交集部分。

#### 左外连接

左外连接的关键字是`left`、`join`、`on`。执行语句例如：`select * from a_table a left join b_table b on a.a_id = b.b_id;`。

即除了匹配两张表相关联的所有记录，还会匹配左表中剩余的记录（相当于整个左边的记录都全部显示出来），右表中未匹配到的记录用`NULL`表示。

#### 右外连接

右外连接的关键字是`right`、`join`、`on`。执行语句例如：`select * from a_table a right join b_table b on a.a_id = b.b_id;`。

与左表相反，即除了匹配两张表相关联的所有记录，还会匹配右表中剩余的记录（相当于整个右边的记录都全部显示出来），左表中未匹配到的记录用`NULL`表示。

#### 全连接

返回左右表中所有的记录和左右表中相关联的记录（左右表的交集部分）。

目前MySQL是不支持全连接的。

### 分片、分区、分表、分库

#### 分片

分片（Sharding）是将一个数据分成两个或者多个较小的块，称为逻辑分片（logical shards）。然后逻辑分片分布在单独的数据库节点上，称为物理分片（physical shards）。物理分片可以容纳多个逻辑分片。

数据库分片（Database shards）是无共享架构的一个例子。这意味着分片是**自治**的：分片间不共享任何相同的数据或者服务器资源。

#### 分区

数据分区是一种物理数据库的设计技术，它的目的是在特定的SQL操作中减少数据读写的总量以缩短响应时间。分区不会形成新的数据表，实际上还是一张表，只是将表的数据均衡分摊到了不同的硬盘空间里，底层是由N个物理区块组成的。

**分区的好处**：
* **存储更多的数据**。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。相比单个磁盘或文件系统，可以存储更多的数据。
* **优化查询**。在使用`where`语句时，可以只扫描一个或者多个分区表来提交查询效率。
* **分区表更容易维护**。

**分区的局限**：
* 一个表最多只能有1024个分区
* 如果分区字段中含有主键或者唯一索引的列，那么主键列和唯一索引的列都必须要包含进来。
* 分区表中无法使用外键约束。

##### 水平分区

水平分区是对表的行进行分区。所有在表中定义的列都能在每个分区的数据集中找到，所以这个表的特性仍然是存在的。

例如，一个大学四年的成绩单，可以被分为四个不同的分区，每个分区中含有的数据集是每一年的成绩。（水平分区一定要按照某个属性列来分区，即这里分区的就是学年这个列）。

##### 垂直分区

这种分区一般来说是通过对表的垂直划分来减少表的宽度，使某些特定的列被划分到了特定的分区。

例如，一个学院表中有学院标号、学院名称、院长、学院简章、学院历史等属性列。学院简章和学院历史数据列的每一行都含有text等大字段，但是又不会经常被访问到，所以就将这两个属性列划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。

#### 分表

分表就是把一张表按照一定的规则分解成N个具有独立存储空间的实体表。

#### 分库

数据分布在不同的数据库之中（数据量极大）。

### 游标

游标是一种能从包括多条数据记录的结果中每次提取一条记录的机制。它的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果。尽管游标能遍历结果中的所有行，但一次只会指向一行。它的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。

游标具有三个属性：
* 不敏感（Asensitive）：数据库可以选择不复制结果集
* 只读（Read only）
* 不滚动（Nonscrollable）：游标是只能向一个方向前进的，并且不可以跳过任何一行数据

它的优点是对从数据库中查询得到的结果集的每一行都可以进行分开的独立的相同或者不相同的操作，是一种分离的思想。它的主要是就是性能不高，只能一行一行操作。在数据量较大的情况下，速度过慢。游标可能会造成死锁，内存不足等。

```SQL
// 定义游标，cursor_name是游标名称，select_statement是查询语句
declare cursor_name cursor for select_statement
// 打开游标
open cursor_name
// 取游标中的数据
fetch cursor_name into var_name
fetch next from cursor_name
fetch prior from cursor_name
fetch first from cursor_name
fetch last from cursor_name
// 关闭游标
close cursor_name
// 释放游标
deallocate cursor_name
```

### 常用SQL语句

```SQL
// 创建数据库
create database db_name;
// 删除数据库
drop database db_name;
// 创建新表，包含主键tbl_id和name两个属性
create table tbl_name (tbl_id int(11 not null auto_increment, name varchar(255) default null, primary key(tbl_id)));
// 删除表
drop table tbl_name;
// 增加一个列
alter table tbl_name add column column_name type;
// 添加主键
alter table tbl_name add primary key(id);
// 删除主键（一个表只有一个主键，所以不需要指定名称或者某一列）
alter table tbl_name drop primary key;
// 创建外键（表已经创建）
alter table table1 add foreign key (id) references table2(id);
// 创建外键（定义多个列的外键约束）
alter table table1 add constraint fk_tbl1tbl2 foreign key (id) references table2(id);
// 撤销外键约束
alter table tbl_name drop foreign key fk_tbl1tbl2;
// 创建索引（[]为可选）
create [unique] index idx_name on tbl_name;
// 删除索引（索引是不可更改的，必须删除后重新创建）
drop index idx_name;
// 创建视图
create view view_name as select_statement;
// 删除视图
drop view view_name;
// 查询
selct * from tbl_name where 查询条件;
// 插入
insert into tbl_name values(value1, value2);
// 插入（指定所要插入的数据的列）
insert into tbl_name (column1, column2) values (value1, value2);
// 删除
delete from tbl_name where 删除范围;
```

### ORM

ORM（Object Relational Mapping，对象关系映射）是一种思想，就是把对象（Object）转变成数据库中的记录，或者把数据库中的记录转变成对象。ORM通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，在后端具体操作数据库时，就不需要编写复杂的SQL语句，而是向操作对象一样就可以了。

这里需要了解两个概念，持久化（Persistence）和持久层（Persistence layer）。持久化，是把数据（如内存中的对象）保存到可永久保存的存储设备中。而持久层，是专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。

传统的使用JDBC操作数据库时，业务处理逻辑和数据存取逻辑是混淆在一起的。一般是如下几个步骤：
1. 建立数据库连接，获得`Connection`对象；
2. 根据用户的输入**组装**成SQL语句（复杂）；
3. 根据SQL语句建立`Statement`对象或者`PreparedStatement`对象；（`PreparedStatement是预编译的`，比`Statement`访问速度更快，代码的可读性和可维护性也更好）
4. 用`Connection`对象执行SQL语句，获得返回的结果集`ResultSet`对象；
5. 然后逐行读取结果集`ResultSet`对象中的数据；
6. 根据读取到的数据，按特定的业务逻辑进行操作；
7. 根据操作得到的结果再组装成新的SQL语句；
8. 再使用`Connection`对象执行更新的SQL语句去更新数据库中的数据；
9. 最后依次关闭`Statement`对象和建立连接的`Connection`对象；

从上可以看出，这个使用JDBC的逻辑是十分复杂的，除了上面的情况，还需要考虑到语句可能执行失败的处理逻辑。而如果使用ORM技术，例如流行的Hibernate或者MyBatis技术，业务逻辑会简化很多：

```Java
public Double calaAmount(String c_id, double amount) {
    // 根据id获取到Customer对象
    Customer customer = CustomerManager.getCustomer(id);
    // 根据顾客的等级获取相应的优惠政策
    Promo promo = PromoManager.getPromo(customer.getLevel());
    // 计算最终的价格
    customer.getAmount(customer.getAmount().add(amount));
    // 返回优惠后的价格
    return amount * promo.getRate();
}
```

以上就是业务逻辑的代码，可见是与数据存取逻辑完全分离的。数据存储逻辑等操作全部放在两个类中`CustomerManager`和`PromoManager`这两个类中完成。

### 数据库连接池

数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需要从缓冲池中取出一个，使用完毕之后再放回去。**可以通过设定连接池最大连接数来防止系统无尽地与数据库连接**。

连接池的核心思想是连接的复用，工作原理主要由三部分组成，分别为连接层的建立，连接池连接的使用管理，连接池的关闭。

1. **连接池的建立**。一般在系统初始化时，连接池会根据系统配置建立，并在池中建立几个连接对象，以便使用时能从连接池中获取。
2. **连接池的管理**。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其策略是：
  
   当客户请求数据库连接时，首先检查连接池中是否有空闲连接；如果存在空闲连接，则将连接分配给客户使用并作相应处理（即标记该连接为正在使用中，引用计数加1）；如果没有空闲连接，则查看当前所打开的连接数是否已经达到最大连接数，如果没有达到最大连接数，就重新创建一个新的连接给请求的客户；如果已经达到，那么就设定最大的等待时间让其等待，如果超出了这个等待时间，就抛出异常给用户。

   当客户释放数据库连接时，则要先判断该连接的**引用次数**是否超过了规定值，如果超过了就要从连接池中删除该连接，并判断当前连接池内总的连接数是否小于最小连接数，如果小于了又要将连接池充满；如果没超过就将这个连接标记为开放状态，可供再次复用；
3. **连接池的关闭**。当程序退出时，关闭连接池中所有的连接，释放连接池相关资源，该过程正好与创建是相反的。

**连接池的主要优点**：
1. **减少连接的创建时间**。连接池中的连接是早已准备好的，可以重复使用的，获取后就可以直接访问数据库进行操作，减少了连接创建的次数和时间；
2. **更快的系统响应速度**。数据库连接池在初始化过程中，往往已经创建了若干的数据库连接置于池中备用。此时连接的初始化工作均已完成。利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间；
3. **统一的连接管理**。如果不使用连接池，每次访问数据库都要创建一个连接，系统的稳定性受连接需求的影响很大，容易产生资源浪费和高负载异常。而连接池可以使性能最大化，将资源利用在一定的水平之下。连接池能够控制池中的连接数量，增强了稳定性。

### B树和B+树

#### 区别

#### B树的好处

#### B+树的好处

### MySQL

#### 数据库引擎

#### 数据类型

MySQL支持多种类型，大致可以分为三类：数值、日期/时间、字符串（字符）类型。所有数据类型详情可见：[MySQL数据类型](https://www.runoob.com/mysql/mysql-data-types.html)

1. `in`和`exist`的区别
2. `varchar`和`char`的区别
3. `varchar(50)`中50的含义
4. `int(20)`中20的含义
5. `int(10)`和`char(10)`和`varchar(10)`的区别

#### 有关权限的表

MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在MySQL数据库里，由`mysql_install_db`脚本初始化。

* user权限表：记录允许连接到服务器的用户账号信息，里面的权限是全局级的；
* db权限表：记录各个账号在各个数据库上的操作权限；
* table_priv权限表：记录数据**表级**的操作权限；
* columns_priv权限表：记录数据**列级**的操作权限；
* host权限表：配合db权限表对给定主机上数据库级操作权限做更细致的控制，这个权限表不受`grant`和`revoke`语句的影响

### SQL优化

1. 如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到？如何才能知道这条语句执行很慢的原因？
2. SQL的生命周期
3. 大表的数据查询怎么优化
4. 超大分页怎么处理
5. MySQL分页
6. 慢查询日志
7. 主键使用自增长ID还是UUID？
8. 优化关联查询
9. 优化LIMIT分页
10. 优化UNION查询
11. 优化WHERE子句

## 数据结构

## 算法面试

### 深度学习

#### 模型评估方法

1. Accuracy作为指标有哪些局限性
2. ROC曲线和PR曲线各是什么
3. 编程实现AUC的计算，复杂度是多少
4. AUC指标有什么特点？放缩结果对AUC是否有影响
5. 余弦距离与欧氏距离有什么特点

#### 基本方法

1. 如何划分训练集？如何选择验证集？
2. 什么是偏差和方差？
3. 什么是过拟合？在深度学习中，解决过拟合的方法有哪些？
4. 深度模型参数调整的一般方法论

#### 优化方法

1. 简述了解的优化器
2. 常用的损失函数有哪些，分别适用于场景
3. 梯度下降与拟牛顿法的异同
4. L1和L2正则分别有什么特点？为什么L1更稀疏

#### 深度学习基础

1. 用一层隐藏层的神经网络，以ReLU作为激活函数，MSE作为损失函数推导反向传播
2. NN的权重参数能否初始化为0
3. 什么是梯度消失和梯度爆炸
4. 常用的激活函数和导数
5. ReLU的优点和局限性，改进方法是什么
6. sigmoid和tanh为什么会导致梯度消失
7. 一个隐藏层需要多少个节点能实现包含n元输入的任意布尔函数
8. 多个隐藏层实现包含n元输入的任意布尔函数，需要多少个节点和网络层
9. Dropout为什么能够防止过拟合
10. Dropout和BN在前向传播和反向传播阶段的区别

#### CNN

1. 给定卷积核的尺寸，特征图大小的计算方法
2. 网络容量的计算方法
3. 共享参数有什么优点
4. 常用的池化操作有哪些，有什么特点
5. CNN如何用于文本分类
6. ResNet提出的背景和核心理论是什么
7. 空洞卷积是什么？有什么应用场景

#### RNN

1. 简述RNN，LSTM，GRU的区别和联系
2. 画出LSTM的结构图，写出公式
3. RNN的梯度消失问题，如何解决
4. LSTM中是否可以用ReLU作为激活函数
5. LSTM各个门分别使用什么作为激活函数
6. 简述seq2seq模型
7. seq2seq在解码的时候有哪些方法
8. 注意力机制是什么

### 机器学习

#### 基础

1. 样本不均衡如何处理
2. 什么是生成模型什么是判别模型

#### 集成学习

1. 集成学习的分类？有什么代表性的模型和方法
2. 如何从偏差和方差的角度解释bagging和boosting的原理
3. GBDT的原理，它和Xgboost的区别和联系
4. adaboost和dbdt的区别联系

#### 模型

1. 手推LR、K-means和SVM
2. 简述ridge和asson的区别和联系
3. 树模型如何调参
4. 树模型如何剪枝
5. 是否一定存在参数能够使得SVM的训练误差到0
6. 逻辑回归如何处理多分类
7. 决策树有哪些划分指标，其区别和联系
8. 简述SVD和PCA的区别和联系
9. 如何使用梯度下降方法进行矩阵分解
10. LDA与PCA的区别与联系

#### 特征工程

1. 常用的特征筛选方法有哪些
2. 文本如何构造特征
3. 类别变量如何构造特征
4. 连续值变量如何构造特征
5. 哪些模型需要对特征进行归一化
6. 什么是组合特征？如何处理高维组合特征

#### CV

#### NLP

1. word2vec的原理
2. glove的原理
3. fasttext的原理
4. 了解elmo和bert吗？简述与word embedding的联系与趋避

### 算法

#### 搜索回溯

1. 八皇后，全排列，组合
2. 重复数字的排列，重复数字的组合
3. 图的搜索
4. A star

#### 概率题

1. 用rand7构造rand10
2. 轮盘赌

#### 动态规划

1. 编辑距离
2. 背包问题
3. LCS

#### 字符串

1. 给定字符串是否符合正则表达式
2. 给定字符串是否是数字
3. KMP
4. 超大数相加

#### 海量数据

1. 海量日志的出现最多的K个字符串
2. 10亿个1-10的数字排序
3. trie树
4. 布隆过滤器