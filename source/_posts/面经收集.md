---
title: 面经收集
tags:
  - 面试
categories: 
  - Android
date: 2020-03-03
---

## 阿里钉钉三面

1. 自我介绍
2. 对MVC和MVP的理解
3. Handler的内存泄漏问题具体是什么，解决方案知道有什么，空数据的时候Handler的阻塞问题
4. 为什么使用MVP，它的优势是什么，内存泄漏是什么样的
5. http长连接和短连接的这两个概念
6. RecyclerView的复用机制，和ListView的一个区别在哪里
7. HashMap和ConcurrentHashMap和HashTable问题
8. 一个app的启动流程，冷启动和热启动

<!-- more -->

## 腾讯电话面一面

1. Class编译过程
2. 自定义View要经过哪些过程吗？
3. 如何绘制圆形、曲线等？
4. 自定义View是如何绘制在屏幕上的？
5. 简述Activity的生命周期
6. 应用切换到后台，前台Activity的生命周期经过哪些变化？
7. `onNewIntent()`方法什么时候会触发？
8. `singleTask`和`singleTop`有什么区别？
9. 两个Activity如何进行跨进程通信？
10. 一个进程进行文件读取时，如何设置权限（不让其他进程访问）？
11. Android如何实现多线程？
12. 简述Handler如何实现多线程？
13. JVM是什么？为什么需要JVM？
14. 简述客户端网络请求架构？
15. 如何保证客户端网络请求的安全性？
16. HTTP长连接和短连接的不同
17. 简述三次握手
18. HTTPS是何如加密的
19. DNS是什么
20. 如何从一亿个QQ号中筛选出五个指定的QQ号》
21. 快排算法实现过程，时间复杂度是多少？有什么弊端
22. 简述归并排序算法，时间复杂度是多少？

## 腾讯暑期Android实习一二面

### 一面

1. ArrayList和LinkedList的区别，它们各自的优缺点是什么以及它们有什么异同点

2. 进程和线程的区别

3. `static`这个命名的变量和类有什么不同？

4. 二叉树有几种遍历方式？

    * 先序遍历：根、左、右

    * 中序遍历：左、根、右

    * 后序遍历：左、右、根

    * 层次遍历：从上往下层次遍历

5. 堆和栈的特点

    1. 栈内存是用来存储局部变量和方法调用的，堆内存是用来存储Java中对象的。无论是成员变量、局部变量还是类变量，它们指向的对象都存储在堆内存中。
    2. 栈内存远远小于堆内存。
    3. 数据结构方面：堆可以看成一颗树，栈是一个先进后出的数据解耦股。

6. 队列和栈，它们在数据进出顺序的方面有什么不同点？

    先进先出和先进后出

7. Java有几种内存模式，其中变量/方法/类分别储存在哪里？栈内存主要用来存放什么？

8. 介绍一个Java的垃圾回收机制

    垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源。可以调用`System.gc()`方法或者`Runtime.getRuntime().gc()`方法。

9. 说一下去MVC是什么？

10. Android六大布局，线性布局和相对布局哪个效率高？

11. Activity生命周期

12. Activty从打开状态到运行状态经历了哪几个方法？

## 阿里淘系技术部Android实习一二面

### 一面

1. 简历项目介绍

2. 看过哪些Android或者Java的书籍

    《第一行代码》、《Android进阶之光》

3. 设计一个图片加载框架需要考虑到哪些方面

    图片加载包含封装、解析、下载、解码、变换、缓存、显示等操作。

    1. 封装参数：这些参数会贯穿整个过程
    2. 解析路径：图片的来源有很多种，格式也不尽相同，需要规范化
    3. 读取缓存：同样的请求，可以从缓存中读取图片
    4. 查找文件/下载文件：如果是本地的文件，直接解码；如果是网络图片，需要先下载
    5. 解码：
    6. 变换：通过解码成bitmap，可能要做一些变换处理（例如圆角等）
    7. 缓存：得到最终的bitmap后，可以缓存起来，以便下次可以使用
    8. 显示：显示图片，可能会添加一些动画

    为了防止图片分辨率过大，出现OOM，还需要进行进一步处理。比如说用到`BitmapFactory`类对大图片进行压缩处理后再放到内存中。

4. 场景：找出海量字符里面出现次数最多的那个字符

    1. 分治法+HashMap：

        比如说分为很多批，1批有100个字符。这100个字符可以存进`String`类型的字符串数组中，每批使用循环遍历一次，存入`HashMap<String, Integer>`里面，`String`对应这个数的字符串，`Integer`对应它出现的次数，最后最大的字符就是出现次数最多的。

5. Activity的启动流程

    当在Activity中调用`startActivity`方法来启动另一个Activity时，调用流程：`startActivity`$\rightarrow$`startActivity(intent, bundle)`$\rightarrow$`startActivityForResult(intent, -1, bundle)`。最后去调用`Instrumentation.execStartActivity`方法。

    `Instrumentation`有什么作用呢？为什么要在`Instrumentation`中去执行`execStartActivity`方法呢？

    `Instrumentation`是在任何应用程序运行前进行初始化的，可以用它来检测系统和应用程序之间的交互。每一个Activity都会持有`Instrumentation`的引用，但是整个进程只有一个`Instrumentation`实例，所以`Instrumentation`相当于一个大管家，管理着Activity和Application的生命周期，包括着Activity的创建。

6. Android性能优化

7. 算法：找出单向链表的中间节点

8. 算法：单向链表的头尾节点交换

9. 算法：给定N个`int`型的数组，每个数组的元素个数不确定也不一定相同，请将N个`int`类型的数组合并成一个数组，同时进行降序的排列

### 二面

1. 为什么学习Android

2. Android看的书籍，收获？

3. 最满意的项目

4. 项目里的多线程

5. Activity启动过程

6. 内存泄漏，用什么工具检测？

    **内存泄漏**是指：对象在它有限的生命周期结束后，它们将被垃圾回收，如果在回收时，这个对象还在被一系列的引用，就会导致该对象不会被回收，就会导致内存泄漏。随着泄漏的累积，应用将消耗完内存，应用的流畅性就会大大减弱。

    可以使用**LeakCanary**检测内存泄漏。当发生内存泄漏时，会进入内存泄漏报告分析。

7. Android页面的刷新频率

8. Android如何发现性能问题

9. 操作系统死锁

   死锁的四个条件：

   1. 互斥：该资源任意时刻都只由一个线程占用；
   2. 持有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
   3. 不可抢占：线程已获得的资源在未使用完之前不能被其它资源所侵占，只有自己使用完毕才能释放资源；
   4. 环路等待：形成进程和请求资源之间的环路，呈一种头尾相接的循环等待资源关系。

10. 树的区别（大小顶堆、AVL、排序树）

   1. AVL树：即平衡二叉树，AVL得名于其发明者的名字。

       平衡二叉树的定义：

       1. 左右子树的高度差都小于等于1
       2. 其每一个子树均为平衡二叉树

   2. 二叉堆：是一种特殊的堆，具有堆的性质（父节点的键值总是大于等于或者小于等于任何一个子节点的键值）。二叉堆又具有二叉树的性质（二叉堆是完全二叉树或者是近似完全二叉树。）

       1. 最大堆：当父节点的键值总是大于等于它的每一个子节点的键值时就是最大堆
       2. 最小堆：当父节点的键值总是小于等于它的每一个子节点的键值时就是最小堆

       二叉堆查找的时间复杂度是$O(n)$，创建二叉堆、插入节点、删除节点的时间复杂度都是$O(\log2n)$。

   3. 排序树：二叉排序树又叫做二叉查找树或二叉搜索树。它满足以下性质：

       1. 若它的左子树不为空，则左子树的所有节点的值都要小于它的根节点的值；
       2. 若它的右子树不为空，则右子树的所有节点的值都要大于它的根节点的值；
       3. 它的左、右子树也都分别为二叉排序树。

       当然，如果这棵树是一颗空树，那也满足是二叉排序树。

11. 算法：矩阵逆时针打印每一个元素

## CVTE Android实习一二面

### 一面

1. 自我介绍

2. Retrofit源码

3. Java线程同步的方法

    1. 同步方法`synchronized`修饰方法

        ```java
        public synchronized void save() {}
        ```

        Java的每个对象都有一个内置锁，如果使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就会处于阻塞状态。

    2. 同步代码块`synchronized`修饰代码块

        ```java
        synchronized(object) {}
        ```

        被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。

        同步是一种高开销的操作，所以应该尽量减少同步的内容。

    3. 使用特殊域变量`volatile`实现线程同步

        ```java
        private volatile int account = 100;
        ```

        只需要加上`volatile`就可以实现线程同步。

        1. `volatile`关键字为域变量的访问提供了一种免锁机制
        2. 使用`volatile`修饰域相当于告诉虚拟机该域可能会被其它线程更新，因此每次使用该域都要重新计算，而不是使用寄存器的值
        3. `volatile`不会提供任何原子操作，也不能用来修饰`final`类型的变量

    4. 使用重入锁实现线程同步

    5. 使用局部变量实现线程同步

    6. 使用阻塞队列实现线程同步

    7. 使用原子变量实现线程同步

4. `Synchronized`和`Lock`的区别

    `Synchronized`：是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻只有一个线程执行改该段代码。

    `Lock`：是一个接口，主要有`Lock`、`ReadWriteLock`、`ReentrantLock`、`ReentrantReadWriteLock`等。

    **区别**：

    * `Lock`是一个接口，而`Synchronized`是Java中的关键字，是内置的语言实现；
    * `Synchronized`在发生异常的时候，会自动释放线程占有的锁，所以不会产生死锁现象；而`Lock`在发生异常的时候，如果没有主动通过`unLock()`方法去释放锁，则有可能会造成死锁现象，因此使用`Lock`时需要在`finally`块中释放锁；
    * `Lock`可以让等待的锁的线程响应中断，而`Synchronized`不能；使用`Synchronized`时，等待的线程会一直等待下去，不能响应中断；
    * `Lock`可以提高多个线程进行读操作的效率，通过`ReadWriteLock`去实现读写分离；

5. 锁的类型（悲观、乐观、可重入、可中断、公平、读写）

    见[Java锁的原理与类型]()

6. 四种引用

    1. 强引用：

        使用强引用时，属于不可回收的资源，垃圾回收器绝不会回收它。当内存空间不足时，Java虚拟机宁愿抛出`OutOfMemoryError`的异常，使程序终止，也不会回收具有强引用的对象来解决内存不足的问题。这是最常使用到的引用。

        ```java
        Object obj = new Object();
        ```

    2. 软引用：

        如果一个对象具有软引用，那么如果此时内存空间足够，垃圾回收器就不会回收它。但如果内存空间不足时，就会回收这些对象的内存。只要垃圾回收器还没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列联合使用，如果软引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。

        ```java
        Object obj = new Object();
        ReferenceQueue queue = new ReferenceQueue();
        SoftReference reference = new SoftReference(obj, queue);
        // 强引用对象滞空，保留软引用
        obj = null;
        ```

        当内存不足时，软引用对象被回收，`reference.get()`为`null`，将软引用的对象添加进ReferenceQueue队列中。

    3. 弱引用：

        弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间是否充足，都会回收它的内存。同理，弱引用也可以和引用队列一起使用。

        ```java
        Object obj = new Object();
        ReferenceQueue queue = new ReferenceQueue();
        WeakReference reference = new WeakReference(obj, queue);
        // 强引用对象滞空，保留弱引用
        obj = null;
        ```

    4. 虚引用：

        虚引用不影响对象的生命周期，如果一个对象与虚引用关联，则相当于没有引用与之关联，虚引用在任何时候都可能被垃圾回收器回收。

        但是注意，虚引用必须和引用队列关联使用，当垃圾回收器准备与虚引用关联的对象时，会把这个虚引用添加到与之关联的引用队列中。

        因此，程序可以通过判断引用队列中是否已经加入了虚引用来判断对象是否要被垃圾回收。如果某个对象的虚引用已经被加入到引用队列中，那么就可以在该对象的内存被回收之前采取必要的行动。

        ```java
        Object obj = new Object();
        ReferenceQueue queue = new ReferenceQueue();
        PhantomReference reference = new PhantomReference(obj, queue);
        // 强引用对象滞空，保留软引用
        obj = null;
        ```

    5. 引用总结：

        ![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20170628111722923.png)

        ![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20170628191146753.png)

7. GC机制

8. 线程池（ThreadPoolExecutor参数、线程池类型、线程池工作策略）

9. binder（binder内部具体类和方法，工作流程，IPC方式的比较）

10. HTTP响应码

    * 1XX：表示请求已经被收到了，需要进一步的处理才能完成；
    * 2XX：成功处理请求；
    * 3XX：重定向使用Location指向的资源或者缓存中的资源；
    * 4XX：客户端出现错误，请求失败；
    * 5XX：服务端出现错误，请求失败

11. cookie/session的区别

    * cooike数据保存在用户的浏览器上（临时文件夹中），session数据保存在服务器上；
    * cookie是以明文的方式存放在客户端的，不是很安全，别人可以通过分析存在在本地的cookie来进行COOKIE诈骗；
    * cookie会传递消息给服务器；session本身存放在服务器中，不会有传送流量；
    * 生命周期：
        * cookie的生命周期是累加的，从创建时开始计时，20分钟后生命周期结束
        * session的生命周期是间隔的，创建后20分钟内没有访问session就会被销毁；但如果20分钟内访问了session，就又要重新计算session的生命周期；
    * session是一定时间内会存储在服务器中。当访问增多时会增加服务器的性能消耗，此时就可以考虑使用cookie；
    * cookie为多个用户浏览器共享，session为一个用户浏览器独享；

12. Handler消息传递机制（内部机制、执行流程、线层切换）

    Android应用程序被创建的时候都会创建一个UI主线程，但有时会进行一些比较耗时的操作，为了防止阻塞UI主线程，会把耗时的操作放到子线程中进行处理，处理完之后操作UI，但是又因为Android规定UI只能在主线程中操作，所以消息传递机制是为了解决Android应用的多线程问题。Handler是一种异步回调机制，它可以在完成一个耗时任务后做出相应的通知。

    > 首先需要在主线程中创建一个Handler对象，并重写`handleMessage()`方法，然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler的`sendMessage()`方法把这个消息发送出去。这个消息会进入到`MessageQueue`队列中等待被处理，而`Looper`会一直尝试从`MessageQueue`中取出待处理信息，最后发送回Handler的`handleMessage()`方法。
    >
    > 因为`Handler`是在主线程中创建的，所以`handleMessage()`方法也会在主线程中执行，所以最后就可以进行UI操作了。一条Message经过这个流程从子线程进入到了主线程，从不能更新UI变成了可以更新UI，整个异步消息处理的核心就是这样。

    ![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20190512113022344.jpg)

13. Android动画机制

14. 自定义View

### 二面

1. 自我介绍

2. Retrofit源码（动态代理）

3. Glide源码

4. 实现一个图片加载框架要考虑什么

5. HashMap源码，线程安全要用哪个（ConcurrentHashMap）

    官方文档中是这样描述HashMap的：

    > Hash table based **implementation of the Map interface**. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is **unsynchronized** and **permits nulls**.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.

    这其中有几个关键的信息：基于Map接口实现、允许键/值为`null`、非同步、不保证有序（比如插入的排序）、也不保证序不随时间变化。

    所以：

    1. HashMap的特点：

        是基于Map接口时间的，存储键值对时，它接收键值对为`null`，是非同步的，HashMap存储着`Entry(hash, key, value, next)`对象。

    2. HashMap的工作原理：

        通过hash的方法，通过put和get存储和获取对象。

        存储对象时，将键值对传递给put方法，它调用hashCode计算hash从而得到bucket的位置，进一步存储，HashMap会根据当前的bucket占用的情况自动调整容量（超过Load Factor则resize为原来的2倍）。

        获取对象时，把key传递给get，它调用hashCode计算hash从而得到bucket的位置，并进一步调用`equals()`方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来。如果一个bucket中碰撞冲突的元素超过某个限制（默认为8），则使用红黑树来替换链表，从而提高速度。

    3. get和put的原理？`equals()`和`hashCode()`有什么作用？

        通过对key的`hashCode()`进行hashing，计算下标n-1和hash值，从而获得bucket的位置。如果产生碰撞，则利用`key.equals()`的方法去链表或树中去查找对应的节点。

    4. hash如何实现的？

        在Java1.8中，是通过`hashCode()`的高16位异或低16位实现的：`(h = k.hashCode()) ^ (h >>> 16)`，这么做可以在bucket的n比较小时，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。

    5. 如果HashMap大小超过了负载因子（load factor）定义的容量，怎么办？

        如果超过负载因子（默认为0.75），则resize一个原来长度两倍的HashMap，并且重新调用hash方法。

    6. 想要线程安全是使用HashMap还是ConcurrentHashMap？

        HashMap线程是不安全的。例如：

        1. 多线程环境下，put的时候导致的多线程数据不一致
        2. HashMap的get操作可能会因为resize而引起死循环

        ConcurrentHashMap是线程安全的。因为：

        1. 分段机制：segment，每段加reentrantLock可重入锁
        2. 定位元素：找segment的数组下标；找segment的HashEntry数组下标
        3. get方法：不需要加锁，value值使用了volatile关键字修饰
        4. put方法：hash计算端，锁定段，hash计算HashEntry数组，若超多阈值，就扩容释放；put过程中会modCount+1，为了后续的计算大小
        5. size方法：为了求Map的大小，需要全局锁，但是性能差；所以采用modCount计算器，用于记录段的大小
        6. 弱一致性：clear时是不加锁的，所以多线程中可能会出现数据不一致

6. 事件分发机制

7. 滑动冲突（手写外部拦截法的伪代码）

8. 性能优化

9. 手写快排

## 字节跳动Android实习一二面

### 一面

1. Parcelable和Serializable是什么，做什么用，谁更高效？

    `Serializable`是Java原生的接口，`Parcelable`是Android提供的接口。

    * `Parcelabel`：实现这个接口要重写三个方法，就是实现序列化过程要实现三个功能——**序列化**、**反序列化**、**内容描述**。

        * 序列化：由`writeToParcel()`方法完成，里面主要是`write`一些对象的属性
        * 反序列化：由CREATOR完成，内部标明了如何创建序列化对象和数组，并通过`read`方法来完成反序列化过程
        * 内容描述：重写`describeContents()`方法来完成，一般返回0，如果当前对象中存在文件描述时返回1

        `Parcelabel`开销小，效率高，使用场景为内存序列化。

    * `Serializable`：就是直接实现`Serializable`接口，无需实现方法，`Java`就会对这个对象进行高效的序列化操作。它简单，但是开销大，序列化过程的I/O操作过多，使用了反射，序列化过程慢，效率低，使用场景为序列化到本地或者通过网络传输。

2. 数据库中的事务

    数据库事务（Transaction）是访问并可能操作各种数据项的一个数据库操作序列，要么全部执行，要么全部不执行，是一个不可分割的工作单位。

    * 原子性：
    * 一致性：
    * 夺隔离性：
    * 夺持久性：

3. 假如手机只有10M内存，想要申请1M的内存是否一定能成功？

4. 讲一个时间片

    时间片表示进程在被抢占之前所能持续运行的时间。

5. 对线程池的理解

    线程池就是事先将线程放到一个容器中，当使用线程的时候，就不用再新建一个线程，直接从线程中取出就好。可以用`execute()`方法启动线程池。

    **好处**：

    1. 降低资源消耗：重复利用线程池中的线程节省线程创建和销毁带来的消耗；
    2. 提高性能：当任务需求时，可以不用创建线程，而是可以直接从线程池中取出线程去执行，更高效；
    3. 提高线程的可管理性：如果频繁无限制地创建线程会消耗系统资源，降低系统稳定性导致系统崩溃、内存溢出等问题；

6. 想要在一个图片的右上角实现一个圆角是怎么实现的？

7. Java的四种引用

8. 抖音无限上滑是怎么实现的？

9. 什么时候会发生内存泄漏？

10. 算法题：两数之和（时间复杂度）

### 二面

1. 自我介绍，做过的项目

2. 数据库频繁读取数据，可以用什么方式来优化（索引）

3. 死锁的四个条件，开发过程中什么情况容易造成死锁

4. 手机端应用和电脑端应用的注意事项和区别

5. `public`父类中子类重写能不能用`protected`，反过来呢？

6. 场景题：抖音开屏广告是如何实现的（包括倒计时和要播放的视频），倒计时点击跳过的时候应该如何实现？

    倒计时用Handler，播放的视频用url打开保存在本地的视频

7. 算法题：二叉树的最长路径（DP）

## 字节跳动Android实习一二三四面

### 一面

1. 自我介绍
2. 操作系统线程和进程的同步机制和通信机制
3. 手写Java双重检验的单例模式
4. 数据库的索引和它的原理
5. Java的四种引用方式
6. OSI和TCP/IP的网络模型，路由器和交换机位于哪一层
7. `synchronized`的类锁和对象锁的区别，哪些是对象锁，哪些是类锁
8. 算法题：给一对无序数组，给一个target整数，然后找出数组中两个数字相加为target，并输出下标
9. 给两对有序的数组，给出合并后有序的数组（数组合并）
10. http和https的区别
11. HTTP1和HTTP2的区别，HTTP2和HTTPS的关系
12. 操作系统的分页分段管理，虚拟内存
13. Java的GC机制，引用计数和可达性分析算法，`finlize()`方法，四种回收算法，哪些对象可以作为GC ROOTS的对象
14. 说一下Java的`synchronized`和`volatile`关键字，可见性、重排序、原子性
15. 智力题：8个物品，有一个质量较大，如何两次称出它
16. 算法题：最长连续子序列

### 二面

1. 缓存溢出
2. Android中常用哪些控件
3. Glide的使用
4. RxJava的通信机制
5. Android四大组件
6. 手写SQL语句，分组查询
7. 中断是什么
8. 算法题：汉诺塔

### 三面

1. 了解bitmap的解析吗
2. 设计一个自定义View，View中包含图片和文字，并且只能继承View
3. 用过约束布局吗？它的特点和原理，比起相对布局的优势
4. Glide相关
5. https的加密过程，为什么要这么做
6. 浏览器输入一个url后发生了什么，DNS协议的原理
7. `get`和`post`的区别
8. 封装一个单链表，要求实现删除，添加，反转的方法
9. 算法题：数组反转，给定一个target整数，每target长度反转一次

### 四面

1. 看过哪些Android源码
2. OkHttp的缓存策略
3. 除了Glide还用过哪些图片加载框架
4. Activity的四种启动方式，区别
5. Android的线程同步机制和进程通信机制
6. Java中的泛型，类型擦除

## 阿里河马Java实习一面

1. 自我介绍
2. 面向对象三大特性
3. 继承和接口的区别
4. 重写、重载的原理，重载和重写各自应用的场景
5. `int`和`Integer`的区别，为什么会有`Integer`缓冲池？`Integer`缓冲池细节，比如`Integet a = 1; Integer b = new Integet(1)`，a和b比较返回true还是false？
6. Object类有什么方法？
7. `HashCode`有什么作用？`equals`和`HashCode`有什么关系？
8. `HashCode`在`HashMap`中的作用？`HashMap`和`ConcurrentHashMap`的区别？
9. 什么是线程安全的？操作变量情景下怎么样才是线程安全的？怎么样是线程不安全的？
10. 多个线程操作局部变量，静态变量的情况下，虚拟机是怎么分配内存的？
11. `Synchronized`的实现原理，锁的升级过程，修饰实例对象和`class`的区别
12. 讲一下`wait`、`notify`、`notifyAll`，`notify`能具体指定唤醒一个实例吗？为什么是随机唤醒，底层是如何实现的？
13. 讲一下`ClassLoader`，jre下的jar包是由什么加载的？
14. 讲一下`Exception`和`Error`
15. 用户线程和守护线程的区别和使用场景？守护线程能否访问数据库？
16. TCP三次握手。为什么不能只用两次和四次？TCP四次挥手
17. HTTP和HTTPS的区别。给你一个网站，考虑使用HTTP还是HTTPS？
18. 讲一下你理解的MVC，SpringMVC的处理流程，拦截请求是怎么实现的？
19. 讲一下IOC和AOP编程
20. 什么时候用索引？什么时候不用？
21. 分布式事务如何保证一致性？
22. `HashMap`的实现原理？`get`和`put`

## 京东数科一面

1. 常见的集合`collection`和`collections`的区别
2. `list`和`set`的区别，以及各自的子类
3. `HashMap`的原理
4. `ConcurrentHashMap`的原理
5. `start`和`run`的区别，线程状态等
6. 线程池工作原理，核心参数，阻塞队列；常见的两种阻塞队列有何不同？

## 字节跳动后端实习一二面

### 一面

1. 数据库隔离级别
2. 数据库事务特性
3. `select`、`epoll`、`poll`
4. Java运行时内存区域
5. 避免死锁的方式
6. 手撕代码：<font color="red">最长上升子序列的个数</font>

### 二面

1. 手撕代码：最长的不包含重复字符的子串长度
2. DNS解析过程

## 美团Java实习一面

1. `Integer`缓冲池，`long`是否有？
2. `HashMap`底层实现
3. `HashMap`线程安全吗？解释一下发生链表死循环？
4. `Map`下有哪些线程安全？
5. `ConcurrentHashMap`的实现，`HashTable`和`HashMap`的区别
6. `ConcurrentHashMap`的`size`操作是怎么做的？需要加锁吗？
7. Java的内存回收，什么时候会内存回收？
8. GC算法
9. Java垃圾回收器
10. MySQL的引擎
11. 事务的概念

## 字节跳动测试开发实习一二面

1. Git常用命令，有冲突时会怎么做？
2. UDP和TCP的区别？
3. 进程和线程
4. 手撕代码：链表判断入环点
5. 手撕代码：翻转句子中的单词
6. Java的`int`的取值范围
7. Java的内存模型
8. `Student s = new Student()`在内存中都经历了什么
9. `get`和`post`请求
10. 输入一个url到显示网页的过程
11. 编程题：字符串中的英文单词逆序，可能包含N个
12. 编程题：数组重排，将当前数字成为后面第一个比自己打的数字，如果没有填-1，要求最优的时间复杂度











