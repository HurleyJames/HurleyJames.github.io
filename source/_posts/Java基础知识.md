---
title: Java基础知识
tags:
  - 面试
categories: 
  - Java
date: 2020-01-24
---

## Java基础知识

### 面向对象和面向过程的区别

* **面向过程：面向过程比面向对象的性能更高**。因为类调用时需要实例化，开销比较大。但是，面向过程没有面向对象易维护、易复用、易拓展。
* **面向对象：易维护、易复用、易拓展**。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。

<!-- more -->

### JVM、JDK和JRE

#### JVM

Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。

##### 字节码

> 在 Java 中，JVM可以理解的代码就叫做`字节码`（即扩展名为 `.class` 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。

##### Java程序从源代码到运行的步骤

![](https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67.png)

#### JDK和JRE

JDK是Java Development Kit，是Java SDK。它拥有JRE的一切，还有编译器（javac）和工具（例如javadoc）。**它能够创建和编译程序。**

JRE是Java运行时的环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令等。**但它不能用于创建新程序。**

### Java和C++的区别

* 都是面向对象的语言，都支持封装、继承和多 态
* Java**不提供指针**来直接访问内存，程序内存会更加安全
* Java的类是**单继承**的，C++支持**多重继承**；Java的接口可以多继承
* Java有自动内存管理机制

### 重载和重写的区别

#### 重载

发生在同一类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。简单的说，就是**多个方法有相同的名字、不同的参数**，便产生了重载。

#### 重写

重写是子类对父类的允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为`private`则子类不能重写该方法。

### 三大特性：封装 继承 多态

#### 封装

封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。

### 继承

继承是使用已存在的类的定义作为基础建立类的技术，新的类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。

* 子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。
* 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
* 子类可以用自己的方式实现父类的方法。

#### 多态

多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。

在Java中可以有两种形式实现多态：**继承**和**接口**。

### 接口和抽象类的区别

1. 接口的方法默认是`public`，所有方法在接口中不能实现，而抽象类可以有非抽象的方法。
2. 接口中除了static、final变量，不能有其它变量，而抽象类中则不一定。
3. 一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可以通过`extends`关键字扩展多个接口。
4. 接口方法默认修饰符是`public`，抽象方法可以有`public`、`protected`和`default`这些修饰符（不能使用`private`关键字修饰）

### String StringBuffer StringBuilder的区别

#### 可变性

`String`类中是使用`final`关键字修饰字符数组来保存字符串，所以`String`对象是不可变的。`StringBuilder`与`StringBuffer`都继承自`AbstractStringBuilder`类，在`AbstractStringBuilder`中没有用`final`关键字修饰，所以这两种对象是可变的。

#### 线程安全性

`String`中的对象是不可变的，也可以理解为常量，线程安全。`StringBuffer`对方法添加了同步锁或者对调用的方法加了同步锁，所以是**线程安全**的。`StringBuilder`并没有对方法进行加同步锁，所以是**非线程安全**的。

#### 性能

每次对`String`类型进行改变时，都会生成一个新的`String`对象，然后将指针指向新的`String`对象。

`StringBuffer`每次都会对`StringBuffer`对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用`StringBuilder`相比使用`StringBuffer`能获得10%~15%左右的性能提升，但是要冒线程不安全的风险。

#### 总结

1. 操作**少量数据**：适用`String`
2. **单线程**操作字符串缓冲区下操作大量数据：适用`StringBuilder`
3. **多线程**操作字符串缓冲区下操作大量数据：适用`StringBuffer`

### 自动装箱与拆箱

* **装箱**：将基本类型用它们对应的引用类型包装起来；
* **拆箱**：将包装类型转换为基本数据类型；

### 成员变量和局部变量的区别

1. **语法形式**：成员变量是**属于类**的，而局部变量是在**方法中定义的变量**或者是**方法的参数**；成员变量可以被`public`、`private`、`static`等修饰符修饰，而局部变量不能被访问控制修饰符及`static`所修饰；但是它们都能被`final`修饰符修饰。
2. **变量在内存中的存储方式**：如果成员变量是使用`static`修饰的，那么这个成员变量是属于类的；如果没有使用`static`修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。
3. **变量在内存中的生存时间**：成员变量是对象的一部分，随着对象的创建而存在；而局部变量会随着方法的调用而自动消失。
4. 成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（如果被`final`修饰，则必须显式赋值），而局部变量不会自动赋值。

### 构造方法的作用和特性

构造方法的主要作用是完成对类对象的初始化工作。

#### 特性

1. 名字与类名相同。
2. 没有返回值，但是也不能用`void`声明构造函数。
3. 生成类的对象时自动执行，无需调用。

### 静态方法和实例方法的不同

1. 在外部调用**静态方法**时，可以使用`类名.方法名`的方式，也可以使用`对象名.方法名`的方式。而实例方法只能后面这种方式，即需要创建新对象而静态方法不需要。
2. 静态方法在访问本类的成员时，只能允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。

### `==`与`equals`

**==**：判断两个对象的地址是否相等，即判断**两个对象是否是同一个对象**。

**equals()**：判断两个对象是否相等，但有两种使用情况：

* 如果类没有覆盖`equals()`方法，则通过`equals()`比较该类的两个对象时，等价于通过`==`比较这两个对象。
* 如果类覆盖了`equals()`方法，一般都覆盖`equals()`方法来比较两个对象的内容是否相等，若相等则直接返回`true`。

### final关键字

`final`关键字主要用在三个地方：变量、方法、类。

1. 如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。
2. 当用`final`修饰一个类时，表明这个类不能被继承。`final`类中的所有成员方法都会被隐式的指定为`final`方法。
3. 使用`final`的原因有两个。一个是把方法锁定，以防任何继承类来修改它的含义。所以类中所有的`private`方法都被隐式的指定为`final`；第二个原因是效率。

### static关键字

`static`关键字主要有以下四种使用场景：

1. **修饰成员变量和成员方法**：被`static`修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以直接通过类名调用。被`static`声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。调用格式：`类名.静态变量名`和`类名.静态方法名()`。
2. **静态代码块**：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，静态代码块只执行一次。
3. **静态内部类（`static`只能修饰内部类）**：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用意味：1. 它的创建是不需要依赖外围类的创建；2. 它不能使用任何外围类的非`static`成员变量和方法。
4. **静态导包（用来导入类中的静态资源）**：格式为`import static`，这个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。

#### 静态代码块

静态代码块的格式是

```java
static {
    // 语句体;
    i = 3;
}
```

一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中的出现的先后顺序依次执行它们，每个代码块只会被执行一次。

静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。

### this和super关键字

`this`关键字用于引用类的当前实例，此关键字是可选的，使用此关键字可能会使代码更易读或易懂。

`super`关键字用于从子类访问父类的变量和方法。

* 使用`super()`调用父类中的其它构造方法时，该语句必须处于首行，否则编译器会报错。另外，`this`调用本类中的其它构造方法时，也要放在首行。
* `this`、`super`不能用在`static`方法中。

### 异常处理

在`Java`中，所有的异常都有一个共同的祖先`java.lang`包中的`Throwable`类。`Throwable`有两个重要的子类：`Exception`（异常）和`Error`（错误），二者都是`Java`异常处理的重要子类，各自包含大量的子类。异常和错误的区别：异常能被程序本身处理，错误是无法处理的。

#### Error（错误）

**是程序无法处理的错误**，表示运行应用程序中较严重问题。大多数错误表示代码运行时JVM（Java虚拟机）出现的问题，例如JVM不再有继续执行操作所需的内存资源时，将出现`OutOfMemoryError`。这些错误表示故障是发生于虚拟机自身或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（`Virtual MachineError`）、类定义错误（`NoClassDefFoundError`）等。这些错误在运行前是不可查的。

#### Exception（异常）

**是程序本身可以处理的异常**。`Exceptiton`类有一个重要的子类`RuntimeException`。除此之外，还有`NullPointerException`和`ArrayIndexOutOfBoundsException`等。

#### Throwable类常用方法

* `public string getMessage()`：返回异常发生时的简要描述
* `public string toString()`：返回异常发生时的详细信息
* `public string getLocalizedMessage()`：返回异常对象的本地化信息。如果`Throwable`的子类有覆盖这个方法，则可以生成本地化信息。如果子类没有覆盖这个方法，则方法返回的信息与`getMessage()`返回的结果相同
* `public void printStackTrace()`：在控制台上打印`Throwable`对象封装的异常信息

#### 总结

* **try块**：用于捕获异常，其后可以接多个**catch块**或者不接。如果其后没有**catch块**，则必须跟一个**finally块**。
* **catch块**：用于处理`try`捕获到的异常。
* **finally块**：无论是否捕获或处理异常，**finally块**里的语句都会被执行。如果在**try块**或者**catch块**中有`return`语句，则在`return`返回之前执行**finally语句**。

有四种特殊情况下，`finally`块不会执行：

1. 在`finally`语句块第一行发生了异常。
2. 在前面的代码中使用了`System.exit()`退出程序。
3. 程序所在的线程死亡。
4. 关闭CPU。

### hashCode与equals

`hashCode()`的作用是获取哈希码，也称为散列码；它实际上是返回一个`int`整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。`hashCode()`定义在JDK的`Object.java`中，意味着Java的任何类都包含`hashCode()`函数。`hashCode()`在散列表中才有用，在其它情况下没用。在散列表中`hashCode()`的作用是获取对象的散列码，进而确定该对象在散列表中的位置。

1. 如果两个对象相等，则`hashCode`也一定是相同的
2. 如果两个对象相等，则对两个对象分别调用`equals()`方法都返回`true`
3. 两个对象有相同的`hashCode`值，也不一定是相等的
4. `equals`方法被覆盖过，则`hashCode`方法也必须被覆盖
5. `hashCode()` 的默认行为是对堆上的对象产生独特值。如果没有重写` hashCode()`，则该 `class `的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）

### Collections工具类和Arrays工具类常见方法

#### Collections工具类常用方法：

1. 排序
2. 查找，替换操作
3. 同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包的并发集合）

##### 排序操作

```java
void reverse(List list)	// 反转
void shuffle(List list) // 随机排序
void sort(List list) // 按自然排序的升序排序
void sort(List list, Comparator c) // 定制排序，由Comparator控制排序逻辑
void swap(List list, int i, int j) // 交换两个索引位置的元素
void rotate(List list, int distance) // 旋转。当distance为正数时，将list后distatnce个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面。
```

##### 查找，替换操作

```java
int binarySearch(List list, Object key) // 对List进行二分查找，返回索引，注意List必须是有序的
int max(Collection coll)	// 根据元素的自然顺序，返回最大元素
int max(Collection coll, Comparator c) // 根据定制排序，返回最大元素，排序规则由Comparatator类控制
void fill(List list, Object obj) // 用指定的元素代替指定list中的所有元素
int frequency(Collection c, Object o) // 统计元素出现个数
int indexOfSubList(List list, List target) // 统计target在list中第一次出现的索引
boolean replaceAll(List list, Object oldVal, Object newVal) // 用新元素替换旧元素
```

##### 同步控制

因为`HashSet`、`TreeSet`、`ArrayList`、`LinkedList`、`HashMap`、`TreeMap`都是线程不安全的。`Collections`提供了多个`synchronizedXxx()`静态方法可以把它们包装成线程同步的集合。

**最好不要使用下面这些方法，因为效率非常低**。

```java
synchronizedCollection(Collection<T> c);
synchronizedList(List<T> list);
synchronizedMap(Map<K, V>, m);
synchronizedSet(Set<T> s);
```

#### Arrays类的常见操作

1. 排序：`sort()`
2. 查找：`binarySearch()`
3. 比较：`equals()`
4. 填充：`fill()`
5. 转列表：`asList()`
6. 转字符串：`toString()`
7. 赋值：`copyOf()`

### Java中的IO流

#### 分类

* 按照流的流向分，可以分为**输入流**和**输出流**；
* 按照操作单元分，可以分为**字节流**和**字符流**；
* 按照流的角色分，可以分为**节点流**和**处理流**；

Java的IO流中的类都是从4个抽象类基类中派生出来的。

* `InputStream/Reader`：所有的输入流的基类，前者是**字节输入流**，后者是**字符输入流**。
* `OutputStream/Writer`：所有的输出流的基类，前者是**字节输出流**，后者是**字符输出流**。

### 泛型

如果一个方法接收`List<Object>`作为形式参数，那么如果尝试将`List<String>`的对象作为实际参数传进去，就会发现无法通过编译。尽管`String`是`Object`的子类，但是实际上会**产生隐含的类型转换问题**，所以编译器是禁止这样的行为的。

#### 类型擦除

在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数会被编译器在编译的时候去掉，这个过程就叫做**类型擦除**。比如，`List<String>`和`List<Object>`等类型在编译之后都会变成`List`。JVM看到的只有`List`，而由泛型附加的类型信息对于JVM来说是不可见的。

#### 通配符

在使用泛型类的时候，既可以指定一个具体的类型，如`List<String>`就声明了具体类型是`String`类型；但也可以通过通配符`?`来表示未知类型，如`List<?>`就表示了`List`中包含的元素类型是未知的，也就意味着所有类型都是可以的。

但注意`List<?>`并不等同于`List<Object>`。因为`List<Object>`确定了`List`中包含的是`Object`及其子类，在使用的时候都可以通过`Object`来进行引用，而`List<?>`其中包含的元素是不确定的。如果其包含的是`String`类型的，那往里添加`Integer`类型的元素就是错误的。

在某些情况下，可以使用**上下界**来限制未知类型的范围。如通过`List<? extends Number>`来说明`List`中可能包含的元素类型是`Number`及其子类。而`List<? super Number>`则说明`List`中包含的是`Number`及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。





