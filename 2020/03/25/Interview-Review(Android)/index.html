<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Interview-Review(Android) | Hurley</title><meta name="description" content="本篇主要是面试复习内容的Android部分。 Android主要分为以下几个部分：  Activity Fragment Service Broadcast Receiver Content Provider 数据存储 Bitmap Handler AsyncTask View Animation Window 布局 事件 设计模式   ActivityActivity生命周期 启动Activit"><meta name="keywords" content="面试"><meta name="author" content="Hurley"><meta name="copyright" content="Hurley"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/icon.png"><link rel="canonical" href="https://hurleyjames.github.io/2020/03/25/Interview-Review(Android)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Interview-Review(Android)"><meta property="og:url" content="https://hurleyjames.github.io/2020/03/25/Interview-Review(Android)/"><meta property="og:site_name" content="Hurley"><meta property="og:description" content="本篇主要是面试复习内容的Android部分。 Android主要分为以下几个部分：  Activity Fragment Service Broadcast Receiver Content Provider 数据存储 Bitmap Handler AsyncTask View Animation Window 布局 事件 设计模式   ActivityActivity生命周期 启动Activit"><meta property="og:image" content="https://hurleyjames.github.io/../image/android-interview.png"><meta property="article:published_time" content="2020-03-24T16:00:00.000Z"><meta property="article:modified_time" content="2020-12-06T05:29:01.116Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="prev" title="Interview-Review(Java)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/"><link rel="next" title="121.Best Time to Buy and Sell Stock" href="https://hurleyjames.github.io/2020/03/12/121.Best-Time-to-Buy-and-Sell-Stock/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/26319720?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">71</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Activity"><span class="toc-number">1.</span> <span class="toc-text">Activity</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity生命周期"><span class="toc-number">1.1.</span> <span class="toc-text">Activity生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#横竖屏切换时Activity的生命周期变化"><span class="toc-number">1.1.1.</span> <span class="toc-text">横竖屏切换时Activity的生命周期变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity-A启动了Activity-B，它们的生命周期的变化"><span class="toc-number">1.1.2.</span> <span class="toc-text">Activity A启动了Activity B，它们的生命周期的变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onSaveInstanceState-和onRestoreInstanceState-调用的过程和时机"><span class="toc-number">1.1.3.</span> <span class="toc-text">onSaveInstanceState()和onRestoreInstanceState()调用的过程和时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态"><span class="toc-number">1.1.4.</span> <span class="toc-text">优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity四种启动模式"><span class="toc-number">1.2.</span> <span class="toc-text">Activity四种启动模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#standard标准模式"><span class="toc-number">1.2.1.</span> <span class="toc-text">standard标准模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleTop栈顶复用模式"><span class="toc-number">1.2.2.</span> <span class="toc-text">singleTop栈顶复用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleTask栈内复用模式"><span class="toc-number">1.2.3.</span> <span class="toc-text">singleTask栈内复用模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#singleInstance单实例模式"><span class="toc-number">1.2.4.</span> <span class="toc-text">singleInstance单实例模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么情况下分别使用上面四种不同的启动模式"><span class="toc-number">1.2.5.</span> <span class="toc-text">什么情况下分别使用上面四种不同的启动模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#onNewIntent-调用时机"><span class="toc-number">1.2.6.</span> <span class="toc-text">onNewIntent()调用时机</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Activity的启动过程"><span class="toc-number">1.2.7.</span> <span class="toc-text">Activity的启动过程</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Fragment"><span class="toc-number">2.</span> <span class="toc-text">Fragment</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Fragment的生命周期"><span class="toc-number">2.1.</span> <span class="toc-text">Fragment的生命周期</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity与Fragment的异同"><span class="toc-number">2.2.</span> <span class="toc-text">Activity与Fragment的异同</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity和Fragment的关系"><span class="toc-number">2.3.</span> <span class="toc-text">Activity和Fragment的关系</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Service"><span class="toc-number">3.</span> <span class="toc-text">Service</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Service的两种启动方式和生命周期"><span class="toc-number">3.1.</span> <span class="toc-text">Service的两种启动方式和生命周期</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过startService-来启动（各自飞）"><span class="toc-number">3.1.1.</span> <span class="toc-text">通过startService()来启动（各自飞）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过bindService-来启动（共存亡）"><span class="toc-number">3.1.2.</span> <span class="toc-text">通过bindService()来启动（共存亡）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如果一个Service既被startService-启动又被bindService-启动，生命周期是怎么样的（或者问如何把Service停止）"><span class="toc-number">3.1.3.</span> <span class="toc-text">如果一个Service既被startService()启动又被bindService()启动，生命周期是怎么样的（或者问如何把Service停止）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Service的生命方法运行在哪个线程中"><span class="toc-number">3.1.4.</span> <span class="toc-text">Service的生命方法运行在哪个线程中</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IntentService与Service的区别"><span class="toc-number">3.2.</span> <span class="toc-text">IntentService与Service的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何保证Service不被杀死（如何提高Service的优先级）"><span class="toc-number">3.3.</span> <span class="toc-text">如何保证Service不被杀死（如何提高Service的优先级）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Service与Activity如何实现通信"><span class="toc-number">3.4.</span> <span class="toc-text">Service与Activity如何实现通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用的系统Service"><span class="toc-number">3.5.</span> <span class="toc-text">常用的系统Service</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#BroadcastReceiver"><span class="toc-number">4.</span> <span class="toc-text">BroadcastReceiver</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态注册和静态注册的区别"><span class="toc-number">4.1.</span> <span class="toc-text">动态注册和静态注册的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#广播的各种形式"><span class="toc-number">4.2.</span> <span class="toc-text">广播的各种形式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序"><span class="toc-number">4.3.</span> <span class="toc-text">顺序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#ContentProvider"><span class="toc-number">5.</span> <span class="toc-text">ContentProvider</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#网络框架"><span class="toc-number">6.</span> <span class="toc-text">网络框架</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#HttpClient与HttpUrlConnection"><span class="toc-number">6.1.</span> <span class="toc-text">HttpClient与HttpUrlConnection</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">6.1.1.</span> <span class="toc-text">区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#OkHttp"><span class="toc-number">6.2.</span> <span class="toc-text">OkHttp</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理"><span class="toc-number">6.2.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Retrofit"><span class="toc-number">6.3.</span> <span class="toc-text">Retrofit</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-1"><span class="toc-number">6.3.1.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理"><span class="toc-number">6.3.2.</span> <span class="toc-text">代理</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态代理"><span class="toc-number">6.3.2.1.</span> <span class="toc-text">静态代理</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#动态代理"><span class="toc-number">6.3.2.2.</span> <span class="toc-text">动态代理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Volley"><span class="toc-number">6.4.</span> <span class="toc-text">Volley</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数据存储"><span class="toc-number">7.</span> <span class="toc-text">数据存储</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android中提供哪些数据持久存储的方法"><span class="toc-number">7.1.</span> <span class="toc-text">Android中提供哪些数据持久存储的方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文件存储"><span class="toc-number">7.1.1.</span> <span class="toc-text">文件存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SharedPreferences存储"><span class="toc-number">7.1.2.</span> <span class="toc-text">SharedPreferences存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库存储"><span class="toc-number">7.1.3.</span> <span class="toc-text">数据库存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ContentProvider存储"><span class="toc-number">7.1.4.</span> <span class="toc-text">ContentProvider存储</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网络存储"><span class="toc-number">7.1.5.</span> <span class="toc-text">网络存储</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SharedPreferences适用情形？使用中需要注意什么？"><span class="toc-number">7.2.</span> <span class="toc-text">SharedPreferences适用情形？使用中需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQLite的事务处理？是如何做的？"><span class="toc-number">7.3.</span> <span class="toc-text">SQLite的事务处理？是如何做的？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Bitmap"><span class="toc-number">8.</span> <span class="toc-text">Bitmap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#图片框架的三级缓存机制"><span class="toc-number">8.1.</span> <span class="toc-text">图片框架的三级缓存机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#LRU算法的原理"><span class="toc-number">8.2.</span> <span class="toc-text">LRU算法的原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#实现ImageLoader"><span class="toc-number">8.3.</span> <span class="toc-text">实现ImageLoader</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#同步加载和异步加载接口的设计"><span class="toc-number">8.3.1.</span> <span class="toc-text">同步加载和异步加载接口的设计</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#同步加载"><span class="toc-number">8.3.1.1.</span> <span class="toc-text">同步加载</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#异步加载"><span class="toc-number">8.3.1.2.</span> <span class="toc-text">异步加载</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Android中缓存更新策略"><span class="toc-number">8.4.</span> <span class="toc-text">Android中缓存更新策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#线程"><span class="toc-number">9.</span> <span class="toc-text">线程</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask"><span class="toc-number">9.1.</span> <span class="toc-text">AsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-2"><span class="toc-number">9.1.1.</span> <span class="toc-text">原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#IntentService"><span class="toc-number">9.2.</span> <span class="toc-text">IntentService</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程池的好处、原理、类型"><span class="toc-number">9.3.</span> <span class="toc-text">线程池的好处、原理、类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#好处"><span class="toc-number">9.3.1.</span> <span class="toc-text">好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原理-3"><span class="toc-number">9.3.2.</span> <span class="toc-text">原理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">9.3.3.</span> <span class="toc-text">分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadPoolExecutor的工作策略"><span class="toc-number">9.4.</span> <span class="toc-text">ThreadPoolExecutor的工作策略</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Pipeline管道模式"><span class="toc-number">9.5.</span> <span class="toc-text">Pipeline管道模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Handler"><span class="toc-number">10.</span> <span class="toc-text">Handler</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Handler消息传递机制工作原理"><span class="toc-number">10.1.</span> <span class="toc-text">Handler消息传递机制工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#一个Thread可以有几个Looper？几个Handler？"><span class="toc-number">10.2.</span> <span class="toc-text">一个Thread可以有几个Looper？几个Handler？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？"><span class="toc-number">10.3.</span> <span class="toc-text">如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#为什么在子线程中创建Handler会抛出异常"><span class="toc-number">10.4.</span> <span class="toc-text">为什么在子线程中创建Handler会抛出异常</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#主线程的Looper是轮询死循环为何没有阻塞主线程"><span class="toc-number">10.5.</span> <span class="toc-text">主线程的Looper是轮询死循环为何没有阻塞主线程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用Handler的postDelay-后消息队列会发生什么变化"><span class="toc-number">10.6.</span> <span class="toc-text">使用Handler的postDelay()后消息队列会发生什么变化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Message可以如何创建？哪种效果更好，为什么？"><span class="toc-number">10.7.</span> <span class="toc-text">Message可以如何创建？哪种效果更好，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#runOnUiThread如何实现子线程更新UI"><span class="toc-number">10.8.</span> <span class="toc-text">runOnUiThread如何实现子线程更新UI</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作"><span class="toc-number">10.9.</span> <span class="toc-text">ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作?</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#AsyncTask-1"><span class="toc-number">11.</span> <span class="toc-text">AsyncTask</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask原理"><span class="toc-number">11.1.</span> <span class="toc-text">AsyncTask原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask相比Handler有什么优点和缺点"><span class="toc-number">11.2.</span> <span class="toc-text">AsyncTask相比Handler有什么优点和缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#使用AsyncTask需要注意什么"><span class="toc-number">11.3.</span> <span class="toc-text">使用AsyncTask需要注意什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AsyncTask中使用的线程池大小"><span class="toc-number">11.4.</span> <span class="toc-text">AsyncTask中使用的线程池大小</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HandlerThread有什么特点"><span class="toc-number">11.5.</span> <span class="toc-text">HandlerThread有什么特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HandlerThread常规使用步骤"><span class="toc-number">11.6.</span> <span class="toc-text">HandlerThread常规使用步骤</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速实现子线程使用Handler"><span class="toc-number">11.7.</span> <span class="toc-text">快速实现子线程使用Handler</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#View"><span class="toc-number">12.</span> <span class="toc-text">View</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#View的绘制流程"><span class="toc-number">12.1.</span> <span class="toc-text">View的绘制流程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#自定义View"><span class="toc-number">12.2.</span> <span class="toc-text">自定义View</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分类-1"><span class="toc-number">12.2.1.</span> <span class="toc-text">分类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现步骤"><span class="toc-number">12.2.2.</span> <span class="toc-text">实现步骤</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View的滑动方式"><span class="toc-number">12.3.</span> <span class="toc-text">View的滑动方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#通过View本身提供的scrollTo-scrollBy方法"><span class="toc-number">12.3.1.</span> <span class="toc-text">通过View本身提供的scrollTo/scrollBy方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过动画给View施加平移效果实现滑动"><span class="toc-number">12.3.2.</span> <span class="toc-text">通过动画给View施加平移效果实现滑动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通过改变View的LayoutParams使View重新布局实现滑动"><span class="toc-number">12.3.3.</span> <span class="toc-text">通过改变View的LayoutParams使View重新布局实现滑动</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#三种方法的使用对比"><span class="toc-number">12.3.4.</span> <span class="toc-text">三种方法的使用对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何解决View的滑动冲突"><span class="toc-number">12.3.5.</span> <span class="toc-text">如何解决View的滑动冲突</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View的事件分发机制"><span class="toc-number">12.4.</span> <span class="toc-text">View的事件分发机制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View的工作原理"><span class="toc-number">12.5.</span> <span class="toc-text">View的工作原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View和ViewGroup的区别"><span class="toc-number">12.6.</span> <span class="toc-text">View和ViewGroup的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#非UI线程可以更新UI吗"><span class="toc-number">12.7.</span> <span class="toc-text">非UI线程可以更新UI吗</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MotionEvent是什么？包含几种事件？什么时候会产生？"><span class="toc-number">12.8.</span> <span class="toc-text">MotionEvent是什么？包含几种事件？什么时候会产生？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Animation"><span class="toc-number">13.</span> <span class="toc-text">Animation</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Android中有哪几种类型的动画"><span class="toc-number">13.1.</span> <span class="toc-text">Android中有哪几种类型的动画</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#View动画和属性动画的区别"><span class="toc-number">13.2.</span> <span class="toc-text">View动画和属性动画的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#帧动画在使用时需要注意到什么"><span class="toc-number">13.3.</span> <span class="toc-text">帧动画在使用时需要注意到什么</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#属性动画中插值器和估值器的作用"><span class="toc-number">13.4.</span> <span class="toc-text">属性动画中插值器和估值器的作用</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#插值器（Interpoloator）"><span class="toc-number">13.4.1.</span> <span class="toc-text">插值器（Interpoloator）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#估值器（TypeEvaluator）"><span class="toc-number">13.4.2.</span> <span class="toc-text">估值器（TypeEvaluator）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Window"><span class="toc-number">14.</span> <span class="toc-text">Window</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Activity、View、Window之间的关系"><span class="toc-number">14.1.</span> <span class="toc-text">Activity、View、Window之间的关系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Window有哪几种类型"><span class="toc-number">14.2.</span> <span class="toc-text">Window有哪几种类型</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#布局"><span class="toc-number">15.</span> <span class="toc-text">布局</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#六大布局"><span class="toc-number">15.1.</span> <span class="toc-text">六大布局</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#margin和padding的区别"><span class="toc-number">15.1.1.</span> <span class="toc-text">margin和padding的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConstraintLayout"><span class="toc-number">15.2.</span> <span class="toc-text">ConstraintLayout</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#ConstraintLayout与RelativeLayout的区别"><span class="toc-number">15.2.1.</span> <span class="toc-text">ConstraintLayout与RelativeLayout的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#RecyclerView"><span class="toc-number">15.3.</span> <span class="toc-text">RecyclerView</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView与ListView的区别"><span class="toc-number">15.3.1.</span> <span class="toc-text">RecyclerView与ListView的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解adapter订阅者模式"><span class="toc-number">15.3.2.</span> <span class="toc-text">如何理解adapter订阅者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ViewHolder的作用"><span class="toc-number">15.3.3.</span> <span class="toc-text">ViewHolder的作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解ViewHolder的复用"><span class="toc-number">15.3.4.</span> <span class="toc-text">如何理解ViewHolder的复用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#什么时候停止调用onCreateViewHolder"><span class="toc-number">15.3.5.</span> <span class="toc-text">什么时候停止调用onCreateViewHolder</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LayoutManager的作用是什么"><span class="toc-number">15.3.6.</span> <span class="toc-text">LayoutManager的作用是什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#LayoutManager的样式有哪些"><span class="toc-number">15.3.7.</span> <span class="toc-text">LayoutManager的样式有哪些</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#上拉加载的功能是如何做的"><span class="toc-number">15.3.8.</span> <span class="toc-text">上拉加载的功能是如何做的</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#添加滚动监听事件需要注意什么"><span class="toc-number">15.3.9.</span> <span class="toc-text">添加滚动监听事件需要注意什么</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#网格布局上拉加载如何优化"><span class="toc-number">15.3.10.</span> <span class="toc-text">网格布局上拉加载如何优化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#如何理解RecyclerView三级缓存是如何实现的"><span class="toc-number">15.3.11.</span> <span class="toc-text">如何理解RecyclerView三级缓存是如何实现的</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#一级缓存"><span class="toc-number">15.3.11.1.</span> <span class="toc-text">一级缓存</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView滑动卡顿的原因有哪些？如何解决？"><span class="toc-number">15.3.12.</span> <span class="toc-text">RecyclerView滑动卡顿的原因有哪些？如何解决？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#RecyclerView常见的优化有哪些？"><span class="toc-number">15.3.13.</span> <span class="toc-text">RecyclerView常见的优化有哪些？</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#事件"><span class="toc-number">16.</span> <span class="toc-text">事件</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Intent"><span class="toc-number">16.1.</span> <span class="toc-text">Intent</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Intent可以传递哪些类型的数据"><span class="toc-number">16.1.1.</span> <span class="toc-text">Intent可以传递哪些类型的数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#进程间通信的方式"><span class="toc-number">16.2.</span> <span class="toc-text">进程间通信的方式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#设计模式"><span class="toc-number">17.</span> <span class="toc-text">设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#六大原则"><span class="toc-number">17.1.</span> <span class="toc-text">六大原则</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23种设计模式"><span class="toc-number">17.2.</span> <span class="toc-text">23种设计模式</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#MVC与MVP与MVVM"><span class="toc-number">18.</span> <span class="toc-text">MVC与MVP与MVVM</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#MVC"><span class="toc-number">18.1.</span> <span class="toc-text">MVC</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVP"><span class="toc-number">18.2.</span> <span class="toc-text">MVP</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MVVM"><span class="toc-number">18.3.</span> <span class="toc-text">MVVM</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/../image/android-interview.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hurley</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Interview-Review(Android)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-03-25 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-03-25</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-06 13:29:01"><i class="fas fa-history fa-fw"></i> 更新于 2020-12-06</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">17.5k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 55 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本篇主要是面试复习内容的Android部分。</p>
<p>Android主要分为以下几个部分：</p>
<ul>
<li><a href="#Activity">Activity</a></li>
<li><a href="#Fragment">Fragment</a></li>
<li><a href="Service">Service</a></li>
<li><a href="#broadcastreceiver">Broadcast Receiver</a></li>
<li><a href="#contentprovider">Content Provider</a></li>
<li><a href="#数据存储">数据存储</a></li>
<li><a href="#bitmap">Bitmap</a></li>
<li><a href="#handler">Handler</a></li>
<li><a href="#asynctask">AsyncTask</a></li>
<li><a href="#view">View</a></li>
<li><a href="#animation">Animation</a></li>
<li><a href="#window">Window</a></li>
<li><a href="#布局">布局</a></li>
<li><a href="#事件">事件</a></li>
<li><a href="#设计模式">设计模式</a></li>
</ul>
<a id="more"></a>
<h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><ul>
<li>启动Activity：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code>，进入运行状态；</li>
<li>Activity退居后台（Home或者启动了新的Activity）：<code>onPause()</code>⟶<code>onStop()</code>；</li>
<li>Activity返回前台：<code>onRestart()</code>⟶<code>onStart()</code>⟶<code>onResume()</code>;</li>
<li>如果Acitivity后台期间内存不足，再次启动时就会重新执行启动流程；</li>
<li>锁屏：<code>onPause()</code>⟶<code>onStop()</code>；</li>
<li>解锁：<code>onStart()</code>⟶<code>onResume()</code>；</li>
</ul>
<p><strong>具体方法介绍</strong>：</p>
<ul>
<li><code>onCreate()</code>：在每个Activity中都会重写这个方法，它会在活动第一次被创建的时候调用；</li>
<li><code>onStart()</code>：这个方法由不可见变为可见时调用；</li>
<li><code>onResume()</code>：这个方法在Activity准备好和用户进行交互时调用。此时的活动肯定位于活动返回栈的栈顶，并且处于运行状态；</li>
<li><code>onPause()</code>：这个方法是当系统准备启动或者恢复另一个活动的时候调用。通常会在这个方法里释放一些非常消耗CPU的资源等；</li>
<li><code>onStop()</code>：这个方法在完全不可见的时候调用；</li>
<li><code>onDestroy()</code>：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态；</li>
<li><code>onRestart()</code>：这个方法在活动由停止状态变为运行状态之前调用，即活动被重新启动了</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/01/JO9941.png" alt="Activity的生命周期"></p>
<p><strong>三个时期</strong>：</p>
<ul>
<li><strong>完整生存期</strong>：活动在<code>onCreate()</code>到<code>onDestroy()</code>方法之间所经历的就是<strong>完整生存期</strong>。一般情况下，一个活动会在<code>onCreate()</code>方法中完成各种初始化操作，而在<code>onDestroy()</code>方法中完成释放内存的操作；</li>
<li><strong>可见生存期</strong>：活动在<code>onStart()</code>到<code>onStop()</code>方法之间所经历的就是<strong>可见生存期</strong>。<strong>可见生存期的</strong>的意思就是活动对于用户总是可见的（即使有可能与用户无法交互）；</li>
<li><strong>前台生存期</strong>：活动在<code>onResume()</code>和<code>onPause()</code>方法之间的就是时期就是<strong>前台生存期</strong>。在<strong>前台生存期</strong>内，活动总是处于运行状态的，即此时的活动是可以和用户进行交互的。</li>
</ul>
<h3 id="横竖屏切换时Activity的生命周期变化"><a href="#横竖屏切换时Activity的生命周期变化" class="headerlink" title="横竖屏切换时Activity的生命周期变化"></a>横竖屏切换时Activity的生命周期变化</h3><p>这需要判断<code>AndroidManifest.xml</code>中是否设置了<code>configChanges</code>属性。而<code>configChanges</code>常用的属性有：</p>
<ul>
<li><code>orientation</code>：屏幕在纵向和横向间旋转</li>
<li><code>keyboardHidden</code>：键盘显示或者隐藏</li>
<li><code>screenSize</code>：屏幕大小改变了</li>
</ul>
<p><strong><code>AndroidManifest</code>没有设置<code>configChanges</code>属性</strong></p>
<p>如果是从<strong>竖屏启动切换横屏</strong>：</p>
<p><strong>竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onPause()</code>⟶<code>onSavedInstanceState()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>⟶<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onRestoreInstanceState()</code>⟶<code>onResume()</code>⟶<code>onPause()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>（Android6.0、7.0、8.0适用）</p>
<p>如果是从<strong>横屏启动切换竖屏</strong>：</p>
<p>生命周期与<strong>从竖屏启动切换横屏一样</strong>。</p>
<p><strong>总结</strong>：如果没有设置<code>configChanges</code>属性的话，在Android6.0、7.0、8.0的手机上表现是一样的。首先是正常地走一遍流程（在<code>onPause()</code>之后会有<code>onSavedInstanceState()</code>），然后重新创建之后在<code>onStart()</code>之后会有<code>onRestoreInstanceState()</code>。</p>
<p><strong><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation&quot;</code></strong></p>
<p>如果是从<strong>竖屏启动切换横屏</strong>：</p>
<p><strong>Android 6.0 竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onPause()</code>⟶<code>onSavedInstanceState()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>⟶<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onRestoreInstanceState()</code>⟶<code>onResume()</code>⟶<code>onPause()</code>⟶<code>onStop()</code>⟶<code>onDestory()</code></p>
<p><strong>Android 7.0 竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onConfigurationChanged()</code>⟶<code>onPause()</code>⟶<code>onSavedInstanceState()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>⟶<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onRestoreInstanceState()</code>⟶<code>onResume()</code>⟶<code>onPause()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code></p>
<p><strong>Android 8.0 竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onConfigurationChanged()</code></p>
<p><strong>总结</strong>：在设置了<code>configChanges</code>属性为<code>orientation</code>之后，Android 6.0的生命周期与没有设置是一样的。而Android 7.0则会先多回调一个<code>onConfigurationChanged()</code>方法，剩下的流程一样。Android 8.0则只是回调了<code>onConfigurationChanged()</code>方法，并没有走Activity生命周期的方法。</p>
<p>如果是从<strong>横屏启动切换竖屏</strong>：</p>
<p>生命周期与<strong>从竖屏启动切换横屏一样</strong>。</p>
<p><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code></p>
<p><strong>竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onConfigurationChanged()</code>（Android6.0、7.0、8.0适用）</p>
<p><strong>总结</strong>：当设置了<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize</code>时，就不会调用Activity其它生命周期的方法，只会调用<code>onConfigurationChanged()</code>方法。</p>
<p><strong><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation|screenSize&quot;</code></strong></p>
<p>与<code>orientation|keyboardHidden|screenSize</code>相同，只回调<code>onConfigurationChanged()</code>方法。</p>
<p><strong><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation|keyboardHidden&quot;</code></strong></p>
<p>与只设置了<code>orientation</code>的相同，Android 6.0、7.0会回调生命周期的方法，Android 8.0则只回调<code>onConfigurationChanged()</code>方法。</p>
<p><strong>总结（不同手机系统系统可能会有略微差异）</strong></p>
<ol>
<li>不设置<code>configChanges</code>属性是不会回调<code>onConfigurationChanged()</code>方法的，且切屏的时候会回调生命周期的方法；</li>
<li>只有设置了<code>orientation</code>和<code>screenSize</code>才会保证不会调用生命周期的方法，且切屏的时候只会回调<code>onConfigurationChanged()</code>方法；</li>
<li>如果设置了<code>orientation</code>而没有设置<code>screenSize</code>，那么切屏就会调用<code>onConfigurationChanged()</code>方法，但仍然会走生命周期；</li>
</ol>
<h3 id="Activity-A启动了Activity-B，它们的生命周期的变化"><a href="#Activity-A启动了Activity-B，它们的生命周期的变化" class="headerlink" title="Activity A启动了Activity B，它们的生命周期的变化"></a>Activity A启动了Activity B，它们的生命周期的变化</h3><ol>
<li><p><strong>启动Activity A</strong></p>
<p><code>onCreate()</code>创建活动A，<code>onStart()</code>显示在屏幕上，<code>onResume()</code>处于运行状态；</p>
</li>
<li><p><strong>在Activity A中启动Activity B</strong></p>
<p>活动A被暂停，使用<code>onPause()</code>进入暂停状态；<code>onCreate()</code>创建活动B，<code>onStart()</code>显示活动B在屏幕上，<code>onResume()</code>让活动B进入运行状态；活动A经过<code>onStop()</code>进入停止状态；</p>
</li>
<li><p><strong>从Activity B中返回Activity A（比如按物理返回键）</strong></p>
<p>活动B用<code>onPause()</code>方法进入暂停状态；活动A被重启，使用<code>onRestart()</code>方法从停止状态进入活动状态，调用<code>onStart()</code>方法使活动A显示在屏幕上，<code>onResume()</code>方法进入运行状态；活动B被<code>onStop()</code>方法进入停止状态，最后使用<code>onDestroy()</code>方法销毁；</p>
</li>
<li><p><strong>继续按物理返回键</strong></p>
<p>活动A用<code>onPause()</code>方法暂停，然后用<code>onStop()</code>方法停止，最后用<code>onDestroy()</code>方法被销毁；</p>
</li>
</ol>
<h3 id="onSaveInstanceState-和onRestoreInstanceState-调用的过程和时机"><a href="#onSaveInstanceState-和onRestoreInstanceState-调用的过程和时机" class="headerlink" title="onSaveInstanceState()和onRestoreInstanceState()调用的过程和时机"></a><code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>调用的过程和时机</h3><ul>
<li><strong>调用时机</strong>：Activity的异常情况下（例如转动屏幕或者被系统回收）的情况下，会调用到<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>。如果是单独按Home或者启动新Activity仍然会单独触发<code>onSaveInstanceState</code>调用。</li>
<li><strong>调用过程</strong>：在<strong>异常情况</strong>下，会在调用<code>onStop()</code>方法之前，调用<code>onSaveInstanceState</code>方法保存；而新的Activity重建时，就可以通过<code>onRestoreInstanceState</code>方法取出之前保存的数据并恢复，<code>onRestoreInstanceState</code>的调用时机在<code>onCreate()</code>之后。</li>
</ul>
<h3 id="优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态"><a href="#优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态" class="headerlink" title="优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态"></a>优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态</h3><h2 id="Activity四种启动模式"><a href="#Activity四种启动模式" class="headerlink" title="Activity四种启动模式"></a>Activity四种启动模式</h2><h3 id="standard标准模式"><a href="#standard标准模式" class="headerlink" title="standard标准模式"></a>standard标准模式</h3><p>是默认启动的模式，每次都会新创建一个实例对象；每次发送的Intent都会创建一个新的Activity（<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code>），并且将其放入返回栈的栈顶。这样每次都新建一个实例的话太浪费。</p>
<h3 id="singleTop栈顶复用模式"><a href="#singleTop栈顶复用模式" class="headerlink" title="singleTop栈顶复用模式"></a>singleTop栈顶复用模式</h3><p>如果在返回栈顶发现了相同的实例则重用，不会新建；否则就新建并压入栈顶；同时Activity的<code>onNewIntent()</code>方法会被回调。在这个模式下，我们必须同时在<code>onCreate()</code>和<code>onNewIntent()</code>两个方法中处理好传入的Intent</p>
<h3 id="singleTask栈内复用模式"><a href="#singleTask栈内复用模式" class="headerlink" title="singleTask栈内复用模式"></a>singleTask栈内复用模式</h3><p>如果在整个返回栈中发现了相同的实例，就将其最上面的任务终止并移除，重用该实例，同时回调<code>onNewIntent()</code>方法；否则新建实例并压入栈；</p>
<h3 id="singleInstance单实例模式"><a href="#singleInstance单实例模式" class="headerlink" title="singleInstance单实例模式"></a>singleInstance单实例模式</h3><p>允许不同的应用，进程线程等共用一个实例，无论如何应用调用该实例都会重用；即持有这个Activity的Task不能再有其它Activity的实例了；</p>
<p>例如，如果从这个Activity中启动另外一个不同的Activity，将会自动创建一个新的Task来存放新的Activity；如果从一个已经存在许多Activity的的Task中调用启动模式是<code>singleInstance</code>的Activity，这个新的Activity同样会被放在一个新的Task中。不管怎么样，都会创建一个新的Task来存放Activity。</p>
<h3 id="什么情况下分别使用上面四种不同的启动模式"><a href="#什么情况下分别使用上面四种不同的启动模式" class="headerlink" title="什么情况下分别使用上面四种不同的启动模式"></a>什么情况下分别使用上面四种不同的启动模式</h3><h3 id="onNewIntent-调用时机"><a href="#onNewIntent-调用时机" class="headerlink" title="onNewIntent()调用时机"></a><code>onNewIntent()</code>调用时机</h3><p>如果一个Activity的启动模式是<code>singleTop</code>、<code>singleTask</code>、<code>singleInstance</code>，在复用Activity时就会在「调用<code>onStart()</code>方法之前调用<code>onNewIntent()</code>方法」。作用就是让已经创建的Activity处理新的Intent。</p>
<h3 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h3><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/01/JOCbOU.png" alt="Fragment的生命周期"></p>
<p><strong>具体方法介绍</strong>：</p>
<ol>
<li><code>onAttach()</code>：完成Fragment与Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作；</li>
<li><code>onCreate()</code>：完成Fragment的初始化；</li>
<li><code>onCreateView()</code>：加载View布局，绑定布局文件；</li>
<li><code>onActivityCreated()</code>：与Fragment绑定的Activity已经执行完成了<code>onCreate()</code>，可以与Activity进行交互操作；</li>
<li><code>onStart()</code>：Fragment变为可见状态；</li>
<li><code>onResume()</code>：Fragment变为可交互状态；</li>
<li><code>onPause()</code>：Fragment变为不可交互状态（不代表是不可见）；</li>
<li><code>onSaveInstanceState()</code>：保存当前Fragment的状态，记录一些数据；</li>
<li><code>onStop()</code>：Fragment变为不可见状态；</li>
<li><code>onDestroyView()</code>：销毁Fragment的有关视图，但并未和Activity解绑，还可以通过<code>onCreateView()</code>重新创建视图；</li>
<li><code>onDestroy()</code>：销毁Fragment时调用；</li>
<li><code>onDetach()</code>：解除和Activity的绑定，是Fragment销毁的最后一步。</li>
</ol>
<p>添加Fragment可以分为<strong>静态添加</strong>和<strong>动态添加*</strong>两类。<strong>静态添加</strong>是指在XML中直接Fragment，缺点是添加之后不能删除。一般推荐是在代码中FragmentManager中使用一系列的<code>FragmentTransaction</code>事务操作动态控制。</p>
<ul>
<li><code>add</code></li>
<li><code>remove</code></li>
<li><code>show</code></li>
<li><code>hide</code></li>
<li><code>replace</code></li>
<li><code>replace</code>+<code>addToBackStack</code></li>
<li><code>detach</code></li>
</ul>
<h2 id="Activity与Fragment的异同"><a href="#Activity与Fragment的异同" class="headerlink" title="Activity与Fragment的异同"></a>Activity与Fragment的异同</h2><ul>
<li>相同点：Activity与Fragment都可以包含布局，都有自己的生命周期；</li>
<li>不同点：因为Fragment是依附在Activity上的，多了一些和宿主Activity相关的生命周期方法，例如<code>onAttch()</code>、<code>onActivityCreated()</code>、<code>onDetach()</code>等；Fragment的生命周期方法都是由宿主Activity而不是由操作系统调用的，Activity中的生命周期方法都是是<code>protected</code>，而Fragment的生命周期方法都是<code>public</code>，因为Activity需要调用Fragment这些方法并管理它。</li>
</ul>
<h2 id="Activity和Fragment的关系"><a href="#Activity和Fragment的关系" class="headerlink" title="Activity和Fragment的关系"></a>Activity和Fragment的关系</h2><ul>
<li>Fragment的出现是为了解决Android碎片化，可以作为Activity界面的组成部分，可以在Activity运行中实现动态地加入、移除和交换；</li>
<li>一个Activity可以同时出现多个Fragment，而一个Fragment也可以在多个Activity中使用；</li>
<li>Activity中的<code>FragmentManager</code>负责调用队列中Fragment的生命周期方法；</li>
</ul>
<h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service的两种启动方式和生命周期"><a href="#Service的两种启动方式和生命周期" class="headerlink" title="Service的两种启动方式和生命周期"></a>Service的两种启动方式和生命周期</h2><p>Service有两种启动方式，一种是通过<code>startService()</code>来启动的，另一种是通过<code>bindService()</code>来启动的；</p>
<p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/01/JO9lgf.png" alt="Service的生命周期"></p>
<h3 id="通过startService-来启动（各自飞）"><a href="#通过startService-来启动（各自飞）" class="headerlink" title="通过startService()来启动（各自飞）"></a>通过<code>startService()</code>来启动（各自飞）</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2018053114134692.jpg" alt="startService()的生命周期"></p>
<p><strong>使用方法</strong>：</p>
<ol>
<li>定义一个类，并继承Service</li>
<li>在<code>AndroidManifest.xml</code>文件中配置此Service</li>
<li>使用Context的<code>startService(Intent)</code>方法来启动此Service</li>
<li>不使用该服务时，调用<code>stopService(Intent)</code>方法停止此Service（当使用IntentService时调用<code>stopSelf</code>方法）</li>
</ol>
<blockquote>
<p>如果服务已经开启，就不会重复地执行<code>onCreate()</code>方法，而是调用<code>onStart()</code>或者<code>onStartCommand()</code>方法。服务停止时就调用<code>onDestroy()</code>方法。</p>
</blockquote>
<p><strong>特点</strong>：</p>
<ul>
<li>一旦服务开启了，就与开启者没有任何关系了</li>
<li>开启者退出之后，服务还是可以在后台长期运行的（前提是没有调用<code>stopService(Intent)方法</code>）</li>
<li>开启者不能调用服务里面的方法</li>
</ul>
<h3 id="通过bindService-来启动（共存亡）"><a href="#通过bindService-来启动（共存亡）" class="headerlink" title="通过bindService()来启动（共存亡）"></a>通过<code>bindService()</code>来启动（共存亡）</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20180531142740474.jpg" alt="bindService()的生命周期"></p>
<p><strong>使用方法</strong>：</p>
<ol>
<li>定义一个类，并继承Service</li>
<li>在<code>AndroidManifest.xml</code>文件中配置此Service</li>
<li>使用Context的<code>bindService(Intent, ServiceConnection, int)方法来启动此Service</code></li>
<li>不使用该服务时，调用<code>unbindService(ServiceConnection)方法停止此Service</code></li>
</ol>
<blockquote>
<p>绑定服务是不会调用<code>onStart()</code>或者<code>onStartCommand()</code>方法的。</p>
</blockquote>
<p><strong>特点</strong>：</p>
<ul>
<li>使用<code>onBind()</code>的方式开启服务绑定服务，如果调用者销毁，服务也会被销毁</li>
<li>绑定者可以调用服务内部的方法</li>
</ul>
<h3 id="如果一个Service既被startService-启动又被bindService-启动，生命周期是怎么样的（或者问如何把Service停止）"><a href="#如果一个Service既被startService-启动又被bindService-启动，生命周期是怎么样的（或者问如何把Service停止）" class="headerlink" title="如果一个Service既被startService()启动又被bindService()启动，生命周期是怎么样的（或者问如何把Service停止）"></a>如果一个Service既被<code>startService()</code>启动又被<code>bindService()</code>启动，生命周期是怎么样的（或者问如何把Service停止）</h3><ol>
<li><code>startService()</code>和<code>bindService()</code>可以同时启动同一Service，执行时会回调对应的<code>onStartCommand()</code>或者<code>onBind()</code>方法，但是<code>onCreate()</code>方法只会被执行一次，不会被重复执行；</li>
<li>在停止Service时，既需要调用<code>stopService()</code>方法，又需要调用<code>unBindService()</code>方法，没有先后顺序要求，只有两个方法都执行完毕之后，才会执行Service的<code>onDestroy()</code>方法，<code>onDestroy()</code>方法只会被执行一次（最后一个<code>stopService</code>或者<code>unBindService</code>方法会导致Service执行<code>onDestroy()</code>）。</li>
</ol>
<h3 id="Service的生命方法运行在哪个线程中"><a href="#Service的生命方法运行在哪个线程中" class="headerlink" title="Service的生命方法运行在哪个线程中"></a>Service的生命方法运行在哪个线程中</h3><p>Service默认运行在主线程中，所以其生命方法也是运行在主线程中。如果需要在Service中进行耗时的操作，那必须另起线程或者使用IntentService，否则会引起ANR。</p>
<h2 id="IntentService与Service的区别"><a href="#IntentService与Service的区别" class="headerlink" title="IntentService与Service的区别"></a>IntentService与Service的区别</h2><ul>
<li>Service默认运行在主线程中，如果需要耗时的操作，就必须开启子线程；而IntentService可用于长时间的任务，通常不会与主线程通信。如果需要通信，可以使用主线程处理程序或者广播意图。另一种使用情况是需要回调（意图触发任务）。</li>
<li>Service是由<code>startService()</code>方法触发，而IntentService是使用Intent触发的，产生了一个新的工作线程，并且在这个线程上调用了<code>onHandlerIntent()</code>方法。</li>
<li>Service和IntentService可以从任何线程，活动或其它应用程序组件中触发</li>
<li>Service在后台运行，但是是在应用程序的主线程运行；IntentService在单独的工程线程中运行；</li>
<li>Service可能会阻止应用程序的主线程；IntentService不能并行执行任务，所以所有连续的Intent都将进入工程线程的消息队列并将按顺序执行；</li>
<li>如果使用Service，是调用<code>stopSelf()</code>或者<code>stopService()</code>来结束它的工作；而IntentService会在处理完所有启动请求后停止服务，不必调用方法；</li>
</ul>
<p><strong>IntentService的优点</strong>：</p>
<ul>
<li>会创建独立的工作线程来处理所有的Intent请求；</li>
<li>会创建独立的工作线程来处理<code>onHandleIntent()</code>方法实现的代码，无需处理多线程问题；</li>
<li>在所有请求处理完成后，IntentService会自动停止；</li>
<li>为Service的<code>onBind()</code>方法提供默认实现，返回<code>null</code>；</li>
<li>为Service的<code>onStartCommand()</code>方法提供默认实现，将请求Intent添加到队列中；</li>
<li>IntentService不会阻塞UI线程；</li>
<li>IntentService若未执行完成上一次的任务，不会重新开启一个线程，而是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用<code>stopSelf()</code>方法</li>
</ul>
<h2 id="如何保证Service不被杀死（如何提高Service的优先级）"><a href="#如何保证Service不被杀死（如何提高Service的优先级）" class="headerlink" title="如何保证Service不被杀死（如何提高Service的优先级）"></a>如何保证Service不被杀死（如何提高Service的优先级）</h2><ol>
<li><strong>在<code>onStartCommand()</code>方法中返回<code>START_STICKY</code></strong>。这种情况下，当内存不足需要回收该Service时，系统会将该Service标记为<code>started</code>状态，并在合适的时机重新调用<code>onStartCommand()</code>方法重新启动该Service，这种情况下不会保留<code>onStartCommand()</code>方法中的<code>intent</code>对象（<code>intent</code>对象为<code>null</code>）。如果需要在重启Service时保留<code>onStartCommand()</code>中的<code>intent</code>对象，就可以返回<code>START_REDELIVER_INTENT</code>，此时则会保留<code>intent</code>最近一次的值，并传入到<code>onStartCommand()</code>方法中。</li>
<li><strong>提高该Service在所有Service中的优先级</strong>。可以在<code>AndroidManifest.xml</code>中为每一个Service都配置一个优先级<code>android:priority</code>，数值越大，优先级就越高。</li>
<li><strong>将Service设置为前台Service</strong>。因为Service是默认在后台运行的，但调用<code>Service.startForeground()</code>就可以将该Service设置为前台Service，从而提高Service的优先级。当系统的进程空间紧张时，会按照进程优先级依次回收，Android系统的进程优先级如下：<ol>
<li>前台进程（foreground_app）</li>
<li>可见进程（visible_app）</li>
<li>次要服务进程（secondary_app）</li>
<li>后台进程（hidden_app）</li>
<li>内容提供者进程（content_provider）</li>
<li>空进程（empty_app）</li>
</ol>
</li>
<li><strong>在Service的<code>onDestroy()</code>方法里发送一个自定义广播</strong>，在广播的<code>onReceiver()</code>里重新启动该Service。</li>
<li><strong>监听开机广播，开机时自动启动Service</strong>。</li>
</ol>
<h2 id="Service与Activity如何实现通信"><a href="#Service与Activity如何实现通信" class="headerlink" title="Service与Activity如何实现通信"></a>Service与Activity如何实现通信</h2><p>可以通过<code>bindService()</code>的方式。先在Activity里实现一个ServiceConnection接口，并将该接口传递给<code>bindService()</code>方法，在ServiceConnection接口的<code>onServiceConnected()</code>方法里执行相关操作。</p>
<h2 id="常用的系统Service"><a href="#常用的系统Service" class="headerlink" title="常用的系统Service"></a>常用的系统Service</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">传入的Name</th>
<th style="text-align:center">返回的对象</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">WINDOW_SERVICE</td>
<td style="text-align:center">WindowManager</td>
<td style="text-align:center">管理打开的窗口程序</td>
</tr>
<tr>
<td style="text-align:center">LAYOUT_INFLATER_SERVICE</td>
<td style="text-align:center">LayoutInflater</td>
<td style="text-align:center">取得XML里定义的View</td>
</tr>
<tr>
<td style="text-align:center">ACTIVITY_SERVICE</td>
<td style="text-align:center">ActivityManager</td>
<td style="text-align:center">管理应用程序的系统状态</td>
</tr>
<tr>
<td style="text-align:center">POWER_SERVICE</td>
<td style="text-align:center">PowerManager</td>
<td style="text-align:center">电源服务</td>
</tr>
<tr>
<td style="text-align:center">ALARM_SERVICE</td>
<td style="text-align:center">AlarmManager</td>
<td style="text-align:center">闹钟服务</td>
</tr>
<tr>
<td style="text-align:center">NOTIFICATION_SERVICE</td>
<td style="text-align:center">NotificationManager</td>
<td style="text-align:center">状态栏服务</td>
</tr>
<tr>
<td style="text-align:center">KEYGUARD_SERVICE</td>
<td style="text-align:center">KeyguardManager</td>
<td style="text-align:center">键盘锁服务</td>
</tr>
</tbody>
</table>
</div>
<h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><blockquote>
<p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。例如，在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接受系统的广播让应用程序作出相应的处理。</p>
</blockquote>
<h2 id="动态注册和静态注册的区别"><a href="#动态注册和静态注册的区别" class="headerlink" title="动态注册和静态注册的区别"></a>动态注册和静态注册的区别</h2><ul>
<li><strong>静态注册</strong>：在<code>AndroidManifest.xml</code>中进行注册。常驻系统，不受组件生命周期的影响。即便应用退出了，广播还是可以被接收、耗电、占内存等；</li>
<li><strong>动态注册</strong>：在代码中使用<code>IntentFilter</code>进行注册。非常驻系统，跟随组件的生命变化，组件结束了广播就结束了。在组件结束前，需要先移除广播，否则容易造成内存泄漏。动态注册的广播永远要快于静态注册的广播，不论静态注册的优先级多高。</li>
</ul>
<h2 id="广播的各种形式"><a href="#广播的各种形式" class="headerlink" title="广播的各种形式"></a>广播的各种形式</h2><ul>
<li><strong>普通广播</strong>：使用<code>sendBroadcast()</code>发送，是最常用的广播。一种<strong>完全异步</strong>执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接受到这条广播信息，因此它们接受的先后是随机的；</li>
<li><strong>有序广播</strong>：使用<code>sendOrderedBroadcast()</code>，发送出去的广播会被接收者按照顺序接收，而广播接收者按照优先级Priority属性值从大到小排序（优先级相同，则动态注册的广播优先）。是一种<strong>同步执行</strong>的广播，在广播发出之后，同一时刻就只有一个广播接收器能够收到这条广播信息；</li>
<li><strong>本地广播</strong>：发出的广播只能够在应用程序的<strong>内部</strong>进行传递，并且广播接收器也只能本应用程序发出的广播；</li>
<li><strong>粘性广播</strong>：这种类型的广播会一直逗留，当有匹配该广播的接收器被注册后，该接收器就会收到这条广播。</li>
</ul>
<h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><blockquote>
<p>我们知道动态注册的广播的优先级始终高于静态注册的广播，而静态注册的广播的优先级主要根据Priority属性值的大小排序，那么如果都是静态注册的广播，优先级大小又一样，那接收的顺序是怎么样的呢？</p>
</blockquote>
<p>在都是静态注册的情况下，最高安装的程序优先级别最高 | 按照<strong>字符</strong>排列顺序决定谁先接收到广播信息。</p>
<p>所以，有序广播的优先级遵循如下的规则：</p>
<ol>
<li>动态注册优先级级别最高，其次是静态注册</li>
<li>在动态注册中，最早动态注册的优先级别最高</li>
<li>在静态注册中，最早安装的程序，静态注册的优先级别最高</li>
<li>如果都是静态注册，按照<strong>字符</strong>排列顺序决定谁先收到广播信息</li>
<li><code>adb install</code>安装的比<code>adb push</code>到其它目录的应用程序优先级更高</li>
</ol>
<h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><blockquote>
<p>ContentProvider（内容提供者）是Android的四大组件之一，管理Android以结构化的方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口给<strong>其它应用程序</strong>调用。不同的应用程序之间进行数据共享，它还可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄漏风险。</p>
</blockquote>
<ul>
<li>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做<strong>进程间数据共享</strong>。</li>
<li>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li>
<li>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</li>
</ul>
<h1 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h1><h2 id="HttpClient与HttpUrlConnection"><a href="#HttpClient与HttpUrlConnection" class="headerlink" title="HttpClient与HttpUrlConnection"></a>HttpClient与HttpUrlConnection</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>HttpClient是Apache公司提供的库，提供高效的、最新的、功能丰富的支持HTTP协议工具包，支持HTTP协议最新的版本和建议，封装了http的请求，参数，内容体，响应等，拥有众多API。</p>
<p>HttpURLConnection是Sun公司提供的库，也是Java的标准类库<code>java.net</code>中的一员，但这个类什么都没封装，用起来很原始，若需要高级功能，则会显得不太方便，比如重访问的自定义，会话和cookie等一些高级功能。</p>
<p>这两种方式都支持HTTPS协议，以流的形式进行上传和下载，配置超时时间，IPV6，连接池等功能。</p>
<p>功能上说，HttpClient的库要丰富很多，封装了请求头、参数、内容体、响应等，包括代理、Cookie、鉴权、压缩、连接池的使用等等。但是HttpClient的高级功能的代码写起来很复杂，而HttpUrlConnection的代码对大部分工作都进行了封装，屏蔽了不需要的细节，适合直接调用。</p>
<p>性能上说，HttpUrlConnection支持GZip压缩、系统级连接池、缓存策略的处理等等，加快了请求的速度。</p>
<p>因此，在Android6.0之后，HttpClient被废弃，建议选用HttpUrlConnection。</p>
<h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20191120233736397.png" alt="OkHttp的执行过程"></p>
<ol>
<li>通过OkHttpClient创建一个Call，并发起同步或者异步的请求；</li>
<li>OkHttp会通过Dispatcher线程池会对所有的RealCall（即具体实现类）进行统一管理，并通过<code>execute()</code>以及<code>enqueue()</code>方法对同步或者异步请求进行解决；</li>
<li><code>execute()</code>以及<code>enqueue()</code>两个方法，会最终调用RealCall的<code>getResponseWithInterceptorChain()</code>方法，从拦截器链中获取返回结果；</li>
<li>拦截器链中，包括重定向拦截器、桥接拦截器、缓存拦截器、连接拦截器、网络拦截器等依次解决，最后将结果返回给调用方。</li>
</ol>
<hr>
<p>OkHttp的底层是通过Java的Socket发送HTTP请求与接收响应的(HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。而OkHttp对Socket的读写操作使用的Okio库进行了一层封装。</p>
<h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Retrofit通过接口以及注解的方式来描述网络请求，并用动态代理的方式生成网络请求的request，然后通过client调用底层的网络框架OkHttp来发起网络请求，将返回的response通过convertrFactory转换成相应的数据model，最后通过callAdapter转化成其它的数据方式。</p>
<h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>静态代理类由程序员创建或工具生成代理类的源码，再编译代理类，所谓静态就是<strong>在程序运行前就已经存在代理类的字节码文件</strong>，代理类和委托类的关系在<strong>运行前</strong>就确定了。</p>
<p>动态代理类是程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定的。</p>
<h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理业务类只需要关注业务逻辑本身，保证了业务类的重用性。代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，需要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。</p>
<h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler invoke）。这样，在接口方法数量比较多的时候，可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使类职责更加单一，复用性更强。</p>
<h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h2><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="Android中提供哪些数据持久存储的方法"><a href="#Android中提供哪些数据持久存储的方法" class="headerlink" title="Android中提供哪些数据持久存储的方法"></a>Android中提供哪些数据持久存储的方法</h2><ul>
<li>文件存储</li>
<li>SharedPreference存储</li>
<li>数据库存储</li>
<li>ContentProvider存储</li>
<li>网络存储</li>
</ul>
<h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>文件存储是通过文件的方式将数据不做任何处理的存储进文件系统中，适合一些简单的文本数据或者二进制数据。主要是通过文件IO流的存储提供了<code>FileInputStream()</code>和<code>FileOutputStream()</code>方法来存储和提取文件中的数据。</p>
<h3 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h3><p>SharedPreferences的存储数据和读取数据十分简单，提供了<code>get</code>和<code>put</code>方法。</p>
<h3 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h3><p>Android自身就支持SQLite这种轻量级的数据库。</p>
<h3 id="ContentProvider存储"><a href="#ContentProvider存储" class="headerlink" title="ContentProvider存储"></a>ContentProvider存储</h3><p>之所以不选择与数据库直接交互，而选择通过ContentProvider进行交互，是因为Android的安全性问题决定的。它的数据库是私有的，所以外部数据无法直接访问这个数据库。而通过ContentProvider，将数据库的内容提供给外部应用，同时将外部应用的数据存储到数据库中。如果外部应用想要操作数据库暴露的数据时，需要ContentResolver来操作ContentProvider暴露的数据。一旦某个应用通过ContentProvider暴露了数据，那么不管该应用程序是否启动，其他的应用都能通过该接口操作暴露的数据，对数据进行增删查改的操作。</p>
<h3 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h3><p> Android提供了通过网络来实现数据的存储和获取的方法，即将数据存储在网络（服务器）中。</p>
<h2 id="SharedPreferences适用情形？使用中需要注意什么？"><a href="#SharedPreferences适用情形？使用中需要注意什么？" class="headerlink" title="SharedPreferences适用情形？使用中需要注意什么？"></a>SharedPreferences适用情形？使用中需要注意什么？</h2><p>SharedPreferences是Android平台上一个轻量级的存储辅助类，特别适合保存软件的配置参数。它提供了<code>string</code>，<code>set</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>boolean</code>六种数据类型，它是以key-value的形式保存在 <code>data/data/&lt;packagename&gt;/shared_prefs</code> 下的xml文件中。</p>
<p>由于系统对SharedPreferences的读/写有一定的缓存策略，即在内存中有一份该文件的缓存，因此在多进程模式下，其读/写会变得不可靠，甚至丢失数据。</p>
<p><strong>注意</strong>：</p>
<ul>
<li>SharedPreferences是以单例形式存在的</li>
<li>创建sp单例是将文件的内容全部都载入内存中</li>
<li>单进程下读取安全</li>
<li>用<code>apply()</code>异步提交的方法代替<code>commit</code></li>
<li>因为sp的数据常驻内存，所以不适合存储过大的数据（例如接口数据，达到了MB的级别）</li>
</ul>
<h2 id="SQLite的事务处理？是如何做的？"><a href="#SQLite的事务处理？是如何做的？" class="headerlink" title="SQLite的事务处理？是如何做的？"></a>SQLite的事务处理？是如何做的？</h2><p>SQLite在做CRUD操作时都默认开启了事务，然后把SQL语句翻译成对应的SQLiteStatement并调用其相应的CRUD方法，此时整个操作还是在rollback journal这个临时文件上进行，只有操作顺利完成才会更新.db数据库，否则会被回滚。</p>
<h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><h2 id="图片框架的三级缓存机制"><a href="#图片框架的三级缓存机制" class="headerlink" title="图片框架的三级缓存机制"></a>图片框架的三级缓存机制</h2><ol>
<li><strong>内存缓存</strong>（优先加载，速度最快）：首次加载的时候通过网络加载，获取图片，然后保存到内存中和本地中；之后运行时，优先访问内存中的图片缓存；</li>
<li><strong>本地缓存</strong>（次优先加载，速度快）：如果内存中没有，则访问本地的图片；</li>
<li><strong>网络缓存</strong>（最后加载，速度慢，浪费流量）：如果本地还没有，就有可能是第一次访问，所以进行网络请求；</li>
</ol>
<p><strong>三级缓存的原理</strong>：内存作为一级缓存，本地作为二级缓存，网络加载为最后。其中，内存使用LruCache，其内部通过<code>LinkedHashMap</code>来持有外界缓存对象的强引用；对于本地缓存，使用DiskLruCache。而加载图片的时候，首先使用LRU方式进行寻找，找不到指定内容，就按照三级缓存的策略，再进行本地搜索，最后进行网络加载。</p>
<h2 id="LRU算法的原理"><a href="#LRU算法的原理" class="headerlink" title="LRU算法的原理"></a>LRU算法的原理</h2><p>LRU（Least Recently Used）算法是近期最少使用算法，其核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。采用LRU算法的缓存主要有以下两种：</p>
<ul>
<li><strong>LruCache（内存缓存）</strong>：LruCache类是一个<strong>线程安全</strong>的<strong>泛型类</strong>：内部采用一个<code>LinkedHashMap</code>以强引用的方式存储外界的缓存对象，并提高<code>get</code>和<code>put</code>方法来完成缓存的获取和添加操作，当缓存满了就会移除较早使用的缓存对象，再添加新的</li>
<li><strong>DiskLruCache（磁盘缓存）</strong>：通过将缓存对象写入文件系统从而实现缓存效果。DiskLruCache的缓存添加的操作是通过Editor完成的，Editor表示一个缓存对象的编辑对象。</li>
</ul>
<p>LruCache用于实现内存缓存，DiskLruCache用于实现存储设备缓存，两者相结合就可以实现一个有价值的ImageLoader。</p>
<h2 id="实现ImageLoader"><a href="#实现ImageLoader" class="headerlink" title="实现ImageLoader"></a>实现ImageLoader</h2><p>一个优秀的ImageLoader应该具备以下功能：</p>
<ul>
<li><strong>图片的同步加载</strong>：以同步的方式向调用者提供所加载的图片（可能内存中、缓存中或者网络获取的）</li>
<li><strong>图片的异步加载</strong>：开启自己的线程加载图片</li>
<li><strong>图片压缩</strong>：降低OOM</li>
<li><strong>内存缓存</strong></li>
<li><strong>磁盘缓存</strong></li>
<li><strong>网络获取</strong></li>
</ul>
<h3 id="同步加载和异步加载接口的设计"><a href="#同步加载和异步加载接口的设计" class="headerlink" title="同步加载和异步加载接口的设计"></a>同步加载和异步加载接口的设计</h3><h4 id="同步加载"><a href="#同步加载" class="headerlink" title="同步加载"></a>同步加载</h4><p>工作遵循以下几个步骤：首先尝试从内存缓存中读取图片，接着尝试从磁盘缓存中读取图片，最后才从网络中请求图片。这个过程是不能在主线车中调用的，否则会抛出异常。那么，这个执行环境的检查就是**通过检查当前线程的<code>Looper</code>是否为主线程的<code>Looper</code>，来判断当前线程是否为主线程。</p>
<h4 id="异步加载"><a href="#异步加载" class="headerlink" title="异步加载"></a>异步加载</h4><p>异步加载也就是所谓的开启一个新的线程去加载图片。它会首先尝试从内存中读取图片，如果成功就直接返回结果，否则会在<strong>线程池</strong>中调用<code>loadBitmap</code>这个加载图片的方法。当图片加载成功后，图片的地址以及绑定的ImageView会封装成一个<code>LoaderResult</code>对象，然后通过<code>mainHandler</code>向主线程发送一个消息，这样就通知可以在主线程给ImageView显示图片了。所以，上面的核心是用到了<strong>线程池</strong>和<strong>Handler</strong>。</p>
<p>之所以使用线程池，是因为如果使用普通的线程去加载图片，那么随着列表的滑动，可能会产生大量的线程，这会降低效率。</p>
<h2 id="Android中缓存更新策略"><a href="#Android中缓存更新策略" class="headerlink" title="Android中缓存更新策略"></a>Android中缓存更新策略</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>AsyncTask、IntentService、HandlerThread的表现形式都和传统的线程有区别，但本质上仍然是传统的线程。对于AsyncTask来说，底层用到了线程池，对于IntentService和HandlerThread来说，底层则是直接使用到了线程。</p>
<ul>
<li>AsyncTask底层封装了线程池和Handler，主要是为了方便开发者在子线程中更新UI。</li>
<li>HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。</li>
<li>IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，内部采用HandlerThread来执行任务，当任务执行完毕后会自动退出。</li>
</ul>
<h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask在具体的使用过程中也有条件限制：</p>
<ul>
<li>AsyncTask的类必须在主线程中加载，即第一次访问AsyncTask必须发生在主线程；</li>
<li>AsyncTask的对象必须在主线程中创建；</li>
<li>execute方法必须在UI线程调用；</li>
<li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会异常；</li>
</ul>
<h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（IntentHandler），其中线程池SerialExecutor用于任务的排队，而线程池THREAD_POOL_EXECUTOR用于真正地执行任务。IntentHandler用于将执行环境从线程池切换到主线程。</p>
<h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是一种特殊的Service，它继承了Service并且是一个抽象类，所以必须构建它的子类才可以使用IntentService。IntentService可用于执行后台耗时的任务，当任务执行完毕后会自动停止。它的优先级比很多单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。</p>
<p>IntentService底层是封装了HandlerThread和Handler。</p>
<h2 id="线程池的好处、原理、类型"><a href="#线程池的好处、原理、类型" class="headerlink" title="线程池的好处、原理、类型"></a>线程池的好处、原理、类型</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>在编程中经常会使用线程来异步处理任务，但是每个线程的创建和销毁都需要一定的开销。如果每次执行一个任务都需要开启一个新的线程去执行，则这些线程的创建和销毁将消耗大量的资源；并且线程都是“各自为政”的，很难对其进行控制，这时候就需要线程池来对线程进行管理。</p>
<ul>
<li>重用线程池中的线程，避免线程的创建和销毁带来的性能消耗；</li>
<li>有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞现象；</li>
<li>进行线程管理，提供定时/循环间隔执行等功能</li>
</ul>
<h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>ThreadPoolExecutor是线程池的真正实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure>
<ul>
<li><strong>corePoolSize</strong>核心线程数：一般会在线程中一直存活</li>
<li><strong>maximumPoolSize</strong>最大线程数：当活动线程数达到这个数值后，后续的任务将会被阻塞</li>
<li><strong>keepAliveTime</strong>非核心线程超时时间：超过这个时长，闲置的非核心线程就会被回收</li>
<li><strong>unit</strong>：用于指定keepAliveTime参数的时间单位</li>
<li><strong>workQueue</strong>任务队列：通过线程池的execute()方法提交的Runnable对象会存储在这个参数中。</li>
<li><strong>threadFactory</strong>：线程工厂，可创建新线程</li>
<li><strong>handler</strong>：在线程池无法执行新任务时进行调度</li>
</ul>
<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul>
<li><strong>FixThreadPool</strong>：线程数量固定的线程池，所有线程都是核心线程，当线程空闲时不会被回收；能快速响应外界请求。</li>
<li><strong>CachedThreadPool</strong>：线程数量不定的线程池（最大线程数为Integer.MAX_VALUE），只有非核心线程，空闲线程有超时机制，超时回收；适合于执行大量的耗时较少的任务</li>
<li><strong>ScheduledThreadPool</strong>：核心线程数量固定，非核心线程数量不定；可进行定时任务和固定周期的任务。</li>
<li><strong>SingleThreadExecutor</strong>：只有一个核心线程，可确保所有的任务都在同一个线程中按顺序执行；好处是无需处理线程同步问题。</li>
</ul>
<h2 id="ThreadPoolExecutor的工作策略"><a href="#ThreadPoolExecutor的工作策略" class="headerlink" title="ThreadPoolExecutor的工作策略"></a>ThreadPoolExecutor的工作策略</h2><h2 id="Pipeline管道模式"><a href="#Pipeline管道模式" class="headerlink" title="Pipeline管道模式"></a>Pipeline管道模式</h2><h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>Android应用程序被创建的时候都会创建一个UI主线程，但有时会有一些比较耗时的操作，为了防止阻塞UI主线程，我们会将耗时的操作放到子线程中进行处理，处理完之后操作UI，但是Android不允许子线程操作UI，因为违背了Android单线程模型的原则（即Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行）。</p>
<p>消息传递机制主要是为了解决Android应用的多线程问题。Handler是一种异步回调机制，它可以在完成一个耗时任务后做出相应的通知。</p>
<ul>
<li><strong>主线程（UI线程）</strong>：当程序第一次启动时，Android会同时启动一个主线程，主要负责处理与UI系相关的事件；</li>
<li><strong>Message</strong>：Handler用来接收和处理的消息对象（Bean对象），作用是通信时相关信息的存放和传递；</li>
<li><strong>ThreadLocal</strong>：是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。作用简要来说就是负责存储和获取本线程的Looper；</li>
<li><strong>Message Queue</strong>：采用单链表的数据结构来存储消息列表，用来存放通过Handler发送过来的Message，按照先进先出的方式执行；</li>
<li><strong>Handler</strong>：就是Message的主要处理者，负责发送Message到消息队列和处理Looper分派过来的Message；</li>
<li><strong>Looper</strong>：扮演Message Queue和Handler之间的一个桥梁的角色。它循环取出Message Queue中的Message，将取出的Message交付给相应的Handler；</li>
</ul>
<p><strong>调用流程</strong>：</p>
<ol>
<li>首先调用<code>Looper.prepare()</code>方法，会创建一个Looper实例，该实例包含一个MessageQueue，并将该实例保存在当前线程中Threadlocal</li>
<li>调用<code>Looper.loop()</code>开始消息循环，不断地向MessageQueue中读取消息，并调用<code>msg.target.dispatchMessage(msg)</code>来处理消息</li>
<li>构建Handler的时候，会先获取到当前Handler所在线程的Looper并得到其中的MessageQueue</li>
<li>使用Handler发送消息的时候，会将一个Message到保存当前线程Looper中的MessageQueue</li>
<li>当<code>Looper.loop()</code>获取到消息的时候，调用<code>msg.target.dispatchMessage(msg)</code>来处理消息,其实<code>Message.target = handler</code>也就是调用Handler的dispatchMessage来处理</li>
<li>Handler的dispatchMessage最终回去调用handlerMessage方法。到这里就知道，其实Handler的handler在哪条线程执行，取决于构建Handler时所使用的是哪条线程保存的Looper，因为handlerMessage其实是Looper去调用的。</li>
</ol>
<h2 id="Handler消息传递机制工作原理"><a href="#Handler消息传递机制工作原理" class="headerlink" title="Handler消息传递机制工作原理"></a>Handler消息传递机制工作原理</h2><p>首先需要在主线程当中创建一个Handler对象，并重写<code>handleMessage()</code>方法。然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去。之后这条消息会被添加到MessageQueue的队列中等待被处理。<code>Looper.prepare()</code>中会先判断线程是否有Looper实例，没有就创建一个Looper实例，然后加入本线程的ThreadLocal中。而Looper则会一直尝试从MessageQueue中使用<code>loop()</code>方法取出待处理消息，最后分发回Handler的<code>handleMessage()</code>方法中。由于Handler是在主线程中创建的，所以此时handleMessage()方法中的代码也会在主线程中运行，于是就可进行UI操作了。一条Message经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新UI变成了可以更新UI，整个异步消息处理的核心思想就是如此。<br>「Handler消息机制中的主要功能都由 MessageQueue 和 Looper 去实现了，Handler 主要用于往队列里插入 Message 和 执行 Looper 取出的 Message 两个过程。」</p>
<p>Android消息机制中引入了消息池。Handler创建消息时首先查询消息池中是否有消息存在，如果有直接从消息池中取得，如果没有则重新初始化一个消息实例。使用消息池的好处是：消息不被使用时，并不作为垃圾回收，而是放入消息池，可供下次Handler创建消息时使用。消息池提高了消息对象的复用，减少系统垃圾回收的次数。</p>
<h2 id="一个Thread可以有几个Looper？几个Handler？"><a href="#一个Thread可以有几个Looper？几个Handler？" class="headerlink" title="一个Thread可以有几个Looper？几个Handler？"></a>一个Thread可以有几个Looper？几个Handler？</h2><p>由于使用了ThreadLocal机制，所以注定了一个线程只能有一个Looper，但Handler可以new无数个，它们使用的消息队列都是同一个，也就是同一个Looper。</p>
<p>在主线程可以直接使用handler，是因为主线程已经默认帮我们初始化了Looper，调用了<code>Looper.prepare()</code>和<code>loop()</code>方法，我们可以在主线程定义多个handler都不用自己生成或绑定Looper，所以一个线程只有一个Looper。</p>
<h2 id="如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？"><a href="#如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？" class="headerlink" title="如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？"></a>如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？</h2><p>我们知道Thread是不具备消息循环的，而Looper恰恰弥补了这点，通过<code>Looper.prepare()</code>方法可以将一个Thread线程转换成Looper线程。Looper类管理线程的消息队列和消息循环，具体来说是为一个线程开启一个消息循环，Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。而一个Looper对象可以对应多个线程，比如主线程的mainLooper，供主线程和所属子线程共同使用。</p>
<h2 id="为什么在子线程中创建Handler会抛出异常"><a href="#为什么在子线程中创建Handler会抛出异常" class="headerlink" title="为什么在子线程中创建Handler会抛出异常"></a>为什么在子线程中创建Handler会抛出异常</h2><p>因为这样创建的话，Handler的源码里的mLooper会为null，所以抛出异常。即线程中的mLooper还未被创建，所以<code>Looper.myLooper()</code>中的<code>sThreadLocal.get()</code>就会返回null值。</p>
<p>MessageQueue是存在于Looper中的，如果没有Looper就没有MessageQueue，所以创建Handler时，Looper不能为空。Looper对象是通过<code>Looper.prepare()</code>方法创建的。</p>
<h2 id="主线程的Looper是轮询死循环为何没有阻塞主线程"><a href="#主线程的Looper是轮询死循环为何没有阻塞主线程" class="headerlink" title="主线程的Looper是轮询死循环为何没有阻塞主线程"></a>主线程的Looper是轮询死循环为何没有阻塞主线程</h2><p>为什么主线程中的<code>Looper.loop()</code>方法一直在无限循环地检测消息队列中是否有新的消息，却不会造成ANR？</p>
<p>因为Looper的作用是持有一个Message Queue，这个消息队列中存放着外部来的消息。当有消息过来的时候，Looper就会按顺序把消息一个个取出来进行处理。所以，「只有没有输入事件，此时Message Queue是空的，<strong>Looper进行空闲状态，线程才会进入阻塞</strong>，释放CPU，等待输入事件的唤醒」。</p>
<h2 id="使用Handler的postDelay-后消息队列会发生什么变化"><a href="#使用Handler的postDelay-后消息队列会发生什么变化" class="headerlink" title="使用Handler的postDelay()后消息队列会发生什么变化"></a>使用Handler的<code>postDelay()</code>后消息队列会发生什么变化</h2><p>在<code>postDelay()</code>这个方法内，如果头部的Message有延迟并且延迟时间内没收到，就会计算时间。在循环开始的时候判断如果这个Message有延迟，那么就会调用某个方法进行阻塞。这个方法的作用相当于<code>Object.wait()</code>。</p>
<p><code>postDelay()</code>的Message并不是先等待一定时间再放入到MessageQueue中，而是直接进入并阻塞当前线程，然后将其delay的时间和队头的进行比较，按照触发时间进行排序，如果触发时间更近则放入队头，保证队头的时间最小、队尾的时间最大。此时，如果队头的Message正是被delay的，则将当前线程堵塞一段时间，直到等待足够时间再唤醒执行该Message，否则唤醒后直接执行。</p>
<h2 id="Message可以如何创建？哪种效果更好，为什么？"><a href="#Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="Message可以如何创建？哪种效果更好，为什么？"></a>Message可以如何创建？哪种效果更好，为什么？</h2><p>创建Message对象的几种方式：</p>
<ul>
<li><code>Message msg = new Message();</code></li>
<li><code>Message msg = Message.obtain();</code></li>
<li><code>Message msg = handler.obtainMessage();</code></li>
</ul>
<p>第一个就最普通的new一个新的Message对象，而后两个是从整个Message池中返回一个新的Message实例，能够有效地避免重复的Message创建对象，因此更鼓励后两种方式。</p>
<h2 id="runOnUiThread如何实现子线程更新UI"><a href="#runOnUiThread如何实现子线程更新UI" class="headerlink" title="runOnUiThread如何实现子线程更新UI"></a>runOnUiThread如何实现子线程更新UI</h2><p>在<code>runOnUiThread</code>程序中，会首先判断当前线程是否是UI线程，如果是就直接运行；如果不是则post，本质上还是使用Handler机制来处理线程与UI通信。Handler的handlerMessage()方法的执行是在主线程中。</p>
<h2 id="ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作"><a href="#ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作" class="headerlink" title="ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作?"></a>ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作?</h2><ul>
<li>线程本地存储的功能</li>
</ul>
<p>ThreadLocal类可实现线程本地存储的功能，<strong>把共享数据的可见范围限制在同一个线程之内</strong>，无须同步就能保证线程之间不出现数据争用的问题，这里可理解为ThreadLocal帮助Handler找到本线程的Looper。</p>
<ul>
<li>怎么存储呢？底层数据结构是什么</li>
</ul>
<p>每个线程的Thread对象中都有一个ThreadLocalMap对象，它存储了一组以<code>ThreadLocal.threadLocalHashCode为key</code>、以本地线程变量为value的键值对，而ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，也就包含了一个独一无二的threadLocalHashCode值，通过这个值就可以在线程键值值对中找回对应的本地线程变量。</p>
<ul>
<li>如何避免UI线程尽量只做跟UI相关的工作</li>
</ul>
<p>耗时的操作(比如数据库操作，I/O,连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理尽量用Handler来处理UIthread和别的thread之间的交互。使用Thread或者HandlerThread时，调用<code>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</code>设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。使用Handler处理工作线程结果，而不是使用<code>Thread.wait()</code>或者<code>Thread.sleep()</code>来阻塞主线程。</p>
<h1 id="AsyncTask-1"><a href="#AsyncTask-1" class="headerlink" title="AsyncTask"></a>AsyncTask</h1><p>AsyncTask，是Android提供的轻量级的异步类，可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的程度（可以通过接口实现UI进度更新），最后反馈执行的结果给UI主线程。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>AsyncTask中有4个核心方法，如下所示：</p>
<ul>
<li><code>onPreExecute()</code>：在主线程中执行，一般在任务执行前做准备工作，比如对UI做一些标记；</li>
<li><code>doInBackground(Params...params)</code>：在线程池中运行，用来执行较为耗时的操作；</li>
<li><code>onProgressUpdate(Progress...values)</code>：在主线程中运行，将进度更新到UI组件上；</li>
<li><code>onPostExecute(Result result)</code>：在主线层中执行。</li>
</ul>
<p>AsyncTask用到了线程，在线程池中运行线程，并且用到了阻塞队列。</p>
<h2 id="AsyncTask原理"><a href="#AsyncTask原理" class="headerlink" title="AsyncTask原理"></a>AsyncTask原理</h2><p>当调用<code>execute(Params...params)</code>方法后，<code>execute</code>方法会调用<code>onPreExecute()</code>方法，然后由<code>ThreadPoolExecutor</code>实例执行一个<code>FutureTask</code>任务，这个过程中会调用<code>doInBackground(Params...params)</code>方法；如果开发者重写了<code>doInBackground</code>方法，那么会通过<code>InternalHandler</code>实例发送<code>MESSAGE_POST_PROGRESS</code>消息，更新进度。当任务异常时，会发送<code>MESSAGE_POST_CANCEL</code>消息，取消任务；如果执行成功，就发送<code>MESSAGE_POST_RESULT</code>消息，<code>InternalHandler</code>实例会调用<code>onPostExecute(Result result)</code>方法在UI线程处理结果。</p>
<blockquote>
<p>AsyncTask就是线程池加上Handler的封装，减少了开发者处理问题的复杂度，提高了开发效率。</p>
</blockquote>
<h2 id="AsyncTask相比Handler有什么优点和缺点"><a href="#AsyncTask相比Handler有什么优点和缺点" class="headerlink" title="AsyncTask相比Handler有什么优点和缺点"></a>AsyncTask相比Handler有什么优点和缺点</h2><p><strong>优点</strong>：</p>
<p>简单、快捷，过程可控</p>
<p><strong>缺点</strong>：</p>
<p>在使用多个异步操作和需要改变UI时，会相对变得复杂。</p>
<h2 id="使用AsyncTask需要注意什么"><a href="#使用AsyncTask需要注意什么" class="headerlink" title="使用AsyncTask需要注意什么"></a>使用AsyncTask需要注意什么</h2><h2 id="AsyncTask中使用的线程池大小"><a href="#AsyncTask中使用的线程池大小" class="headerlink" title="AsyncTask中使用的线程池大小"></a>AsyncTask中使用的线程池大小</h2><p>在AsyncTask内部实现有<strong>两个</strong>线程池：</p>
<p>SerialExecutor：用于任务的排队，默认是串行的线程池，在3.0以前核心线程数为5、线程池大小为128，而3.0以后变为同一时间只能处理一个任务；<br>THREAD_POOL_EXECUTOR：用于真正执行任务。</p>
<h2 id="HandlerThread有什么特点"><a href="#HandlerThread有什么特点" class="headerlink" title="HandlerThread有什么特点"></a>HandlerThread有什么特点</h2><p>HandlerThread是一个线程类，它继承自Thread。与普通Thread不同，HandlerThread具有消息循环的效果，这是因为它内部HandlerThread.run()方法中有Looper，能通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环。</p>
<ul>
<li>HandlerThread本质上是一个线程类，它继承了Thread；</li>
<li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li>
<li>通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务；</li>
<li>创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用<code>run()</code>方法，创建Looper对象。</li>
</ul>
<h2 id="HandlerThread常规使用步骤"><a href="#HandlerThread常规使用步骤" class="headerlink" title="HandlerThread常规使用步骤"></a>HandlerThread常规使用步骤</h2><ol>
<li><p>创建实例对象</p>
<p> <code>HandlerThread handlerThread = new HandlerThread(&quot;downloadImage&quot;);</code></p>
<p> 传入参数的作用主要是标记当前线程的名字，可以任意字符串。</p>
</li>
<li><p>启动HandlerThread线程</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须先开启线程</span></span><br><span class="line">handlerThread.start();</span><br></pre></td></tr></table></figure>
<p> 到此，我们创建完HandlerThread并启动了线程。那么我们怎么将一个耗时的异步任务投放到HandlerThread线程中去执行呢？</p>
</li>
<li><p>构建循环消息处理机制</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该callback运行于子线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在子线程中进行相应的网络请求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知主线程去更新UI</span></span><br><span class="line">        mUIHandler.sendMessage(msg1);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构建异步handler</p>
 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子线程Handler</span></span><br><span class="line">Handler childHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper(), <span class="keyword">new</span> ChildCallback());</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>第3步和第4步是构建一个可以用于异步操作的handler，并将前面创建的HandlerThread的Looper对象以及Callback接口类作为参数传递给当前的handler，这样当前的异步handler就拥有了HandlerThread的Looper对象，由于HandlerThread本身是异步线程，因此Looper也与异步线程绑定，从而handlerMessage方法也就可以异步处理耗时任务了，这样我们的Looper+Handler+MessageQueue+Thread异步循环机制构建完成。</p>
<h2 id="快速实现子线程使用Handler"><a href="#快速实现子线程使用Handler" class="headerlink" title="快速实现子线程使用Handler"></a>快速实现子线程使用Handler</h2><h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><h2 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h2><ol>
<li>测量——<code>onMeasure()</code>：决定View的大小</li>
<li>布局——<code>onLayout()</code>：决定View在ViewGroup中的位置</li>
<li>绘制——<code>onDraw()</code>：绘制这个View</li>
</ol>
<h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul>
<li>继承View，重写<code>onDraw()</code>方法</li>
<li>继承ViewGroup，派生特殊的Layout</li>
<li>继承特定的View，例如TextView</li>
<li>继承特定的ViewGroup，例如LinearLayout</li>
</ul>
<h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul>
<li>继承View类或者其子类</li>
<li>重写View中的一些函数</li>
<li>为自定义View类增加属性（两种方式）</li>
<li>绘制控件（导入布局）</li>
<li>响应用户事件</li>
<li>定义回调函数</li>
</ul>
<h2 id="View的滑动方式"><a href="#View的滑动方式" class="headerlink" title="View的滑动方式"></a>View的滑动方式</h2><h3 id="通过View本身提供的scrollTo-scrollBy方法"><a href="#通过View本身提供的scrollTo-scrollBy方法" class="headerlink" title="通过View本身提供的scrollTo/scrollBy方法"></a>通过View本身提供的<code>scrollTo</code>/<code>scrollBy</code>方法</h3><p>这个方法移动的是View的内容，而View本身不移动。</p>
<p><code>scrollTo</code>和<code>scrollBy</code>也是有区别的。<code>scrollBy</code>内部调用了<code>scrollTo</code>，它是基于当前位置的<strong>相对滑动</strong>；而<code>scrollTo</code>是<strong>绝对滑动</strong>，因此如果利用相同输入参数多次调用<code>scrollTo()</code>方法，由于View初始位置是不变的，只会出现一次View滚动的效果而不是多次的。</p>
<h3 id="通过动画给View施加平移效果实现滑动"><a href="#通过动画给View施加平移效果实现滑动" class="headerlink" title="通过动画给View施加平移效果实现滑动"></a>通过动画给View施加平移效果实现滑动</h3><p>只是通过动画的方式移动View的影像，然而View本身位置不发生改变</p>
<h3 id="通过改变View的LayoutParams使View重新布局实现滑动"><a href="#通过改变View的LayoutParams使View重新布局实现滑动" class="headerlink" title="通过改变View的LayoutParams使View重新布局实现滑动"></a>通过改变View的LayoutParams使View重新布局实现滑动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarginLayoutParams params = mButton.getLayoutParams();</span><br><span class="line">params.width += <span class="number">10</span>;</span><br><span class="line">params.height += <span class="number">10</span>;</span><br><span class="line">mButton.requestLayout();</span><br><span class="line">mButton.setLayoutParams(params);</span><br></pre></td></tr></table></figure>
<h3 id="三种方法的使用对比"><a href="#三种方法的使用对比" class="headerlink" title="三种方法的使用对比"></a>三种方法的使用对比</h3><ul>
<li><code>scrollTo</code>/<code>scrollBy</code>：操作简单，适合对View内容的滑动；</li>
<li>动画：操作简单，主要适合于没有交互的View和实现复杂的动画效果；</li>
<li>改变布局参数：操作稍微复杂，适合有交互的View</li>
</ul>
<h3 id="如何解决View的滑动冲突"><a href="#如何解决View的滑动冲突" class="headerlink" title="如何解决View的滑动冲突"></a>如何解决View的滑动冲突</h3><p>首先判断是什么原因引起的View滑动冲突。</p>
<ul>
<li>对于由于外部滑动和内部滑动<strong>方向不一致</strong>导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件；</li>
<li>对于由于外部滑动方向和内部滑动<strong>方向一致</strong>导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件何时让内部View拦截事件；</li>
<li><p>上面两种情况的嵌套。</p>
</li>
<li><p><strong>外部拦截法</strong>：时间都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截；具体方法需要重写父容器的<code>onInterceptTouchEvent</code>方法，在内部做出相应的拦截；</p>
</li>
<li><strong>内部拦截法</strong>：父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法是配合<code>requestDisallowInterceptTouchEvent</code>方法。</li>
</ul>
<h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p>当我们点击屏幕时，产生了点击事件，这个事件被封装成类：<code>MotionEvent</code>。</p>
<p>事件的分发机制由三个重要想法来共同完成：<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code>、<code>onTouchEvent</code>。</p>
<ul>
<li><p><strong>事件分发</strong>：<code>public boolean dispatchTouchEvent(MotionEvent event)</code></p>
<p>  用来进行事件的<strong>分发（传递）</strong>。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前的<code>onTouchEvent</code>和下级View的<code>dispatchTouchEvent</code>影响，表示是否消耗了当前事件；</p>
</li>
<li><p><strong>事件拦截</strong>：<code>public boolean onInterceptTouchEvent(MotionEvent event)</code></p>
<p>  用来判断是否<strong>拦截</strong>某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件；</p>
</li>
<li><p><strong>事件响应</strong>：<code>public boolean onTouchEvent(MotionEvent event)</code></p>
<p>  在<code>dispatchTouchEvent</code>方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件。</p>
</li>
</ul>
<p><strong>三者的关系可以用以下伪代码表示</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">        result = onTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`onInterceptTouchEvent()`和`onTouchEvent()`方法都是在`dispatchTouchEvent()`方法里调用。</span><br></pre></td></tr></table></figure></p>
<h2 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h2><p>View的工作流程就是先measure测量，用于确定View的宽高，再layout布局，用于确定View的最终宽高和四个顶点的位置，最后使用draw绘制，用于将View绘制到屏幕上。</p>
<p>measure用来测量view的宽和高，layout方法的作用是确定元素的位置，draw的过程则有：</p>
<ul>
<li>如果需要，则绘制背景；</li>
<li>保存当前canvas层；</li>
<li>绘制view的内容；</li>
<li>绘制子view；</li>
<li>如果需要，绘制view的褪色边缘，类似于阴影效果；</li>
<li>绘制装饰，比如滚动条里；</li>
</ul>
<h2 id="View和ViewGroup的区别"><a href="#View和ViewGroup的区别" class="headerlink" title="View和ViewGroup的区别"></a>View和ViewGroup的区别</h2><h2 id="非UI线程可以更新UI吗"><a href="#非UI线程可以更新UI吗" class="headerlink" title="非UI线程可以更新UI吗"></a>非UI线程可以更新UI吗</h2><p>其实是非UI线程是可以刷新UI的。前提是<strong>它要拥有自己的ViewRoot，即更新UI的线程和创建ViewRoot的线程是同一个</strong>，或者<strong>在执行<code>checkThread()</code>方法之前去更新UI</strong>。</p>
<p>因为在访问UI时，ViewRootImpl会调用<code>checkThread()</code>方法去检查当前访问UI的线程是哪一个，如果不会UI线程就会抛出异常。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException (</span><br><span class="line">            <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ViewRootImpl的创建是在<code>onResume()</code>方法回调之后，而在执行<code>onCreate()</code>方法的时候还没有创建ViewRootImpl，就无法去检查当前线程。但是一般情况下，我们不会在<code>onCreate()</code>方法中做更新UI的操作。</p>
<h2 id="MotionEvent是什么？包含几种事件？什么时候会产生？"><a href="#MotionEvent是什么？包含几种事件？什么时候会产生？" class="headerlink" title="MotionEvent是什么？包含几种事件？什么时候会产生？"></a>MotionEvent是什么？包含几种事件？什么时候会产生？</h2><h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><h2 id="Android中有哪几种类型的动画"><a href="#Android中有哪几种类型的动画" class="headerlink" title="Android中有哪几种类型的动画"></a>Android中有哪几种类型的动画</h2><ul>
<li><strong>View动画（View Animation）/ 补间动画（Tween Animation）</strong>：对View进行平移、缩放、旋转和透明度变化的动画，不能真正地改变View的位置</li>
<li><strong>逐帧动画（Drawable Animation）</strong>：是View动画的一种，它会按照顺序播放一组预先定义好的图片</li>
<li><strong>属性动画（Property Animation）</strong>：通过不断的改变View的属性，不断地重绘而形成动画效果</li>
</ul>
<h2 id="View动画和属性动画的区别"><a href="#View动画和属性动画的区别" class="headerlink" title="View动画和属性动画的区别"></a>View动画和属性动画的区别</h2><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">View动画</th>
<th style="text-align:center">属性动画</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">动画实现</td>
<td style="text-align:center">通过不断的<strong>图形变换</strong>（TranslateAnimation，ScaleAnimation，RotateAnimation，AlphaAnimation）</td>
<td style="text-align:center">通过动态改变<strong>对象属性</strong>（ValueAnimator，ObjectAnimator，AnimatorSet）</td>
</tr>
<tr>
<td style="text-align:center">作用对象</td>
<td style="text-align:center">View对象</td>
<td style="text-align:center">任何对象</td>
</tr>
<tr>
<td style="text-align:center">存放位置</td>
<td style="text-align:center"><code>res/anim/</code></td>
<td style="text-align:center"><code>res/animator/</code></td>
</tr>
<tr>
<td style="text-align:center">状态变化</td>
<td style="text-align:center">未真正改变view的位置</td>
<td style="text-align:center">真正地改变了view的位置</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>View动画改变的只是View的显示，而没有改变View的响应区域；而属性动画会通过反射技术来获取和执行属性的<code>get</code>、<code>set</code>方法，从而改变了对象位置的属性值。</p>
</blockquote>
<h2 id="帧动画在使用时需要注意到什么"><a href="#帧动画在使用时需要注意到什么" class="headerlink" title="帧动画在使用时需要注意到什么"></a>帧动画在使用时需要注意到什么</h2><p>使用帧动画时注意不能使用尺寸过大的图片，否则容易造成OOM。</p>
<h2 id="属性动画中插值器和估值器的作用"><a href="#属性动画中插值器和估值器的作用" class="headerlink" title="属性动画中插值器和估值器的作用"></a>属性动画中插值器和估值器的作用</h2><h3 id="插值器（Interpoloator）"><a href="#插值器（Interpoloator）" class="headerlink" title="插值器（Interpoloator）"></a>插值器（Interpoloator）</h3><ul>
<li>定义：一个接口</li>
<li>作用：设置属性值从初始值过渡到结束值的<strong>变化规律</strong>（确定了动画效果变化的模式，如匀速变化、加速变化、减速变化等）</li>
<li>使用方法：可以在XML和Java代码中设置</li>
</ul>
<h3 id="估值器（TypeEvaluator）"><a href="#估值器（TypeEvaluator）" class="headerlink" title="估值器（TypeEvaluator）"></a>估值器（TypeEvaluator）</h3><ul>
<li>定义：一个接口</li>
<li>作用：设置属性值从初始值过渡到结束值的<strong>变化具体数值</strong>（估值器决定了具体的变化数值）</li>
</ul>
<h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><h2 id="Activity、View、Window之间的关系"><a href="#Activity、View、Window之间的关系" class="headerlink" title="Activity、View、Window之间的关系"></a>Activity、View、Window之间的关系</h2><p>Activity是界面载体，可以展示页面；而View实际上是一个个视图，这些视图可以搭载在一个Layout文件上，通过Activity的<code>setContentView()</code>方法传递给Activity；Window是一个窗体，每个Activity对应一个Window，通常在代码中通过<code>getWindow()</code>方法获取它。</p>
<blockquote>
<p>每个Activity包含了一个Window对象，这个对象是由PhoneWindow实现的。PhoneWindow将内部的DecorView作为了一个应用窗口的根View，这个DecorView又把屏幕划分为了两个区域：一个是ActionBar（TitleBar），一个是ContentView。我们平时编写的XML文件布局就是展示在ContentView中。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/02/JjBNu9.png" alt="Activitiy、View、Window之间的关系"></p>
<h2 id="Window有哪几种类型"><a href="#Window有哪几种类型" class="headerlink" title="Window有哪几种类型"></a>Window有哪几种类型</h2><ul>
<li><strong>应用Window</strong>：对应一个Activity</li>
<li><strong>子Window</strong>：不能单独存在，需附属特定的父Window。比如Dialog。</li>
<li><strong>系统Window</strong>：需要申明权限才可以创建，比如Toast</li>
</ul>
<p>Window是分层的，层级大的会覆盖在层级小的Window上面，对应的是<code>WindowManager.LayoutParams</code>的<code>type</code>参数。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">Window</th>
<th style="text-align:center">层级</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">应用Window</td>
<td style="text-align:center">1~99</td>
</tr>
<tr>
<td style="text-align:center">子Window</td>
<td style="text-align:center">1000~1999</td>
</tr>
<tr>
<td style="text-align:center">系统Window</td>
<td style="text-align:center">2000~2999</td>
</tr>
</tbody>
</table>
</div>
<h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="六大布局"><a href="#六大布局" class="headerlink" title="六大布局"></a>六大布局</h2><ul>
<li>LinearLayout</li>
<li>RelativeLayout</li>
<li>TableLayout</li>
<li>FrameLayout</li>
<li>AbsoluteLayout</li>
<li>GridLayout</li>
</ul>
<h3 id="margin和padding的区别"><a href="#margin和padding的区别" class="headerlink" title="margin和padding的区别"></a>margin和padding的区别</h3><h2 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h2><p>ConstrainLayout约束布局和RelativeLayout相对布局有点类似控件之间都是依赖关系而存在的，但是会比RelativeLayout更加灵活。</p>
<p>它的好处就是提升了性能，减少了布局之间的嵌套。</p>
<h3 id="ConstraintLayout与RelativeLayout的区别"><a href="#ConstraintLayout与RelativeLayout的区别" class="headerlink" title="ConstraintLayout与RelativeLayout的区别"></a>ConstraintLayout与RelativeLayout的区别</h3><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><ul>
<li>LayoutManager：负责Item视图的布局的显示管理</li>
<li>ItemDecoration：给每一个item视图添加子View（例如可以添加分割线）</li>
<li>ItemAnimator：负责处理数据添加或者删除时的动画效果</li>
<li>Adapter：为每一项item创建视图。一是根据不同的ViewType创建与之相应的item布局，二是访问数据集合并将数据绑定到正确的View上</li>
<li>ViewHolder：承载item视图的子布局</li>
<li>Recycler：负责处理View的缓存</li>
</ul>
<p><strong>方法的作用</strong>：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Item视图，并返回给相应的ViewHolder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 绑定数据到正确的Item视图上</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回该Adapter所持有的Item数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 用来获取当前项Item，即position参数是哪种类型的布局</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span></span></span><br></pre></td></tr></table></figure>
<h3 id="RecyclerView与ListView的区别"><a href="#RecyclerView与ListView的区别" class="headerlink" title="RecyclerView与ListView的区别"></a>RecyclerView与ListView的区别</h3><ol>
<li><p>缓存机制不同</p>
<p> ListView是两级缓存，而RecyclerView是四级缓存，支持多个ItemView缓存，支持自定义缓存处理逻辑，支持所有的RecyclerView共用同一个RecyclerViewPool。</p>
<p> ListView的两级缓存是<code>mActiveViews</code>和<code>mScrapViews</code>。</p>
<p> RecyclerView的四级缓存是<code>mAttachedScrap</code>和<code>mCacheViews</code>和<code>mViewCatchExtension</code>和<code>mRecyclerPool</code>。</p>
</li>
<li><p>局部刷新</p>
<p> RecyclerView提供了局部刷新的接口，通过局部刷新的机制，可以避免调用许多无用的bindView。</p>
</li>
<li><p>ListView不强制要写ViewHolder，而RecyclerView是强制要写ViewHolder的，从而去重写<code>getItemCount()</code>、<code>onCreateViewHolder()</code>、<code>onBindViewHolder()</code>三个方法</p>
</li>
<li><p>ListView的分割线是直接设置Divider，而RecyclerView是不支持直接在布局中添加分割线的</p>
</li>
<li><p>ListView支持点击事件，而RecyclerView不支持点击事件，只有设置回调接口来设置点击事件。</p>
</li>
<li><p>ListView的布局效果单一，只能是纵向效果；RecyclerView布局效果丰富，通过LayoutManager中设置，可以实现线性布局（横向、纵向），表格布局，瀑布流布局等等。</p>
</li>
</ol>
<h3 id="如何理解adapter订阅者模式"><a href="#如何理解adapter订阅者模式" class="headerlink" title="如何理解adapter订阅者模式"></a>如何理解adapter订阅者模式</h3><h3 id="ViewHolder的作用"><a href="#ViewHolder的作用" class="headerlink" title="ViewHolder的作用"></a>ViewHolder的作用</h3><p>ViewHolder内部是存储一些子View，避免时间代价很大的findViewById的操作。</p>
<h3 id="如何理解ViewHolder的复用"><a href="#如何理解ViewHolder的复用" class="headerlink" title="如何理解ViewHolder的复用"></a>如何理解ViewHolder的复用</h3><p>在重写RecyclerView.Adapter的时候，需要重写两个方法：</p>
<ul>
<li><code>onCreateViewHolder()</code></li>
<li><code>onBindViewHolder()</code></li>
</ul>
<p>它的复用机制就是当创建了足够多的ViewHolder对象之后，无论怎么滑动，都只需要复用以前创建的对象即可。</p>
<p>当数量足够用的时候，会停止调用<code>onCreateViewHolder()</code>方法，但是<code>onBindViewHolder()</code>方法会每次都会调用。</p>
<hr>
<p>RecyclerView的复用机制的调用入口是<code>getViewPosition()</code>方法，重点则是在<code>tryGetViewHolderForPositionByDeadline()</code>方法之中。</p>
<p>它的关键步骤主要如下：</p>
<ul>
<li>判断Cache池中是否有相应的ViewHolder对象</li>
<li>从<code>mViewCacheExtension</code>中寻找对象</li>
<li>从<code>RecyclerViewPool</code>中寻找对象</li>
<li>如果之前的步骤都没有寻找到对象，那么就用Adapter的<code>createViewHolder()</code>方法去创建ViewHolder对象</li>
<li>最后是根据不同的<code>ViewHolderFlags</code>情况（例如是否可复用等）来决定是否执行<code>tryBindViewHolderByDeadline()</code>方法，<code>onBindViewHolder()</code>方法是唯一的入口。</li>
</ul>
<h3 id="什么时候停止调用onCreateViewHolder"><a href="#什么时候停止调用onCreateViewHolder" class="headerlink" title="什么时候停止调用onCreateViewHolder"></a>什么时候停止调用onCreateViewHolder</h3><h3 id="LayoutManager的作用是什么"><a href="#LayoutManager的作用是什么" class="headerlink" title="LayoutManager的作用是什么"></a>LayoutManager的作用是什么</h3><p>LayoutManager的作用是用来设置item的位置，并且负责决定何时回收和复用item。一个RecyclerView如果想展示内容，就必须设置LayoutManager。</p>
<h3 id="LayoutManager的样式有哪些"><a href="#LayoutManager的样式有哪些" class="headerlink" title="LayoutManager的样式有哪些"></a>LayoutManager的样式有哪些</h3><ul>
<li>LinearLayoutManager：设置水平或者垂直的item视图</li>
<li>GridLayoutManager：网格状的item视图</li>
<li>StaggeredGridLayoutManager：交错的网格布局</li>
</ul>
<h3 id="上拉加载的功能是如何做的"><a href="#上拉加载的功能是如何做的" class="headerlink" title="上拉加载的功能是如何做的"></a>上拉加载的功能是如何做的</h3><h3 id="添加滚动监听事件需要注意什么"><a href="#添加滚动监听事件需要注意什么" class="headerlink" title="添加滚动监听事件需要注意什么"></a>添加滚动监听事件需要注意什么</h3><h3 id="网格布局上拉加载如何优化"><a href="#网格布局上拉加载如何优化" class="headerlink" title="网格布局上拉加载如何优化"></a>网格布局上拉加载如何优化</h3><h3 id="如何理解RecyclerView三级缓存是如何实现的"><a href="#如何理解RecyclerView三级缓存是如何实现的" class="headerlink" title="如何理解RecyclerView三级缓存是如何实现的"></a>如何理解RecyclerView三级缓存是如何实现的</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><blockquote>
<p>返回布局和内容都有效的ViewHolder</p>
</blockquote>
<ol>
<li>按position或者id匹配</li>
<li>命中一级缓存是无需使用<code>onCreateViewHolder</code>和<code>onBindViewHolder</code></li>
<li></li>
</ol>
<h3 id="RecyclerView滑动卡顿的原因有哪些？如何解决？"><a href="#RecyclerView滑动卡顿的原因有哪些？如何解决？" class="headerlink" title="RecyclerView滑动卡顿的原因有哪些？如何解决？"></a>RecyclerView滑动卡顿的原因有哪些？如何解决？</h3><h3 id="RecyclerView常见的优化有哪些？"><a href="#RecyclerView常见的优化有哪些？" class="headerlink" title="RecyclerView常见的优化有哪些？"></a>RecyclerView常见的优化有哪些？</h3><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><h3 id="Intent可以传递哪些类型的数据"><a href="#Intent可以传递哪些类型的数据" class="headerlink" title="Intent可以传递哪些类型的数据"></a>Intent可以传递哪些类型的数据</h3><ul>
<li>8种基本数据类型及其数组</li>
<li>String / CharSequence 实例类型的数据及其数组</li>
<li>实现了Parcelable的对象及其数组</li>
<li>实现了Serializable的对象及其数组</li>
</ul>
<h2 id="进程间通信的方式"><a href="#进程间通信的方式" class="headerlink" title="进程间通信的方式"></a>进程间通信的方式</h2><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><ul>
<li><p><strong>单一职责原则</strong>：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p>
<blockquote>
<p>There should never be more than one reason for a class to change.</p>
</blockquote>
<p>  不同的类具有不同的职责，各司其职。如果一个类拥有了两种职责，那么就最好将其分为两个类。</p>
</li>
<li><p><strong>里氏替换原则（Liskov Substitution Principle）</strong>：所有引用基类的地方必须能够透明地使用其子类的对象。</p>
<blockquote>
<p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.</p>
</blockquote>
<p>  它是开闭原则的具体实现手段之一。里氏替换原则的核心是<strong>抽象</strong>，而抽象又依赖于<strong>继承</strong>这个特性。继承的优点有：1. 代码重用，减少创建类的成本，每个子类拥有父类的属性和方法；2. 子类和父类基本相似，但是又于父类有区别；3. 提高代码的可拓展性。继承的缺点有：1. 继承是侵入性的，只要继承了就必须拥有父类的所有属性和方法；2. 可能会造成子类代码的冗余，灵活性降低，因为子类必须拥有父类所有的属性和方法。里氏替换原则和开闭原则是相互依赖的，通过里式替换来达到对扩展的开发，对修改的关闭效果。</p>
</li>
<li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong>：高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p>
<blockquote>
<p>High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depends upon details. Details should depend upon abstractions.</p>
</blockquote>
<p>  在Java中，<strong>抽象</strong>是指接口或者抽象类（Abstract），两者都是不可以被实例化的（不能被new）；而<strong>细节</strong>指的是具体的实现类，实现接口或者抽象类，是可以被实例化的。高层模块指的就是调用端，低层模块就是具体的实现类。所以依赖倒转原则在Java中的表现就是，模块间的依赖通过抽象产生，实现类之间是不会产生依赖关系的，其依赖关系是通过接口或者抽象类产生的。如果类与类之间直接依赖细节，那么可能会直接耦合。需要修改时，就会同时修改依赖者的代码，限制了可拓展性。</p>
</li>
<li><p><strong>接口隔离原则（Interface Segregation Principle）</strong>：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</p>
<blockquote>
<p>The dependency of one class to another one should depend on the smallest possible interface.</p>
</blockquote>
<p>  接口隔离原则的建立最小的接口是指建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量要少。即为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有的依赖它的类调用。需要注意以下几点：</p>
<ul>
<li>接口尽量要小，但是也有限度。对接口进行细化可以提高程序设计的灵活性；但是如果太小了，则会造成接口数量过多，设计复杂化；</li>
<li>为依赖接口的类定制服务，只暴露给调用的类需要的方法，它不需要的方法则隐蔽起来。这样才能建立最小的依赖关系；</li>
<li>提高内聚，减少对外交互。接口方法尽量少用<code>public</code>修饰，接口是对外的承诺，承诺越少对系统开发越有利，变更风险也会越少。</li>
</ul>
</li>
<li><p><strong>迪米特原则（Law of Demeter，最少知道原则）</strong>：一个对象应该对其它对象保持最少的了解，即一个软件实体应当尽可能少地与其它实体发生相互作用</p>
<blockquote>
<p>Only talk to your immediate friends.</p>
</blockquote>
<p>  一个类应该对自己需要耦合或者调用的类了解最少，类的内部如何实现与调用者或者依赖关系越密切，耦合度就越大。当一个类发生变化时，对另外一个类的影响也越大。即<strong>低耦合、高内聚</strong>。</p>
<ul>
<li>在类的划分上，应当尽量创建松耦合的类。类之间的耦合度越低，当一个类修改时，就不会对关联的类造成太大的波及；</li>
<li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；</li>
<li>在对其它类的引用上，一个类对其它对象的引用应当降到最低；</li>
</ul>
</li>
<li><p><strong>开放封闭原则（Open Close Principle）</strong>：对扩展开放，对修改关闭</p>
<blockquote>
<p>Software entities like classes, modules and functions should be open for extension but closed for modifications.</p>
</blockquote>
<p>  即<strong>类、模块、函数等应该是可以拓展的，但是不可修改</strong>。开闭原则指导我们，当软件发生变化时，应该尽量通过<strong>拓展</strong>的方式来实现变化，而不是通过<strong>修改</strong>已有代码来实现（OCP原则并不是说绝对不可以修改原始的类）。</p>
</li>
<li><p><strong>合成复用原则（六大原则之外）</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</p>
<p>  合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。即首先考虑组合/聚合，可以使系统更灵活，降低类与类之间的耦合度，其次才考虑继承。在使用继承时，也要严格遵循里氏替换原则。</p>
</li>
</ul>
<h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p>23种设计模式分为三大类（分类不同版本有不同的数量）：</p>
<ul>
<li><p><strong>创建型模式（6种）</strong>：单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式</p>
<blockquote>
<p>创建型模式对类的实例化过程进行了抽象，能够将模块中对象的创建和对象的使用分离。为了使结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚具体的细节，使整个系统的设计更加符合单一职责原则。</p>
</blockquote>
</li>
<li><p><strong>结构型模式（6种）</strong>：外观模式、适配器模式、桥接模式、代理模式、装饰者模式、享元模式</p>
<blockquote>
<p>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</p>
</blockquote>
</li>
<li><p><strong>行为型模式（11种）</strong>：职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</p>
<blockquote>
<p>行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象之间的职责，并研究系统在运行时实例对象之间的交互。</p>
</blockquote>
</li>
</ul>
<p>具体的23种设计模式详见<a href="#designpattern">Java基础部分的设计模式分析</a></p>
<h1 id="MVC与MVP与MVVM"><a href="#MVC与MVP与MVVM" class="headerlink" title="MVC与MVP与MVVM"></a>MVC与MVP与MVVM</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote>
<p>MVC用一种业务逻辑、数据、界面显示分离的方法组织代码。</p>
</blockquote>
<p>Android中的MVC的角色定义如下：</p>
<ul>
<li>模型层Model：针对业务模型，建立的数据结构和相关的类，可以被理解为是Model。Model与View是无关的，而是与业务相关的。</li>
<li>视图层View：一般采用XML文件或者Java代码进行界面的描述。</li>
<li>控制层Controller：Android的控制层通常在Activity、Fragment或者由它们控制的其它业务类中。</li>
</ul>
<p>MVC简单来说就是「通过Controller来操作Model层的数据，并且返回给View层展示」。</p>
<p>MVC的缺点是：</p>
<ul>
<li>Android中的Activity或者Fragment并不是一个标准MVC模式中的Controller。随着界面及其逻辑的复杂度不断提升，Activity类的职责也在不断的增加，会变得十分的庞大臃肿。</li>
<li>View层和Model层相互耦合，不易于开发和维护。</li>
</ul>
<h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>在MVP里，Presenter完全将Model和View层进行了分离，把主要的程序逻辑都放在了Presenter里实现。Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，这样变更View时可以保持Presenter的不变。</p>
<p>View层里只有<code>get</code>/<code>set</code>方法，以及用户输入和设置界面显示的代码，除此之外就没有别的内容了，因为主要的逻辑就放在了Presenter层里实现。</p>
<ul>
<li>Model：主要提供数据的存取功能，Preseter层需要通过Model层来存储和获取数据；</li>
<li>View：负责处理用户事件和视图的展示，Android中对应的是Activity或者Fragment或者某个View；</li>
<li>Presenter：作为View和Model层之间的桥梁。它从Model层获取数据并显示在View层中，使得View和Model层之间没有耦合。</li>
</ul>
<h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>将Presenter改为ViewModel，不同的是ViewModel与Model和View是双向绑定的。当View发生改变时，ViewModel通知Model进行更新数据；而Model更新之后，ViewModel也会通知View层更新界面。</p>
<p>通过Data Binding，可以通过声明式布局的方式精简代码来绑定应用程序的逻辑和布局。</p>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Hurley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hurleyjames.github.io/2020/03/25/Interview-Review(Android)/">https://hurleyjames.github.io/2020/03/25/Interview-Review(Android)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hurleyjames.github.io" target="_blank">Hurley</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/../image/spring-cloud.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/images/wechat.JPG" alt="wechat" onclick="window.open('/images/wechat.JPG')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/images/alipay.JPG" alt="alipay" onclick="window.open('/images/alipay.JPG')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/06/Interview-Review(Java)/"><img class="prev-cover" data-src="/../image/java-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Interview-Review(Java)</div></div></a></div><div class="next-post pull-right"><a href="/2020/03/12/121.Best-Time-to-Buy-and-Sell-Stock/"><img class="next-cover" data-src="/../image/best-time-to-buy-and-sell-stock.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">121.Best Time to Buy and Sell Stock</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/../image/android-interview.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2021 By Hurley</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">随时意气风发，独自声势浩大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>