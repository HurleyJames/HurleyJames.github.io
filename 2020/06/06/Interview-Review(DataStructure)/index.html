<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Interview-Review(DataStructure) | Hurley</title><meta name="description" content="本篇主要是面试复习内容的数据结构部分。 基本概念 数据结构的定义  数据的逻辑结构：反映数据元素之间的关系的数据元素集合的表示。逻辑结构包括：集合、线形结构、树形结构、图形结构四种。 数据的存储结构：数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。常用的存储结构有顺序、链接、索引等存储结构。    哈希表（散列表）哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-"><meta name="keywords" content="面试"><meta name="author" content="Hurley"><meta name="copyright" content="Hurley"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/icon.png"><link rel="canonical" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(DataStructure)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Interview-Review(DataStructure)"><meta property="og:url" content="https://hurleyjames.github.io/2020/06/06/Interview-Review(DataStructure)/"><meta property="og:site_name" content="Hurley"><meta property="og:description" content="本篇主要是面试复习内容的数据结构部分。 基本概念 数据结构的定义  数据的逻辑结构：反映数据元素之间的关系的数据元素集合的表示。逻辑结构包括：集合、线形结构、树形结构、图形结构四种。 数据的存储结构：数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。常用的存储结构有顺序、链接、索引等存储结构。    哈希表（散列表）哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-"><meta property="og:image" content="https://hurleyjames.github.io/../image/data-structure-interview.png"><meta property="article:published_time" content="2020-06-05T16:00:00.000Z"><meta property="article:modified_time" content="2020-10-28T03:12:30.273Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="prev" title="Interview-Review(OS)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(OS)/"><link rel="next" title="Interview-Review(Database)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Database)/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/26319720?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">66</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">26</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#基本概念"><span class="toc-number">1.</span> <span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#哈希表（散列表）"><span class="toc-number">2.</span> <span class="toc-text">哈希表（散列表）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希函数"><span class="toc-number">2.1.</span> <span class="toc-text">哈希函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希冲突"><span class="toc-number">2.2.</span> <span class="toc-text">哈希冲突</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashMap"><span class="toc-number">2.3.</span> <span class="toc-text">HashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ConcurrentHashMap"><span class="toc-number">2.4.</span> <span class="toc-text">ConcurrentHashMap</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashSet"><span class="toc-number">2.5.</span> <span class="toc-text">HashSet</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#HashTable"><span class="toc-number">2.6.</span> <span class="toc-text">HashTable</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#栈和队列"><span class="toc-number">3.</span> <span class="toc-text">栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#栈"><span class="toc-number">3.1.</span> <span class="toc-text">栈</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#堆"><span class="toc-number">3.2.</span> <span class="toc-text">堆</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#堆和栈的区别"><span class="toc-number">3.2.1.</span> <span class="toc-text">堆和栈的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现"><span class="toc-number">3.2.2.</span> <span class="toc-text">实现</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#队列"><span class="toc-number">3.3.</span> <span class="toc-text">队列</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#栈和队列的区别"><span class="toc-number">3.4.</span> <span class="toc-text">栈和队列的区别</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#数组和链表"><span class="toc-number">4.</span> <span class="toc-text">数组和链表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#数组"><span class="toc-number">4.1.</span> <span class="toc-text">数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#链表"><span class="toc-number">4.2.</span> <span class="toc-text">链表</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#树"><span class="toc-number">5.</span> <span class="toc-text">树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉树"><span class="toc-number">5.1.</span> <span class="toc-text">二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#遍历二叉树"><span class="toc-number">5.1.1.</span> <span class="toc-text">遍历二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#前序遍历"><span class="toc-number">5.1.1.1.</span> <span class="toc-text">前序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#中序遍历"><span class="toc-number">5.1.1.2.</span> <span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#后序遍历"><span class="toc-number">5.1.1.3.</span> <span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#层次遍历"><span class="toc-number">5.1.1.4.</span> <span class="toc-text">层次遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#线索二叉树"><span class="toc-number">5.1.2.</span> <span class="toc-text">线索二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#完全二叉树"><span class="toc-number">5.1.3.</span> <span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#满二叉树"><span class="toc-number">5.1.4.</span> <span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#霍夫曼树"><span class="toc-number">5.1.5.</span> <span class="toc-text">霍夫曼树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#树与森林"><span class="toc-number">5.2.</span> <span class="toc-text">树与森林</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#图"><span class="toc-number">6.</span> <span class="toc-text">图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#概念"><span class="toc-number">6.1.</span> <span class="toc-text">概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#广度优先遍历和深度优先遍历"><span class="toc-number">6.2.</span> <span class="toc-text">广度优先遍历和深度优先遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#广度优先遍历"><span class="toc-number">6.2.1.</span> <span class="toc-text">广度优先遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#深度优先遍历"><span class="toc-number">6.2.2.</span> <span class="toc-text">深度优先遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#拓扑排序"><span class="toc-number">6.3.</span> <span class="toc-text">拓扑排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijikstra算法——最短路径问题"><span class="toc-number">6.4.</span> <span class="toc-text">Dijikstra算法——最短路径问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#排序"><span class="toc-number">7.</span> <span class="toc-text">排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#冒泡排序"><span class="toc-number">7.1.</span> <span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#选择排序"><span class="toc-number">7.2.</span> <span class="toc-text">选择排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插入排序"><span class="toc-number">7.3.</span> <span class="toc-text">插入排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#快速排序"><span class="toc-number">7.4.</span> <span class="toc-text">快速排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#希尔排序"><span class="toc-number">7.5.</span> <span class="toc-text">希尔排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#归并排序"><span class="toc-number">7.6.</span> <span class="toc-text">归并排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#桶排序"><span class="toc-number">7.7.</span> <span class="toc-text">桶排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#基数排序"><span class="toc-number">7.8.</span> <span class="toc-text">基数排序</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#计数排序"><span class="toc-number">7.9.</span> <span class="toc-text">计数排序</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#查找"><span class="toc-number">8.</span> <span class="toc-text">查找</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#顺序查找"><span class="toc-number">8.1.</span> <span class="toc-text">顺序查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#有序查找"><span class="toc-number">8.2.</span> <span class="toc-text">有序查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二分查找"><span class="toc-number">8.3.</span> <span class="toc-text">二分查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#插值查找"><span class="toc-number">8.4.</span> <span class="toc-text">插值查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#斐波那契查找"><span class="toc-number">8.5.</span> <span class="toc-text">斐波那契查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线性索引查找"><span class="toc-number">8.6.</span> <span class="toc-text">线性索引查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#哈希查找"><span class="toc-number">8.7.</span> <span class="toc-text">哈希查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#二叉查找树"><span class="toc-number">8.8.</span> <span class="toc-text">二叉查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#平衡二叉树"><span class="toc-number">8.9.</span> <span class="toc-text">平衡二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#红黑树"><span class="toc-number">8.10.</span> <span class="toc-text">红黑树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#简介"><span class="toc-number">8.10.1.</span> <span class="toc-text">简介</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#应用"><span class="toc-number">8.10.2.</span> <span class="toc-text">应用</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B树和B-树"><span class="toc-number">8.11.</span> <span class="toc-text">B树和B+树</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#动态规划"><span class="toc-number">9.</span> <span class="toc-text">动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#动态规划与分治法的区别"><span class="toc-number">9.1.</span> <span class="toc-text">动态规划与分治法的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#共同点"><span class="toc-number">9.1.1.</span> <span class="toc-text">共同点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方法"><span class="toc-number">9.1.2.</span> <span class="toc-text">实现方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">9.1.3.</span> <span class="toc-text">区别</span></a></li></ol></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/../image/data-structure-interview.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hurley</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Interview-Review(DataStructure)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-06 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-10-28 11:12:30"><i class="fas fa-history fa-fw"></i> 更新于 2020-10-28</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">6.8k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 21 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本篇主要是面试复习内容的数据结构部分。</p>
<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol>
<li><p>数据结构的定义</p>
<ul>
<li>数据的<strong>逻辑结构</strong>：反映数据元素之间的关系的数据元素集合的表示。逻辑结构包括：<strong>集合</strong>、<strong>线形结构</strong>、<strong>树形结构</strong>、<strong>图形</strong>结构四种。</li>
<li>数据的<strong>存储结构</strong>：数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。常用的存储结构有<strong>顺序</strong>、<strong>链接</strong>、<strong>索引</strong>等存储结构。</li>
</ul>
</li>
</ol>
<h1 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h1><p>哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，<strong>哈希函数</strong>和<strong>哈希冲突</strong>。</p>
<h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol>
<li><p>简述一下Java中的HashMap的实现原理</p>
<blockquote>
<p>HashMap的底层就是<strong>数组</strong>加上<strong>链表</strong>的结构实现的。结构如下图：</p>
<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/hashmap.png" alt=""></p>
<p>数组用来存放元素位置，链表用来解决哈希冲突。</p>
<p>当需要往HashMap中添加对象时，需要先计算key的hashCode，然后hashCode计算出元素应该放在数组的哪个位置。找到该位置后，判断该位置上是否已经存在键值对，如果已存在就覆盖，如果不存在就直接放到该位置。链表的存在是为了解决不同的key出现了Hash冲突的问题。一般元素会放到链表的头，这样做会减少操作。</p>
<p>HashMap有一个扩容因子0.75，当元素数量大于数组长度乘以扩容因子时，会触发扩容操作。扩容时，将数组长度变为原来2倍，然后将元素重新计算hashCode放到相应的位置。</p>
</blockquote>
</li>
<li><p>往HashMap中put元素的时候，先根据key计算hashCode，然后找到了数组中的对应位置。那么，是如何根据hashCode找到在数组中的具体位置呢？采用什么算法？</p>
</li>
</ol>
<ol>
<li><p>底层数组的初始长度是多少？为什么会设计成这个数呢？</p>
<blockquote>
<p>底层数组的默认长度是16。每次扩容都乘以2，都保证长度length是2的n次幂。原因就是这样可以使用位运算来加快计算在数组中的位置。</p>
</blockquote>
</li>
<li><p>扩容因子0.75，那么什么时候会触发扩容呢？是数组中元素占用位置的数量超过扩容因子时会触发还是HashMap的总元素数量超过扩容因子时会触发？</p>
<blockquote>
<p>HashMap中元素总个数达到阈值时就会扩容。</p>
</blockquote>
</li>
<li><p>为什么扩容的时候要重新计算hashCode呢？直接从旧的数组中移到新的数组中移到新的数组响应的位置不可以吗？</p>
<blockquote>
<p>扩容的时候是需要重新计算hash的，并且重新放置元素。但是并不可以从旧的数组直接移到新的数组响应的位置。因为虽然key的hashCode不会变，但是数组的长度发生了变化，那么根据hashCode计算数组位置时，得出的索引值也肯定是不同的。如果直接平移过来，会直接导致扩容前添加到HashMap中的数据无法被<code>get()</code>到。因为数组中的索引变化了，所以无法找到。</p>
</blockquote>
</li>
<li><p>HashMap是数据结构中哈希表的一个具体实现，还有哪些哈希表的其它实现方式？</p>
</li>
</ol>
<h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote>
<p>栈是一种「先进后出」的线性表，可以由数组或者链表来实现。通过链表或者数组的栈顶（Top）指针指针对数据进行压栈或者出栈的操作。</p>
</blockquote>
<p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/Stack" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/Stack</a></p>
<h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>Java中的栈主要是用来存放八个基本数据类型的，以及方法调用的上下文。栈是与每一个线程相关联的，JVM在创建每一个线程，都会分配一定的栈空间给线程，主要存放线程执行过程中的局部变量。栈的空间会随着线程的终止而释放。</p>
<p>栈的优势<strong>存取速度要比堆更快，栈数据可以共享</strong>。缺点是<strong>存储在栈中的数据大小与生存期都是确定的，缺乏灵活性</strong>。</p>
<p>Java中的堆是<strong>所有的线程可以共享的一块内存区域</strong>。堆是用来存储各种Java的对象和数组的，是一个运行时数据区。堆是由垃圾回收来负责的，不需要程序代码来显式地释放。</p>
<p>堆的优势是<strong>可以动态地分配内存的大小，生存期也无需事先告知编译器，因为是在运行时动态分配内存的</strong>。Java的垃圾回收器会自动收走这些不再使用的数据。缺点是存取速度较慢，因为运行时要动态分配内存。</p>
<p>除此之外，<strong>静态存储区</strong>是主要存放静态数据、全局<code>static</code>数据和常量的。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。总的来说：<strong>堆和栈针对非静态数据，而方法区针对静态数据</strong>。</p>
<h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul>
<li>堆是一个完全二叉树(除了最后一层，其他层从左到右的节点都是满的)</li>
<li>堆中的节点，都大于等于或小于等于其子节点</li>
<li>堆通常使用数组来存储</li>
</ul>
<p>在这棵树中，<strong>所有父节点都满足大于等于其子节点的堆叫大根堆</strong>，<strong>所有父节点都满足小于等于其子节点的堆叫小根堆</strong>。堆虽然是一颗树，但是通常存放在一个数组中，父节点和孩子节点的父子关系通过数组下标来确定。</p>
<p><strong>添加节点</strong>：</p>
<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/11.png" alt=""></p>
<ul>
<li>将新节点添加到树的末尾，即数组的末尾</li>
<li>再将插入的节点与其父节点做对比，如果父节点大于插入的节点，则交换二者的位置，直到插入的节点比父节点小为止</li>
</ul>
<p><strong>删除根节点</strong>：</p>
<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/12.png" alt=""></p>
<p>删除根节点则是删除后再依次比较其与子节点的大小，直到找到新的父节点</p>
<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote>
<p>队列是一种『先进先出』的线性表，一般可以用链表和数组来实现，只允许在尾部插入，在头部删除。</p>
</blockquote>
<p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/Queue" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/Queue</a></p>
<h2 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h2><blockquote>
<p>栈和队列都是两种操作受限的线性表。</p>
</blockquote>
<p>栈是限制在表的一端进行插入和删除运算的线性表，是「先进后出」的；队列是一种运算受限的线性表，只允许在标的一端进行插入，而在另一端进行删除，是『先进先出』的。</p>
<p><strong>相同点</strong>：</p>
<ul>
<li>都是线性结构的</li>
<li>插入操作都是限定在表尾进行</li>
<li>都可以通过顺序结构和链式结构实现</li>
<li>插入和删除的复杂度都是$O(1)$，空间复杂度也一样</li>
<li>多链栈和多链队列的管理模式相同</li>
</ul>
<p><strong>不同点</strong>：</p>
<ul>
<li>删除数据元素的位置不同：栈的删除操作在表尾进行，队列的删除操作在表头进行</li>
<li>顺序栈能够实现多栈的空间共享，而顺序队列不能</li>
</ul>
<h1 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h1><p>数组和链表的区别：</p>
<p><strong>数组的优点</strong>：</p>
<ul>
<li>随机访问性强，<strong>查找速度快</strong>，时间复杂度为$O(1)$。</li>
</ul>
<p><strong>数组的缺点</strong>：</p>
<ul>
<li>头插和头删的效率低，时间复杂度为$O(N)$</li>
<li>空间利用率不高</li>
<li>内存空间要求高，必须有足够的连续的内存空间</li>
<li>数组空间的大小固定，不能动态拓展</li>
</ul>
<p><strong>链表的优点</strong>：</p>
<ul>
<li>任意位置插入元素和删除元素的速度快，时间复杂度为$O(1)$</li>
<li>内存利用率高，不会浪费内存</li>
<li>链表的空间大小不固定，可以动态拓展</li>
</ul>
<p><strong>链表的缺点</strong>：</p>
<ul>
<li>随机访问效率低，时间复杂度为$O(N)$</li>
</ul>
<hr>
<p>综上，「对于想要快速访问数据，不经常有插入和删除元素的时候，选择数组；对于需要经常的插入和删除元素，而对访问元素时的效率没有很高要求的话，选择链表。」</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote>
<p>数组是由相同元素的集合所组成的数据结构，存储在一块连续的内存单元，根据元素的索引可以计算出该元素对应的存储地址。</p>
</blockquote>
<p><strong>数组的特点</strong>：</p>
<ul>
<li>在内存中，数组是一块连续的区域</li>
<li>数组需要预留空间（在使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即<strong>数组空间利用率低</strong>）</li>
<li>在数组起始位置处，<strong>插入数据</strong>和<strong>删除数据</strong>效率低。<br>  插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移；删除数据时，待删除位置后面的所有元素都需要向前搬移；这导致了<strong>插入数据</strong>和<strong>删除数据</strong>效率较低。</li>
<li>随机访问效率很高，时间复杂度可以达到$O(1)$。<br>  因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址处向后偏移就可以访问到了。这意味着数组的<strong>查找效率</strong>更高。</li>
<li>数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移。</li>
<li>数组的空间是从<strong>栈</strong>分配的。</li>
</ul>
<h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote>
<p>由一串节点组成，每个节点包含任意的实例数据和一个或两个用来指向下一节点或者上一节点位置的链接。</p>
</blockquote>
<p><strong>链表的特点</strong>：</p>
<ul>
<li>在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续</li>
<li>链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址；每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据</li>
<li><strong>查找</strong>数据时效率低,时间复杂度为$O(N)$；因为链表的空间是分散的，所以不具有随机访问性，如要需要访问某个位置的数据，需要从第一个数据开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度达到$O(N)$</li>
<li>空间不需要提前指定大小，是动态申请的，根据需求动态的申请和删除内存空间，扩展方便，故空间的利用率较高</li>
<li>任意位置插入元素和删除元素效率较高，时间复杂度为$O(1)$</li>
<li>链表的空间是从<strong>堆</strong>中分配的</li>
</ul>
<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote>
<p>实现抽象数据类型的数据结构。</p>
</blockquote>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/BinaryTree" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/BinaryTree</a></p>
<p>定义树节点为类：TreeNode。具体实现如下：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left; <span class="comment">// 左子树根节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right; <span class="comment">// 右子树根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>根$\rightarrow$左$\rightarrow$右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DLRTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示结点的数据</span></span><br><span class="line">        treeNodeData(treeNode);</span><br><span class="line">        DLRTree(treeNode.left);</span><br><span class="line">        DLRTree(treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左$\rightarrow$根$\rightarrow$右</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LDRTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示结点的数据</span></span><br><span class="line">        LDRTree(treeNode.left);</span><br><span class="line">        treeNodeData(treeNode);</span><br><span class="line">        LDRTree(treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左$\rightarrow$右$\rightarrow$根</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRDTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示结点的数据</span></span><br><span class="line">        LRDTree(treeNode.left);</span><br><span class="line">        LRDTree(treeNode.right);</span><br><span class="line">        treeNodeData(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>分层遍历二叉树（按层次从上到下，从左到右）迭代，相当于<strong>广度优先搜索</strong>，使用<strong>队列</strong>实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按层遍历算法</span></span><br><span class="line"><span class="comment"> * 首先处理第1层即根结点，再处理第1层根结点的左右子树，即第2层...循环处理，就可以逐层遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> treeNode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    TreeType p;</span><br><span class="line">    <span class="comment">// 定义一个顺序栈</span></span><br><span class="line">    TreeNode[] q = <span class="keyword">new</span> TreeNode[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队首引用不为空</span></span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算循环队列队尾序号</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">        <span class="comment">// 将二叉树根引用进队</span></span><br><span class="line">        q[tail] = treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列不为空，进行循环</span></span><br><span class="line">    <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">        <span class="comment">// 计算循环队列的队首序号</span></span><br><span class="line">        head = (head + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">        <span class="comment">// 获取队首元素</span></span><br><span class="line">        p = q[head];</span><br><span class="line">        <span class="comment">// 处理队首元素，输出显示</span></span><br><span class="line">        treeNodeData(p);</span><br><span class="line">        <span class="comment">// 如果结点存在左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算循环队列的队尾序号</span></span><br><span class="line">            tail = (tail + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">            q[tail] = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果结点存在右子树</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算循环队列的队尾序号</span></span><br><span class="line">            tail = (tail + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">            q[tail] = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>线索化的二叉树就是：在原有的二叉树基础上有些改动，将没有孩子结点的链域声明为线，<strong>左孩子指向前驱，右孩子指向后继节点</strong>。有孩子结点的为链，表示指向原先的左右孩子。</p>
<p>发明线索二叉树的原因是因为，在原先的二叉链表中，查找节点的左、右孩子节点是可以直接实现的，但查找该节点的前驱和后继节点就会变得十分困难。所以，每个节点中可以增加两个指针域来存放遍历时得到的前驱节点和后继节点，这样就可以通过指针来访问。</p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>若二叉树的深度为h，那么除了第h层外，其余各层都达到了最大个数的节点个数，并且第h层（最底层）的所有节点都集中在最左边，这就是完全二叉树。</p>
<p>正是因为二叉树这个性质，所以当它缺少节点时，总是从叶子层（即最底层）的右子树开始缺少节点。</p>
<h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><blockquote>
<p>国内定义：如果一个二叉树的每一层的节点树都达到了最大值，那么这个树就是满二叉树。</p>
<p>国外定义：满二叉树的节点必须满足要么是叶子节点，度为0；要么是度为2的节点，不存在度为1的节点；</p>
</blockquote>
<h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><h2 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一种网状结构，图分为<strong>有向图</strong>和<strong>无向图</strong>。边有方向的称为有向图，边无方向的称为无向图。通常使用<code>G=&lt;V,E&gt;</code>来表示一个图，V表示顶点，E表示边。</p>
<p>图有两种表示方法：邻接表和邻接矩阵。邻接矩阵就是用二维数组来表示，这种情况很容易造成空间浪费，所以进行空间优化后可以选择使用邻接表的方式来表示。</p>
<p>邻接表是数组嵌套链表，会比邻接矩阵节省不少空间，但是对于无向图来说，仍然会浪费一半的空间。</p>
<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>弧</strong>：在有向图中，通常将边称为弧，含箭头的一端成为弧头，另一端称为弧尾，记作$<vi,vj>$，它表示从顶点vi到顶点vj有一条边。边就是弧。</p>
<p><strong>顶点的度</strong>：与它关联的边的数量。</p>
<p><strong>子图</strong>：一张图的一部分。</p>
<p><strong>连通图与非连通图</strong>：连通图是指图内任意两个节点间，都有一条路径能连接它们。否则，就是非连通图。<strong>如果图中有孤立的岛，则说明是非连通图</strong>。</p>
<p><strong>加权图与非加权图</strong>：加权图含有权重，非加权图的节点和边上有没有权重。</p>
<p><strong>非循环图和循环图</strong>：非循环图是指图中不存在循环路径（起点和终点是同一个顶点），反之循环图则是包含循环路径。有向图和无向图都可能包含循环。</p>
<p><strong>树与图的关系</strong>：树是一个无向连通图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p>
<h2 id="广度优先遍历和深度优先遍历"><a href="#广度优先遍历和深度优先遍历" class="headerlink" title="广度优先遍历和深度优先遍历"></a>广度优先遍历和深度优先遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="Dijikstra算法——最短路径问题"><a href="#Dijikstra算法——最短路径问题" class="headerlink" title="Dijikstra算法——最短路径问题"></a>Dijikstra算法——最短路径问题</h2><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/Sort" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/Sort</a></p>
<p>常见的<strong>稳定排序算法</strong>有：</p>
<ul>
<li>冒泡排序（Bubble Sort） — $O(n^2)$</li>
<li>插入排序（Insertion Sort）— $O(n^2)$</li>
<li>桶排序（Bucket Sort）— $O(n)$; 需要$O(k)$额外空间</li>
<li>计数排序 (Counting Sort) — $O(n+k)$; 需要$O(n+k)$额外空间</li>
<li>归并排序（Merge Sort）— $O(nlogn)$; 需要$O(n)$额外空间</li>
<li>二叉排序树排序 （Binary tree sort） — $O(nlogn)$ 期望时间; $O(n^2)$最坏时间; 需要$O(n)$额外空间</li>
<li>基数排序（Radix sort）— $O(n·k)$; 需要 $O(n)$额外空间</li>
</ul>
<p>常见的<strong>不稳定排序算法</strong>有：</p>
<ul>
<li>选择排序（Selection Sort）— $O(n^2)$</li>
<li>希尔排序（Shell Sort）— $O(nlogn)$</li>
<li>堆排序（Heapsort）— $O(nlogn)$</li>
<li>快速排序（Quicksort）— $O(nlogn)$ 期望时间, $O(n^2)$ 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序</li>
</ul>
<h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是最简单的也是最基础的排序之一。其大体思想就是通过与<strong>相邻元素</strong>的比较和交换来把较小的树都排到前面。</p>
<p>比如，一个无序序列5,3,8,6,4。首先从前向后冒泡，5和3比较，把3交换到前面，序变成3,5,8,6,4。5和8无需交换。同理8和6交换，变成3,5,6,8,4。8和4交换，变成3,5,6,4,8。这样一次冒泡就完了，把最大的数8排到最后面了。对剩下的序列<strong>依次冒泡</strong>就会得到一个有序序列。</p>
<script type="math/tex; mode=display">
5,3,8,6,4\\
\downarrow\\
3,5,8,6,4\\
\downarrow\\
3,5,6,8,4\\
\downarrow\\
3,5,6,4,8\\
\downarrow\\
3,5,4,6,8\\
\downarrow\\
3,4,5,6,8\\</script><p>冒泡排序的时间复杂度为：$O(n^2)$。</p>
<h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过<strong>相邻的比较和交换</strong>。而选择排序是通过<strong>对整体的选择</strong>。</p>
<p>举个例子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4。对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。</p>
<script type="math/tex; mode=display">
5,3,8,6,4\\
\downarrow\\
3,5,8,6,4\\
\downarrow\\
3,4,8,6,5\\
\downarrow\\
3,4,5,6,8</script><p>选择排序的时间复杂度为：$O(n^2)$。</p>
<h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经<strong>有序</strong>。</p>
<script type="math/tex; mode=display">
5,3,8,6,4\\
\downarrow\\
3,5,8,6,4\\
\downarrow\\
3,5,6,8,4\\
\downarrow\\
3,4,6,8,5\\
\downarrow\\
3,4,5,8,6\\
\downarrow\\
3,4,5,6,8</script><p>简单插入排序的时间复杂度为：$O(n^2)$。</p>
<h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>比如5,3,8,6,4的无序序列，以5作为基准（<strong>单独拎出来放在顶上</strong>）。思路是右指针找比基准数小的，左指针找比基准数大的，交换之。5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</p>
<script type="math/tex; mode=display">
5,3,8,6,4\\
\downarrow\\
4,3,8,6,5\\
\downarrow\\
3,4,5,6,8\\</script><p>快速排序是不稳定的，其时间平均时间复杂度是：$O(nlogn)$。</p>
<h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找也称为线性查找，属于无序查找算法。它是最简单的查找策略，对于小规模的数据，顺序查找是一个不错的选择。</p>
<p><strong>基本思想</strong>是从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。</p>
<ol>
<li>从表中的第一个元素开始，依次与关键字进行比较；</li>
<li>若某个元素匹配关键字，则查找成功；</li>
<li>若查找到最后一个元素还未匹配关键字，则查找失败；</li>
</ol>
<p><strong>时间复杂度</strong>：顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为$O(n)$。</p>
<p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/blob/master/Search/src/SequentialSearch.java" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/blob/master/Search/src/SequentialSearch.java</a></p>
<h2 id="有序查找"><a href="#有序查找" class="headerlink" title="有序查找"></a>有序查找</h2><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找（binary search）也称为折半查找（half-interval search），属于有序查找算法，是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。元素必须是有序的，如果是无序的则要限进行排序操作。</p>
<p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程就结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且同样是从中间元素开始查找（递归）。这样每一次比较都会使搜索范围缩小一半。</p>
<p><strong>时间复杂度</strong>：因为正常情况下每次查找的元素都在一半一半地减少，所以二分查找的时间复杂度是$log_2(n)$</p>
<p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/blob/master/Search/src/BinarySearch.java" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/blob/master/Search/src/BinarySearch.java</a></p>
<h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>其实二分查找就是折半，那么为什么不能折四分之一或者其它数字呢？</p>
<p>即二分查找的查找点计算为$mid=(low+high)/2$，那么通过类比，可以将查找的点改进为：</p>
<p><script type="math/tex">mid=low+(key-a[low])/(a[high]-a[low])*(high-low)</script></p>
<p><strong>基本思想</strong>就是基于二分查找的改进，将折半改为自适应，可以提高查找效率。但插值查找的前提也必须是已经有序排列。</p>
<p>代码位于：</p>
<h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BinarySearch Tree）也叫二叉搜索树，也可以叫二叉排序树（BinarySort Tree），是具有以下性质的二叉树：</p>
<ol>
<li>若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；</li>
<li>若任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值；</li>
<li>任意节点的左、右子树也分别为二叉查找树；</li>
</ol>
<p>即 右 &gt; 根 &gt; 左，同时对二叉查找树进行<strong>中序遍历</strong>，即可得到有序的数列。</p>
<p>使用二叉查找树的思路是：</p>
<ul>
<li>如果相等，即查找成功；</li>
<li>如果比较结果为根节点的关键字值较大（大了），则说明可能在左子树中；</li>
<li>如果比较结果为根节点的关键字值较小（小了），则说明可能在右子树中；</li>
</ul>
<h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树是对二叉查找树的一种改进。二叉查找树有一个明显的缺点就是树的结构仍然具有极大的变动性，最坏的情况下就是一颗单支二叉树，丢失了二叉查找树的一些原有的优点。</p>
<p><strong>平衡二叉树（AVL）</strong>：它可以是一颗空树，也可以是具有以下性质的二叉查找树：</p>
<blockquote>
<p>它的节点左子树和右子树的深度之差不超过1，而且该节点的左子树和右子树都是一颗平衡二叉树（即同样满足这个性质）。</p>
</blockquote>
<p><strong>平衡因子</strong>：节点左子树的深度 - 节点右子树的深度。值可以为0、-1、1。</p>
<h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>红黑树是一种特殊二叉查找树。红黑树上的每个节点都有存储位以表示节点的颜色，可以是红色也可以是黑色。</p>
<p>其特点有：</p>
<ul>
<li>每个节点都是黑色或者红色</li>
<li>根节点是黑色</li>
<li>每个叶子节点都是黑色（叶子节点是指为空（NIL或者NULL）的节点）</li>
<li>如果一个节点是红色的，其子节点就是黑色的</li>
<li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li>
</ul>
<p>因为特性5，所以红黑树是一个相对接近平衡的二叉树。</p>
<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/14.jpg" alt=""></p>
<h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>红黑树主要用来存储有序的数据，它的时间复杂度是$O(lg_n)$。</p>
<p>Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p>
<h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><p>也称为多路查找树。</p>
<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</p>
<h2 id="动态规划与分治法的区别"><a href="#动态规划与分治法的区别" class="headerlink" title="动态规划与分治法的区别"></a>动态规划与分治法的区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>二者都是要求原问题具有最优子结构的特征，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，形成原问题的解。</p>
<h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul>
<li><strong>分治法</strong>常常利用<strong>递归</strong>来实现。</li>
<li><strong>动态规划</strong>通常利用迭代法自底向上求解，但也可使用具有记忆功能的递归法自顶向下求解。</li>
</ul>
<h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul>
<li>分治法将分解后的子问题看成是相互独立的；</li>
<li>动态规划将分解后的子问题理解为相互间是有联系的，有重叠部分的。</li>
</ul>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Hurley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hurleyjames.github.io/2020/06/06/Interview-Review(DataStructure)/">https://hurleyjames.github.io/2020/06/06/Interview-Review(DataStructure)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hurleyjames.github.io" target="_blank">Hurley</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/../image/single-number.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/images/wechat.JPG" alt="wechat" onclick="window.open('/images/wechat.JPG')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/images/alipay.JPG" alt="alipay" onclick="window.open('/images/alipay.JPG')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/06/Interview-Review(OS)/"><img class="prev-cover" data-src="/../image/os-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Interview-Review(OS)</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/06/Interview-Review(Database)/"><img class="next-cover" data-src="/../image/database-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Interview-Review(Database)</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/../image/data-structure-interview.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Hurley</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">随时意气风发，独自声势浩大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>