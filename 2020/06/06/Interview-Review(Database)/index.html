<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Interview-Review(Database) | Hurley</title><meta name="description" content="本篇主要是面试复习内容的数据库部分。  数据库类型非关系型数据库（NoSQL） mongoDB Hbase Neo4j redis CouchDB  关系型数据库 SQLite SQL Server MySQL ORACLE PostgreSQL Microsoft Access Teradata SAP  存储过程存储过程就像编程语言中的函数一样，封装了代码（PLSQL、T-SQL）。 优点："><meta name="keywords" content="面试"><meta name="author" content="Hurley"><meta name="copyright" content="Hurley"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/icon.png"><link rel="canonical" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Database)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Interview-Review(Database)"><meta property="og:url" content="https://hurleyjames.github.io/2020/06/06/Interview-Review(Database)/"><meta property="og:site_name" content="Hurley"><meta property="og:description" content="本篇主要是面试复习内容的数据库部分。  数据库类型非关系型数据库（NoSQL） mongoDB Hbase Neo4j redis CouchDB  关系型数据库 SQLite SQL Server MySQL ORACLE PostgreSQL Microsoft Access Teradata SAP  存储过程存储过程就像编程语言中的函数一样，封装了代码（PLSQL、T-SQL）。 优点："><meta property="og:image" content="https://hurleyjames.github.io/../image/database-interview.png"><meta property="article:published_time" content="2020-06-05T16:00:00.000Z"><meta property="article:modified_time" content="2020-12-23T05:08:50.982Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="prev" title="Interview-Review(Network)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Network)/"><link rel="next" title="Interview-Review(Java)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/26319720?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">71</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库类型"><span class="toc-number">1.</span> <span class="toc-text">数据库类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#非关系型数据库（NoSQL）"><span class="toc-number">1.1.</span> <span class="toc-text">非关系型数据库（NoSQL）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关系型数据库"><span class="toc-number">1.2.</span> <span class="toc-text">关系型数据库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#存储过程"><span class="toc-number">2.</span> <span class="toc-text">存储过程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#优点："><span class="toc-number">2.1.</span> <span class="toc-text">优点：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#缺点："><span class="toc-number">2.2.</span> <span class="toc-text">缺点：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#触发器"><span class="toc-number">3.</span> <span class="toc-text">触发器</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">3.1.</span> <span class="toc-text">作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语句"><span class="toc-number">3.2.</span> <span class="toc-text">语句</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#三个范式"><span class="toc-number">4.</span> <span class="toc-text">三个范式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#第一范式1NF"><span class="toc-number">4.1.</span> <span class="toc-text">第一范式1NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第二范式2NF"><span class="toc-number">4.2.</span> <span class="toc-text">第二范式2NF</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#第三范式3NF"><span class="toc-number">4.3.</span> <span class="toc-text">第三范式3NF</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#视图"><span class="toc-number">5.</span> <span class="toc-text">视图</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#表和视图的区别"><span class="toc-number">5.1.</span> <span class="toc-text">表和视图的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL语句种类"><span class="toc-number">6.</span> <span class="toc-text">SQL语句种类</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#DEOP、DELETE和TRUNCATE的区别"><span class="toc-number">6.1.</span> <span class="toc-text">DEOP、DELETE和TRUNCATE的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引"><span class="toc-number">7.</span> <span class="toc-text">索引</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#特点"><span class="toc-number">7.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点"><span class="toc-number">7.2.</span> <span class="toc-text">优缺点</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#优点"><span class="toc-number">7.2.1.</span> <span class="toc-text">优点</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#缺点"><span class="toc-number">7.2.2.</span> <span class="toc-text">缺点</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#语法"><span class="toc-number">7.3.</span> <span class="toc-text">语法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#创建索引"><span class="toc-number">7.3.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#删除索引"><span class="toc-number">7.3.2.</span> <span class="toc-text">删除索引</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#场景"><span class="toc-number">7.4.</span> <span class="toc-text">场景</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建索引的注意事项"><span class="toc-number">7.5.</span> <span class="toc-text">创建索引的注意事项</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#事务"><span class="toc-number">8.</span> <span class="toc-text">事务</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#四个特性"><span class="toc-number">8.1.</span> <span class="toc-text">四个特性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#原子性（Atomicity）"><span class="toc-number">8.1.1.</span> <span class="toc-text">原子性（Atomicity）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#一致性（Consistency）"><span class="toc-number">8.1.2.</span> <span class="toc-text">一致性（Consistency）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#隔离性（Isolation）"><span class="toc-number">8.1.3.</span> <span class="toc-text">隔离性（Isolation）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#持久性（Durability）"><span class="toc-number">8.1.4.</span> <span class="toc-text">持久性（Durability）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#事务隔离级别"><span class="toc-number">8.2.</span> <span class="toc-text">事务隔离级别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#隔离级别与锁的关系"><span class="toc-number">8.2.1.</span> <span class="toc-text">隔离级别与锁的关系</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#脏读"><span class="toc-number">8.2.2.</span> <span class="toc-text">脏读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可重复读"><span class="toc-number">8.2.3.</span> <span class="toc-text">不可重复读</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#幻读（虚读）"><span class="toc-number">8.2.4.</span> <span class="toc-text">幻读（虚读）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">8.2.5.</span> <span class="toc-text">总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库的乐观锁和悲观锁"><span class="toc-number">9.</span> <span class="toc-text">数据库的乐观锁和悲观锁</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#超键、候选键、主键、外键"><span class="toc-number">10.</span> <span class="toc-text">超键、候选键、主键、外键</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL约束"><span class="toc-number">11.</span> <span class="toc-text">SQL约束</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#内连接、外连接、全连接"><span class="toc-number">12.</span> <span class="toc-text">内连接、外连接、全连接</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#内连接"><span class="toc-number">12.1.</span> <span class="toc-text">内连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#左外连接"><span class="toc-number">12.2.</span> <span class="toc-text">左外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#右外连接"><span class="toc-number">12.3.</span> <span class="toc-text">右外连接</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#全连接"><span class="toc-number">12.4.</span> <span class="toc-text">全连接</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#分片、分区、分表、分库"><span class="toc-number">13.</span> <span class="toc-text">分片、分区、分表、分库</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分片"><span class="toc-number">13.1.</span> <span class="toc-text">分片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分区"><span class="toc-number">13.2.</span> <span class="toc-text">分区</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#水平分区"><span class="toc-number">13.2.1.</span> <span class="toc-text">水平分区</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#垂直分区"><span class="toc-number">13.2.2.</span> <span class="toc-text">垂直分区</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分表"><span class="toc-number">13.3.</span> <span class="toc-text">分表</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#分库"><span class="toc-number">13.4.</span> <span class="toc-text">分库</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#游标"><span class="toc-number">14.</span> <span class="toc-text">游标</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#常用SQL语句"><span class="toc-number">15.</span> <span class="toc-text">常用SQL语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ORM"><span class="toc-number">16.</span> <span class="toc-text">ORM</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#数据库连接池"><span class="toc-number">17.</span> <span class="toc-text">数据库连接池</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#B树和B-树"><span class="toc-number">18.</span> <span class="toc-text">B树和B+树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#区别"><span class="toc-number">18.1.</span> <span class="toc-text">区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B树的好处"><span class="toc-number">18.2.</span> <span class="toc-text">B树的好处</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#B-树的好处"><span class="toc-number">18.3.</span> <span class="toc-text">B+树的好处</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#MySQL"><span class="toc-number">19.</span> <span class="toc-text">MySQL</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#数据库引擎"><span class="toc-number">19.1.</span> <span class="toc-text">数据库引擎</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#数据类型"><span class="toc-number">19.2.</span> <span class="toc-text">数据类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#有关权限的表"><span class="toc-number">19.3.</span> <span class="toc-text">有关权限的表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#SQL优化"><span class="toc-number">20.</span> <span class="toc-text">SQL优化</span></a></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/../image/database-interview.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hurley</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Interview-Review(Database)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-06 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-12-23 13:08:50"><i class="fas fa-history fa-fw"></i> 更新于 2020-12-23</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">8.9k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 27 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本篇主要是面试复习内容的数据库部分。</p>
<a id="more"></a>
<h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><h3 id="非关系型数据库（NoSQL）"><a href="#非关系型数据库（NoSQL）" class="headerlink" title="非关系型数据库（NoSQL）"></a>非关系型数据库（NoSQL）</h3><ul>
<li>mongoDB</li>
<li>Hbase</li>
<li>Neo4j</li>
<li>redis</li>
<li>CouchDB</li>
</ul>
<h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul>
<li>SQLite</li>
<li>SQL Server</li>
<li>MySQL</li>
<li>ORACLE</li>
<li>PostgreSQL</li>
<li>Microsoft Access</li>
<li>Teradata</li>
<li>SAP</li>
</ul>
<h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程就像编程语言中的函数一样，封装了代码（PLSQL、T-SQL）。</p>
<h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul>
<li>能够将代码封装起来</li>
<li>保存在数据库之中</li>
<li>让编程语言进行调用</li>
<li>存储过程是一个预编译的代码块，执行效率比较高</li>
<li>一个存储过程替代大量T_SQL语句，可以降低网络通信量，提高通信速率</li>
</ul>
<h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul>
<li>每个数据库的存储过程几乎都是不一样的，十分难以维护</li>
<li>业务逻辑放在数据库上，比较难迭代</li>
</ul>
<h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>触发器是一种特殊的存储过程，主要是<strong>通过「事件」来触发而被执行的</strong>。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。<strong>触发器不能由用户显示调用</strong>，而是只有当出发时间发生并且被捕捉到后，才会被触发。</p>
<h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event <span class="keyword">on</span> tbl_name</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line">trigger_stmt</span><br></pre></td></tr></table></figure>
<ul>
<li><code>trigger_name</code>：标识触发器名称，由用户自定义</li>
<li><code>trigger_time</code>：标识触发器的时机，取值可以是<code>before</code>和<code>after</code></li>
<li><code>tbl_name</code>：标识建立触发器的表名，即在哪张表上建立触发器</li>
<li><code>trigger_stmt</code>：触发器的程序体，可以是一句SQL语句或者用<code>begin</code>和<code>end</code>包含的多条SQL语句，即触发后会执行的操作</li>
</ul>
<p>可以建立6种触发器：<code>before insert</code>、<code>before update</code>、<code>before delete</code>、<code>after insert</code>、<code>after update</code>、<code>after delete</code>。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查看触发器</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.<span class="string">`triggers`</span>;</span><br><span class="line">// 或者（[]代表可省略）</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span> [<span class="keyword">from</span> schema_name];</span><br><span class="line"></span><br><span class="line">// 删除触发器</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> trigger_name;</span><br></pre></td></tr></table></figure>
<p><code>schema_name</code>在这里指数据库名称，<code>trigger_name</code>是触发器名称。</p>
<h2 id="三个范式"><a href="#三个范式" class="headerlink" title="三个范式"></a>三个范式</h2><h3 id="第一范式1NF"><a href="#第一范式1NF" class="headerlink" title="第一范式1NF"></a>第一范式1NF</h3><blockquote>
<p><strong>字段是最小的单元不可再分</strong>。</p>
</blockquote>
<p>例如，学生信息组成了学生信息表，由年龄、性别、学号、名字等组成。这些字段都是不可再分的，所以就是满足第一范式的。</p>
<p>即<strong>第一范式就是无重复的列</strong>。</p>
<h3 id="第二范式2NF"><a href="#第二范式2NF" class="headerlink" title="第二范式2NF"></a>第二范式2NF</h3><blockquote>
<p>第二范式首先是满足第一范式的，然后表中的字段必须完全依赖于全部的主键而非部分的主键。</p>
</blockquote>
<p>即其它字段组成的记录和这个主键表示的都是同一个东西，而主键是唯一的，它们这些字段都只需要依赖于这个主键。</p>
<p>比如，一个学号为1的学生，他年龄23，女，姓名X。在这行记录中，学号就是这个学生的主键，年龄、性别、姓名等其它字段都是依赖于学号这个主键的。</p>
<p>即<strong>第二范式就是非主属性都全部依赖于主关键字</strong>。</p>
<h3 id="第三范式3NF"><a href="#第三范式3NF" class="headerlink" title="第三范式3NF"></a>第三范式3NF</h3><blockquote>
<p>第三范式是满足第二范式的，非主键外的所有字段必须互不依赖。</p>
</blockquote>
<p>即数据只会在一个存储，不会重复地出现在多张表中，这样就消除了传递依赖。</p>
<p>比如，大学里有很多不同的学院（计算机学院、软件学院、商学院等）。那个学院信息列表可以由以下字段组成：学院编号，院长，学院名称，学院介绍等。在这个记录中，学院编号就是学院这张表的主键。那么学生信息表中，就不能再添加学院编号，院长，学院简介等属性，否则就重复。就会发生<strong>非主键外的字段形成了依赖关系</strong>，也就是学院表中的一些非主键的属性和学生表有依赖关系了。这是不行的，正确的做法是：学生表中只能增加一个学院表的主键，即学院编号字段。</p>
<p>即<strong>属性是不依赖于其他非主属性的</strong>。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote>
<p>视图是一种基于数据表的虚表。</p>
</blockquote>
<ul>
<li>视图是一张虚表</li>
<li>视图建立在已有表的基础之上，视图赖以建立的这些表就叫做基表</li>
<li><strong>向视图提供数据内容的语句为<code>SELECT</code>语句，可以将视图理解为存储起来的SELECT语句</strong></li>
<li>视图向用户提供基表数据的另一钟表现形式</li>
<li>视图没有存储真正的数据，真正的数据是存储在基表中</li>
<li>我们可以操作视图，但是操作视图最终还是会转化成操作基表</li>
<li>一个基表可以有0个或者多个视图</li>
</ul>
<p>因为在查询时会编写很长的SQL语句，而视图是基于查询的一种虚表，视图可以将查询出来的数据进行封装，在使用时就会非常方便。</p>
<p>使用视图可以专注逻辑，但不会提高查询的效率。</p>
<p>视图是永远不会自动消失的，除非手动删除它。</p>
<h3 id="表和视图的区别"><a href="#表和视图的区别" class="headerlink" title="表和视图的区别"></a>表和视图的区别</h3><ol>
<li>视图是已经编译好的SQL语句，而表不是</li>
<li>视图没有实际的物理内容，表有</li>
<li>表是内容，视图是窗口</li>
<li>表占用物理空间，视图不占用物理空间，只是逻辑概念的存在，表可以及时对它进行修改，但视图只能由创建的语句来修改</li>
<li>表是内模式，视图是外模式</li>
<li>从安全的角度来说，视图可以不给用户接触到数据表，从而不知道表的结构</li>
<li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表</li>
<li>视图的建立和删除只会影响视图本身，不会影响对应的表</li>
<li>可以用<code>update</code>、<code>insert</code>、<code>delete</code>等SQL语句修改表中的数据，但是对于视图只能进行<code>select</code>操作</li>
</ol>
<h2 id="SQL语句种类"><a href="#SQL语句种类" class="headerlink" title="SQL语句种类"></a>SQL语句种类</h2><ul>
<li>DDL(Data Definition Language)：数据定义语言，定义对数据库对象（库、表、列、索引）的操作，比如有<code>create</code>、<code>drop</code>、<code>alter</code>、<code>rename</code>、<code>truncate</code>等命令；</li>
<li>DML(Data Manipulation Language)：数据操作语言，定义对数据库记录的操作，代表指令有<code>insert</code>、<code>delete</code>、<code>update</code>、<code>select</code>等命令；</li>
<li>DCL(Data Control Language)：数据控制语言，定义对数据库、表、字段、用户的访问权限和安全级别。代表指令有<code>grant</code>、<code>revoke</code>、<code>commit</code>、<code>rollback</code>、<code>savepoint</code>等命令。</li>
</ul>
<h3 id="DEOP、DELETE和TRUNCATE的区别"><a href="#DEOP、DELETE和TRUNCATE的区别" class="headerlink" title="DEOP、DELETE和TRUNCATE的区别"></a>DEOP、DELETE和TRUNCATE的区别</h3><p><code>drop table</code>：</p>
<ol>
<li>属于DDL</li>
<li>不可回滚</li>
<li>不可以接<code>where</code></li>
<li>表的内容和结构都被删除</li>
<li>删除的速度快</li>
</ol>
<p><code>truncate table</code>：</p>
<ol>
<li>属于DDL</li>
<li>不可回滚</li>
<li>不可以接<code>where</code></li>
<li>只删除表的内容</li>
<li>删除的速度快</li>
</ol>
<p><code>delete from</code>：</p>
<ol>
<li>属于DML</li>
<li>可以回滚</li>
<li>可以接<code>where</code></li>
<li>表的结构还在，表的内容是否在要取决于<code>where</code>执行的情况</li>
<li>删除的速度慢，需要逐行删除</li>
</ol>
<p><strong>使用场景</strong>：</p>
<ul>
<li>当不再需要一张表的时候，就用<code>drop</code>命令</li>
<li>只想删除表中部分数据行时，用<code>delete</code>命令，并且需要带上<code>where</code>子句</li>
<li>保留表的结构但是删除所有的数据要用<code>truncate</code>命令</li>
</ul>
<h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote>
<p>索引（index）是一种快速查询表中内容的机制，类似于字典的目录。它运用在表中的某些字段上，但存储时，独立于表之外。它是用于提高数据库表数据访问速度的数据库对象。</p>
<p>数据库索引，是数据库管理系统中一个排序的数据结构，以协助快速查询、庚戌年数据库表中的数据。</p>
<p>索引的实现通常使用B树及其变种B+树。</p>
</blockquote>
<ul>
<li>索引可以避免全盘扫描。多数查询可以仅扫描少量索引页及数据页，而不是遍历所有数据页。</li>
<li>对于非聚集索引，有些查询甚至不用访问数据页。</li>
<li>对于聚集索引，可以避免数据插入操作集中于表的最后一个数据页。</li>
<li>在某些情况下，查询甚至可以不用访问数据页。</li>
</ul>
<p><strong>分类</strong>：</p>
<ul>
<li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li>
<li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引会要求主键中的每个值都是唯一的，并且不能为空</li>
<li><strong>聚集索引</strong>（Clustered）：表中各行的物理顺序与键值的逻辑（索引）的顺序是相同的，每个表中只能有一个</li>
<li><strong>非聚集索引</strong>（Non-Clustered）：非聚集索引指定了表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，而索引中包含了指向数据存储位置的指针。数量可以有多个，但是要小于249个</li>
</ul>
<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul>
<li>索引一旦建立，Oracle系统会对其自动维护，而且由Oracle系统决定何时使用索引</li>
<li>用户不用在查询语句中指定要使用哪个索引</li>
<li><strong>在定义了<code>primary key</code>或者<code>unique</code>约束后，系统会自动在相应的列上创建索引</strong></li>
<li>用户可以根据自己需求，对指定的单个字段或者多个字段，添加索引</li>
</ul>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><ul>
<li>通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性</li>
<li>可以大大加快数据的检索速度（创建索引的最主要原因）</li>
<li>可以加速表和表之间的连接，特别是实现数据的参考完整性方面特别有意义</li>
<li>在使用分组和排序子句进行数据检索时，同样可以显著减少查询中分组和排序的时间</li>
<li>通过使用索引，可以在查询的过程中，使用优化隐藏器，提高系统的性能</li>
</ul>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><ul>
<li>创建索引和维护索引需要耗费时间，这种时间随着数据量的增加而增加</li>
<li>索引需要占用物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空间，如果建立的是聚集索引，那么需要的空间会更大</li>
<li>当对表中的数据进行增加、删除和修改的时候，索引也要动态地维护，相当于降低了数据的维护速度</li>
</ul>
<h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name (column_list);</span><br><span class="line">// 唯一索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> (column_list);</span><br><span class="line">// 主键索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span> (column_list);</span><br></pre></td></tr></table></figure>
<p>创建索引的方式包括普通索引、<code>unique</code>索引和<code>primary key</code>索引，<code>table_name</code>是要增加索引的表名，<code>column_list</code>是指出对哪些列要进行索引，如果是多列时，各列之间用逗号分隔。索引名<code>index_name</code>是可选的，如果缺醒，MySQL会根据第一个索引列赋一个名称。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (column_list);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (column_list);</span><br></pre></td></tr></table></figure>
<p>这同样是一种创建索引的方法，与<code>alter</code>语句具有相同的含义，索引名是不可选的。除此之外，<strong>不能用<code>create index</code>语句创建<code>primary key</code>索引</strong>。</p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure>
<p>在前两句中，是使用不同的命令删除了<code>table_name</code>中的索引<code>index_name</code>，而最后一句则是删除<code>primary key</code>的索引中才会使用。如果没有创建<code>primary key</code>索引，但是表具有一个或多个<code>unique</code>索引，就删除第一个<code>unique</code>索引。</p>
<h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><strong>需要创建索引的场景</strong>：</p>
<ul>
<li>表经常要进行<code>select</code>操作</li>
<li>表很大（很多记录），记录的内容分布范围也很广</li>
<li>列名经常在<code>where</code>子句或者连接条件中出现</li>
</ul>
<p><strong>不需要创建索引的场景</strong>：</p>
<ul>
<li>表经常要进行<code>insert</code>、<code>update</code>或<code>delete</code>操作</li>
<li>表很小，记录很少</li>
<li>列名不经常在<code>where</code>子句或者连接条件中出现</li>
</ul>
<h3 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h3><ul>
<li>非空字段：</li>
<li>取值离散大的字段：</li>
<li>索引字段越小越好：</li>
</ul>
<h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote>
<p>数据库事务（transaction）是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p>
</blockquote>
<h3 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>原子性是指<strong>事务中一个不可再分割的工作单元，事务中的操作要么全部执行，要么全部不执行</strong>。要么全部提交成功，要么全部失败回滚。即对于一个事务来说，不能只执行其中的一部分操作。</p>
<h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>一致性是指<strong>在事务开始之前和事务结束之后，数据库的完整性约束都没有遭到破坏</strong>。数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p>
<p>比如A给B转账，不论转账是否成功，A和B两人的存款总额是不会发生变化的。</p>
<h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p><strong>当多个事务同时并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行结果</strong>。</p>
<h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p><strong>该事务对数据库所做的更改持久地保存在数据库之中，并不会发生回滚</strong>。即完成的事务是永久的部分，对系统的影响是永久存在的。</p>
<h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库定义了四个隔离级别：</p>
<ul>
<li>Serializable（序列化）：Serializable是最高的事务隔离级别，花销也最高，性能很低，一般很少使用。在该级别下，事务顺序执行，可以避免脏读、不可重复读和幻读。</li>
<li>Repeatable read（重复读）：可以避免不可重复读，但有可能出现脏读和幻读。例如，只要事务开始，就不能再对该记录进行修改，所以会发生不可重复读。（MySQL默认隔离级别就是Repeatable read）</li>
<li>Read committed（读提交）：避免了脏读，但是有可能会发生不可重复读和幻读。（SQL Server和Oracle的默认级别就是Read committed）。</li>
<li>Read uncommitted（读未提交）：脏读、不可重复读和幻读都可能发生。</li>
</ul>
<p>分别对应<code>Connection</code>类中的四个常量：</p>
<ul>
<li><code>TRANSACTION_SERIALIZABLE</code></li>
<li><code>TRANSACTION_REPEATABLE_READ</code></li>
<li><code>TRANSACTION_READ_COMMITTED</code></li>
<li><code>TRANSACTION_READ_UNCOMMITTED</code></li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Serializable</td>
<td style="text-align:center">❎</td>
<td style="text-align:center">❎</td>
<td style="text-align:center">❎</td>
</tr>
<tr>
<td style="text-align:center">Repeatable read</td>
<td style="text-align:center">❎</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">Read committed</td>
<td style="text-align:center">❎</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
<tr>
<td style="text-align:center">Read uncommitted</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
<td style="text-align:center">✅</td>
</tr>
</tbody>
</table>
</div>
<center>✅：可能出现❎：不会出现</center>

<h4 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h4><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><blockquote>
<p>一个事务读取到另外一个事务未提交的数据。</p>
</blockquote>
<p>比如，A向B转账，A已经执行了转账语句，但是A还没有提交事务，这时候B读取数据时发现自己账户余额已经变多了。如果B通知A已经收到钱后，A又执行回滚事务（rollback），那么B再查看账户就会发现余额没有变多。</p>
<h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><blockquote>
<p>一个事务读取到另外一个事务已经提交的数据，即一个事务可以看到其它事务所做的修改。</p>
</blockquote>
<p>例如，A查询数据库，而B修改了数据库的数据，这就会导致A多次查询数据库的结果都不一样。这就发生了在一个事务内多次读到的数据是不一样的，就称为不可重复读。</p>
<h4 id="幻读（虚读）"><a href="#幻读（虚读）" class="headerlink" title="幻读（虚读）"></a>幻读（虚读）</h4><blockquote>
<p>一个事务读取到了别的事务插入的数据，导致前后读取不一致。</p>
</blockquote>
<p>例如，事务A对一个表中的所有数据都进行了修改，同时，事务B向这个表插入了一行新的数据，那么操作事务A的用户就发现有一行新的数据没有修改到，前后读取不一致，仿佛产生了幻觉，叫做幻读（虚读）。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>脏读是不可容忍的，不可重复读和幻读在一定情况下是可以的。</p>
<h2 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h2><p><strong>乐观锁和悲观锁是并发控制主要采用的技术手段</strong>。</p>
<ul>
<li>悲观锁：假如会发生并发冲突，就屏蔽一切可能会违反数据完整性的操作<ul>
<li><strong>在查询完数据后就把事务锁起来，直到提交事务</strong></li>
<li>实现方式：使用数据库中的锁机制</li>
</ul>
</li>
<li>乐观锁：假如不会发送并发冲突，只在提交操作时检查是否会违反数据完整性<ul>
<li><strong>在修改数据的时候把事务锁起来，通过<code>version</code>的方式来进行锁定</strong></li>
<li>实现方式：使用<code>version</code>版本或者时间戳</li>
</ul>
</li>
</ul>
<h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><ul>
<li>超键（super key）：在关系中能唯一标识元组的属性集称为关系模式的超键。</li>
<li>候选键（candidate key）：不含有多余属性的超键叫做候选键，即最小的超键，没有冗余元素</li>
<li>主键（primary key）：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合叫做主键。一个数据列只能有一个主键，且主键的取值不能为空</li>
<li>外键（foreign key）：在一个表中，存在另一个表的主键，就叫做这个表的外键</li>
</ul>
<p>假如有以下两个表：</p>
<p>学生表（学号，身份证号，姓名，性别，老师编号）；老师表（老师编号，姓名，性别）。</p>
<p><strong>超键</strong>：因为超键的定义是关系中能够唯一标识的属性，所以对于学生表来说，<strong>学号</strong>和<strong>身份证号</strong>是可以表示学生的（都是唯一的），所以超键就是含有<strong>学号</strong>和<strong>身份证号</strong>的任意组合。比如：<code>(学号)</code>、<code>(学号，姓名)</code>、<code>(身份证号，性别)</code>等等。</p>
<p><strong>候选键</strong>：候选键属于超键，是最小的超键，所以对于学生表而言的候选键为：<strong>学号</strong>和<strong>身份证号</strong>。</p>
<p><strong>主键</strong>：主键就是候选键中的一个（当然有时候选键只有一个），是人为规定的。例如，我们通常设置学号为主键。</p>
<p><strong>外键</strong>：外键就是两个表之间的连接。例如，在学生表中有一个字段是老师编号，而老师编号又是老师表中的主键，那么老师编号这个字段就是学生表中的外键。</p>
<h2 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h2><ul>
<li>空值约束<code>not null</code>：用于控制字段内容一定不为空</li>
<li>唯一约束<code>unique</code>：控制字段不能重复，一个表中可以多个<code>unique</code>约束</li>
<li>主键约束<code>primary key</code>：用于控制字段内容不能重复，但是每个表中只能出现一个</li>
<li>外键约束<code>foreign key</code>：用于与另一张表相关联，是能确认另一张表记录的字段，用于保持数据的一致性</li>
<li>检查约束<code>check</code>：用于控制字段的值范围</li>
<li>默认值约束<code>default</code>：用于向列中插入默认值。如果没有规定其它的值，那么会将默认值添加到所有的新纪录</li>
</ul>
<h2 id="内连接、外连接、全连接"><a href="#内连接、外连接、全连接" class="headerlink" title="内连接、外连接、全连接"></a>内连接、外连接、全连接</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接语句的关键字是<code>inner</code>、<code>join</code>、<code>on</code>。执行语句例如：<code>select * from a_table a inner join b_table b on a.a_id = b.b_id;</code>。</p>
<p>即匹配两张表中相关联的记录，也就是两张表中都有的记录，返回两个表的交集部分。</p>
<h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>左外连接的关键字是<code>left</code>、<code>join</code>、<code>on</code>。执行语句例如：<code>select * from a_table a left join b_table b on a.a_id = b.b_id;</code>。</p>
<p>即除了匹配两张表相关联的所有记录，还会匹配左表中剩余的记录（相当于整个左边的记录都全部显示出来），右表中未匹配到的记录用<code>NULL</code>表示。</p>
<h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>右外连接的关键字是<code>right</code>、<code>join</code>、<code>on</code>。执行语句例如：<code>select * from a_table a right join b_table b on a.a_id = b.b_id;</code>。</p>
<p>与左表相反，即除了匹配两张表相关联的所有记录，还会匹配右表中剩余的记录（相当于整个右边的记录都全部显示出来），左表中未匹配到的记录用<code>NULL</code>表示。</p>
<h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><p>返回左右表中所有的记录和左右表中相关联的记录（左右表的交集部分）。</p>
<p>目前MySQL是不支持全连接的。</p>
<h2 id="分片、分区、分表、分库"><a href="#分片、分区、分表、分库" class="headerlink" title="分片、分区、分表、分库"></a>分片、分区、分表、分库</h2><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片（Sharding）是将一个数据分成两个或者多个较小的块，称为逻辑分片（logical shards）。然后逻辑分片分布在单独的数据库节点上，称为物理分片（physical shards）。物理分片可以容纳多个逻辑分片。</p>
<p>数据库分片（Database shards）是无共享架构的一个例子。这意味着分片是<strong>自治</strong>的：分片间不共享任何相同的数据或者服务器资源。</p>
<h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>数据分区是一种物理数据库的设计技术，它的目的是在特定的SQL操作中减少数据读写的总量以缩短响应时间。分区不会形成新的数据表，实际上还是一张表，只是将表的数据均衡分摊到了不同的硬盘空间里，底层是由N个物理区块组成的。</p>
<p><strong>分区的好处</strong>：</p>
<ul>
<li><strong>存储更多的数据</strong>。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。相比单个磁盘或文件系统，可以存储更多的数据。</li>
<li><strong>优化查询</strong>。在使用<code>where</code>语句时，可以只扫描一个或者多个分区表来提交查询效率。</li>
<li><strong>分区表更容易维护</strong>。</li>
</ul>
<p><strong>分区的局限</strong>：</p>
<ul>
<li>一个表最多只能有1024个分区</li>
<li>如果分区字段中含有主键或者唯一索引的列，那么主键列和唯一索引的列都必须要包含进来。</li>
<li>分区表中无法使用外键约束。</li>
</ul>
<h4 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h4><p>水平分区是对表的行进行分区。所有在表中定义的列都能在每个分区的数据集中找到，所以这个表的特性仍然是存在的。</p>
<p>例如，一个大学四年的成绩单，可以被分为四个不同的分区，每个分区中含有的数据集是每一年的成绩。（水平分区一定要按照某个属性列来分区，即这里分区的就是学年这个列）。</p>
<h4 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h4><p>这种分区一般来说是通过对表的垂直划分来减少表的宽度，使某些特定的列被划分到了特定的分区。</p>
<p>例如，一个学院表中有学院标号、学院名称、院长、学院简章、学院历史等属性列。学院简章和学院历史数据列的每一行都含有text等大字段，但是又不会经常被访问到，所以就将这两个属性列划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p>
<h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>分表就是把一张表按照一定的规则分解成N个具有独立存储空间的实体表。</p>
<h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>数据分布在不同的数据库之中（数据量极大）。</p>
<h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标是一种能从包括多条数据记录的结果中每次提取一条记录的机制。它的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果。尽管游标能遍历结果中的所有行，但一次只会指向一行。它的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p>
<p>游标具有三个属性：</p>
<ul>
<li>不敏感（Asensitive）：数据库可以选择不复制结果集</li>
<li>只读（Read only）</li>
<li>不滚动（Nonscrollable）：游标是只能向一个方向前进的，并且不可以跳过任何一行数据</li>
</ul>
<p>它的优点是对从数据库中查询得到的结果集的每一行都可以进行分开的独立的相同或者不相同的操作，是一种分离的思想。它的主要是就是性能不高，只能一行一行操作。在数据量较大的情况下，速度过慢。游标可能会造成死锁，内存不足等。</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义游标，cursor_name是游标名称，select_statement是查询语句</span><br><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement</span><br><span class="line">// 打开游标</span><br><span class="line"><span class="keyword">open</span> cursor_name</span><br><span class="line">// 取游标中的数据</span><br><span class="line"><span class="keyword">fetch</span> cursor_name <span class="keyword">into</span> var_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> cursor_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">prior</span> <span class="keyword">from</span> cursor_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">first</span> <span class="keyword">from</span> cursor_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">last</span> <span class="keyword">from</span> cursor_name</span><br><span class="line">// 关闭游标</span><br><span class="line"><span class="keyword">close</span> cursor_name</span><br><span class="line">// 释放游标</span><br><span class="line"><span class="keyword">deallocate</span> cursor_name</span><br></pre></td></tr></table></figure>
<h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 创建数据库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_name;</span><br><span class="line">// 删除数据库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_name;</span><br><span class="line">// 创建新表，包含主键tbl_id和name两个属性</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_name (tbl_id <span class="built_in">int</span>(<span class="number">11</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">null</span>, primary <span class="keyword">key</span>(tbl_id)));</span><br><span class="line">// 删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tbl_name;</span><br><span class="line">// 增加一个列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> <span class="keyword">column</span> column_name <span class="keyword">type</span>;</span><br><span class="line">// 添加主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line">// 删除主键（一个表只有一个主键，所以不需要指定名称或者某一列）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line">// 创建外键（表已经创建）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">references</span> table2(<span class="keyword">id</span>);</span><br><span class="line">// 创建外键（定义多个列的外键约束）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">add</span> <span class="keyword">constraint</span> fk_tbl1tbl2 <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">references</span> table2(<span class="keyword">id</span>);</span><br><span class="line">// 撤销外键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> fk_tbl1tbl2;</span><br><span class="line">// 创建索引（[]为可选）</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] <span class="keyword">index</span> idx_name <span class="keyword">on</span> tbl_name;</span><br><span class="line">// 删除索引（索引是不可更改的，必须删除后重新创建）</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_name;</span><br><span class="line">// 创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> select_statement;</span><br><span class="line">// 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_name;</span><br><span class="line">// 查询</span><br><span class="line">selct * from tbl_name where 查询条件;</span><br><span class="line">// 插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_name <span class="keyword">values</span>(value1, value2);</span><br><span class="line">// 插入（指定所要插入的数据的列）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_name (column1, column2) <span class="keyword">values</span> (value1, value2);</span><br><span class="line">// 删除</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl_name <span class="keyword">where</span> 删除范围;</span><br></pre></td></tr></table></figure>
<h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM（Object Relational Mapping，对象关系映射）是一种思想，就是把对象（Object）转变成数据库中的记录，或者把数据库中的记录转变成对象。ORM通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，在后端具体操作数据库时，就不需要编写复杂的SQL语句，而是向操作对象一样就可以了。</p>
<p>这里需要了解两个概念，持久化（Persistence）和持久层（Persistence layer）。持久化，是把数据（如内存中的对象）保存到可永久保存的存储设备中。而持久层，是专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。</p>
<p>传统的使用JDBC操作数据库时，业务处理逻辑和数据存取逻辑是混淆在一起的。一般是如下几个步骤：</p>
<ol>
<li>建立数据库连接，获得<code>Connection</code>对象；</li>
<li>根据用户的输入<strong>组装</strong>成SQL语句（复杂）；</li>
<li>根据SQL语句建立<code>Statement</code>对象或者<code>PreparedStatement</code>对象；（<code>PreparedStatement是预编译的</code>，比<code>Statement</code>访问速度更快，代码的可读性和可维护性也更好）</li>
<li>用<code>Connection</code>对象执行SQL语句，获得返回的结果集<code>ResultSet</code>对象；</li>
<li>然后逐行读取结果集<code>ResultSet</code>对象中的数据；</li>
<li>根据读取到的数据，按特定的业务逻辑进行操作；</li>
<li>根据操作得到的结果再组装成新的SQL语句；</li>
<li>再使用<code>Connection</code>对象执行更新的SQL语句去更新数据库中的数据；</li>
<li>最后依次关闭<code>Statement</code>对象和建立连接的<code>Connection</code>对象；</li>
</ol>
<p>从上可以看出，这个使用JDBC的逻辑是十分复杂的，除了上面的情况，还需要考虑到语句可能执行失败的处理逻辑。而如果使用ORM技术，例如流行的Hibernate或者MyBatis技术，业务逻辑会简化很多：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">calaAmount</span><span class="params">(String c_id, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据id获取到Customer对象</span></span><br><span class="line">    Customer customer = CustomerManager.getCustomer(id);</span><br><span class="line">    <span class="comment">// 根据顾客的等级获取相应的优惠政策</span></span><br><span class="line">    Promo promo = PromoManager.getPromo(customer.getLevel());</span><br><span class="line">    <span class="comment">// 计算最终的价格</span></span><br><span class="line">    customer.getAmount(customer.getAmount().add(amount));</span><br><span class="line">    <span class="comment">// 返回优惠后的价格</span></span><br><span class="line">    <span class="keyword">return</span> amount * promo.getRate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上就是业务逻辑的代码，可见是与数据存取逻辑完全分离的。数据存储逻辑等操作全部放在两个类中<code>CustomerManager</code>和<code>PromoManager</code>这两个类中完成。</p>
<h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需要从缓冲池中取出一个，使用完毕之后再放回去。<strong>可以通过设定连接池最大连接数来防止系统无尽地与数据库连接</strong>。</p>
<p>连接池的核心思想是连接的复用，工作原理主要由三部分组成，分别为连接层的建立，连接池连接的使用管理，连接池的关闭。</p>
<ol>
<li><p><strong>连接池的建立</strong>。一般在系统初始化时，连接池会根据系统配置建立，并在池中建立几个连接对象，以便使用时能从连接池中获取。</p>
</li>
<li><p><strong>连接池的管理</strong>。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其策略是：</p>
<p> 当客户请求数据库连接时，首先检查连接池中是否有空闲连接；如果存在空闲连接，则将连接分配给客户使用并作相应处理（即标记该连接为正在使用中，引用计数加1）；如果没有空闲连接，则查看当前所打开的连接数是否已经达到最大连接数，如果没有达到最大连接数，就重新创建一个新的连接给请求的客户；如果已经达到，那么就设定最大的等待时间让其等待，如果超出了这个等待时间，就抛出异常给用户。</p>
<p> 当客户释放数据库连接时，则要先判断该连接的<strong>引用次数</strong>是否超过了规定值，如果超过了就要从连接池中删除该连接，并判断当前连接池内总的连接数是否小于最小连接数，如果小于了又要将连接池充满；如果没超过就将这个连接标记为开放状态，可供再次复用；</p>
</li>
<li><p><strong>连接池的关闭</strong>。当程序退出时，关闭连接池中所有的连接，释放连接池相关资源，该过程正好与创建是相反的。</p>
</li>
</ol>
<p><strong>连接池的主要优点</strong>：</p>
<ol>
<li><strong>减少连接的创建时间</strong>。连接池中的连接是早已准备好的，可以重复使用的，获取后就可以直接访问数据库进行操作，减少了连接创建的次数和时间；</li>
<li><strong>更快的系统响应速度</strong>。数据库连接池在初始化过程中，往往已经创建了若干的数据库连接置于池中备用。此时连接的初始化工作均已完成。利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间；</li>
<li><strong>统一的连接管理</strong>。如果不使用连接池，每次访问数据库都要创建一个连接，系统的稳定性受连接需求的影响很大，容易产生资源浪费和高负载异常。而连接池可以使性能最大化，将资源利用在一定的水平之下。连接池能够控制池中的连接数量，增强了稳定性。</li>
</ol>
<h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h3 id="B树的好处"><a href="#B树的好处" class="headerlink" title="B树的好处"></a>B树的好处</h3><h3 id="B-树的好处"><a href="#B-树的好处" class="headerlink" title="B+树的好处"></a>B+树的好处</h3><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间、字符串（字符）类型。所有数据类型详情可见：<a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">MySQL数据类型</a></p>
<ol>
<li><code>in</code>和<code>exist</code>的区别</li>
<li><code>varchar</code>和<code>char</code>的区别</li>
<li><code>varchar(50)</code>中50的含义</li>
<li><code>int(20)</code>中20的含义</li>
<li><code>int(10)</code>和<code>char(10)</code>和<code>varchar(10)</code>的区别</li>
</ol>
<h3 id="有关权限的表"><a href="#有关权限的表" class="headerlink" title="有关权限的表"></a>有关权限的表</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在MySQL数据库里，由<code>mysql_install_db</code>脚本初始化。</p>
<ul>
<li>user权限表：记录允许连接到服务器的用户账号信息，里面的权限是全局级的；</li>
<li>db权限表：记录各个账号在各个数据库上的操作权限；</li>
<li>table_priv权限表：记录数据<strong>表级</strong>的操作权限；</li>
<li>columns_priv权限表：记录数据<strong>列级</strong>的操作权限；</li>
<li>host权限表：配合db权限表对给定主机上数据库级操作权限做更细致的控制，这个权限表不受<code>grant</code>和<code>revoke</code>语句的影响</li>
</ul>
<h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ol>
<li><p>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到？如何才能知道这条语句执行很慢的原因？</p>
<p> 对于低性能的SQL语句的定位，最重要也是最有效的方法就是<strong>使用执行计划</strong>，MySQL提供了<code>explain</code>命令来查看语句的执行计划。我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化。对于查询语句，最重要的优化方式就是<strong>使用索引</strong>。而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</p>
</li>
<li><p>SQL的生命周期</p>
<p> <strong>连接器</strong>：</p>
<p> 建立与MySQL的连接，用于查询SQL语句，判断权限；</p>
<p> <strong>查询缓存</strong>：</p>
<ul>
<li>如果语句不再查询缓存中，那么就要继续执行后面的执行阶段。执行完成之后，执行结果集会被存入查询缓存中；</li>
<li><p>如果查询命中了缓存，那么MySQL不需要执行后面的复杂操作，可以直接返回结果，提升效率；</p>
<p><strong>分析器</strong>：</p>
<p>对SQL语句进行硬解析，分析器会先做词法分析，分析SQL语句的组成部分，判断其是否满足语法规则。</p>
<p><strong>优化器</strong>：</p>
<p>优化器的作用是指当表里面有多个索引的时候，决定去使用哪个索引；或者当一个语句有多表关联（join）的时候，决定各个表的连接顺序。其实不同的执行方法的结果是一样的，但是效率会有所不同就，优化器的作用就是决定选择使用哪一个方案。</p>
<p><strong>执行器</strong>：</p>
</li>
<li><p>有索引：第一次调用的是取满足条件的第一行这个接口，之后循环取满足条件的下一行的这个接口，最终把查询的结果返回客户端；</p>
</li>
<li>无索引：调用InnoDB引擎接口取这个表的第一行，判断SQL查询条件，如果不是则跳过，如果是则将这行存在结果集中；调用引擎接口取下一行，重复相同的判断逻辑，直到取到这个表的最后一行。最终，执行器将上述遍历过程中所有满足条件的行组成的记录作为结果返回给客户端。</li>
</ul>
</li>
<li><p>大表的数据查询怎么优化</p>
</li>
<li>超大分页怎么处理</li>
<li>MySQL分页</li>
<li>慢查询日志</li>
<li>主键使用自增长ID还是UUID？</li>
<li>优化关联查询</li>
<li>优化LIMIT分页</li>
<li>优化UNION查询</li>
<li>优化WHERE子句</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Hurley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Database)/">https://hurleyjames.github.io/2020/06/06/Interview-Review(Database)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hurleyjames.github.io" target="_blank">Hurley</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/../image/reentrantlock.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/images/wechat.JPG" alt="wechat" onclick="window.open('/images/wechat.JPG')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/images/alipay.JPG" alt="alipay" onclick="window.open('/images/alipay.JPG')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/06/Interview-Review(Network)/"><img class="prev-cover" data-src="/../image/network-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Interview-Review(Network)</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/06/Interview-Review(Java)/"><img class="next-cover" data-src="/../image/java-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Interview-Review(Java)</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/../image/database-interview.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2021 By Hurley</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">随时意气风发，独自声势浩大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>