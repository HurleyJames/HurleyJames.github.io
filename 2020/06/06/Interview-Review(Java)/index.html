<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Interview-Review(Java) | Hurley</title><meta name="description" content="本篇主要是面试复习内容的Java部分。   关键字  final关键字 final关键字主要用在三个地方：变量、方法、类。  如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式的指定为final方法。 使用final的原因有两个。一个是"><meta name="keywords" content="面试"><meta name="author" content="Hurley"><meta name="copyright" content="Hurley"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/icon.png"><link rel="canonical" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Interview-Review(Java)"><meta property="og:url" content="https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/"><meta property="og:site_name" content="Hurley"><meta property="og:description" content="本篇主要是面试复习内容的Java部分。   关键字  final关键字 final关键字主要用在三个地方：变量、方法、类。  如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。 当用final修饰一个类时，表明这个类不能被继承。final类中的所有成员方法都会被隐式的指定为final方法。 使用final的原因有两个。一个是"><meta property="og:image" content="https://hurleyjames.github.io/../image/java-interview.png"><meta property="article:published_time" content="2020-06-05T16:00:00.000Z"><meta property="article:modified_time" content="2021-01-07T13:20:36.867Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="prev" title="Interview-Review(OS)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(OS)/"><link rel="next" title="Interview-Review(Android)" href="https://hurleyjames.github.io/2020/03/25/Interview-Review(Android)/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: true
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/26319720?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">71</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">30</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">14</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><i class="fas fa-arrow-right" id="toggle-sidebar"></i><div id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">目录</div><div class="sidebar-toc__progress"><span class="progress-notice">你已经读了</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar">     </div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#关键字"><span class="toc-number">1.</span> <span class="toc-text"> 关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#final关键字"><span class="toc-number">1.1.</span> <span class="toc-text"> final关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#static关键字"><span class="toc-number">1.2.</span> <span class="toc-text"> static关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#静态变量"><span class="toc-number">1.2.1.</span> <span class="toc-text"> 静态变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#实例变量"><span class="toc-number">1.2.2.</span> <span class="toc-text"> 实例变量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态方法"><span class="toc-number">1.2.3.</span> <span class="toc-text"> 静态方法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态代码块"><span class="toc-number">1.2.4.</span> <span class="toc-text"> 静态代码块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#this和super关键字"><span class="toc-number">1.3.</span> <span class="toc-text"> this和super关键字</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#synchroinzed关键字"><span class="toc-number">1.4.</span> <span class="toc-text"> synchroinzed关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized的底层实现原理"><span class="toc-number">1.4.1.</span> <span class="toc-text"> synchronized的底层实现原理</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#监视器锁-monitor"><span class="toc-number">1.4.1.1.</span> <span class="toc-text"> 监视器锁-Monitor</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#锁粗化"><span class="toc-number">1.4.1.2.</span> <span class="toc-text"> 锁粗化</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#锁消除"><span class="toc-number">1.4.1.3.</span> <span class="toc-text"> 锁消除</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#偏向锁"><span class="toc-number">1.4.1.4.</span> <span class="toc-text"> 偏向锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#轻量级锁"><span class="toc-number">1.4.1.5.</span> <span class="toc-text"> 轻量级锁</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#适应性自旋"><span class="toc-number">1.4.1.6.</span> <span class="toc-text"> 适应性自旋</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#synchronized与lock锁的区别"><span class="toc-number">1.4.2.</span> <span class="toc-text"> synchronized与Lock锁的区别</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#volatile关键字"><span class="toc-number">1.5.</span> <span class="toc-text"> volatile关键字</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#volatile的底层实现原理"><span class="toc-number">1.5.1.</span> <span class="toc-text"> volatile的底层实现原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#成员变量和局部变量的区别"><span class="toc-number">1.6.</span> <span class="toc-text"> 成员变量和局部变量的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#object通用方法"><span class="toc-number">2.</span> <span class="toc-text"> Object通用方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#与equals"><span class="toc-number">2.1.</span> <span class="toc-text"> ==与equals</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashcode与equals"><span class="toc-number">2.2.</span> <span class="toc-text"> hashCode()与equals()</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#string"><span class="toc-number">3.</span> <span class="toc-text"> String</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#string-stringbuffer-stringbuilder的区别"><span class="toc-number">3.1.</span> <span class="toc-text"> String StringBuffer StringBuilder的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#可变性"><span class="toc-number">3.1.1.</span> <span class="toc-text"> 可变性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#线程安全性"><span class="toc-number">3.1.2.</span> <span class="toc-text"> 线程安全性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#性能"><span class="toc-number">3.1.3.</span> <span class="toc-text"> 性能</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#总结"><span class="toc-number">3.1.4.</span> <span class="toc-text"> 总结</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#类型"><span class="toc-number">4.</span> <span class="toc-text"> 类型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#基本类型与运算"><span class="toc-number">4.1.</span> <span class="toc-text"> 基本类型与运算</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#引用类型"><span class="toc-number">4.2.</span> <span class="toc-text"> 引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#两种类型的对比"><span class="toc-number">4.3.</span> <span class="toc-text"> 两种类型的对比</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#自动装箱与拆箱"><span class="toc-number">4.4.</span> <span class="toc-text"> 自动装箱与拆箱</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#反射"><span class="toc-number">5.</span> <span class="toc-text"> 反射</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#作用"><span class="toc-number">5.1.</span> <span class="toc-text"> 作用</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#用途"><span class="toc-number">5.2.</span> <span class="toc-text"> 用途</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#实现方式"><span class="toc-number">5.3.</span> <span class="toc-text"> 实现方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#优缺点"><span class="toc-number">5.4.</span> <span class="toc-text"> 优缺点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#序列化"><span class="toc-number">6.</span> <span class="toc-text"> 序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#异常"><span class="toc-number">7.</span> <span class="toc-text"> 异常</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#error错误"><span class="toc-number">7.1.</span> <span class="toc-text"> Error（错误）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#exception异常"><span class="toc-number">7.2.</span> <span class="toc-text"> Exception（异常）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#runtime-exception运行时异常"><span class="toc-number">7.2.1.</span> <span class="toc-text"> Runtime Exception（运行时异常）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#throwable类常用方法"><span class="toc-number">7.3.</span> <span class="toc-text"> Throwable类常用方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#总结-2"><span class="toc-number">7.4.</span> <span class="toc-text"> 总结</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#泛型"><span class="toc-number">8.</span> <span class="toc-text"> 泛型</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#类型擦除"><span class="toc-number">8.1.</span> <span class="toc-text"> 类型擦除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#通配符"><span class="toc-number">8.2.</span> <span class="toc-text"> 通配符</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#注解"><span class="toc-number">9.</span> <span class="toc-text"> 注解</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#常见注解"><span class="toc-number">9.1.</span> <span class="toc-text"> 常见注解</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#特性"><span class="toc-number">10.</span> <span class="toc-text"> 特性</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#封装"><span class="toc-number">10.1.</span> <span class="toc-text"> 封装</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#继承"><span class="toc-number">10.2.</span> <span class="toc-text"> 继承</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#接口和抽象类的区别"><span class="toc-number">10.2.1.</span> <span class="toc-text"> 接口和抽象类的区别</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#重载和重写的区别"><span class="toc-number">10.2.2.</span> <span class="toc-text"> 重载和重写的区别</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#重载"><span class="toc-number">10.2.2.1.</span> <span class="toc-text"> 重载</span></a></li><li class="toc-item toc-level-5"><a class="toc-link" href="#重写"><span class="toc-number">10.2.2.2.</span> <span class="toc-text"> 重写</span></a></li></ol></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多态"><span class="toc-number">10.3.</span> <span class="toc-text"> 多态</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#构造方法的作用和特性"><span class="toc-number">10.4.</span> <span class="toc-text"> 构造方法的作用和特性</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#面向对象和面向过程的区别"><span class="toc-number">10.5.</span> <span class="toc-text"> 面向对象和面向过程的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#jvm-jdk和jre"><span class="toc-number">10.6.</span> <span class="toc-text"> JVM、JDK和JRE</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#jvm"><span class="toc-number">10.6.1.</span> <span class="toc-text"> JVM</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#jdk和jre"><span class="toc-number">10.6.2.</span> <span class="toc-text"> JDK和JRE</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#java和c的区别"><span class="toc-number">10.7.</span> <span class="toc-text"> Java和C++的区别</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#io流"><span class="toc-number">11.</span> <span class="toc-text"> IO流</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#分类"><span class="toc-number">11.1.</span> <span class="toc-text"> 分类</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#集合框架"><span class="toc-number">12.</span> <span class="toc-text"> 集合框架</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#集合的特点"><span class="toc-number">12.1.</span> <span class="toc-text"> 集合的特点</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#集合和数组的区别"><span class="toc-number">12.2.</span> <span class="toc-text"> 集合和数组的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#常用的集合类"><span class="toc-number">12.3.</span> <span class="toc-text"> 常用的集合类</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#list-set-map-三者的区别"><span class="toc-number">12.4.</span> <span class="toc-text"> List | Set | Map 三者的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist"><span class="toc-number">12.5.</span> <span class="toc-text"> ArrayList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#arraylist的原理"><span class="toc-number">12.5.1.</span> <span class="toc-text"> ArrayList的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#linkedlist"><span class="toc-number">12.6.</span> <span class="toc-text"> LinkedList</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#linkedlist的原理"><span class="toc-number">12.6.1.</span> <span class="toc-text"> LinkedList的原理</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arraylist与linkedlist的区别"><span class="toc-number">12.7.</span> <span class="toc-text"> ArrayList与LinkedList的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#vector"><span class="toc-number">12.8.</span> <span class="toc-text"> Vector</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap"><span class="toc-number">12.9.</span> <span class="toc-text"> HashMap</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashset"><span class="toc-number">12.10.</span> <span class="toc-text"> HashSet</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashtable"><span class="toc-number">12.11.</span> <span class="toc-text"> HashTable</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#concurrenthashmap"><span class="toc-number">12.12.</span> <span class="toc-text"> ConcurrentHashMap</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#base-17"><span class="toc-number">12.12.1.</span> <span class="toc-text"> Base 1.7</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#base-18"><span class="toc-number">12.12.2.</span> <span class="toc-text"> Base 1.8</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap与hashtable的区别"><span class="toc-number">12.13.</span> <span class="toc-text"> HashMap与HashTable的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap与hashset的区别"><span class="toc-number">12.14.</span> <span class="toc-text"> HashMap与HashSet的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#hashmap与concurrenthashmap的区别"><span class="toc-number">12.15.</span> <span class="toc-text"> HashMap与ConcurrentHashMap的区别</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#collections工具类常用方法"><span class="toc-number">12.16.</span> <span class="toc-text"> Collections工具类常用方法：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#arrays类的常见操作"><span class="toc-number">12.17.</span> <span class="toc-text"> Arrays类的常见操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#线程"><span class="toc-number">13.</span> <span class="toc-text"> 线程</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#开启线程的方式"><span class="toc-number">13.1.</span> <span class="toc-text"> 开启线程的方式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#thread类和runnable接口实现多线程哪个更好"><span class="toc-number">13.1.1.</span> <span class="toc-text"> Thread类和Runnable接口实现多线程哪个更好</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#callable和runnable接口的区别是什么"><span class="toc-number">13.1.2.</span> <span class="toc-text"> Callable和Runnable接口的区别是什么</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23种设计模式span-iddesignpattern"><span class="toc-number">14.</span> <span class="toc-text"> 23种设计模式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#单例模式"><span class="toc-number">14.1.</span> <span class="toc-text"> 单例模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#饿汉模式"><span class="toc-number">14.1.1.</span> <span class="toc-text"> 饿汉模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#懒汉模式线程不安全"><span class="toc-number">14.1.2.</span> <span class="toc-text"> 懒汉模式（线程不安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#懒汉模式线程安全"><span class="toc-number">14.1.3.</span> <span class="toc-text"> 懒汉模式（线程安全）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#双重检验锁模式double-checked-locking-pattern"><span class="toc-number">14.1.4.</span> <span class="toc-text"> 双重检验锁模式（double checked locking pattern）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#静态内部类单例模式"><span class="toc-number">14.1.5.</span> <span class="toc-text"> 静态内部类单例模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#枚举单例"><span class="toc-number">14.1.6.</span> <span class="toc-text"> 枚举单例</span></a><ol class="toc-child"><li class="toc-item toc-level-5"><a class="toc-link" href="#枚举单例与饿汉模式的区别"><span class="toc-number">14.1.6.1.</span> <span class="toc-text"> 枚举单例与饿汉模式的区别</span></a></li></ol></li><li class="toc-item toc-level-4"><a class="toc-link" href="#使用容器实现单例模式"><span class="toc-number">14.1.7.</span> <span class="toc-text"> 使用容器实现单例模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单工厂模式"><span class="toc-number">14.2.</span> <span class="toc-text"> 简单工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#工厂方法模式"><span class="toc-number">14.3.</span> <span class="toc-text"> 工厂方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#抽象工厂模式"><span class="toc-number">14.4.</span> <span class="toc-text"> 抽象工厂模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#建造者模式"><span class="toc-number">14.5.</span> <span class="toc-text"> 建造者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#原型模式"><span class="toc-number">14.6.</span> <span class="toc-text"> 原型模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#外观模式"><span class="toc-number">14.7.</span> <span class="toc-text"> 外观模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#适配器模式"><span class="toc-number">14.8.</span> <span class="toc-text"> 适配器模式</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#类的适配器模式"><span class="toc-number">14.8.1.</span> <span class="toc-text"> 类的适配器模式</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#对象的适配器模式"><span class="toc-number">14.8.2.</span> <span class="toc-text"> 对象的适配器模式</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#桥接模式"><span class="toc-number">14.9.</span> <span class="toc-text"> 桥接模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#代理模式"><span class="toc-number">14.10.</span> <span class="toc-text"> 代理模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#装饰器模式"><span class="toc-number">14.11.</span> <span class="toc-text"> 装饰器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#享元模式"><span class="toc-number">14.12.</span> <span class="toc-text"> 享元模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#职责链模式"><span class="toc-number">14.13.</span> <span class="toc-text"> 职责链模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#命令模式"><span class="toc-number">14.14.</span> <span class="toc-text"> 命令模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#解释器模式"><span class="toc-number">14.15.</span> <span class="toc-text"> 解释器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#迭代器模式"><span class="toc-number">14.16.</span> <span class="toc-text"> 迭代器模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#中介者模式"><span class="toc-number">14.17.</span> <span class="toc-text"> 中介者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#备忘录模式"><span class="toc-number">14.18.</span> <span class="toc-text"> 备忘录模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#观察者模式"><span class="toc-number">14.19.</span> <span class="toc-text"> 观察者模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#状态模式"><span class="toc-number">14.20.</span> <span class="toc-text"> 状态模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#策略模式"><span class="toc-number">14.21.</span> <span class="toc-text"> 策略模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#模板方法模式"><span class="toc-number">14.22.</span> <span class="toc-text"> 模板方法模式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#访问者模式"><span class="toc-number">14.23.</span> <span class="toc-text"> 访问者模式</span></a></li></ol></li></ol></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/../image/java-interview.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hurley</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Interview-Review(Java)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-06 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2021-01-07 21:20:36"><i class="fas fa-history fa-fw"></i> 更新于 2021-01-07</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">19.7k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 63 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本篇主要是面试复习内容的Java部分。</p>
<a id="more"></a>
<h2 id="关键字"><a class="markdownIt-Anchor" href="#关键字"></a> 关键字</h2>
<h3 id="final关键字"><a class="markdownIt-Anchor" href="#final关键字"></a> final关键字</h3>
<p><code>final</code>关键字主要用在三个地方：变量、方法、类。</p>
<ol>
<li>如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li>
<li><strong>当用<code>final</code>修饰一个类时，表明这个类不能被继承。</strong><code>final</code>类中的所有成员方法都会被隐式的指定为<code>final</code>方法。</li>
<li>使用<code>final</code>的原因有两个。一个是把方法锁定，以防任何继承类来修改它的含义。所以类中所有的<code>private</code>方法都被隐式的指定为<code>final</code>；第二个原因是效率。</li>
</ol>
<h3 id="static关键字"><a class="markdownIt-Anchor" href="#static关键字"></a> static关键字</h3>
<p><code>static</code>关键字的主要意义是在于创建独立于具体对象的域变量和方法。即使没有创建对象，也会使用属性和调用方法。<code>static</code>关键字可以用来形成静态代码块以优化程序性能。<code>static</code>块可以放置于类中的任何地方，类中可以有多个<code>static</code>块。当类被<strong>初次</strong>加载时，就会按照<code>static</code>块的顺序来执行每个<code>static</code>块，并且<strong>只会执行一次</strong>。</p>
<p><code>static</code>优化性能的原因是在于它只会在类加载的时候执行一次。所以有时候可以将一些只需要执行一次的初始化操作放在<code>static</code>代码块中执行。</p>
<p><code>static</code>关键字主要有以下四种使用场景：</p>
<ol>
<li><strong>修饰成员变量和成员方法</strong>：被<code>static</code>修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以直接通过类名调用。被<code>static</code>声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。调用格式：<code>类名.静态变量名</code>和<code>类名.静态方法名()</code>。<strong><code>static</code>是不允许修饰局部变量的</strong>。</li>
<li><strong>静态代码块</strong>：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，静态代码块只执行一次。</li>
<li><strong>静态内部类（<code>static</code>只能修饰内部类）</strong>：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用意味：1. 它的创建是不需要依赖外围类的创建；2. 它不能使用任何外围类的非<code>static</code>成员变量和方法。这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</li>
<li><strong>静态导包（用来导入类中的静态资源）</strong>：格式为<code>import static</code>，这个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。因为会影响代码的可读性，所以一般情况下不建议使用。</li>
</ol>
<h4 id="静态变量"><a class="markdownIt-Anchor" href="#静态变量"></a> 静态变量</h4>
<p>被<code>static</code>修饰的成员变量叫静态变量，也叫<code>static</code>变量。它是属于这个类的，而不是属于这个对象的。比如一个类名是A的类，那么调用它就是<code>A.func()</code>，而不用<code>A a = new A();</code>去实例化A后，再使用<code>a.func()</code>的方式去调用。</p>
<p>静态变量在内存中只会有一份，在类的加载过程中，JVM只会为静态变量分配一次内存空间。</p>
<h4 id="实例变量"><a class="markdownIt-Anchor" href="#实例变量"></a> 实例变量</h4>
<p>没有被<code>static</code>修饰的成员变量叫做实例变量，实例变量是属于这个类的实例对象。即必须使用上述的<code>a.func()</code>的方式，先实例话这个类的对象，再调用。</p>
<p>在每次创建对象时，都会为每个对象分配成员变量内存空间。而实例变量是属于实例对象的，所以在内存中，创建几次对象，就会有几份成员变量。</p>
<h4 id="静态方法"><a class="markdownIt-Anchor" href="#静态方法"></a> 静态方法</h4>
<p>用<code>static</code>修饰的方法也叫做静态方法。注意<strong>构造方法不是静态方法</strong>。</p>
<h4 id="静态代码块"><a class="markdownIt-Anchor" href="#静态代码块"></a> 静态代码块</h4>
<p>静态代码块的格式是</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 语句体;</span></span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中的出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p>
<p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。</p>
<h3 id="this和super关键字"><a class="markdownIt-Anchor" href="#this和super关键字"></a> this和super关键字</h3>
<p><code>this</code>关键字用于引用类的当前实例，此关键字是可选的，使用此关键字可能会使代码更易读或易懂。</p>
<p><code>super</code>关键字用于从子类访问父类的变量和方法。</p>
<ul>
<li>使用<code>super()</code>调用父类中的其它构造方法时，该语句必须处于首行，否则编译器会报错。另外，<code>this</code>调用本类中的其它构造方法时，也要放在首行。</li>
<li><code>this</code>、<code>super</code>不能用在<code>static</code>方法中。</li>
</ul>
<h3 id="synchroinzed关键字"><a class="markdownIt-Anchor" href="#synchroinzed关键字"></a> synchroinzed关键字</h3>
<h4 id="synchronized的底层实现原理"><a class="markdownIt-Anchor" href="#synchronized的底层实现原理"></a> synchronized的底层实现原理</h4>
<p><code>synchronized</code>是基于JVM内置锁实现的，通过进入与退出Monitor（监视器锁）的对象实现的。</p>
<p>在JDK1.5之前，它是一个重量级的锁，是直接通过对Monitor对象的MonitorEnter/MonitorExit指令操作来进行加锁。这样会导致「用户态」和「内核态」的来回切换，效率降低。</p>
<p>JDK1.5之后，通过加入<strong>锁粗化（Lock Coarsening）</strong>、<strong>锁消除（Lock Elimination）</strong>、<strong>轻量级锁（Lightweight Locking）</strong>、<strong>偏向锁（Biased Locking）</strong>、**适应性自旋（Adaptive Spinning）**等技术来减少锁操作的开销。</p>
<p>大致流程就是：<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">无</mi><mi mathvariant="normal">锁</mi><mi mathvariant="normal">状</mi><mi mathvariant="normal">态</mi><mo>→</mo><mi mathvariant="normal">偏</mi><mi mathvariant="normal">向</mi><mi mathvariant="normal">锁</mi><mo>→</mo><mi mathvariant="normal">轻</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">级</mi><mi mathvariant="normal">锁</mi><mo>→</mo><mi mathvariant="normal">重</mi><mi mathvariant="normal">量</mi><mi mathvariant="normal">级</mi><mi mathvariant="normal">锁</mi></mrow><annotation encoding="application/x-tex">无锁状态\rightarrow 偏向锁\rightarrow 轻量级锁\rightarrow 重量级锁</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">无</span><span class="mord cjk_fallback">锁</span><span class="mord cjk_fallback">状</span><span class="mord cjk_fallback">态</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">偏</span><span class="mord cjk_fallback">向</span><span class="mord cjk_fallback">锁</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">轻</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">级</span><span class="mord cjk_fallback">锁</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">重</span><span class="mord cjk_fallback">量</span><span class="mord cjk_fallback">级</span><span class="mord cjk_fallback">锁</span></span></span></span></p>
<h5 id="监视器锁-monitor"><a class="markdownIt-Anchor" href="#监视器锁-monitor"></a> 监视器锁-Monitor</h5>
<p>监视器锁是基于操作系统底层的Mutex Lock（互斥锁）实现的，这里会涉及到如下的切换：</p>
<p><span class="katex-display"><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">态</mi><mo>→</mo><mi mathvariant="normal">内</mi><mi mathvariant="normal">核</mi><mi mathvariant="normal">态</mi><mo>→</mo><mi mathvariant="normal">用</mi><mi mathvariant="normal">户</mi><mi mathvariant="normal">态</mi></mrow><annotation encoding="application/x-tex">用户态\rightarrow 内核态\rightarrow 用户态
</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">态</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mord cjk_fallback">内</span><span class="mord cjk_fallback">核</span><span class="mord cjk_fallback">态</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">→</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0em;vertical-align:0em;"></span><span class="mord cjk_fallback">用</span><span class="mord cjk_fallback">户</span><span class="mord cjk_fallback">态</span></span></span></span></span></p>
<p>所以，它是一个重量级的锁。</p>
<h5 id="锁粗化"><a class="markdownIt-Anchor" href="#锁粗化"></a> 锁粗化</h5>
<p>当JVM虚拟机感知到一系列连续操作都是对同一个对象进行加锁时，这时候是没有其它的线程发起竞争的，那么，频繁地对同一个对象进行加锁、解锁操作是非常消耗性能的，所以JVM会对锁的范围进行扩大。</p>
<p>例如，如下代码：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 循环对同一个对象加锁1000次</span></span><br><span class="line">        <span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因为上面这个代码是对同一个对象循环进行加锁，所以，代码会被优化为：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getNumStatic</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span>(object) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i1 = <span class="number">0</span>; i1 &lt; <span class="number">1000</span>; i++) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>即将<code>synchronized</code>提取到循环体之外。</p>
<h5 id="锁消除"><a class="markdownIt-Anchor" href="#锁消除"></a> 锁消除</h5>
<p>当JVM通过<strong>逃逸分析</strong>判断某一段代码块不需要加锁时，就在JVM阶段将锁去除。</p>
<h5 id="偏向锁"><a class="markdownIt-Anchor" href="#偏向锁"></a> 偏向锁</h5>
<p>如果某个锁总是由同一线程多次获得，那么为了减少同一线程获取锁的代价（比如锁切换时会涉及到CAS操作），就会引入偏向锁。</p>
<blockquote>
<p>偏向锁的核心思想是，如果一个线程获得了锁，那么锁就会进入偏向模式，此时Mark Word的结构也会变成偏向结构。如此，当这个线程再次请求锁的时候，就无需再做任何同步的操作，即获取锁的过程，这样就省略了大量不必要的申请锁的操作，从而优化了程序的性能。</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 默认开启</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 开启偏向锁</span></span><br><span class="line">-XX:+UseBiasedLocking -XX:BiasedLockingStartupDelay=0</span><br><span class="line"><span class="meta">#</span><span class="bash"> 关闭偏向锁</span></span><br><span class="line">-XX:-UseBiasedLocking</span><br></pre></td></tr></table></figure>
<h5 id="轻量级锁"><a class="markdownIt-Anchor" href="#轻量级锁"></a> 轻量级锁</h5>
<p>只有在偏向锁失败的情况下，JVM才会升级成为轻量级锁。</p>
<blockquote>
<p>轻量级锁会认为：在大多数情况下，在一个线程执行期间，是不存在锁竞争的（即线程交替执行）。</p>
</blockquote>
<p>所以，如果出现了大量线程竞争同一把锁的情况下，轻量级锁也就会失效了。为此，JVM引入了自旋锁。</p>
<h5 id="适应性自旋"><a class="markdownIt-Anchor" href="#适应性自旋"></a> 适应性自旋</h5>
<p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面被乖巧，JVM就会让等待线程进行几次空循环，让轻量级锁被释放，再被循环中的等待线程占有。如果在指定的循环次数中都无法获取锁，那么锁就会升级为重量级锁。</p>
<h4 id="synchronized与lock锁的区别"><a class="markdownIt-Anchor" href="#synchronized与lock锁的区别"></a> synchronized与Lock锁的区别</h4>
<h3 id="volatile关键字"><a class="markdownIt-Anchor" href="#volatile关键字"></a> volatile关键字</h3>
<p><code>volatile</code>主要用在多线程、同步变量。当一个共享变量被<code>volatile</code>修饰之后，就具备了两个含义：</p>
<ul>
<li>线程修改了变量的值时，变量的新值对于其它线程是立即可见的，即「不同线程对这个变量进行操作时具有<strong>可见性</strong>」。</li>
<li>禁止使用指令重排序。</li>
</ul>
<p>禁止指令重排序包含两个含义：</p>
<ul>
<li>当程序执行到<code>volatile</code>变量的操作时，在其前面的操作已经全部执行完毕，并且结果会对后面的操作可见，在其后面的操作还没有进行；</li>
<li>在进行指令优化时，<code>volatile</code>变量之前的语句不能在<code>volatile</code>后面执行，<code>volatile</code>之后的也不会在之前执行；</li>
</ul>
<h4 id="volatile的底层实现原理"><a class="markdownIt-Anchor" href="#volatile的底层实现原理"></a> volatile的底层实现原理</h4>
<h3 id="成员变量和局部变量的区别"><a class="markdownIt-Anchor" href="#成员变量和局部变量的区别"></a> 成员变量和局部变量的区别</h3>
<ol>
<li><strong>语法形式</strong>：成员变量是<strong>属于类</strong>的，而局部变量是在<strong>方法中定义的变量</strong>或者是<strong>方法的参数</strong>；成员变量可以被<code>public</code>、<code>private</code>、<code>static</code>等修饰符修饰，而局部变量不能被访问控制修饰符及<code>static</code>所修饰；但是它们都能被<code>final</code>修饰符修饰。</li>
<li><strong>变量在内存中的存储方式</strong>：如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的；如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li>
<li><strong>变量在内存中的生存时间</strong>：成员变量是对象的一部分，随着对象的创建而存在；而局部变量会随着方法的调用而自动消失。</li>
<li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（如果被<code>final</code>修饰，则必须显式赋值），而局部变量不会自动赋值。</li>
</ol>
<h2 id="object通用方法"><a class="markdownIt-Anchor" href="#object通用方法"></a> Object通用方法</h2>
<h3 id="与equals"><a class="markdownIt-Anchor" href="#与equals"></a> <code>==</code>与<code>equals</code></h3>
<p><strong>==</strong>：判断两个对象的地址是否相等，即判断<strong>两个对象是否是同一个对象</strong>。</p>
<p><strong>equals()</strong>：判断两个对象是否相等，但有两种使用情况：</p>
<ul>
<li>如果类没有覆盖<code>equals()</code>方法，则通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象。</li>
<li>如果类覆盖了<code>equals()</code>方法，一般都覆盖<code>equals()</code>方法来比较两个对象的内容是否相等，若相等则直接返回<code>true</code>。</li>
</ul>
<h3 id="hashcode与equals"><a class="markdownIt-Anchor" href="#hashcode与equals"></a> <code>hashCode()</code>与<code>equals()</code></h3>
<p><code>hashCode()</code>的作用是获取哈希码，也称为散列码；它实际上是返回一个<code>int</code>整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在JDK的<code>Object.java</code>中，意味着Java的任何类都包含<code>hashCode()</code>函数。<code>hashCode()</code>在散列表中才有用，在其它情况下没用。在散列表中<code>hashCode()</code>的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p>
<ol>
<li>如果两个对象相等，则<code>hashCode</code>也一定是相同的</li>
<li>如果两个对象相等，则对两个对象分别调用<code>equals()</code>方法都返回<code>true</code></li>
<li>两个对象有相同的<code>hashCode</code>值，也不一定是相等的</li>
<li><code>equals</code>方法被覆盖过，则<code>hashCode</code>方法也必须被覆盖</li>
<li><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写<code>hashCode()</code>，则该 <code>class</code>的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li>
</ol>
<h2 id="string"><a class="markdownIt-Anchor" href="#string"></a> String</h2>
<h3 id="string-stringbuffer-stringbuilder的区别"><a class="markdownIt-Anchor" href="#string-stringbuffer-stringbuilder的区别"></a> String StringBuffer StringBuilder的区别</h3>
<p>三者都是<code>final</code>类，都是不允许被继承的。</p>
<h4 id="可变性"><a class="markdownIt-Anchor" href="#可变性"></a> 可变性</h4>
<p><code>String</code>类中是使用<code>final</code>关键字修饰字节（字符，取决于JDK版本）数组来保存字符串，所以<code>String</code>对象是<strong>不可变的</strong>。<code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中没有用<code>final</code>关键字修饰，所以这两种对象是<strong>可变的</strong>。</p>
<h4 id="线程安全性"><a class="markdownIt-Anchor" href="#线程安全性"></a> 线程安全性</h4>
<p><strong><code>String</code>中的对象是不可变的</strong>，也可以理解为常量，<strong>线程安全</strong>。</p>
<p><code>StringBuffer</code>中的所有方法都添加了同步锁<code>synchronized</code>关键字或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。</p>
<p><code>StringBuilder</code>并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p>
<h4 id="性能"><a class="markdownIt-Anchor" href="#性能"></a> 性能</h4>
<p>每次对<code>String</code>类型进行改变时，都会生成一个新的<code>String</code>对象，然后将指针指向新的<code>String</code>对象。</p>
<p><code>StringBuffer</code>每次都会对<code>StringBuffer</code>对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<code>StringBuilder</code>相比使用<code>StringBuffer</code>能获得10%~15%左右的性能提升，但是要冒线程不安全的风险。</p>
<h4 id="总结"><a class="markdownIt-Anchor" href="#总结"></a> 总结</h4>
<ol>
<li>操作<strong>少量数据</strong>：适用<code>String</code></li>
<li><strong>单线程</strong>操作字符串缓冲区下操作大量数据：适用<code>StringBuilder</code></li>
<li><strong>多线程</strong>操作字符串缓冲区下操作大量数据：适用<code>StringBuffer</code></li>
</ol>
<h2 id="类型"><a class="markdownIt-Anchor" href="#类型"></a> 类型</h2>
<h3 id="基本类型与运算"><a class="markdownIt-Anchor" href="#基本类型与运算"></a> 基本类型与运算</h3>
<p>Java的基本数据类型包括<code>byte</code>、<code>int</code>、<code>char</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>、<code>short</code>。</p>
<p>所以<code>String</code>不是基本数据类型，<code>void</code>也不是基本数据类型。</p>
<table>
<thead>
<tr>
<th>数据类型</th>
<th>大小</th>
<th>包装类</th>
</tr>
</thead>
<tbody>
<tr>
<td>byte</td>
<td>8</td>
<td>Byte</td>
</tr>
<tr>
<td>short</td>
<td>16</td>
<td>Double</td>
</tr>
<tr>
<td>int</td>
<td>32</td>
<td>Integer</td>
</tr>
<tr>
<td>long</td>
<td>64</td>
<td>Long</td>
</tr>
<tr>
<td>float</td>
<td>32</td>
<td>Float</td>
</tr>
<tr>
<td>double</td>
<td>64</td>
<td>Double</td>
</tr>
<tr>
<td>char</td>
<td>16</td>
<td>Character</td>
</tr>
<tr>
<td>boolean</td>
<td>1</td>
<td>Boolean</td>
</tr>
</tbody>
</table>
<h3 id="引用类型"><a class="markdownIt-Anchor" href="#引用类型"></a> 引用类型</h3>
<p>引用类型是指向一个对象，不是原始值，指向对象的变量是引用变量。</p>
<p>在Java中，除了基本数据类型之外都是引用数据类型，包括自己定义的class类也是引用类型。</p>
<p>常见的引用类型有：String | StringBuffer | StringBuilder | ArrayList | HashSet | HashMap等。</p>
<p>引用类型（reference type）指向一个对象，不是原始值，指向对象的变量是引用变量。</p>
<p>在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型，可以像基本类型一样使用。</p>
<p>引用类型常见的有：String，StringBuffer，ArrayList，HashSet，HashMap等。String也属于引用数据类型。</p>
<h3 id="两种类型的对比"><a class="markdownIt-Anchor" href="#两种类型的对比"></a> 两种类型的对比</h3>
<table>
<thead>
<tr>
<th>基本数据类型</th>
<th>引用数据类型</th>
</tr>
</thead>
<tbody>
<tr>
<td>在栈中分配内存</td>
<td>在堆中分配内存，堆的读写速度远不及栈</td>
</tr>
<tr>
<td>变量名指向具体的数值</td>
<td>变量名指向存数据对象的内存地址，即变量名指向的是hash值</td>
</tr>
<tr>
<td>基本数据类型之间的赋值是创建新的拷贝</td>
<td>对象之间的赋值只是传递引用</td>
</tr>
<tr>
<td><code>==</code>和<code>!=</code>是在比较值</td>
<td><code>==</code>和<code>!=</code>是在比较两个引用是否相同，需要自己实现<code>equals()</code>方法</td>
</tr>
<tr>
<td>基本类型变量创建和销毁很快</td>
<td>类对象需要创建JVM去销毁</td>
</tr>
</tbody>
</table>
<h3 id="自动装箱与拆箱"><a class="markdownIt-Anchor" href="#自动装箱与拆箱"></a> 自动装箱与拆箱</h3>
<ul>
<li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li>
<li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li>
</ul>
<h2 id="反射"><a class="markdownIt-Anchor" href="#反射"></a> 反射</h2>
<p>使用反射可以创建对象，但是相比而言，通过<code>new</code>创建对象的效率较高。因为通过反射创建对象时，先要查找类的资源，使用类加载器创建，过程比较繁琐，效率较低。</p>
<h3 id="作用"><a class="markdownIt-Anchor" href="#作用"></a> 作用</h3>
<p>反射机制是指在运行时，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法。所以在Java中，只要给定类的名字，就可以通过反射机制来获得类的所有信息。这种<strong>动态获取的信息以及动态调用对象的方法的功能就称为Java的反射机制</strong>。</p>
<ul>
<li>在运行时能够判断任意一个对象所属的类</li>
<li>在运行时构造任意一个类的对象</li>
<li>在运行时判断任意一个类所具有的成员变量和方法</li>
<li>在运行时调用任一对象的方法</li>
<li>在运行时创建新类的对象</li>
</ul>
<h3 id="用途"><a class="markdownIt-Anchor" href="#用途"></a> 用途</h3>
<p>连接数据库的JDBC就是典型的反射机制，除此之外，Hibernate、Struts等框架也是用反射机制来实现的。</p>
<h3 id="实现方式"><a class="markdownIt-Anchor" href="#实现方式"></a> 实现方式</h3>
<p><strong>实现Java反射的类</strong>：</p>
<ul>
<li><code>Class</code>：表示正在运行的Java应用程序的类和接口，所有获取对象的信息都需要Class类来实现</li>
<li><code>Field</code>：提供有关类和接口的属性信息，以及对它的动态访问的权限</li>
<li><code>Constructor</code>：提供类的单个构造方法的信息以及它的访问权限</li>
<li><code>Method</code>：提供类或者接口中某个方法的信息</li>
</ul>
<h3 id="优缺点"><a class="markdownIt-Anchor" href="#优缺点"></a> 优缺点</h3>
<p><strong>优点</strong>：</p>
<ul>
<li>能够运行时动态获取类的实例，提高灵活性</li>
<li>能够与动态编译相结合</li>
</ul>
<p><strong>缺点</strong>：</p>
<ul>
<li>使用反射性能较低，需要解析字节码，将内存中的对象进行解析</li>
</ul>
<h2 id="序列化"><a class="markdownIt-Anchor" href="#序列化"></a> 序列化</h2>
<blockquote>
<p>序列化：Java中的序列化机制能够将一个实例对象信息写入到一个字节流中（只序列化对象的属性值，不序列化方法），序列化后的对象可用于网络传输，或者持久化到数据库、磁盘中。<br />
反序列化：需要对象的时候，再通过字节流中的信息来重构一个相同的对象。、</p>
</blockquote>
<p>Java要使一个类实现序列化，最简单的方式就是实现<code>Serializable</code>接口的方式。</p>
<h2 id="异常"><a class="markdownIt-Anchor" href="#异常"></a> 异常</h2>
<p>在<code>Java</code>中，所有的异常都有一个共同的祖先<code>java.lang</code>包中的<code>Throwable</code>类。<code>Throwable</code>有两个重要的子类：<code>Exception</code>（异常）和<code>Error</code>（错误），二者都是<code>Java</code>异常处理的重要子类，各自包含大量的子类。异常和错误的区别：异常能被程序本身处理，错误是无法处理的。</p>
<h3 id="error错误"><a class="markdownIt-Anchor" href="#error错误"></a> Error（错误）</h3>
<p><strong>是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误表示代码运行时JVM（Java虚拟机）出现的问题，例如JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些错误表示故障是发生于虚拟机自身或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（<code>Virtual MachineError</code>）、类定义错误（<code>NoClassDefFoundError</code>）等。这些错误在运行前是不可查的。</p>
<h3 id="exception异常"><a class="markdownIt-Anchor" href="#exception异常"></a> Exception（异常）</h3>
<p><strong>是程序本身可以处理的异常</strong>。<code>Exceptiton</code>类有一个重要的子类<code>RuntimeException</code>。除此之外，还有<code>NullPointerException</code>和<code>ArrayIndexOutOfBoundsException</code>等。</p>
<h4 id="runtime-exception运行时异常"><a class="markdownIt-Anchor" href="#runtime-exception运行时异常"></a> Runtime Exception（运行时异常）</h4>
<h3 id="throwable类常用方法"><a class="markdownIt-Anchor" href="#throwable类常用方法"></a> Throwable类常用方法</h3>
<ul>
<li><code>public string getMessage()</code>：返回异常发生时的简要描述</li>
<li><code>public string toString()</code>：返回异常发生时的详细信息</li>
<li><code>public string getLocalizedMessage()</code>：返回异常对象的本地化信息。如果<code>Throwable</code>的子类有覆盖这个方法，则可以生成本地化信息。如果子类没有覆盖这个方法，则方法返回的信息与<code>getMessage()</code>返回的结果相同</li>
<li><code>public void printStackTrace()</code>：在控制台上打印<code>Throwable</code>对象封装的异常信息</li>
</ul>
<h3 id="总结-2"><a class="markdownIt-Anchor" href="#总结-2"></a> 总结</h3>
<ul>
<li><strong>try块</strong>：用于捕获异常，其后可以接多个<strong>catch块</strong>或者不接。如果其后没有<strong>catch块</strong>，则必须跟一个<strong>finally块</strong>。</li>
<li><strong>catch块</strong>：用于处理<code>try</code>捕获到的异常。</li>
<li><strong>finally块</strong>：无论是否捕获或处理异常，<strong>finally块</strong>里的语句都会被执行。如果在<strong>try块</strong>或者<strong>catch块</strong>中有<code>return</code>语句，则在<code>return</code>返回之前执行<strong>finally语句</strong>。</li>
</ul>
<p>有四种特殊情况下，<code>finally</code>块不会执行：</p>
<ol>
<li>在<code>finally</code>语句块第一行发生了异常。</li>
<li>在前面的代码中使用了<code>System.exit()</code>退出程序。</li>
<li>程序所在的线程死亡。</li>
<li>关闭CPU。</li>
</ol>
<h2 id="泛型"><a class="markdownIt-Anchor" href="#泛型"></a> 泛型</h2>
<p>如果一个方法接收<code>List&lt;Object&gt;</code>作为形式参数，那么如果尝试将<code>List&lt;String&gt;</code>的对象作为实际参数传进去，就会发现无法通过编译。尽管<code>String</code>是<code>Object</code>的子类，但是实际上会<strong>产生隐含的类型转换问题</strong>，所以编译器是禁止这样的行为的。</p>
<h3 id="类型擦除"><a class="markdownIt-Anchor" href="#类型擦除"></a> 类型擦除</h3>
<p>在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数会被编译器在编译的时候去掉，这个过程就叫做<strong>类型擦除</strong>。比如，<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>等类型在编译之后都会变成<code>List</code>。JVM看到的只有<code>List</code>，而由泛型附加的类型信息对于JVM来说是不可见的。</p>
<h3 id="通配符"><a class="markdownIt-Anchor" href="#通配符"></a> 通配符</h3>
<p>在使用泛型类的时候，既可以指定一个具体的类型，如<code>List&lt;String&gt;</code>就声明了具体类型是<code>String</code>类型；但也可以通过通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就表示了<code>List</code>中包含的元素类型是未知的，也就意味着所有类型都是可以的。</p>
<p>但注意<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。因为<code>List&lt;Object&gt;</code>确定了<code>List</code>中包含的是<code>Object</code>及其子类，在使用的时候都可以通过<code>Object</code>来进行引用，而<code>List&lt;?&gt;</code>其中包含的元素是不确定的。如果其包含的是<code>String</code>类型的，那往里添加<code>Integer</code>类型的元素就是错误的。</p>
<p>在某些情况下，可以使用<strong>上下界</strong>来限制未知类型的范围。如通过<code>List&lt;? extends Number&gt;</code>来说明<code>List</code>中可能包含的元素类型是<code>Number</code>及其子类。而<code>List&lt;? super Number&gt;</code>则说明<code>List</code>中包含的是<code>Number</code>及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。</p>
<h2 id="注解"><a class="markdownIt-Anchor" href="#注解"></a> 注解</h2>
<blockquote>
<p>注解是绑定到程序源代码元素的元数据，对运行代码的操作没有影响。</p>
</blockquote>
<ul>
<li>编译器信息：使用注解，编译器可以检测错误或者抑制警告</li>
<li>编译时和部署时的处理：软件编译工具可以处理注解并生成代码，配置文件等等</li>
<li>运行时处理：可以在运行时检查注解以自定义程序的行为</li>
</ul>
<h3 id="常见注解"><a class="markdownIt-Anchor" href="#常见注解"></a> 常见注解</h3>
<ul>
<li><code>@Override</code>：标记方法是是否覆盖了父类中声明的元素</li>
<li><code>@Deprecated</code>：表示该元素已经弃用并且不应再使用</li>
<li><code>@SuppressWarnings</code>：告知编译器禁止特定警告</li>
<li><code>FunctionalInterface</code>：在Java8中引入，表明声明类型是一个功能接口，可以使用Lambda表达式提供其实现</li>
</ul>
<h2 id="特性"><a class="markdownIt-Anchor" href="#特性"></a> 特性</h2>
<h3 id="封装"><a class="markdownIt-Anchor" href="#封装"></a> 封装</h3>
<p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p>
<h3 id="继承"><a class="markdownIt-Anchor" href="#继承"></a> 继承</h3>
<p>继承是使用已存在的类的定义作为基础建立类的技术，新的类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p>
<ul>
<li>子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ul>
<h4 id="接口和抽象类的区别"><a class="markdownIt-Anchor" href="#接口和抽象类的区别"></a> 接口和抽象类的区别</h4>
<ol>
<li>接口的方法默认是<code>public</code>，所有方法在接口中不能实现，而抽象类可以有非抽象的方法。</li>
<li>接口中除了static、final变量，不能有其它变量，而抽象类中则不一定。</li>
<li>一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可以通过<code>extends</code>关键字扩展多个接口。</li>
<li>接口方法默认修饰符是<code>public</code>，抽象方法可以有<code>public</code>、<code>protected</code>和<code>default</code>这些修饰符（不能使用<code>private</code>关键字修饰）</li>
</ol>
<h4 id="重载和重写的区别"><a class="markdownIt-Anchor" href="#重载和重写的区别"></a> 重载和重写的区别</h4>
<h5 id="重载"><a class="markdownIt-Anchor" href="#重载"></a> 重载</h5>
<p>发生在同一类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。简单的说，就是<strong>多个方法有相同的名字、不同的参数</strong>，便产生了重载。</p>
<h5 id="重写"><a class="markdownIt-Anchor" href="#重写"></a> 重写</h5>
<p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为<code>private</code>则子类不能重写该方法。</p>
<h3 id="多态"><a class="markdownIt-Anchor" href="#多态"></a> 多态</h3>
<p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p>
<p>在Java中可以有两种形式实现多态：<strong>继承</strong>和<strong>接口</strong>。</p>
<h3 id="构造方法的作用和特性"><a class="markdownIt-Anchor" href="#构造方法的作用和特性"></a> 构造方法的作用和特性</h3>
<p>构造方法的主要作用是完成对类对象的初始化工作。</p>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但是也不能用<code>void</code>声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<h3 id="面向对象和面向过程的区别"><a class="markdownIt-Anchor" href="#面向对象和面向过程的区别"></a> 面向对象和面向过程的区别</h3>
<ul>
<li><strong>面向过程：面向过程比面向对象的性能更高</strong>。因为类调用时需要实例化，开销比较大。但是，面向过程没有面向对象易维护、易复用、易拓展。</li>
<li><strong>面向对象：易维护、易复用、易拓展</strong>。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。</li>
</ul>
<h3 id="jvm-jdk和jre"><a class="markdownIt-Anchor" href="#jvm-jdk和jre"></a> JVM、JDK和JRE</h3>
<h4 id="jvm"><a class="markdownIt-Anchor" href="#jvm"></a> JVM</h4>
<p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p>
<p><strong>字节码</strong></p>
<blockquote>
<p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p>
</blockquote>
<p><strong>Java程序从源代码到运行的步骤</strong></p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kxALHnVleJdYKTR.png" alt="Java程序从源代码到运行的步骤" /></p>
<h4 id="jdk和jre"><a class="markdownIt-Anchor" href="#jdk和jre"></a> JDK和JRE</h4>
<p>JDK是Java Development Kit，是Java SDK。它拥有JRE的一切，还有编译器（javac）和工具（例如javadoc）。<strong>它能够创建和编译程序。</strong></p>
<p>JRE是Java运行时的环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令等。<strong>但它不能用于创建新程序</strong>。</p>
<h3 id="java和c的区别"><a class="markdownIt-Anchor" href="#java和c的区别"></a> Java和C++的区别</h3>
<ul>
<li>都是面向对象的语言，都支持封装、继承和多态</li>
<li>Java<strong>不提供指针</strong>来直接访问内存，程序内存会更加安全</li>
<li>Java的类是<strong>单继承</strong>的，C++支持<strong>多重继承</strong>；Java的接口可以多继承</li>
<li>Java有自动内存管理机制</li>
</ul>
<h2 id="io流"><a class="markdownIt-Anchor" href="#io流"></a> IO流</h2>
<h3 id="分类"><a class="markdownIt-Anchor" href="#分类"></a> 分类</h3>
<ul>
<li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li>
<li>按照操作单元分，可以分为<strong>字节流</strong>和<strong>字符流</strong>；</li>
<li>按照流的角色分，可以分为<strong>节点流</strong>和<strong>处理流</strong>；</li>
</ul>
<p>Java的IO流中的类都是从4个抽象类基类中派生出来的。</p>
<ul>
<li><code>InputStream/Reader</code>：所有的输入流的基类，前者是<strong>字节输入流</strong>，后者是<strong>字符输入流</strong>。</li>
<li><code>OutputStream/Writer</code>：所有的输出流的基类，前者是<strong>字节输出流</strong>，后者是<strong>字符输出流</strong>。</li>
</ul>
<h2 id="集合框架"><a class="markdownIt-Anchor" href="#集合框架"></a> 集合框架</h2>
<h3 id="集合的特点"><a class="markdownIt-Anchor" href="#集合的特点"></a> 集合的特点</h3>
<ul>
<li>集合可以用于存储<strong>对象</strong>。</li>
<li>对象的个数确定的话可以使用数组，对象的个数不确定的话可以使用集合，因为集合是可变长度的。</li>
</ul>
<h3 id="集合和数组的区别"><a class="markdownIt-Anchor" href="#集合和数组的区别"></a> 集合和数组的区别</h3>
<ul>
<li>数组是固定长度的；集合是可变长度的。</li>
<li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li>
<li>数据存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型的。</li>
</ul>
<h3 id="常用的集合类"><a class="markdownIt-Anchor" href="#常用的集合类"></a> 常用的集合类</h3>
<p>Map接口和Collection接口是所有集合框架的父接口：</p>
<ul>
<li>Collection接口的子接口包括：Set接口和List接口</li>
<li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li>
<li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li>
<li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li>
</ul>
<p>ArrayList与LinkedList都是List接口的实现类，因此都实现了List的所有未实现的方法。List接口继承了Collection接口，Collection接口又继承了Iterable接口，因此可以看出List同时拥有了Collection与Iterable接口的特性。</p>
<h3 id="list-set-map-三者的区别"><a class="markdownIt-Anchor" href="#list-set-map-三者的区别"></a> List | Set | Map 三者的区别</h3>
<p>List接口存储一组不唯一（即可以有多个元素引用相同的对象），有序的对象</p>
<p>Set中不允许有重复的集合，不会有多个元素引用相同的对象。</p>
<p>Map是使用键值对来存储。Key是不能重复的，是唯一的，Value的值可以相同。</p>
<h3 id="arraylist"><a class="markdownIt-Anchor" href="#arraylist"></a> ArrayList</h3>
<ul>
<li>ArrayList实现了List接口，即ArrayList实现了<strong>可变大小</strong>的数组。它允许所有元素，包括<code>null</code>。</li>
<li>当更多的元素添加到ArrayList时，它的大小会动态增大。它的元素可以通过<code>get/set</code>的方式直接访问，因为ArrayList本质上是一个数组。</li>
<li>ArrayList没有同步方法，这意味着它不是线程安全的。如果多个线程同时访问一个List，则必须要自己实现访问同步：<code>List list = Collections.synchronizedList(new LinkedList(...));</code></li>
</ul>
<h4 id="arraylist的原理"><a class="markdownIt-Anchor" href="#arraylist的原理"></a> ArrayList的原理</h4>
<h3 id="linkedlist"><a class="markdownIt-Anchor" href="#linkedlist"></a> LinkedList</h3>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/GLP9QzyMZeSu4qs.png" alt="LinkedList的结构" /></p>
<ul>
<li>LinkedList是通过双向链表实现的，添加、删除元素的性能比ArrayList好，但是查询元素的性能较差。</li>
<li>LinkedList没有同步方法，这意味着它不是线程安全的。如果多个线程同时访问一个List，则必须要自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<code>List list = Collections.synchronizedList(new LinkedList(...));</code></li>
</ul>
<h4 id="linkedlist的原理"><a class="markdownIt-Anchor" href="#linkedlist的原理"></a> LinkedList的原理</h4>
<h3 id="arraylist与linkedlist的区别"><a class="markdownIt-Anchor" href="#arraylist与linkedlist的区别"></a> ArrayList与LinkedList的区别</h3>
<ul>
<li>ArrayList是<strong>动态数组</strong>的数据结构实现，而LinkedList是<strong>双向链表</strong>的数据结构实现。</li>
<li>对于随机访问<code>get</code>和<code>set</code>，ArrayList要优于LinkedList，因为<strong>LinkedList需要移动指针</strong>。</li>
<li>对于增删操作<code>add</code>和<code>remove</code>，LinkedList比较占优势，因为<strong>ArrayList要移动数据</strong>。</li>
<li><strong>LinkedList比ArrayList更占内存</strong>，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li>
</ul>
<h3 id="vector"><a class="markdownIt-Anchor" href="#vector"></a> Vector</h3>
<p>Vector和ArrayList几乎一样，区别是<strong>Vector是线程安全的</strong>。因为这个原因，所以它的<strong>性能较差</strong>，开销比ArrayList大。所以通常情况下推荐使用ArrayList。</p>
<p>Vector类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。这意味着，Vector是「基于数组实现的」。</p>
<h3 id="hashmap"><a class="markdownIt-Anchor" href="#hashmap"></a> HashMap</h3>
<blockquote>
<p>HashMap是基于Map接口的实现，存储键值对时，它可以接收为null的键和值（其键和值都可以为空），是非同步的，非线程安全的。</p>
<p>Hash table based implementation of the Map interface. The implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is unsynchronized and permits nulls.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p>
</blockquote>
<ol>
<li>
<p>HashMap的工作原理</p>
</li>
<li>
<p><code>get()</code>和<code>put()</code>的原理</p>
</li>
<li>
<p>hash的实现是怎么样的，为什么要这样实现？</p>
</li>
<li>
<p>如果HashMap的大小超过了负载因子(load factor)定义的容量怎么办</p>
</li>
</ol>
<h3 id="hashset"><a class="markdownIt-Anchor" href="#hashset"></a> HashSet</h3>
<h3 id="hashtable"><a class="markdownIt-Anchor" href="#hashtable"></a> HashTable</h3>
<h3 id="concurrenthashmap"><a class="markdownIt-Anchor" href="#concurrenthashmap"></a> ConcurrentHashMap</h3>
<p>ConcurrentHashMap同样也分为1.7、1.8的版本，两者在实现上是略有不同的。</p>
<h4 id="base-17"><a class="markdownIt-Anchor" href="#base-17"></a> Base 1.7</h4>
<blockquote>
<p>ConcurrentHashMap数据结构为一个Segment数组，Segment的数据结构又为HashEntry的数组，HashEntry存的就是键值对，可以构成链表的结构。</p>
</blockquote>
<p>HashEntry是用来封装散列映射表中的键值对的。在HashEntry类中，key、hash和next域都被声明为<code>final</code>类型，value域则被声明为<code>volatile</code>类型。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HashEntry</span>&lt;<span class="title">K</span>, <span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    <span class="keyword">volatile</span> V value;</span><br><span class="line">    <span class="keyword">volatile</span> HashEntry&lt;K, V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在JDK1.8之前，ConcurrentHashMap是使用了「<strong>分段锁</strong>」的方式，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据<code>key.hashCode()</code>来决定把key放到哪个HashTable中，即把Map分成了N个<strong>Segment</strong>，put和get的时候，都是现根据<code>key.hashCode()</code>算出放到哪个Segment中。</p>
<p>原理上来说，ConcurrentHashMap的Segment继承于ReentrantLock，理论上ConcurrentHashMap支持CurrencyLevel（Segment分组数量）的线程并发。每当一个线程占用锁访问一个Segment时，不会影响到其它的Segment。</p>
<p><strong>put的流程</strong>：</p>
<ol>
<li>将当前的Segment中的table通过key的hashcode值定位到HashEntry</li>
<li>遍历该HashEntry，如果不为空则判断传入的key和当前遍历的key是否相等，相等则覆盖旧的value</li>
<li>不为空，则需要新建一个HashEntry并加入到Segment中，同时会先判断是否需要扩容</li>
<li>最后会解除第1步中获取的当前Segment的锁</li>
</ol>
<p><strong>get的流程</strong>：</p>
<p>只需要将Key通过Hash之后，定位到具体的Segment，再通过一次Hash定位到具体的元素上。由于HashEntry中的value属性是由<code>volatile</code>关键词修饰的，保证了内存可见性，所以每次获取到的都是最新值。<strong>整个过程都是不需要加锁的</strong>。</p>
<h4 id="base-18"><a class="markdownIt-Anchor" href="#base-18"></a> Base 1.8</h4>
<p>1.8版本之后，抛弃了Segment分段锁的方式，而是采用了<strong>CAS+synchronized</strong>来保证并发的安全性。</p>
<p><strong>put的流程</strong>：</p>
<ul>
<li>根据key计算出hashcode</li>
<li>判断是否需要进行初始化</li>
<li>通过key定位出的Node，如果为空就表示当前位置可以写入数据，利用CAS尝试写入，失败则自旋保证成功；</li>
<li>如果当前位置<code>hashcode == MOVED == -1</code>，说明需要扩容</li>
<li>如果都不满足，则使用<code>synchronized</code>锁写入数据</li>
<li>如果数量大于<code>TREEIFY_THRESHOLD</code>则通过<code>treeifyBin</code>转化为红黑树</li>
</ul>
<p><strong>get的流程</strong>：</p>
<ul>
<li>根据计算出的hashcode寻址，如果在桶上，则直接返回值</li>
<li>如果是红黑树，则按照红黑树的方式获取值</li>
<li>如果不满足，则按照链表的方式遍历获取值</li>
</ul>
<h3 id="hashmap与hashtable的区别"><a class="markdownIt-Anchor" href="#hashmap与hashtable的区别"></a> HashMap与HashTable的区别</h3>
<ul>
<li><strong>HashMap是非线程安全的</strong>，<strong>HashTable是线程安全的</strong>，HashTable内部的方法基本都用了同步锁<code>synchronized</code>修饰。</li>
<li>因为线程安全的问题，所以HashMap要比HashTable效率更高，这也是HashTable几乎要被淘汰的原因。</li>
<li><strong>HashMap允许有null值</strong>的存在，而在<strong>HashTable中键值只要有一个null</strong>，就会直接抛出空指针异常。</li>
</ul>
<blockquote>
<p>如果使用的JDK5以上的版本，又需要满足线程安全的话，推荐使用ConcurrentHashMap。</p>
</blockquote>
<p>可以使用如下两种方法让HashMap同步，即线程安全：</p>
<ul>
<li><code>Collections.synchronized(hashMap)</code></li>
<li>使用ConcurrentHashMap</li>
</ul>
<h3 id="hashmap与hashset的区别"><a class="markdownIt-Anchor" href="#hashmap与hashset的区别"></a> HashMap与HashSet的区别</h3>
<ul>
<li>HashMap实现了Map接口，HashSet实现了Set接口，所以HashSet中不允许有重复的元素</li>
<li>HashMap存储的是键值对，HashSet仅存储了对象</li>
<li>HashMap使用key来计算hashcode的值，HashSet使用成员对象来计算hashcode的值。如果两个对象的hashcode值相同，就需要使用<code>equals()</code>方法来判断对象的相等性，如果两个对象不同，就返回false。</li>
<li>HashMap比较快，因为是使用唯一的键来获取对象，HashSet较HashMap来说比较慢。</li>
<li>HashMap和HashSet都是线程不安全的</li>
</ul>
<blockquote>
<p>使用HashSet，首先要确保在将对象存储在HashSet之前，确保对象重写<code>equals()</code>和<code>hashCode()</code>方法，这样才能比较对象的值是否相等，因为需要确保set中没有存储相等的对象。</p>
</blockquote>
<h3 id="hashmap与concurrenthashmap的区别"><a class="markdownIt-Anchor" href="#hashmap与concurrenthashmap的区别"></a> HashMap与ConcurrentHashMap的区别</h3>
<ul>
<li>HashMap是线程不安全的，ConcurrentHashMap是线程安全的。</li>
<li><strong>HashMap的键值对允许有null</strong>，但是<strong>ConCurrentHashMap都不允许</strong>。</li>
</ul>
<h3 id="collections工具类常用方法"><a class="markdownIt-Anchor" href="#collections工具类常用方法"></a> Collections工具类常用方法：</h3>
<ol>
<li>排序</li>
<li>查找，替换操作</li>
<li>同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包的并发集合）</li>
</ol>
<p><strong>排序操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span>	<span class="comment">// 反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span> <span class="comment">// 随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span> <span class="comment">// 按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span> <span class="comment">// 定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">// 交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span> <span class="comment">// 旋转。当distance为正数时，将list后distatnce个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure>
<p><strong>查找，替换操作</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span> <span class="comment">// 对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span>	<span class="comment">// 根据元素的自然顺序，返回最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span> <span class="comment">// 根据定制排序，返回最大元素，排序规则由Comparatator类控制</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span> <span class="comment">// 用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span> <span class="comment">// 统计元素出现个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span> <span class="comment">// 统计target在list中第一次出现的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span> <span class="comment">// 用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure>
<p><strong>同步控制</strong></p>
<p><strong>因为<code>HashSet</code>、<code>TreeSet</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>TreeMap</code>都是线程不安全的。</strong><code>Collections</code>提供了多个<code>synchronizedXxx()</code>静态方法可以把它们包装成线程同步的集合。</p>
<p><strong>最好不要使用下面这些方法，因为效率非常低</strong>。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt; c);</span><br><span class="line">synchronizedList(List&lt;T&gt; list);</span><br><span class="line">synchronizedMap(Map&lt;K, V&gt;, m);</span><br><span class="line">synchronizedSet(Set&lt;T&gt; s);</span><br></pre></td></tr></table></figure>
<h3 id="arrays类的常见操作"><a class="markdownIt-Anchor" href="#arrays类的常见操作"></a> Arrays类的常见操作</h3>
<ol>
<li>排序：<code>sort()</code></li>
<li>查找：<code>binarySearch()</code></li>
<li>比较：<code>equals()</code></li>
<li>填充：<code>fill()</code></li>
<li>转列表：<code>asList()</code></li>
<li>转字符串：<code>toString()</code></li>
<li>赋值：<code>copyOf()</code></li>
</ol>
<h2 id="线程"><a class="markdownIt-Anchor" href="#线程"></a> 线程</h2>
<h3 id="开启线程的方式"><a class="markdownIt-Anchor" href="#开启线程的方式"></a> 开启线程的方式</h3>
<h4 id="thread类和runnable接口实现多线程哪个更好"><a class="markdownIt-Anchor" href="#thread类和runnable接口实现多线程哪个更好"></a> Thread类和Runnable接口实现多线程哪个更好</h4>
<h4 id="callable和runnable接口的区别是什么"><a class="markdownIt-Anchor" href="#callable和runnable接口的区别是什么"></a> Callable和Runnable接口的区别是什么</h4>
<ul>
<li>Callable只能运行在线程池中，而Runnable既能运用在Thread中，又能运行在线程池中。</li>
<li>Callable是一个<strong>泛型接口</strong>，该接口又一个返回值的<code>call()</code>函数，而Runnable的<code>run()</code>函数不能将结果返回给客户程序。</li>
</ul>
<h2 id="23种设计模式span-iddesignpattern"><a class="markdownIt-Anchor" href="#23种设计模式span-iddesignpattern"></a> 23种设计模式<span id="designpattern"></h2>
<p>这23种设计模式主要分为3种类型的模式：</p>
<ul>
<li>创建型模式：对象实例化的模式，用于解耦对象的实例化过程</li>
<li>结构性模式：把类或对象结合在一起形成一个更大的结构</li>
<li>行为型模式：类和对象如何交互，划分责任和算法</li>
</ul>
<p>——-</p>
<ul>
<li>单例模式：某个类只能有一个实例，提供一个全局的访问点</li>
<li>简单工厂：一个工厂类根据传入的参数来决定是创建哪个产品的实例化（重载）</li>
<li>工厂方法：定义一个创建对象的接口，让子类去决定对哪个类进行实例化</li>
<li>抽象工厂：创建相关或者依赖对象的家族，但无需明确指定具体的类</li>
<li>建造者模式：封装一个复杂对象的构建过程，并且可以按照步骤构造</li>
<li>原型模式：通过复制现有的实例来创建新的实例</li>
<li>适配器模式：将一个类的方法接口转化成客户希望的另外一个接口</li>
<li>组合模式：将对象组合成树型结构，以表示“部分-整体”的层次结构</li>
<li>装饰模式：动态地给对象添加新的功能</li>
<li>代理模式：为其它对象提供一个代理，以便控制这个对象的访问</li>
<li>享元模式：通过共享技术来有效地支持大量细粒度的对象</li>
<li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口</li>
<li>桥接模式：将抽象的部分与它实现的部分分离，使它们都可以独立的变化</li>
<li>模板模式：定义一个算法结构，但是将一些步骤延迟到子类实现</li>
<li>解释器模式：给定一个语言，定义它的文法的一种表示，并且定义一个解释器</li>
<li>策略模式：定义一系列的算法，把它们封装起来，并且使它们可以相互替换</li>
<li>状态模式：允许一个对象在其对象内部改变时，就改变它的行为</li>
<li>观察者模式：对象间的一对多的依赖关系</li>
<li>备忘录模式：在不破坏封装的前提下，保持对象的内部状态</li>
<li>中介者模式：用一个中介对象来封装一系列的对象交互</li>
<li>命令模式：将命令请求封装为一个对象，使得可以用不同的请求来进行参数化</li>
<li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能</li>
<li>责任链模式：将请求的发送者和接收者解耦，使得每个对象都有处理这个请求的机会</li>
<li>迭代器模式：一种遍历访问聚合对象中各个元素的方法，不暴露该对象的内部结构</li>
</ul>
<h3 id="单例模式"><a class="markdownIt-Anchor" href="#单例模式"></a> 单例模式</h3>
<p>单例模式下，对应类只能生成一个实例。但是也有很多种不同的写法。</p>
<h4 id="饿汉模式"><a class="markdownIt-Anchor" href="#饿汉模式"></a> 饿汉模式</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式在类加载时就完成了初始化操作，所以类加载速度慢，但是获取对象的速度快。这种方式基于类加载机制，避免了多线程的同步问题，但是也不能确定有其它的方式或者其它的静态方法会导致类加载。此时的初始化<code>instance</code>是没有达到<strong>懒加载</strong>的效果的。</p>
<h4 id="懒汉模式线程不安全"><a class="markdownIt-Anchor" href="#懒汉模式线程不安全"></a> 懒汉模式（线程不安全）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>懒汉模式使用了懒加载的模式，申明了一个静态对象，只在用户第一次调用时需要初始化。虽然节约了资源，但是第一次加载时仍需要实例化，速度稍慢，而且<strong>在多线程下不能工作</strong>。因为当有多个线程并行调用<code>getInstance()</code>的时候，就会创建多个实例了。</p>
<h4 id="懒汉模式线程安全"><a class="markdownIt-Anchor" href="#懒汉模式线程安全"></a> 懒汉模式（线程安全）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>为了解决线程不安全的问题，就是将整个<code>getInstance()</code>方法设置为同步（<code>synchronized</code>）。这种写法能够在多线程中很好的工作，但是每次调用<code>getInstance()</code>方法时都需要进行同步，会造成不必要的同步开销。因为在任何时候都只能有一个线程调用<code>getInstance()</code>方法。但是大部分时候我们是用不到同步的，只需要在第一次调用时用到，所以<strong>不建议使用这种方式</strong>。</p>
<h4 id="双重检验锁模式double-checked-locking-pattern"><a class="markdownIt-Anchor" href="#双重检验锁模式double-checked-locking-pattern"></a> 双重检验锁模式（double checked locking pattern）</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>DCL模式是一种使用同步块加锁的方法，在<code>getSingleton()</code>方法中对<code>instance</code>进行了两次判空，第一次是为了不必要的同步，第二次是在<code>instance == null</code>的情况下才创建实例。之所以还要在同步块内再检验一次，就是因为可能会有多个线程一起进入同步块外的<code>if</code>，如果不进行二次检验就会生成多个实例了。</p>
<p>但是上面这段代码仍然有问题。主要是<code>instance = new Singleton()</code>这句代码，<strong>并非是一个原子操作</strong>。在JVM中,这句代码会执行下面三个操作:</p>
<ul>
<li>给<code>instance</code>分配内存</li>
<li>调用<code>Singleton</code>的构造函数来初始化成员变量</li>
<li>将<code>instance</code>对象指向分配的内存空间（执行完这步后<code>instance</code>就为非空了）</li>
</ul>
<p>但是在JVM的即时编译器中存在指令重排序的优化，即第二步和第三步的顺序不能保证谁先执行。解决方法就是<strong>将<code>instance</code>变量声明成<code>volatile</code>就可以了</strong>。因为<code>volatile</code>是可以禁止指令重排序优化。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>volatile</code>的DCL模式的优点是资源利用率高，第一次执行<code>getInstance()</code>时，单例对象才会被实例化，效率高。缺点是第一次加载时反应会慢一些。</p>
<h4 id="静态内部类单例模式"><a class="markdownIt-Anchor" href="#静态内部类单例模式"></a> 静态内部类单例模式</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方法也是《Effect Java》推荐使用的。在第一次加载<code>Singleton</code>类时并不会初始化<code>sInstance</code>，只有第一次调用<code>getInstance()</code>方法的时候虚拟机加载<code>SingletonHolder</code>并初始化<code>sInstance</code>。这样首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于<code>getInstance()</code>方法没有任何线程锁定，因此其性能不会造成任何影响。</p>
<p>由于<code>SingletonHolder</code>是私有的，除了<code>getInstance()</code>方法之外没有方法能够访问它，所以它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。</p>
<h4 id="枚举单例"><a class="markdownIt-Anchor" href="#枚举单例"></a> 枚举单例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>用枚举实现单例的方式十分简单。默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，而且能够防止反序列化导致创建新的对象。但是大部分应用开发很少使用到枚举，因为可读性不是很高，不建议使用。</p>
<h5 id="枚举单例与饿汉模式的区别"><a class="markdownIt-Anchor" href="#枚举单例与饿汉模式的区别"></a> 枚举单例与饿汉模式的区别</h5>
<h4 id="使用容器实现单例模式"><a class="markdownIt-Anchor" href="#使用容器实现单例模式"></a> 使用容器实现单例模式</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Objectinstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!objMap.containsKey(key)) &#123;</span><br><span class="line">            objMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用<code>SingletonManager</code>将多种单例统一管理，使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现的细节，降低了耦合度。</p>
<h3 id="简单工厂模式"><a class="markdownIt-Anchor" href="#简单工厂模式"></a> 简单工厂模式</h3>
<p>简单工厂模式（Simple Factory Pattern），又称为静态工厂方法（Static Factory Method）模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。它专门定义了一个类来负责创建其它类的实例，被创建的实例通常都会具有共同的父类。</p>
<p>之所以要使用简单工厂模式，是因为要把“产品”和“生产”完全分开。用户只需要知道自己要使用哪些产品，以及如何使用产品即可，而产品的生产则由工厂来完成。因为不同的产品可能仅仅是因为某些参数的不同而作用于不同的场景，所以工厂只需要根据传进来的不同的参数去生产具体的产品给消费者使用。</p>
<p>简单工厂模式包含以下角色：</p>
<ul>
<li>Factory（工厂角色）：工厂角色负责实现创建所有实例的内部逻辑</li>
<li>Product（抽象产品角色）：抽象产品角色是所创建的所有产品（实例）的父类，负责描述所有产品（实例）共有的公共接口</li>
<li>ConcreteProduct（具体产品角色）：具体产品角色是这个角色的具体类的实例，是抽象产品角色根据不同参数的具体实现</li>
</ul>
<p>（或者让Product作为具体的产品角色，AbstractProduct作为抽象产品角色）。</p>
<p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/04/YpjgMt.jpg" alt="简单工厂模式" /></p>
<p>简单工厂模式的优点：</p>
<ul>
<li>简单工厂模式实现了对于责任的分割，提供了专门的工厂类用于创建对象，而客户端免除了直接创建产品对象的责任，而是仅仅消费产品；</li>
<li>客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类对应的参数即可；</li>
<li>可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，一定程度上提高了系统的灵活性；</li>
<li><strong>从产品的角度上</strong>符合“开闭原则”</li>
</ul>
<p>简单工厂模式的缺点：</p>
<ul>
<li>因为工厂类集中了所有的产品创建的逻辑，如果一旦不能正常工作，整个系统都会受到影响；</li>
<li>使用简单工厂模式会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度；</li>
<li>系统扩展困难，一旦添加新的产品就要修改工厂类的逻辑，<strong>从工厂的角度上</strong>是不符合“开闭原则”的；</li>
<li>简单工厂模式由于使用了静态工厂方法，造成了工厂角色无法形成基于继承的结构；</li>
</ul>
<p>适用场景：</p>
<ul>
<li>工厂类负责创建的对象比较少的情况。因为创建的对象较少，就不会造成工厂方法中的业务逻辑太过复杂；</li>
<li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li>
</ul>
<h3 id="工厂方法模式"><a class="markdownIt-Anchor" href="#工厂方法模式"></a> 工厂方法模式</h3>
<p>工厂方法模式（Factory Method Pattern）又称为工厂模式，从名字就可以看出相对于简单工厂模式，工厂模式会更复杂一些。在该模式中，工厂父类负责定义创建产品对象的公共接口，而工厂实现类则负责生成具体的产品对象。抽象产品类和具体产品类的逻辑则与简单工厂模式一致。</p>
<p>工厂方法模式包含以下角色：</p>
<ul>
<li>Product（抽象产品）：定义具体产品的公共接口；</li>
<li>ConcreteProduct（具体产品）：继承抽象产品类，定义生产的具体产品；</li>
<li>Factory（抽象工厂）：定义具体工厂的公共接口；</li>
<li>ConcreteFactory（具体工厂）：定义创建对应具体产品实例的方法；</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/ZSjp4aeACOIbMyL.png" alt="工厂方法模式" /></p>
<p>工厂模式的优点：</p>
<ul>
<li>更加符合“开闭原则”：当新增一种产品时，只需要增加响应的具体产品类和具体工厂类，抽象工厂和抽象产品无需修改；</li>
<li>符合“单一职责原则”：每个具体工厂类都只负责创建对应的产品；</li>
<li>不适用静态工厂方法：可以形成基于继承的结构</li>
</ul>
<p>工厂模式可以说是简单工厂模式的一种抽象和拓展，在保留了简单工厂的封装有点的同时，让扩展变得更简单，实现了继承的结构，增加了多态性的体现。</p>
<p>工厂模式缺点：</p>
<ul>
<li>添加新产品时，既要增加新的具体产品类，又要增加新的具体工厂类，系统类的个数成对增加，增加了系统的复杂度；</li>
<li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到OOM、反射等技术，增加了实现难度；</li>
<li>一个具体工厂类只能对应一个产品；</li>
<li>如果需要更换产品而不是新增产品，就仍然需要修改实例化的具体工厂类；</li>
</ul>
<p>适用场景：</p>
<ul>
<li>当一个类希望通过子类来指定创建对象</li>
<li>当一个类不知道它所需要的对象的类</li>
<li>将创建对象的任务委托给多个具体工厂类的某一个，客户端在使用时可以无须关心是哪一个具体工厂类创建了该产品，需要时再动态指定即可，可以将具体工厂类的类名存储在配置文件或者数据库中</li>
</ul>
<h3 id="抽象工厂模式"><a class="markdownIt-Anchor" href="#抽象工厂模式"></a> 抽象工厂模式</h3>
<p>抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p>
<p>因为工厂模式中，每个工厂只能创建一个类，十分浪费；抽象工厂就解决了这个问题。抽象工厂中每个工厂都可以创建多种类的产品。</p>
<p>抽象工厂模式包含以下角色：</p>
<ul>
<li>抽象产品族：描述了抽象产品的公共接口；</li>
<li>抽象产品：描述了具体产品的公共接口；</li>
<li>具体产品：描述了具体产品；</li>
<li>抽象工厂：描述了具体工厂的公共接口；</li>
<li>具体工厂：描述了具体工厂；</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Fp9tThIs8Z5HOyd.png" alt="抽象工厂模式" /></p>
<p>具体代码如下所示：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建抽象产品族类，定义抽象产品的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建抽象产品类，定义具体产品的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerProduct</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建抽象产品类，定义具体产品的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MouldProduct</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建具体产品类，定义生产的具体产品</span></span><br><span class="line"><span class="comment">// 容器A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerProduct</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">ContainerProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了容器产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerProductB</span> <span class="keyword">extends</span> <span class="title">ContainerProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了容器产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模具A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouldProductA</span> <span class="keyword">extends</span> <span class="title">MouldProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了模具产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模具B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouldProductB</span> <span class="keyword">extends</span> <span class="title">MouldProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了模具产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建抽象工厂类，定义具体工厂的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">ManufactureMould</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建具体工厂类，定义工厂创建具体产品实例的方法</span></span><br><span class="line"><span class="comment">// 生产A产品的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContainerProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureMould</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MouldProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产B产品的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContainerProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureMould</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MouldProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类（调用类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FactoryA mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        FactoryB mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        <span class="comment">//A厂当地客户需要容器产品A</span></span><br><span class="line">        mFactoryA.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//A厂当地客户需要模具产品A</span></span><br><span class="line">        mFactoryA.ManufactureMould().Show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B厂当地客户需要容器产品B</span></span><br><span class="line">        mFactoryB.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//B厂当地客户需要模具产品B</span></span><br><span class="line">        mFactoryB.ManufactureMould().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>抽象工厂模式的优点：</p>
<ul>
<li>降低耦合：抽象工厂模式将具体产品的创建放在了具体工厂的子类中</li>
<li>更符合“开闭原则”：新增一种产品时，则需要增加新的具体产品类和相应的工厂子类即可。</li>
</ul>
<p>抽象工厂模式的缺点：</p>
<ul>
<li>很难支持产品的变化：因为抽象工厂接口中已经确定了可以被创建的产品集合，所以如果需要添加新产品的话，就必须去修改抽象工厂的接口，这样就违背了“开闭原则”。</li>
</ul>
<h3 id="建造者模式"><a class="markdownIt-Anchor" href="#建造者模式"></a> 建造者模式</h3>
<blockquote>
<p>建造者模式（Builder Pattern）是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p>
</blockquote>
<p>通俗的说话就是，建造者模式就是如何一步步构建一个包含多个组成部件的对象，相同的构建过程却可以创建出不同的产品。它允许用户只通过指定复杂对象的类型和内容就可以构建它们，而不要知道内部的具体构建细节。</p>
<p>建造者模式包含以下角色：</p>
<ul>
<li>Builder：抽象建造者。给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口是独立于应用程序的商业逻辑的。它必须实现接口要求的两种方法。一个是建造方法<code>buildPart()</code>，一个是返回结构方法<code>getResult()</code>。</li>
<li>ConcreteBuilder：具体建造者。这个角色的任务在于实现抽象建造者Builder声明的接口，给出一步步完成创建产品实例的操作；在建造过程完成后，提供产品的实例。</li>
<li>Director：导演者。这个角色负责调用较早者角色以创建产品对象。这个角色不了解任何关于产品的知识，只是负责调用。</li>
<li>Product：产品。产品就是被建造的对象。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/R9YFaP3tNVreupX.png" alt="建造者模式" /></p>
<p>比如以下一个例子可以用于描述KFC如何创建套餐的。KFC套餐是一个复杂的对象，它一般包含主食（如汉堡、鸡翅等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分。那么服务员这个对象就要根据客户的需要，负责组装这些套餐返回给顾客。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/41z2qbdDvwVPymE.png" alt="KFC如何创建套餐的例子" /></p>
<p>在上面这个模型中，KFCWaiter就是导演者角色。它并不知道具体的主食、饮料等是如何做出来，只负责组装（调用Builder对象），然后与客户端交流。MealBuilder在这里就是抽象建造者对象，里面的<code>getMeal()</code>方法就是从SubMealBuilder这个具体建造者对象得到建造好的产品。Meal是Product对象。</p>
<p>建造者模式的优点：</p>
<ul>
<li>在建造者模式中，客户端是不知道产品内部组成的细节的，它只与Director交互。通过将产品与产品本身的创建过程解耦，使得相同的创建过程却可以创建出不同的产品对象；</li>
<li>同样的，每一个具体建造者也是相对独立的。用户可以使用不同的具体建造者建造出不同的产品对象；</li>
<li>可以更加精细地控制产品的创建过程；</li>
<li>增加新的具体建造者是无需修改原有类库的代码的，符合<strong>开闭原则</strong>。</li>
</ul>
<p>建造者模式的缺点：</p>
<ul>
<li>所创建的产品一般具有较多的共同点（如上面例子中饮料的可乐、果汁等）。如果产品之间差异性很大的话，就不适用于建造者模式（因为使用范围受到一定的限制）；</li>
<li>如果产品的内部变化很复杂，就需要定义很多的具体建造类来实现这种变化，一个是不能满足的，这样系统会很庞大。</li>
</ul>
<h3 id="原型模式"><a class="markdownIt-Anchor" href="#原型模式"></a> 原型模式</h3>
<p>原型模式是通过给定一个原型对象来指明所有创建的对象的类型，然后用这个原型对象提供的复制方法创建出更多同类型的对象。</p>
<p>即原型模式要求对象实现一个可以克隆自身的接口（类型）。这样一来，通过原型实例创建新的对象，就不需要关心这个实例本身的类型，只需要实现克隆自身的方法，也无需再去通过<code>new</code>去创建。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/4B3Rpj7UT56WOHZ.png" alt="原型模式" /></p>
<p>原型对象主要就是用于对象的复制，其核心就是上图中的原型类Prototype。Prototype类需要具备以下两个条件：</p>
<ul>
<li>实现<code>Cloneable</code>接口。它的作用是在运行时通知虚拟机可以安全地实现此接口的类上使用<code>clone</code>方法。在JVM中，只有实现了这个接口的类才可以被拷贝；</li>
<li>重写Object类中的<code>clone</code>方法。</li>
</ul>
<p>总之，原型模式十分简单易理解，实现一个接口，重写一个方法就实现了原型模式。在实际应用中，原型模式很少单独出现，经常与其它模式混用，其原型类Prototype也常用抽象类来替代。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原型模式实现类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            ConcretePrototype clonecp = (ConcretePrototype) cp.clone();</span><br><span class="line">            clonecp.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>原型模式的优点：</p>
<ul>
<li>简化对象的创建；</li>
<li>使用原型模式创建对象比直接<code>new</code>一个对象的性能要好得多，因为<code>clone</code>方法是一个本地方法。</li>
</ul>
<p>使用原型模式的注意事项：</p>
<ul>
<li>使用原型模式复制对象不会调用类的构造方法</li>
<li>深拷贝与浅拷贝。Object类的<code>clone</code>方法只会拷贝对象中的基本数据类型，对于数组、容器对象、引用对象等都不会去拷贝，所以是浅拷贝。</li>
</ul>
<hr />
<h3 id="外观模式"><a class="markdownIt-Anchor" href="#外观模式"></a> 外观模式</h3>
<blockquote>
<p>外观模式定义了一个高层接口，为子系统中的一组接口提供了统一的接口。</p>
</blockquote>
<p>外观模式包含了如下两个角色：</p>
<ul>
<li>外观角色（Facade）：在客户端可以调用它的方法，在外观角色中可以知道相关的子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求都委派到相应的子系统中去，传递给相应的子系统对象去处理；</li>
<li>子系统角色（SubSystem）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不只是一个单独的类，而是一个类的集合，它实现了子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它要处理从外观类传过来的请求；子系统是不知道外观的存在的；</li>
</ul>
<p>外观模式的本质是<strong>封装交互，简化调用</strong>。它的目的不是给予子系统添加新的功能接口，而是让外部减少与子系统内多个模块的交互，松散耦合，让外部更简单地使用子系统。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统角色，由若干个类组成</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统1中的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统1中的方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统2中的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统2中的方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把子系统中的几个方法汇总到了一起</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FacadeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SubClass1 s1 = <span class="keyword">new</span> SubClass1();</span><br><span class="line">        s1.method1();</span><br><span class="line">        SubClass2 s2 = <span class="keyword">new</span> SubClass2();</span><br><span class="line">        s2.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FacadeClass fc = <span class="keyword">new</span> FacadeClass();</span><br><span class="line">        fc.FacadeMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>外观模式为复杂子系统提供了一个简单的接口，并不为子系统添加新的功能和行为；</li>
<li>外观模式实现了子系统与客户端之间的松耦合的关系；</li>
<li>外观模式没有封装子系统的类，只是提供了简单的接口。如果有需要，客户其实也是能直接使用子系统的类的。</li>
<li>外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而非单个类的层次。</li>
</ul>
<h3 id="适配器模式"><a class="markdownIt-Anchor" href="#适配器模式"></a> 适配器模式</h3>
<p>适配器模式（Adapter Pattern），将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，别名为包装器（Wrapper）。</p>
<p>适配器模式包含以下角色：</p>
<ul>
<li>Target：目标抽象类</li>
<li>Adapter：适配器类</li>
<li>Adaptee：适配者类</li>
<li>Client：客户类</li>
</ul>
<p>有两种适配器模式，一种是类的适配器模式，一种是对象的适配器模式。它们都是把适配的类的API转换成目标类的API。</p>
<h4 id="类的适配器模式"><a class="markdownIt-Anchor" href="#类的适配器模式"></a> 类的适配器模式</h4>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/PtfWRNkJIDCGF5s.png" alt="类的适配器模式" /></p>
<p>从上图可以看出，Target目标类想要调用<code>Request</code>方法，但是适配者类Adaptee是没有这个方法的，那么就需要中间有一个适配器类Adapter，把Adaptee的API与Target的API衔接起来（通过继承Adaptee，实现Target接口）。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target mAdapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        mAdapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="对象的适配器模式"><a class="markdownIt-Anchor" href="#对象的适配器模式"></a> 对象的适配器模式</h4>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/TbVk1N6WplAKitw.png" alt="对象的适配器模式" /></p>
<p>对象的适配器模式就是把<strong>继承</strong>改在了Adapter的内部去实现。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee.SepcificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target mAdapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        mAdapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr />
<p>适配器模式的优点：</p>
<ul>
<li>将目标类Target与适配者类Adaptee解耦，中间通过一个适配器类Adapter完成；</li>
<li>增加了类的透明性和复用性；</li>
<li>灵活性和拓展性非常好</li>
<li><strong>类适配器模式</strong>：由于适配器类Adater是适配者类Adaptee的子类，所以在适配器类Adapter还可以重写适配者Adaptee的一些方法，灵活性很强；</li>
<li><strong>对象适配器模式</strong>：一个对象适配器可以把不同的适配者Adaptee适配到同一个目标，即把适配者类Adaptee和它的子类都适配到目标接口Target。</li>
</ul>
<p>适配器模式的缺点：</p>
<p>因为Java等语言不支持多继承，所以一次最多只能适配一个适配者类Adaptee。</p>
<h3 id="桥接模式"><a class="markdownIt-Anchor" href="#桥接模式"></a> 桥接模式</h3>
<p>桥接模式（Bridge Pattern）的主要特点是把抽象（Abstraction）与实现（Implementation）分离开，从而保持各部分的独立性以及对应它们的功能扩展。</p>
<p>桥接模式的角色：</p>
<ul>
<li>Client：调用者</li>
<li>Abstraction：抽象类接口。它的角色就是一个<strong>桥接类</strong></li>
<li>Refined Abstraction：是Abstraction类的子类</li>
<li>Implementer：行为实现类的接口</li>
<li>ConcreteImplementer：Implementer类的子类</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Ng369eFyGPXo4SA.png" alt="桥接模式" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义Implementer接口，定义了一个operation()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了Implementator接口的两个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementerA</span> <span class="keyword">implements</span> <span class="title">Implementer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OperationA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementerB</span> <span class="keyword">implements</span> <span class="title">Implementer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OperationB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了桥接类Abstraction，这是一个抽象类，有对Implementer接口的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Implementer implementer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Implementer <span class="title">getImplementer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> implementer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImplementer</span><span class="params">(Implementer implementer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementer = implementer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用Implementer，调用其operation()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implementer.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getImplementer().operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Abstraction abstraction = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line"></span><br><span class="line">        abstraction.setImplementer(<span class="keyword">new</span> ConcreteImplementerA());</span><br><span class="line">        abstraction.operation();</span><br><span class="line"></span><br><span class="line">        abstraction.setImplementer(<span class="keyword">new</span> ConcreteImplementerB());</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>桥接模式的优点：</p>
<ul>
<li>实现了抽象和实现部分的分离，从而极大地增加了系统的灵活性。对于系统的高层部分，只需要知道抽象部分和实现部分的接口即可，不用知道具体的实现方法</li>
<li>更好的拓展性</li>
<li>可以动态的切换实现</li>
</ul>
<p>桥接模式的缺点：</p>
<ul>
<li>桥接模式的引入增加了系统的理解与设计难度。它的聚合关联联系建立在抽象层，要求开发者针对抽象进行设计和编程；</li>
<li>桥接模式要求正确识别出系统中的两个独立变化的维度，所以其使用范围是有一定局限性的。</li>
</ul>
<h3 id="代理模式"><a class="markdownIt-Anchor" href="#代理模式"></a> 代理模式</h3>
<p>使用代理模式的目的是解决在直接访问对象时带来的问题。比如，要访问的对象在远程机器上，那么可能会因为创建对象开销很大或者其它原因，直接访问对象会给使用者或者系统结构带来很多麻烦，因此需要在访问对象时加上一个对此对象的<strong>访问层</strong>。</p>
<blockquote>
<p>代理模式（Proxy Pattern）：给定一个对象提供一个代理，并由代理对象控制对原对象的引用。</p>
</blockquote>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/driHMlaDG6cBz9Z.png" alt="代理模式" /></p>
<p>代理模式包含以下角色：</p>
<ul>
<li>Subject：抽象主题角色</li>
<li>Proxy：代理主题角色</li>
<li>RealSubject：真实主题角色</li>
</ul>
<p>我们可以通过一个加载图片的过程来说明代理模式。我们创建了一个Image接口和实现了Image接口的实体类。ProxyImage是一个代理类，是用来减少RealImage对象加载的内存占用。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/debUQPI42yESACV.png" alt="" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图片接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实现图片接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Image fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span> + fileName + <span class="string">" from disk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理图片类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        readImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test.jpg"</span>);</span><br><span class="line">        image.display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从以上代码可以看出，通过创建一个ProxyImage的实例，调用其中的<code>display()</code>方法，然后如果图片存在，则再创建一个RealImage的实例，去加载和显示图片。</p>
<p>所以通过代理类ProxyImage，就能够负责协调调用者和被调用者，在一定程度上降低了系统的耦合度。缺点就是可能会造成请求的速度变慢。</p>
<p>除此之外，还可以举出一些实例来证明代理模式。例如，猪八戒去高老庄找高翠兰。但是通过把高翠兰的外貌给抽离出来，而高翠兰本人和孙悟空都能实现这个外貌的接口。那么猪八戒就无法通过高翠兰的外貌识别这究竟是高翠兰还是孙悟空了。这就是代理模式。</p>
<p>几种常见的代理模式：</p>
<ul>
<li>图片代理：比如对大图浏览的控制。用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方式进行处理。先在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片加载到客户端。当需要浏览大图片的时候，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还未完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</li>
<li>远程代理：远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象则承担了大部分的网络通信操作。</li>
<li>虚拟代理：当一个对象的加载十分消耗资源的时候，虚拟代理的优势就非常明显地体现出来。虚拟代理模式是一种内存节省技术，那些占用大连内存或者处理复杂的对象将推迟到使用它的时候才创建。</li>
</ul>
<h3 id="装饰器模式"><a class="markdownIt-Anchor" href="#装饰器模式"></a> 装饰器模式</h3>
<p>装饰器模式（Decorator Pattern）是动态地给一个对象增加一些额外的功能又不改变其结构。就增加对象功能而言，装饰器模式比生成子类的实现更加灵活。其别名也叫包装器（Wrapper）。</p>
<p>装饰器模式包含以下角色：</p>
<ul>
<li>Component：抽象构件。给出一个抽象的接口，以规范准备接受附加功能的对象。</li>
<li>ConcreteComponent：具体构件。定义一个要接受附加功能的对象。</li>
<li>Decorator：抽象装饰类。</li>
<li>ConcreteDecorator：具体装饰类。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/8XstZTvUbkHi6n7.png" alt="装饰器模式" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>根据上面的类图，可以通过“齐天大圣——孙悟空”的例子来掌握装饰器模式。</p>
<p>Component的角色就是“齐天大圣”，注意这里的“齐天大圣”是一个名号，是由孙悟空拥有；而ConcreteComponent就是孙悟空本人，它是“齐天大圣”这个名号的实际拥有者；Decorator是齐天大圣拥有的72变，而具体的ConcreteDecoratorA或者ConcreteDecoratorB就是72变可以变化的角色，例如花鸟鱼虫等等。</p>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/eyaFVKgzIBQ6R42.png" alt="齐天大圣——孙悟空的例子" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 齐天大圣接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MonkeyKing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猴子类，是齐天大圣的本尊（具体实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">MonkeyKing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Monkey move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 72变类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">MonkeyKing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MonkeyKing king;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Change</span><span class="params">(MonkeyKing king)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.king = king;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.king.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的变化类，变成鱼</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">(MonkeyKing king)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(king);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"Change fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的变化类，变成鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(MonkeyKing king)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(king);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"Change bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonkeyKing king = <span class="keyword">new</span> Monkey();</span><br><span class="line">        MonkeyKing bird = <span class="keyword">new</span> Bird(king);</span><br><span class="line">        bird.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>装饰模式是符合“开闭原则”的。再比如，定义一个抽象类Tea，它的功能是只能提供白开水。而通过装饰类BlackTea装饰之后就拓展了新功能，可以用白开水泡红茶，还可以选择加配料等等。</p>
<p>装饰器模式的使用场景：</p>
<ul>
<li>当需要扩展一个类的功能或者给一个类增加附加功能时；</li>
<li>需要动态地给一个对象增加功能，而且这些功能还可以动态地撤销</li>
</ul>
<p>装饰器模式的优点：</p>
<ul>
<li>继承关系的目的都是拓展对象的功能，而装饰器模式可以提供更多的灵活性；</li>
<li>通过使用不同的具体修饰类以及这些修饰类的排列组合，可以创造出很多不同的组合；</li>
</ul>
<p>装饰器模式的缺点：</p>
<ul>
<li>使用装饰器模式就是会比继承关系产生更多的类，而且这些类看上去都比较接近。</li>
</ul>
<h3 id="享元模式"><a class="markdownIt-Anchor" href="#享元模式"></a> 享元模式</h3>
<blockquote>
<p>享元模式（Flyweight Pattern）：运用共享技术有效地支持大量<strong>细粒度对象</strong>的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p>
</blockquote>
<p>在很多情况下，我们需要在系统中增加类和对象的个数，这样会付出很多代价，带来性能下降等问题。而享元模式就是来解决这一问题的。它通过共享技术来实现相同或相似对象的重用。</p>
<p>在享元模式中，可以共享的相同内容被称为<strong>内部状态（IntrinsicState）</strong>，而那些需要外部环境来设置不能共享的内容称为<strong>外部状态（ExtrinsicState）</strong>。在享元模式中，通过会出现工厂模式，需要创建一个享元工厂来负责维护一个<strong>享元池（Flyweight Pool）</strong>，用于存储具有相同内部状态的享元对象。</p>
<p>享元模式包含的角色：</p>
<ul>
<li>Flyweight（抽象享元类）：通常是一个接口或者抽象类。在这里声明了具体享元类的公共方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li>
<li>ConcreteFlyweight（具体享元类）：它实现了抽象享元类中的具体方法，其实例就是享元对象。在具体享元类中为内部状态提供存储空间。</li>
<li>UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，所以与ConcreteFlyweight相反的就是不可被共享的子类，即非共享具体享元类。</li>
<li>FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各个类型的具体享元对象存储在一个享元池中（享元池一般设计成一个存储键值对的集合）。</li>
</ul>
<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/ldkYvmtBTgpZGbI.png" alt="享元模式" /></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂类（含有一个享元池）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象存在，则直接从享元池中获取</span></span><br><span class="line">        <span class="keyword">if</span> (flyweights.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回它</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = <span class="keyword">new</span> ConcreteFlyweight();</span><br><span class="line">            flyweights.put(key, fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的</span></span><br><span class="line">    <span class="keyword">private</span> String intrinsicState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String intrinsicState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是外部状态，则使用时由外部设置，不保存在享元对象中，即使是同一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String extrinsicState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>享元模式的优点：</p>
<ul>
<li>可以极大地较少内存中对象的数量，使得相同的或者相似的对象在内存中只保留一份，从而可以节约系统资源，提高系统性能；</li>
<li>享元模式的外部状态相对独立，而且不会影响到内部状态，从而使得享元对象可以在不同的环境中被共享；</li>
</ul>
<p>享元模式的缺点：</p>
<ul>
<li>使得系统复杂化</li>
<li>读取外部状态将使得运行时间变长</li>
</ul>
<hr />
<h3 id="职责链模式"><a class="markdownIt-Anchor" href="#职责链模式"></a> 职责链模式</h3>
<h3 id="命令模式"><a class="markdownIt-Anchor" href="#命令模式"></a> 命令模式</h3>
<h3 id="解释器模式"><a class="markdownIt-Anchor" href="#解释器模式"></a> 解释器模式</h3>
<h3 id="迭代器模式"><a class="markdownIt-Anchor" href="#迭代器模式"></a> 迭代器模式</h3>
<h3 id="中介者模式"><a class="markdownIt-Anchor" href="#中介者模式"></a> 中介者模式</h3>
<h3 id="备忘录模式"><a class="markdownIt-Anchor" href="#备忘录模式"></a> 备忘录模式</h3>
<h3 id="观察者模式"><a class="markdownIt-Anchor" href="#观察者模式"></a> 观察者模式</h3>
<h3 id="状态模式"><a class="markdownIt-Anchor" href="#状态模式"></a> 状态模式</h3>
<h3 id="策略模式"><a class="markdownIt-Anchor" href="#策略模式"></a> 策略模式</h3>
<h3 id="模板方法模式"><a class="markdownIt-Anchor" href="#模板方法模式"></a> 模板方法模式</h3>
<h3 id="访问者模式"><a class="markdownIt-Anchor" href="#访问者模式"></a> 访问者模式</h3>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Hurley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/">https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hurleyjames.github.io" target="_blank">Hurley</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/../image/dubbo.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/images/wechat.JPG" alt="wechat" onclick="window.open('/images/wechat.JPG')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/images/alipay.JPG" alt="alipay" onclick="window.open('/images/alipay.JPG')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/06/Interview-Review(OS)/"><img class="prev-cover" data-src="/../image/os-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Interview-Review(OS)</div></div></a></div><div class="next-post pull-right"><a href="/2020/03/25/Interview-Review(Android)/"><img class="next-cover" data-src="/../image/android-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Interview-Review(Android)</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/../image/java-interview.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2021 By Hurley</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">随时意气风发，独自声势浩大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button class="close" id="mobile-toc-button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>