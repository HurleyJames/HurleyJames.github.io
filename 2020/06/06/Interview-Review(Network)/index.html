<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Interview-Review(Network) | Hurley</title><meta name="description" content="本篇主要是面试复习内容的计算机网络部分。   HTTP和HTTPS的区别  开销：HTTPS协议需要到CA申请证书或者自制证书 安全性：HTTP的信息是明文传输，是简单无状态的；HTTPS则是具有安全性的SSL加密传输，HTTPS协议是由SSL+HTTP协议构建的，可进行加密传输、身份认证的网络协议，比HTTP协议安全 资源消耗：HTTP是直接与TCP进行数据传输；HTTPS运行在SSL&#x2F;TSL之"><meta name="keywords" content="面试"><meta name="author" content="Hurley"><meta name="copyright" content="Hurley"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/icon.png"><link rel="canonical" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Network)/"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin="crossorigin"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><meta property="og:type" content="article"><meta property="og:title" content="Interview-Review(Network)"><meta property="og:url" content="https://hurleyjames.github.io/2020/06/06/Interview-Review(Network)/"><meta property="og:site_name" content="Hurley"><meta property="og:description" content="本篇主要是面试复习内容的计算机网络部分。   HTTP和HTTPS的区别  开销：HTTPS协议需要到CA申请证书或者自制证书 安全性：HTTP的信息是明文传输，是简单无状态的；HTTPS则是具有安全性的SSL加密传输，HTTPS协议是由SSL+HTTP协议构建的，可进行加密传输、身份认证的网络协议，比HTTP协议安全 资源消耗：HTTP是直接与TCP进行数据传输；HTTPS运行在SSL&#x2F;TSL之"><meta property="og:image" content="https://hurleyjames.github.io/../image/network-interview.png"><meta property="article:published_time" content="2020-06-05T16:00:00.000Z"><meta property="article:modified_time" content="2020-10-28T05:27:21.126Z"><meta name="twitter:card" content="summary"><script>var activateDarkMode = function () {
  document.documentElement.setAttribute('data-theme', 'dark')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#000')
  }
}
var activateLightMode = function () {
  document.documentElement.setAttribute('data-theme', 'light')
  if (document.querySelector('meta[name="theme-color"]') !== null) {
    document.querySelector('meta[name="theme-color"]').setAttribute('content', '#fff')
  }
}

var getCookies = function (name) {
  const value = `; ${document.cookie}`
  const parts = value.split(`; ${name}=`)
  if (parts.length === 2) return parts.pop().split(';').shift()
}

var autoChangeMode = 'false'
var t = getCookies('theme')
if (autoChangeMode === '1') {
  var isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
  var isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
  var isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
  var hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

  if (t === undefined) {
    if (isLightMode) activateLightMode()
    else if (isDarkMode) activateDarkMode()
    else if (isNotSpecified || hasNoSupport) {
      console.log('You specified no preference for a color scheme or your browser does not support it. I Schedule dark mode during night time.')
      var now = new Date()
      var hour = now.getHours()
      var isNight = hour <= 6 || hour >= 18
      isNight ? activateDarkMode() : activateLightMode()
    }
    window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
      if (Cookies.get('theme') === undefined) {
        e.matches ? activateDarkMode() : activateLightMode()
      }
    })
  } else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else if (autoChangeMode === '2') {
  now = new Date()
  hour = now.getHours()
  isNight = hour <= 6 || hour >= 18
  if (t === undefined) isNight ? activateDarkMode() : activateLightMode()
  else if (t === 'light') activateLightMode()
  else activateDarkMode()
} else {
  if (t === 'dark') activateDarkMode()
  else if (t === 'light') activateLightMode()
}</script><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css"><link rel="prev" title="Interview-Review(DataStructure)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(DataStructure)/"><link rel="next" title="Interview-Review(Java)" href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Java)/"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  bookmark: {
    message_prev: '按',
    message_next: '键将本页加入书签'
  },
  runtime_unit: '天',
  runtime: false,
  copyright: undefined,
  ClickShowText: undefined,
  medium_zoom: true,
  fancybox: false,
  Snackbar: undefined,
  justifiedGallery: {
    js: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/js/jquery.justifiedGallery.min.js',
    css: 'https://cdn.jsdelivr.net/npm/justifiedGallery/dist/css/justifiedGallery.min.css'
  },
  baiduPush: false,
  highlightCopy: true,
  highlightLang: true,
  isPhotoFigcaption: true,
  islazyload: true,
  isanchor: false    
}</script><script>var GLOBAL_CONFIG_SITE = { 
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isSidebar: false
  }</script><noscript><style>
#nav {
  opacity: 1
}
.justified-gallery img{
  opacity: 1
}
</style></noscript><link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css"></head><body><div id="loading-box"><div class="loading-left-bg"></div><div class="loading-right-bg"></div><div class="spinner-box"><div class="configure-border-1"><div class="configure-core"></div></div><div class="configure-border-2"><div class="configure-core"></div></div><div class="loading-word">加载中...</div></div></div><div id="mobile-sidebar"><div id="menu_mask"></div><div id="mobile-sidebar-menus"><div class="mobile_author_icon"><img class="avatar-img" src="https://avatars1.githubusercontent.com/u/26319720?s=460&amp;v=4" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="mobile_post_data"><div class="mobile_data_item is-center"><div class="mobile_data_link"><a href="/archives/"><div class="headline">文章</div><div class="length_num">59</div></a></div></div><div class="mobile_data_item is-center">      <div class="mobile_data_link"><a href="/tags/"><div class="headline">标签</div><div class="length_num">23</div></a></div></div><div class="mobile_data_item is-center">     <div class="mobile_data_link"><a href="/categories/"><div class="headline">分类</div><div class="length_num">13</div></a></div></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div></div></div><div id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url(/../image/network-interview.png)"><nav id="nav"><span class="pull-left" id="blog_name"><a class="blog_title" id="site-name" href="/">Hurley</a></span><span class="pull-right menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></div></div><span class="toggle-menu close"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></span></span></nav><div id="post-info"><div id="post-title"><div class="posttitle">Interview-Review(Network)</div></div><div id="post-meta"><div class="meta-firstline"><time class="post-meta__date"><span class="post-meta__date-created" title="发表于 2020-06-06 00:00:00"><i class="far fa-calendar-alt fa-fw"></i> 发表于 2020-06-06</span><span class="post-meta__separator">|</span><span class="post-meta__date-updated" title="更新于 2020-10-28 13:27:21"><i class="fas fa-history fa-fw"></i> 更新于 2020-10-28</span></time></div><div class="meta-secondline"> <span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta__icon"></i><span>字数总计:</span><span class="word-count">7.3k</span><span class="post-meta__separator">|</span><i class="far fa-clock fa-fw post-meta__icon"></i><span>阅读时长: 22 分钟</span></span></div><div class="meta-thirdline"><span class="post-meta-pv-cv"><span class="post-meta__separator">|</span><i class="far fa-eye fa-fw post-meta__icon"></i><span>阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-commentcount"></span></div></div></div></header><main class="layout_post" id="content-inner"><article id="post"><div class="post-content" id="article-container"><p>本篇主要是面试复习内容的计算机网络部分。</p>
<a id="more"></a>
<ol>
<li><p><strong>HTTP和HTTPS的区别</strong></p>
<ul>
<li><strong>开销</strong>：HTTPS协议需要到CA申请证书或者自制证书</li>
<li><strong>安全性</strong>：HTTP的信息是明文传输，是简单无状态的；HTTPS则是具有安全性的SSL加密传输，HTTPS协议是由SSL+HTTP协议构建的，可进行加密传输、身份认证的网络协议，比HTTP协议安全</li>
<li><strong>资源消耗</strong>：HTTP是直接与TCP进行数据传输；HTTPS运行在SSL/TSL之上，SSL/TSL运行在TCP之上，需要消耗更多的CPU和内存资源；</li>
<li><strong>端口不同</strong>：HTTP用到的端口是80（需要国内备案），HTTPS用到的端口是443</li>
</ul>
</li>
<li><p><strong>HTTP2与HTTP1.x相比的新特性</strong></p>
<ul>
<li><p>HTTP2使用新的二进制格式传输，HTTP1.x使用文本（字符串）传输。二进制协议解析起来更高效</p>
</li>
<li><p>HTTP2支持多路复用，即连接共享，即每一个<code>request</code>都是用作连接共享机制的。</p>
<blockquote>
<p>在HTTP1.x协议中，「浏览器客户端在同一时间，针对同一域名下的请求有一定的数量限制。超过限制数目的请求会被阻塞」。HTTP2的多路复用（Multiplexing）允许同时超过单一的HTTP2连接发起多重的请求-响应消息。</p>
</blockquote>
<p>  <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/http16.jpg" alt=""></p>
</li>
<li><p>HTTP2头部压缩，通过<code>gzip</code>和<code>compress</code>压缩头部然后再发送，既避免了重复<code>header</code>的传输，又减小了需要传输的大小</p>
</li>
<li><p>HTTP2支持服务器推送</p>
</li>
</ul>
</li>
<li><p><strong>HTTP2和HTTPS的关系</strong></p>
<p> HTTP2与HTTPS<strong>同属为一种网络传输协议</strong>。HTTP2（原名HTTP/2.0）即超文本传输协议2.0，是下一代HTTP协议。HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性，HTTPS在HTTP的基础下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p>
<p> HTTP2虽然是下一代HTTP协议，做了一些改动（如二进制分帧、多路复用、头部压缩、服务器推送等），但是依然采取的是<strong>不加密的传输方式</strong>，容易导致数据在传输过程中被截取或篡改，无法保证数据的完整性。</p>
<p> 而HTTPS采用的则是<strong>加密传输</strong>，就是在HTTP协议下增加了一层SSL协议，通过对整个通信线路进行加密来防止通信内容被窃听、篡改或伪装。</p>
<p> 所以：</p>
<ul>
<li>https: <strong>加密</strong>的http协议，默认443端口，<strong>基于TCP协议</strong>。</li>
<li>http2: <strong>第二代</strong>http协议，相较于HTTP1.x，大幅度的提升了web性能。在与HTTP/1.1完全语义兼容的基础上，进一步<strong>减少了网络延迟和传输的安全性</strong>，<strong>基于TCP协议</strong>。</li>
</ul>
</li>
<li><p><strong>什么是数字签名和数字证书</strong></p>
<ul>
<li><strong>数字签名</strong>：为了避免数据在传输过程中被替换（例如被黑客修改了报文内容），所以需要发送端发送一个数字签名，即把数据的摘要消息进行加密，比如使用MD5进行加密，得到一个数字签名，然后把这个数字签名和数据一起发送。然后接收端把收到的数据摘要部分进行MD5（相同加密算法）进行加密，如果加密后的结果和数字签名是一样的，就说明数据是正确的真实的。</li>
<li><strong>数字证书</strong>：因为在对称加密中，发送端和接收端双方都是使用公钥进行解密的。<strong>数字签名可以保证数据不被替换</strong>，但是不能保证公钥不被替换。因为数据是通过公钥加密的，如果公钥被替换了，那么数据也可以被伪造。所以我们要确保公钥也是真的。那么，CA证书机构会负责颁发一个证书，里面的公钥保证是真的，用户在请求服务器时，服务器将证书发给用户，而这个证书是由系统内置证书备案的，就能保证证书里的公钥是真的。</li>
</ul>
</li>
<li><p><strong>对称加密与非对称加密</strong></p>
<p> <strong>对称密钥加密</strong>指的是使用同一个密钥进行加密和解密，这种方法存在的问题就是密钥如何安全地发送给对方。</p>
<p> <strong>非对称加密</strong>是指使用一对非对称密钥，即公钥和私钥。公钥是可以任意发布的，但是私钥只有自己知道。发送方使用接收方的公钥进行加密处理，接收方收到加密信息后，使用自己的私钥进行解密。</p>
<p> 因为非对称加密的方式只会发送公钥而不会发送用来解密的私钥，所以可以保证安全性。但是相比对称加密，它的速度非常慢。所以，我们仍然使用对称加密来传送消息，但对称加密所使用的密钥可以通过非对称加密的方式发送出去。</p>
</li>
<li><p><strong>TCP与UDP的区别</strong></p>
<ul>
<li>TCP是面向连接的，UDP是无连接的；</li>
<li>TCP传输性可靠，UDP传输性不可靠；</li>
<li>TCP以<strong>字节流</strong>的形式传输，UDP以<strong>数据报文段</strong>的形式传输；</li>
<li>TCP传输效率慢，UDP传输效率快；</li>
<li>TCP所需资源多，UDP所需资源少；</li>
<li>TCP首部字节是20-60，UDP首部字节是8；</li>
<li>TCP应用于要求通信数据可靠的场景，例如文件传输，邮件传输等；UDP则要求通信速度较快的场景，如域名转换，直播等；</li>
<li>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</li>
</ul>
</li>
<li><p><strong>TCP的字节流是什么机制</strong></p>
</li>
<li><p><strong>字节流和字符流说一下</strong></p>
</li>
<li><p><strong>TCP协议的可靠性是如何保证的</strong></p>
<ul>
<li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不做任何响应，这样TCP发送数据端就会超时而重发数据；</li>
<li><strong>对失序的数据报重排序</strong>：既然TCP报文段作为IP数据报来传输，因为IP数据报到达时可能会失效，所以TCP报文段的到达也可能会失序。所以TCP会对失序数据进行重新排序，然后再上交给应用层；</li>
<li><strong>丢弃重复数据</strong></li>
<li><strong>应答机制</strong>：当TCP收到发自TCP连接另外一端的数据，它将发送一个确认（不是立即发送）；</li>
<li><strong>超时重发</strong>：当TCP发出一个段后，会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到这个确认，就需要重新发送这个报文段；</li>
<li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP接收端只需要另一端（发送端）发送接收端的缓冲区能够容纳得下的数据，这样做可以防止较快主机致使较慢主机的缓冲区溢出，这就是所谓的流量控制（TCP使用的流量控制协议是可变大小的滑动窗口协议）。</li>
</ul>
</li>
<li><p><strong>TCP和UDP对应的常见应用层协议</strong></p>
<ul>
<li>TCP对应的应用层协议有：<ul>
<li>FTP：定义了文件传输协议</li>
<li>SMTP：定义了简单邮件传输协议</li>
<li>POP3：POP3是用于接收邮件的，和SMTP对应</li>
<li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议</li>
</ul>
</li>
<li>UDP对应的应用层协议有：<ul>
<li>DNS：用于域名解析服务，将域名地址转换为IP地址</li>
<li>SNMP：简单网络管理协议</li>
<li>TFTP：简单文件传输协议</li>
</ul>
</li>
</ul>
</li>
<li><p><strong>为什么TCP连接需要三次握手？为什么要四次挥手？画出全过程，并标注ack确认号和seq序列号的值</strong></p>
<p><strong>三次握手</strong>：</p>
<ol>
<li>第一次握手：客户端发送SYN=1的包到服务器，进入SYN_SEND状态，等待服务器确认；</li>
<li>第二次握手：服务器收到SYN的包后，必须使用确认包ACK确认客户的SYN，同时自己也发送SYN包给客户端，即发送ACK=1，SYN=1的包，此时服务器进入SYN_RECY状态；</li>
<li>第三次握手：客户端收到服务器的SYN+ACK的包，向服务器发送确认包ACK=1，发送完毕后，就进行ESTABLISHED状态，完成三次握手。</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/t1.jpeg" alt=""></p>
<p><strong>四次挥手</strong>：</p>
<ol>
<li>客户端主动发送FIN=1</li>
<li>服务端收到后发送ACK=1</li>
<li>服务端再发送FIN=1，ACK=1</li>
<li>客户端最后向服务端发送ACK=1</li>
</ol>
<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/t2.jpeg" alt=""></p>
</li>
<li><p><strong>TCP握手连接确认号为什么要+1，不变不行吗？为什么？</strong></p>
</li>
<li><p><strong>HTTP与TCP的区别</strong></p>
<p>TCP是传输层协议，主要解决数据如何在网络中进行传输。HTTP协议是应用层协议，主要解决如何包装数据。</p>
</li>
<li><p><strong>保活计时器的作用</strong></p>
<p>除了时间等待计时器之外，TCP还有一个保活计时器。比如，一个客户与服务器建立了TCP连接，如果这时突然客户端主机发生故障，那么服务器也不应该再白白等待下去，所以需要使用到保活计时器。</p>
<p>服务器每次收到一次客户的数据，就要重新设置保活计时器，时间通常设置是两个小时。如果在这个时间内都没有收到客户端的数据，服务端就会发送一个探测报文段（每隔75秒发送一次）。若连续发送10次后都没有收到客户端的响应，服务端就会认为客户端出现了故障，从而关闭连接。</p>
</li>
<li><p><strong>TCP的拥塞处理</strong></p>
<p>拥塞控制和流量控制的不同的，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器以及与降低网络传输性能相关的所有因素；流量控制是指点对点通信量的控制，是一个端到端的问，它的作用是抑制发送端发送数据的速率，以便使接收端来得及接收。</p>
<p><strong>拥塞</strong>是指在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，那么网络的性能就会变坏。为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）的状态变量，拥塞控制窗口的大小取决于网络的拥塞程度，并且可以动态变化。发送方的发送窗口会从拥塞窗口和接收方的接收窗口这两者中取较小的那个。</p>
<p>TCP的拥塞控制采用了四种算法：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传和快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略，以减少网络拥塞的发生；</p>
<ul>
<li><strong>慢开始</strong>：当主机开始发送数据时，如果立即把大量的数据字节同时注入到网络，很有可能会引起网络阻塞。所以，较好的方法是先探测一下，即由小到大逐渐增大发送窗口（逐渐增大拥塞窗口数值）。例如，cwnd的初始值为1，每经过一个传播轮次，cwnd加倍。</li>
<li><strong>拥塞避免</strong>：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加。</li>
<li><strong>快重传和快恢复</strong>：快重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。如果没有FRR，那么如果数据包丢失了，TCP就会使用定时器要求传输暂停；而如果有了FRR，当接收方收到了不按顺序的数据段，就会立即给发送发发送一个<strong>重复确认</strong>，当发送方收到了三个重复确认，就会假定这个数据报丢失了，并立即重传这些丢失的数据段。所以，有了FRR，就不会因为暂停而耽误重传要求。当单个数据包丢失时，FRR十分有效；当多个数据包在短时间内丢失，FRR不能很有效地工作；</li>
</ul>
</li>
<li><p><strong>HTTP方法有哪些</strong></p>
<ul>
<li>GET：获取资源，网络中绝大部分请求都会GET请求；</li>
<li>HEAD：获取报文首部，使用和GET相似，但是不会返回报文的实体主体部分；</li>
<li>POST：传输实体主体；</li>
<li>PUT：上传文件，不带有验证机制，所有任何人都能上传文件，存在安全性问题，一般不推荐使用该方法；</li>
<li>PATCH：对资源进行部分修改。PUT也可以修改资源，但是是完全替代，而PATCH允许部分修改；</li>
<li>OPTIONS：查询指定的URL支持的方法；</li>
<li>CONNECT：要求与代理服务器通信时建立隧道；使用SSL和TLS协议把通信内容加密后经网络隧道传输；</li>
<li>TRACE：追踪路径，服务器会把通信路径返回给客户端</li>
</ul>
</li>
<li><p><strong>HTTP中，POST与GET的区别</strong></p>
<ul>
<li>用途不同：GET是从服务器上获取数据，POST向服务器传送数据；</li>
<li>数据传输方式不同：GET请求通过URL传输数据，POST通过<strong>请求体</strong>传输数据（先发送请求头再发请求体，实际上是两次请求）；</li>
<li>传输数据量限制不同：GET传送的数据量小，不能大于2KB（因为浏览器对URL的长度有限制）；POST传送的数据量大，一般默认为不受限制；</li>
<li>GET的数据在URL中，通过历史记录或缓存可以很容易查到数据信息；POST的数据在请求主体内，所以有一定的安全性保证</li>
<li>GET是安全且幂等（同一个请求方法执行多次和仅执行一次的效果完全相同）；POST是非安全非幂等（每次请求对资源的改变并不是相同的），所以GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</li>
</ul>
</li>
<li><p><strong>HTTP的长连接和短连接分别是什么</strong></p>
<p>HTTP的长连接和短连接实际上是TCP的长连接和短连接。</p>
<ul>
<li><strong>长连接</strong>：HTTP1.1规定了默认保持长连接，也称为<strong>持久连接</strong>。当数据传输完成后保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。但是长连接不是永久的连接，它有一个保持时间。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></li>
<li><strong>短连接</strong>：在HTTP/1.0中，默认使用短连接。浏览器和服务器每进行一次HTTP操作，就要建立一个连接，但任务结束就会中断这个连接</li>
</ul>
<p>使用长连接的好处：</p>
<ul>
<li>同一个客户端可以使用这个长连接处理其他请求，避免HTTP重新连接和断开消耗时间；</li>
<li>服务器可以利用这个连接<strong>主动推送</strong>消息到客户端</li>
</ul>
</li>
<li><p><strong>DNS是什么，DNS协议的原理</strong></p>
<p>DNS的全程是Domain Name System或者Domain Name Service，主要作用就是将网址（域名）解析成电脑可以理解的IP地址，这个过程就是DNS域名解析（一个域名往往对应多个DNS地址）。</p>
</li>
<li><p><strong>DNS的解析过程</strong></p>
<ol>
<li>输入<code>www.baidu.com</code>这个域名，操作系统会先检查自己本地的hosts文件中是否已经有这个网址映射关系，如果有，就先调用这个已存在的IP地址映射去完成域名解析；</li>
<li>如果本地hosts文件中没有这个域名的映射，则查找本地DNS解析器缓存中是否有这个网址的映射，如果有就返回这个完成域名解析；</li>
<li>如果hosts和本地DNS解析器缓存里都没有这个域名的映射，那么就会找本地DNS服务器，此服务器收到查询请求时，如果要查询的域名包含在本地配置区域资源中，就返回解析结果给客户机，完成域名解析（此解析具有权威性）；</li>
<li>如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址的映射关系，就调用这个进行IP地址映射，完成域名解析（此解析不具有权威性）；</li>
<li>如果本地DNS服务器本地区域资源和缓存解析都失败了，就让根DNS服务解析，如果自己无法解析，就联系下一级顶级域DNS服务器查询，如果还无法解析就联系下一级次级域名解析，如果还无法解析就使用下一级——主机名（host），又称三级域名进行解析，直到找个这个域名的主机为止。</li>
</ol>
<p><strong>另外一种表述方法是</strong>：</p>
<ol>
<li>发起基于域名的请求后，首先检查<strong>本地缓存</strong>（浏览器缓存$\longrightarrow$操作系统的hosts文件）；</li>
<li>如果<strong>本地缓存</strong>有，直接返回目标IP地址，否则将域名解析请求发送给<strong>本地DNS服务器</strong>；</li>
<li>如果<strong>本地DNS服务器</strong>中有，直接返回目标IP地址；如果没有，<strong>本地DNS服务器</strong>将解析请求发送给<strong>根DNS服务器</strong>;</li>
<li><strong>根DNS服务器</strong>会返回给<strong>本地DNS服务器</strong>一个所查询的<strong>TLD服务器（顶级域名服务器）</strong>地址列表；</li>
<li><strong>本地DNS服务器</strong>再向上一步返回的<strong>TLD服务器</strong>发送请求，<strong>TLD服务器</strong>查询并返回域名对应的域名对应的<strong>权威域名服务器</strong>的地址；</li>
<li><strong>本地DNS服务器</strong>再向上一步返回的<strong>权威域名服务器</strong>发送请求，<strong>权威域名服务器</strong>会查询存储的域名和IP的映射关系表，将IP连同一个<code>TTL</code>（过期时间）值返回给<strong>本地DNS服务器</strong>；</li>
<li><strong>本地DNS服务器</strong>会将IP和主机名的映射保存起来，保存时间由<code>TTL</code>来控制；</li>
<li><strong>本地DNS服务器</strong>把解析的结果返回给用户，用户根据<code>TTL</code>值缓存在<strong>本地系统缓存</strong>中，域名解析过程结束。</li>
</ol>
<p><strong>递归查询与迭代查询</strong>：</p>
<ol>
<li>主机向本地域名服务器的查询一般都是采用递归查询（客户端只发出一次请求，要求对方给出最终结果）。递归查询时，返回的结果只有两种：查询成功或者查询失败；</li>
<li>本地域名服务器向根域名服务器的查询时迭代查询（客户端发出了一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它那得到最终结果，即根域名服务器$\rightarrow$顶级域服务器$\rightarrow$次级域服务器$\rightarrow$主机名host）。迭代查询（又称重指引）时，返回的是最佳的查询点或者主机地址。</li>
</ol>
</li>
<li><p><strong>浏览器输入一个URL后发生了什么（从输入网址到获得页面的过程）</strong></p>
<ol>
<li><strong>DNS解析</strong>：浏览器会查询DNS，获取该域名（URL）对应的IP地址；具体过程包括了浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地的DNS服务器进行查询等；<ol>
<li>首先向本地DNS服务器查询缓存。本地DNS服务器会让根DNS服务器查询，如果不知道就再向顶级域DNS服务器查询，如果还不知道就再向权威DNS服务器查询；(一个域名为<code>www.baidu.com.</code>，根域名就是最后的<code>.</code>，只是因为每个域名都有根域名，所以通常省略了；根域名的下一级是顶级域名，比如<code>.com</code>，<code>.org</code>等；再下一级就是次级域名，比如<code>.baidu</code>；再下一级就是主机名（host）了，比如<code>www</code>，这个又称为三级域名)。所以，整个解析流程就是<strong>分级查询</strong>；</li>
<li>这里查询使用了<strong>递归查询</strong>和<strong>迭代查询</strong></li>
</ol>
</li>
<li><strong>TCP连接</strong>：浏览器获得了域名对应的IP地址之后，浏览器就会向服务器请求建立连接，发起三次握手；</li>
<li><strong>发送HTTP请求</strong>：TCP连接建立之后，浏览器会向服务器发送HTTP请求；</li>
<li><strong>服务器处理请求并返回HTTP报文</strong>：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li>
<li><strong>浏览器解析渲染界面</strong>：浏览器解析并渲染视图，如果有对js、css和图片等静态资源的引用，就重复上述步骤并向服务器请求这些资源；浏览器会根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li>
<li><strong>连接结束</strong></li>
</ol>
</li>
<li><p><strong>HTTP响应码（状态码）</strong></p>
<ul>
<li>1XX：Informational（信息性状态码），表示请求已经被收到了，需要进一步的处理才能完成；</li>
<li>2XX：Success（成功状态码），成功处理请求；</li>
<li>3XX：Redirection（重定向状态码），重定向使用Location指向的资源或者缓存中的资源；</li>
<li>4XX：Client Error（客户端错误状态码），客户端出现错误，请求失败；</li>
<li>5XX：Server Error（服务端错误状态码），服务端出现错误，请求失败</li>
</ul>
<p><strong>常见状态码</strong>：</p>
<ul>
<li>100：Continue，表示到目前为止都很正常，客户端可以继续发送请求；</li>
<li>200：OK，请求正确；</li>
<li>301：Moved Permanently，永久性重定向；</li>
<li>302：Found，临时性重定向；</li>
<li>400：Bad Request，请求报文中存在语法错误；</li>
<li>403：Forbidden，请求被拒绝；</li>
<li>404：Not Found；</li>
<li>500：Internal Server Error，服务器正在执行请求时发生错误；</li>
</ul>
</li>
<li><p><strong>cookie/session的区别</strong></p>
<ul>
<li>cooike数据保存在用户的浏览器上（临时文件夹中），session数据保存在服务器上；</li>
<li>cookie是以明文的方式存放在客户端的，不是很安全，别人可以通过分析存在在本地的cookie来进行COOKIE诈骗；</li>
<li>cookie会传递消息给服务器；session本身存放在服务器中，不会有传送流量；</li>
<li>生命周期：<ul>
<li>cookie的生命周期是累加的，从创建时开始计时，20分钟后生命周期结束</li>
<li>session的生命周期是间隔的，创建后20分钟内没有访问session就会被销毁；但如果20分钟内访问了session，就又要重新计算session的生命周期；</li>
</ul>
</li>
<li>session是一定时间内会存储在服务器中。当访问增多时会增加服务器的性能消耗，此时就可以考虑使用cookie；</li>
<li>cookie为多个用户浏览器共享，session为一个用户浏览器独享；</li>
</ul>
</li>
<li><p><strong>OSI和TCP/IP的网络模型，路由器和交换机位于哪一层</strong></p>
<p><strong>OSI七层模型</strong>由上到下分别是：应用层、表示层、会话层、传输层、网络层、数据链路层和物理层。</p>
<ul>
<li>物理层：网卡、网线、集线器（采用广播的形式来传输信息）、中继器、调制解调器等</li>
<li>数据链路层：网桥、交换机（用来进行报文交换，能够进行地址学习，采用存储转发的形式来交换报文）等</li>
<li>网络层：路由器（一个作用是连通不同的网络，另一个作用是选择信息传送的线路）</li>
<li>传输层以以上：网关工作</li>
</ul>
<p>所以，路由器位于OSI七层模型的第三层，网络层；二层交换机位于OSI的第二层数据链路层，三层交换机位于OSI的第三层网络层，因为其具有路由功能；</p>
<p><strong>TCP/IP四层模型</strong>由上到下分别是：应用层、传输层（TCP和UDP协议）、网络层（整个TCP/IP协议栈的核心，定义了IP协议）和网络接口层。</p>
</li>
<li><p><strong>IP地址的分类</strong></p>
<p>IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址；</p>
<p>每个IP地址包括两个标识码（ID）：网络ID和主机ID。<strong>同一个物理网络下的所有主机都使用同一个网络ID，而网络上的一个主机（网络工作站、服务器和路由器等）则有一个主机ID与其对应</strong>。</p>
<p>A~E类地址的特点如下：</p>
<ul>
<li>A类地址：以0开头，第一个字节范围是：0~127</li>
<li>B类地址：以10开头，第一个字节范围是：128~191</li>
<li>C类地址：以110开头，第一个字节范围是：192~223</li>
<li>D类地址：以1110开头，第一个字节范围是：224~239</li>
<li>E类地址：以1111开头，保留地址</li>
</ul>
</li>
<li><p><strong>私有IP地址的范围</strong></p>
<ul>
<li>A类私有IP地址：<strong>10.0.0.0~10.255.255.255</strong></li>
<li>B类私有IP地址：<strong>172.16.0.0~172.31.255.255</strong></li>
<li>C类私有IP地址：<strong>192.168.0.0~192.168.255.255</strong></li>
</ul>
</li>
<li><p><strong>为什么有了MAC地址还有IP地址</strong></p>
<ul>
<li>每台主机在出厂时都一个唯一的MAC地址，但是IP地址的分配是根据网络的拓扑结构，得以保证路由选择方案建立在网络所处的拓扑位置基础而不是设备制造商的基础上</li>
<li>使用IP地址更方便传输数据。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的</li>
</ul>
</li>
<li><p><strong>五层网络协议体系结构的理解和每一层对应的网络协议有哪些</strong></p>
<ul>
<li><strong>应用层</strong>的任务是通过应用进程之间的监护来完成特定的网络应用。应用层的协议有域名系统DNS，超文本传输协议HTTP，文本传输协议FTP，支持电子邮件的SMTP协议，安全外壳协议SSH等；</li>
<li><strong>传输层</strong>的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。传输层的协议有传输控制协议TCP和用户数据报协议UDP；</li>
<li><strong>网络层</strong>的任务就是选择合适的网间路由和交换结点，确保数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据封装成分组和包进行传送。网络层使用IP协议，所以分组也叫IP数据报，简称数据报。网络层的协议有网际协议IP协议和地址转换协议ARP等；</li>
<li><strong>数据链路层</strong>：在两个相邻节点之间传送数据时，数据链路层将网络层传下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。帧中包含了数据和必要的控制信息（同步信息，地址信息，差错控制等）。控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束，还可以让接收端检测帧中是否有差错，如果有，就丢弃。数据链路层的协议主要有自动重传请求协议ARQ和点对点协议PPP等；</li>
<li><strong>物理层</strong>：在物理层上所传送的数据单位是比特。它的作用是实现相邻计算机之间比特流的透明传送。</li>
</ul>
</li>
<li><p><strong>停止等待协议的理解</strong><br>停止等待协议是为了实现可靠传输的，它的基本原理就是每发送完一个分组就停止发送，等待对方确认，收到确认再发送下一个分组；在停止等待协议中，若接收方收到了重复的分组，就丢弃该分组，但同时还要发送确认。主要包括几种情况：无差错情况、超时重传、确认丢失和确认迟到。</p>
</li>
<li><p><strong>ARQ协议</strong></p>
<ul>
<li><strong>自动重传请求ARQ协议</strong>：停止等待协议中有一个超时重传的情况，指只要超过一段时间仍然没有收到确认，就会重传前面发送过的分组（默认之前发送的那个分组已经丢失了）。所以，每个发送完一个分组都要设置一个超时计时器，其重传时间会设置得比分组传输的平均往返时间要更长（如果更短，就可能是传输还有到达，不可取）。这种自动重传的方式就叫做<strong>自动重传请求ARQ</strong>。</li>
<li><strong>连续ARQ协议</strong>：连续ARQ协议是用来提高信道利用率的。发送方维持一个发送窗口，位于发送窗口内的分组都可以连续发送出去，不需要等待对方确认。而接收方则采用累计确认，对按序到达的最后一个分组发送确认，就能表明这个分组之前的所有分组（包括这个分组）都已经正确收到了。</li>
</ul>
</li>
</ol>
</div><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined" target="_blank" rel="noopener">Hurley</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="https://hurleyjames.github.io/2020/06/06/Interview-Review(Network)/">https://hurleyjames.github.io/2020/06/06/Interview-Review(Network)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://hurleyjames.github.io" target="_blank">Hurley</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post_share"><div class="social-share" data-image="/../image/merge-two-binary-trees.png" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css"/><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js"></script></div></div><div class="post-reward"><button class="reward-button"><i class="fas fa-qrcode"></i> 打赏<div class="reward-main"><ul class="reward-all"><li class="reward-item"><img class="post-qr-code__img" src="/images/wechat.JPG" alt="wechat" onclick="window.open('/images/wechat.JPG')"/><div class="post-qr-code__desc">wechat</div></li><li class="reward-item"><img class="post-qr-code__img" src="/images/alipay.JPG" alt="alipay" onclick="window.open('/images/alipay.JPG')"/><div class="post-qr-code__desc">alipay</div></li></ul></div></button></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2020/06/06/Interview-Review(DataStructure)/"><img class="prev-cover" data-src="/../image/data-structure-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Interview-Review(DataStructure)</div></div></a></div><div class="next-post pull-right"><a href="/2020/06/06/Interview-Review(Java)/"><img class="next-cover" data-src="/../image/java-interview.png" onerror="onerror=null;src='/img/404.jpg'"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Interview-Review(Java)</div></div></a></div></nav></article></main><footer id="footer" style="background-image: url(/../image/network-interview.png)" data-type="photo"><div id="footer-wrap"><div class="copyright">&copy;2017 - 2020 By Hurley</div><div class="framework-info"><span>驱动 </span><a href="https://hexo.io" target="_blank" rel="noopener"><span>Hexo</span></a><span class="footer-separator">|</span><span>主题 </span><a href="https://github.com/jerryc127/hexo-theme-butterfly" target="_blank" rel="noopener"><span>Butterfly</span></a></div><div class="footer_custom_text">随时意气风发，独自声势浩大</div></div></footer></div><section class="rightside" id="rightside"><div id="rightside-config-hide"><button id="readmode" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="font_plus" title="放大字体"><i class="fas fa-plus"></i></button><button id="font_minus" title="缩小字体"><i class="fas fa-minus"></i></button><button id="darkmode" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button></div><div id="rightside-config-show"><button id="rightside_config" title="设置"><i class="fas fa-cog"></i></button><button id="go-up" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/medium-zoom/dist/medium-zoom.min.js"></script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {
    inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
    processEscapes: true,
    skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
  },
  CommonHTML: {
    linebreaks: { automatic: true, width: "90% container" }
  },
  "HTML-CSS": { 
    linebreaks: { automatic: true, width: "90% container" }
  },
  "SVG": { 
    linebreaks: { automatic: true, width: "90% container" }
  }
});
</script><script type="text/x-mathjax-config">MathJax.Hub.Queue(function() {
  var all = MathJax.Hub.getAllJax(), i;
  for (i=0; i < all.length; i += 1) {
    all[i].SourceElement().parentNode.className += ' has-jax';
  }
});
</script><script src="https://cdn.jsdelivr.net/npm/mathjax/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><script id="ribbon_piao" mobile="false" src="/js/third-party/piao.js"></script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module" defer></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js" async></script><script>var endLoading = function () {
  document.body.style.overflow = 'auto';
  document.getElementById('loading-box').classList.add("loaded")
}
window.addEventListener('load',endLoading)</script></body></html>