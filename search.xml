<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS有三宝——var、let、const</title>
      <link href="/2021/01/11/JS%E4%B8%89%E5%AE%9D--var%20let%20const/"/>
      <url>/2021/01/11/JS%E4%B8%89%E5%AE%9D--var%20let%20const/</url>
      
        <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>最早，JavaScript是使用<code>var</code>来声明变量的，但是由于设计得并不合理，后来在ES6推出了<code>let</code>和<code>const</code>。</p><p>var的作用域是<strong>全局</strong>和<strong>函数</strong>作用域，而作用域指的是变量能够作用的范围。所以，全局作用域指的就是变量伴随了整个程序的生命周期；而函数作用域指的是在函数体内定义，可以在该函数内的任意地方使用。</p><p>什么是全局作用域？在App开发中，一个App就是一个进程，那么全局作用域就是在这个应用内部都可以访问到该变量，并且它一直在执行环境中，不会被释放。而浏览器中，就得把一个页面看做是一个全局，所以，全局变量的生命周期和这个页面的生命周期是一样的。</p><p>可是，使用<code>var</code>声明变量有很大的弊端。「它会使变量提升」，即「在代码执行之前，JavaScript引擎把变量和函数的声明部分提升到对应作用域的开始位置」。如果变量提升后，<code>var</code>声明的变量的初始值就是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// name被提升</span></span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'三宝'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>为此，在ES6中，提出了<code>let</code>这个声明变量的方式，使用<code>let</code>声明的变量是<strong>块级作用域</strong>。即用<code>let</code>声明的变量只能在这个块内部使用，而同一变量是不可以重复声明的。不过，如果是在不同的作用域中，即跳出了这个块，那么是可以重复定义的。</p><p>什么是块呢？只要有两个大括号就属于一个域。块就是两个大括号包起来的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用<code>let</code>声明的变量，如果在未声明时就使用，那么会报错<code>Cannot access</code>XXX<code>before initialization</code>。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>但是有时候我们声明一个变量之后，一旦赋值了就不需要再更改了，那么我们就可以用<code>const</code>，即声明常量最常用的手段。所以，在日常开发中，能要用<code>const</code>就要用<code>const</code>，它能够保证程序的状态更加稳定。在别的方面，<code>const</code>都与<code>let</code>类似，不同之处就在于它的不变性，且使用<code>const</code>声明的变量在声明时，就一定要设定初始值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>var</code>声明的变量的作用域是全局或者函数级别的，而<code>let</code>和<code>const</code>声明的变量是块级的，一个<code>{}</code>表示一个代码块。</li><li><code>var</code>声明的变量可以更新，可以重新声明；<code>let</code>声明的变量可以更新，但是不能重新声明；<code>const</code>声明的变量既不能重新更新也不能重新声明；</li><li><code>var</code>和<code>let</code>声明的变量可以不初始化，但是<code>const</code>声明的变量必须初始化；</li><li>其实，<code>var</code>、<code>let</code>、<code>const</code>声明的变量都会发生变量提升（即先使用后定义），<code>var</code>如果这样会被初始化为<code>undefined</code>，而<code>let</code>和<code>const</code>声明的变量则不会被初始化，会直接报错。</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://mp.weixin.qq.com/s/uZOj5HzJmH_fNeUEPipqwA" target="_blank" rel="noopener">var 很傻、let 很亲切 、const 更坚定</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务框架(二)——Spring Cloud</title>
      <link href="/2021/01/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%BA%8C)%E2%80%94%E2%80%94Spring%20Cloud/"/>
      <url>/2021/01/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%BA%8C)%E2%80%94%E2%80%94Spring%20Cloud/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.</p></blockquote><p>Spring Cloud是一系列框架的有序集合，它利用SpringBoot的开发便利性，巧妙地简化了分布式系统的基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以做到一键启动和部署。</p><p><strong>选用Spring Cloud的好处包括</strong>：</p><ul><li>基于HTTP协议，使用RESTFUL风格，接口简单方便，高效透明（Dubbo是使用RPC协议，性能稍优于HTTP协议，但是耦合度更高）</li></ul><h2 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h2><ul><li>服务注册中心：Spring Cloud Netflix Eureka</li><li>服务调用方式：RESTFUL API</li><li>服务监控：SpringBoot Admin</li><li>断路器：Spring Cloud Netflix Hystrix</li><li>服务网关：Spring Cloud Netflix Zuul</li><li>分布式配置：Spring Cloud Config</li><li>服务跟踪：Spring Cloud Sleuth</li><li>消息总线：Spring Cloud Bus</li><li>数据流：Spring Cloud Stream</li><li>批量任务：Spring Cloud Task</li></ul><h3 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h3><p>Eureka是Netflix开发的服务发现组件，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Spring Cloud将其集成在其子项目spring-cloud-netflix上，以实现Spring Cloud的服务发现功能。</p><p>我们可以将自定义的API接口注册到Spring Cloud Eureka上，Eureka负责服务的注册与发现，它的角色与ZooKeeper差不多，都是服务的注册与发现。所以，构成Eureka体系的包括：服务注册中心、服务提供者、服务消费者，主要包含两个组件：Eureka Server和Eureka Client。</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seo74I.png" alt="High Level Architecture"></p><blockquote><p>The architecture above depicts how Eureka is deployed at Netflix and this is how you would typically run it. There is <strong>one</strong> eureka cluster per <strong>region</strong> which knows only about instances in its region. There is at the least <strong>one</strong> eureka server per zone to handle <strong>zone</strong> failures.</p><p>Services <strong>register</strong> with Eureka and then send <strong>heartbeats</strong> to renew their leases every 30 seconds. If the client cannot renew the lease for a few times, it is taken out of the server registry in about 90 seconds. The registration information and the renewals are replicated to all the eureka nodes in the cluster. The clients from any zone can look up the <strong>registry</strong> information (happens every 30 seconds) to locate their services (which could be in any zone) and make remote calls.</p></blockquote><p>Eureka Server提供服务注册功能，提供者节点启动后，会在Eureka Server中进行注册，所以Eureka Server的服务注册表中将会存储所有可用服务节点的信息。各个提供者会向Euraka Server发送心跳，以告知Eureka Server自己的健康状况，默认周期为30秒。如果在多个心跳周期内都没有接收到某个提供者节点的心跳，那么Eureka Server就会认为其已经无法提供服务，就会将该节点从服务注册表中移除。Eureka Server之间是通过复制的方式完成数据的同步。</p><p>Eureka Client是一个Java客户端，是用于简化消费者与Eureka Server的交互。同时，Eureka Client内置有负载均衡器，为消费者从Eureka Server的服务注册表中选择合适的提供者。</p><p>Eureka提供了客户端缓存机制，即使所有的Eureka Server都宕机，客户端仍然能够利用缓存的信息为消费者提供服务发现功能。但此时就不再接受服务注册。</p><p>综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</p><h3 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud Hystrix"></a>Spring Cloud Hystrix</h3><p>Hystrix的意思是豪猪，所以，它表明了框架的主要功能：<strong>自我保护功能</strong>。Hystrix是一个用于处理分布式系统的延迟和容错的开源库。Hystrix具有服务降级，熔断，线程池隔离，信号量隔离，缓存等功能。它能够保证在一个依赖出现问题的情况下，不会倒置整体服务失败，避免级联故障，提高分布式系统的弹性。</p><p>「断路器」本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似保险熔断），向调用方法返回一个符合预期的，可处理的被选相应（FallBack降级操作），而不是长时间的等待或者抛出无法处理的异常。这样保证了服务调用方法的线程不会长时间，不必要地占用，从而避免了故障在分布式系统中的蔓延，从而导致雪崩效应。</p><p>如下图所示，断路器有对应的三个阶段：</p><ul><li>第一阶段：正常</li><li>第二阶段：发现超时或者失败后，标识失败</li><li>第三阶段：达到阈值之后，触发了熔断器策略，标识服务不可用，熔断器就自动断开。如果此时B对C有访问，熔断器会给B立刻返回失败，不再调用C。同时进行间断性尝试，判断服务是否恢复</li></ul><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seooEd.png" alt="Hystrix的三种情况"></p><p>Hystrix存在三种模式：</p><ul><li><strong>断路器模式</strong>：设置超时或者失败等熔断策略</li><li><strong>后备策略模式</strong>：在第二阶段或者第三阶段失败时，如果存在后备策略，都会去执行后备策略</li><li><strong>舱壁模式</strong>：保证一个服务独享一个线程池</li></ul><p>所以，Hystrix的功能执行如下：</p><ul><li>熔断触发前，超时或者失败发生时：<ul><li>如果存在后备策略，执行后备策略</li><li>如果不存在后备策略，抛出异常处理</li></ul></li><li>在熔断触发之前后，立即返回失败，保护下游失败<ul><li>存在后备策略，则执行</li><li>不存在，则抛出异常</li></ul></li><li>在熔断器触发了之后，还可以定期检查服务是否正常，将服务恢复正常</li></ul><h3 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h3><p>Spring Cloud Zuul是Spring Cloud Netflix子项目的核心组件之一，可以作为微服务架构中的API网关使用，支持动态请求路由、负载均衡、效验过滤、服务容错、服务聚合等功能。API网关为微服务架构中的服务提供了统一的访问入口，客户端通过API网关访问相关服务。</p><p>Zuul的核心是一系列的Filters，其作用类比于Servlet框架的Filter，或者AOP。其大部分功能都是通过过滤器来实现的，它们能够执行非常大范围的操作，并且可以在请求-响应生命周期的不同阶段运行，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seoTUA.png" alt="Zuul"></p><p>其定义了四种标准过滤器类型：</p><ul><li>PRE：这种过滤器在请求被路由之前调用。可以用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等</li><li>ROUTING：这种过滤器是用于构建发送给微服务的请求，并使用Apache HttpClient或者Netflix Ribbon请求微服务</li><li>POST：这种过滤器在路由到微服务以后执行，可用来为响应添加标准的HTTP Header、收集统计信息和指标、将相应从微服务发回给客户端等</li><li>ERROR：在其它阶段发生错误时执行该过滤器</li></ul><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seo5HH.png" alt="Zuul四种标准过滤器模型"></p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>在分布式系统中，因为服务数量很多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件Spring Cloud Config，它支持配置服务放在配置服务的内存中（本地），也支持放在远程Git中。</p><p>在Spring Cloud Config组件中，分两个角色：</p><ul><li>Config Server：一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序各个环境下的配置，为客户端提供获取配置信息、加密、解密信息等访问接口</li><li>Config Client：是Config Server的客户端，是微服务架构中的各个微服务应用或基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。</li></ul><p>基于消息总线的配置中心架构需要依赖外部的MQ组件，例如RabbitMQ或者Kafka等实现远程环境变更通知，客户端实时配置变更可以基于Git Hook功能实现。</p><h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>随着微服务部署的节点增多，以及对各个微服务的拆分后，对服务本身的日志和调用链路的监控变得更加困难。Spring Cloud Sleuth就是为了解决分布式链路追踪这个问题而生的。</p><p>Spring Cloud Sleuth的实体概念主要来源于谷歌在2010年发表的一篇论文：《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》：</p><ul><li>Span：基本工作单元。发送RPC就是一个新的span，就像RPC发送响应那样。Span携带了span的唯一64位标识、另外一个Trace的64位的标识。Span还有其余的数据，例如描述、带时间戳的事件、键值annotations（标签）等。</li><li>Trace：一组span造成的树状结构；</li><li>Annotation：用于及时记录事件的存在</li></ul><p>微服务日志追踪主要包括：</p><ul><li>日志输出</li><li>日志收集</li><li>分布式链路追踪：以集成Zipkin服务为基础，准备4个微服务工程：<ul><li>eureka server：复杂服务注册</li><li>zipkin server：负责链路数据收集以及查询</li><li>zuul-gateway：服务网关，负责调用</li><li>personal-service：作为后台server，负责调用</li></ul></li></ul><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>Spring Cloud Config的作用的帮助更新配置文件，即配置文件可以通过Config Server存储到Git地方，通过Config Client进行读取。但是配置发生变化时，又是如何进行更新的呢？</p><p>一种简单的方式是关闭服务，重新让Config Client进行获取。但是这样需要关闭服务，Spring Cloud肯定不允许这样做。那么，它需要通过「消息总线」的方式来进行通知。</p><p>这套机制是：我们使用消息代理来构建一个Topic，然后把微服务架构中的所有服务都连接到这个主题上，当我们向该主题发送消息时，所有订阅了该主题的服务都会收到消息并进行消费。目前Spring Cloud Bus支持两种主流的消息代理：RabbitMQ和Kafka。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/08/cnVklGj5eQwHoih.jpg" alt="Spring Cloud Bus的执行步骤"></p><p>从上图可以看出Spring Cloud Bus的执行步骤：</p><ul><li>提交代码给客户端A</li><li>客户端A收到了请求，从Server端更新配置，发送给Spring Cloud Bus</li><li>Spring Cloud Bus接收到消息，<strong>通知</strong>其它的客户端</li><li>其它客户端接收到通知，请求Server端，获取最新的配置</li><li>这样，全部的客户端都能获取到更新的配置</li></ul><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p>Spring Cloud Stream在Spring Cloud体系内用于构建高度可扩展的基于事件驱动的微服务。而SCS(Spring Cloud Stream)是在Spring Message和Spring Integration两个项目的基础上完成构建的。</p><p>Spring Message模块是Spring Framework的一个模块，其作用就是统一消息的编程模型。</p><p>生产者Producer发送消息到消息通道Message Channel中，消费者Consumer调用<code>receive()</code>方法从消息通道中获取到消息。</p><p>Spring Integration提供了Spring编程模型的扩展，用来支持企业集成模式（Enterprise Integration Patterns）。</p><p>Spring Integration是对Spring Messaging的扩展。它提出了不少新的概念，包括消息的路由MessageRoute、消息的分发MessageDispatcher、消息过滤Filter、消息转换Transfoer、消息聚合Aggregator、消息分隔Splitter等等。</p><hr><p>SCS则是Spring Integration的加强，同时与SpringBoot体系融合，也是Spring Cloud Bus的基础。<strong>它屏蔽了底层消息中间件的实现细节，希望以统一的一套API来进行消息的发送/消费，底层消息中间件的实现细节由各消息中间件的Binder来完成</strong>。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/08/gFcrRKha52Vzibl.png" alt="Binder细节"></p><p>Binder是提供与外部消息中间件集成的组件，会构造Binding，内部构造实现生产者和消费者。<strong>它是连接应用程序跟消息中间件的桥梁，用于消息的消费和生产</strong>。</p><p>SCS解决了开发人员无感知的使用消息中间件的问题，因为SCS对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至还可以动态切换中间件。这使得微服务开发的高度解耦，服务可以主要关注自己的流程。</p><h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><p>Spring Cloud Task允许用户使用Spring Cloud开发和运行短期微服务，并在云和本地运行，甚至还可以在Spring Cloud Data Flow上运行。</p><p>Spring Cloud Task主要是来解决<code>short lived microservices</code>的问题的。因为一般的应用服务都是长时间运转的不停止的，但是有些服务却具有以下特点：</p><ul><li>定时的服务</li><li>临时的服务</li><li>占用资源过多的服务</li></ul><p>这些服务因为重要性偏低，所以可以交个Spring Cloud Task来执行。除此之外，有些任务是串联的。一个业务会牵扯到多个业务，任务之间是通过事件触发的，这就是Spring Cloud Stream来解决的。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务框架(一)——Dubbo</title>
      <link href="/2021/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%B8%80)--Dubbo/"/>
      <url>/2021/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%B8%80)--Dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Dubbo是一个分布式服务框架，致力于提高性能和透明化的RPC远程过程调用的方案，以及SOA服务治理方案。</p></blockquote><p>其核心部分包括了：</p><ul><li><strong>远程通讯</strong>：提供对多种基于长连接的NIO框架的抽象封装，包括多种线程模型，序列化，以及「请求-响应」模式的信息交换模式等。</li><li><strong>集群容错</strong>：提供基于接口方法的透明远程过程调用，包括了多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>自动发现</strong>：基于注册中心目录服务，使服务消费者能够动态地查找服务提供方，使地址透明，使服务提供方可以平滑增加或者减少机器。</li><li><strong>服务自动注册与发现</strong>：不再需要写死服务提供方的地址，注册中心基于接口名来查询服务提供者的IP地址，并且能够平滑地添加或者删除服务提供者。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/crtWdhnKvSFzYm9.png" alt="Dubbo架构"></p><p><strong>节点角色的说明</strong>：</p><ul><li><strong>Provider</strong>：暴露服务的服务提供方</li><li><strong>Consumer</strong>：调用远程服务的服务消费方</li><li><strong>Registry</strong>：服务注册与发现的注册中心</li><li><strong>Monitor</strong>：统计服务的调用次数和调用时间的监控中心</li><li><strong>Container</strong>：服务运行的容器</li></ul><p><strong>调用关系说明</strong>：</p><ul><li>服务容器负责启动，加载，运行服务提供者</li><li>服务提供者在启动时，向注册中心注册自己提供的服务</li><li>服务消费者在启动时，向注册中心订阅自己所需要的服务</li><li>注册中心会返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li><li>服务消费者会从提供者地址列表中，基于软负载均衡的算法，选一台提供者进行调用，入股哦调用失败，再选择另一台进行调用</li><li>服务消费者和提供者，都会在内存中累计调用次数和调用时间，定时每分钟发送一个统计次数的数据到监控中心</li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>Dubbo提供的注册中心有以下几种类型可以选择：</p><ul><li>Multicast注册中心</li><li>ZooKeeper注册中心：ZooKeeper集群由一组Server节点组成，这一组Server节点中存在一个角色作为Leader的节点，其它节点则为Follower。当客户端Client连接到ZooKeeper集群后，执行写请求时，这些请求会被发送到Leader节点上，然后Leader节点上的数据变更会同步到集群中其它的Follower节点。</li><li>Redis注册中心</li><li>Simple注册中心</li></ul><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，保证高效、稳定的消息传输。Dubbo继承了目前主流的网络通信框架：</p><ul><li>Mina</li><li>Netty</li><li>Grizzly</li></ul><h3 id="远程调用协议"><a href="#远程调用协议" class="headerlink" title="远程调用协议"></a>远程调用协议</h3><p>Dubbo支持的远程调用协议：</p><ul><li>Dubbo协议</li><li>HTTP协议</li><li>RMI协议</li><li>Web Service协议</li><li>Thrift协议</li><li>Redis协议</li></ul><p>在通信过程中，不同的服务等级一般对应着不同的服务质量，所以要根据应用的创建场景来选择协议。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul><li><p>注册中心负责服务地址的注册与查找，<strong>相当于目录服务</strong>，服务提供者和消费者只在启动的时候与注册中心交互，所以注册中心不会转发请求，压力较小。</p></li><li><p>监控中心负责统计各个服务的调用次数、调用时间等，统计先在内存汇总后每分钟一个发送到监控中心的服务器里。</p></li><li><p>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间内是不包括网络开销的。</p></li><li><p>服务消费者向注册中心获取服务提供者的地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间是包含网络开销的。</p></li><li><p>注册中心、服务提供者、服务消费者三者之间都是<strong>长连接</strong>，监控中心除外。</p></li><li><p>注册中心通过长连接感知服务提供者的存在，如果服务提供者宕机了，注册中心会立即推送事件通知消费者；如果注册中心和监控中心都宕机了，不会影响已有的提供者和消费者，消费者在本地缓存了提供者的列表；注册中心和监控中心全部都宕机了，服务消费者可以直接连接服务提供者。</p></li></ul><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><ul><li>监控中心宕机了，不影响使用，只是会缺少部分采样数据；</li><li>数据库宕机了，注册中心仍能够缓存提供服务列表进行查询，但是不能注册新的服务</li><li>注册中心对等的集群中的任意一台宕机了，将自动切换到另外一台</li><li>注册中心全部宕机了，服务提供者和服务消费者仍然能够通过本地缓存进行通讯</li><li>如果服务提供者无状态了，任意一台宕机了，也不影响使用</li><li>如果服务提供者全部宕机了，服务消费者应用将无法使用，并且无限次重连等待服务提供者恢复</li></ul><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><p>注册中心对等集群，可以动态增加机器部署实例，所有客户端将自动发现新的注册中心；如果服务提供者无状态了，也可以动态增加机器部署实例，并且注册中心将推送新的服务提供者信息给消费者</p><h3 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h3><p>当服务集群规模进一步扩大，带动IT结构进一步升级，需要实现动态部署，进行流动计算，现有的分布式服务架构不会带来阻力。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重入锁ReentrantLock以及公平性问题</title>
      <link href="/2020/12/09/%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/09/%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>重入锁ReentrantLock，是指支持重进入的锁，表示锁可以支持一个线程对资源的重复加锁，即「任意线程在获取到这个锁之后，如果再次获取该锁，不会被锁阻塞」。重入锁还支持锁时的<strong>公平</strong>和<strong>非公平性</strong>（默认）的选择。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现重入的机制，需要解决以下两个问题：</p><ul><li>线程需要再次获取锁：锁一定要能够识别获取锁的线程是否是当前占据锁的线程，如果符合，就能够获取成功</li><li>锁需要得到最终的释放：线程重复了n次获取了锁之后，就需要在第n次释放锁后，其它的线程才能获取到该锁。主要是通过<strong>计数器</strong>来实现。锁每获取一次，计数器就要自增1；每释放一次，计数器就要自减1，一直减到0为止，表示当前线程已经成功释放了该锁，其它线程可以来获取该锁。</li></ul><h3 id="重入性和公平性"><a href="#重入性和公平性" class="headerlink" title="重入性和公平性"></a>重入性和公平性</h3><p>ReentrantLock不支持隐式的重入锁，但是可以在调用<code>lock()</code>方法时，已经获取到锁的线程，能够再次调用<code>lock()</code>方法获取锁且不被阻塞。ReentrantLock的公平与否，是通过构造方法来决定的，内部类<code>Sync</code>继承了<code>AQS</code>，分为公平锁<strong>FairSync</strong>和非公平锁<strong>NonfairSync</strong>。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><blockquote><p>先对锁进行获取的请求肯定是优先执行的，锁获取的顺序也符合请求的绝对时间顺序，类似于FIFO，那么就是公平锁。反之，就是非公平锁。</p></blockquote><p>以下是公平锁与非公平锁的测试输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁的结果</span></span><br><span class="line">FAIR lock by [<span class="number">9</span>], waiting by []</span><br><span class="line">FAIR lock by [<span class="number">10</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">9</span>]</span><br><span class="line">FAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">10</span>]</span><br><span class="line">FAIR lock by [<span class="number">12</span>], waiting by [<span class="number">9</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">FAIR lock by [<span class="number">9</span>], waiting by [<span class="number">13</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">FAIR lock by [<span class="number">13</span>], waiting by [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">FAIR lock by [<span class="number">10</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">FAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">FAIR lock by [<span class="number">12</span>], waiting by [<span class="number">13</span>]</span><br><span class="line">FAIR lock by [<span class="number">13</span>], waiting by []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁的结果</span></span><br><span class="line">UNFAIR lock by [<span class="number">10</span>], waiting by [<span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">10</span>], waiting by [<span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">9</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">9</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">12</span>], waiting by [<span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">12</span>], waiting by [<span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">13</span>], waiting by []</span><br><span class="line">UNFAIR lock by [<span class="number">13</span>], waiting by []</span><br></pre></td></tr></table></figure><p>从结果中我们可以看出，公平锁每次都是从同步队列中的第一个节点获取锁，而非公平锁则是会连续两次获取锁。</p><p>从开销上来看，<strong>公平锁的开销会更大一些</strong>，因为它每次都要切换到另一个线程，而对于非公平锁，会出现连续获取锁的对象，切换次数要少一些，所以<strong>非公平锁的开销会更小一些</strong>。所以，公平锁保证了锁的获取按照顺序进行，保证了公平性，解决了<strong>饥饿问题</strong>，但是增加了大量的线程切换。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="/2020/11/22/RabbitMQ%E5%85%A5%E9%97%A8/"/>
      <url>/2020/11/22/RabbitMQ%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列，即Message Queue(MQ)，是一种应用程序对应用程序的通信方法，。应用程序通过读写出入队列的消息来通信，而无须专用连接来连接它们。</p><p>消息队列是是典型的生产者、消费者模型。生产者不断生成消息添加到队列中，消费者不断地从队列中获取消息。因为消息的生产和消费都是异步的，并且消息队列只关注消息的发送与接收，并没有业务逻辑的侵入，这样就实现了生产者和消费者之间的解耦。</p><p>消息传递是指程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。</p><p>使用消息队列的好处就是将一些无需即时返回且耗时的操作提取出来，进行了异步处理，大大节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><h3 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h3><p>主要在三个方面：<strong>异步</strong>、<strong>解耦</strong>、<strong>削峰</strong></p><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>例如，用户注册模块，需要发送注册邮件和注册短信，那么传统的方式有：</p><ol><li>串行的方式：将注册信息直接写入数据库后，然后先发送注册邮件，再发送注册短信，以上三个任务都完成了，才返回给客户端；这种方式会让用户一直等待，假如每个阶段要消耗50ms，那么用户就需要等待150ms；</li><li>并行的方式：将注册的信息写入数据库后，同时发送邮件和短信，这样就让邮件和短信的阶段并行操作，节省了时间，用户只需要等待100ms；</li></ol><p>然而，如果使用消息队列，就更能够高效地处理。引入消息队列后，可以把发送邮件、短信等操作当作不是必须的业务逻辑来异步处理。假设，写入消息队列的时间是5ms，那么用户总共只需要等待写入数据库的时间加上写入消息队列的时间，总共是55ms。</p><h4 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h4><p>例如，对于一个购物系统而言，用户下单后，订单系统需要通知库存系统，那么最普通的做法就是「订单系统直接调用库存系统的接口去通知并更改」。</p><p>这种做法的缺点就是：</p><ul><li>当库存系统出现故障时，那么订单会失败</li><li>订单系统和库存系统直接联系过于紧密，高度耦合</li></ul><p>那么，如果引入消息队列呢？</p><p>用户下单后，订单系统完成持久化处理后，将消息写入消息队列中，直接返回用户订单下单成功；库存系统通过订阅订单系统的信息，获取下单消息，进行库存管理的操作。</p><p>这样，即使库存系统出现了故障，消息队列里存储的消息至少保证了消息的可靠传递，不会导致消息丢失。</p><h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p>例如，一个系统每天大部分时间的请求只有每秒50个，但是高峰期期间却会突增到每秒10000个请求，而系统最高只能处理1000个请求。所以，这样直接访问肯定会导致系统崩溃的。即<strong>低峰期无压力，高峰期扛不住</strong>。那么，如果使用了消息队列，把所有的请求都先写入消息队列，系统再从消息队列里慢慢拉取请求，只要拉取并处理的速度不超过系统自己能够处理的最大能力即可。</p><h3 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h3><ul><li>系统的可用性降低了，因为引入的外部依赖越过，系统就越复杂</li><li>使用消息队列，需要保证消息不能重复消费，消息不能丢失，已经消息传递的顺序等等问题</li><li>当生产者生产消息并添加到消息队列中就会直接返回请求成功，但是必须要确保已添加到消息队列的消息不会堆积，处理也不会出现问题，不然数据的一致性就会出现问题</li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>，是为面向消息的中间件设计的。基于此协议的客户端与消息中间件可传递消息，并不受不同产品或者不同编程语言等条件的限制。</p><blockquote><p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全等。</p></blockquote><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>JMS（Java Message Service）是Sun公司最早提出的消息标准，是为了Java应用提供统一的消息操作，它与AMQP有以下的不同：</p><ul><li>JSM定义了同一个接口；AMQP是通过规定协议来统一数据交互的格式；</li><li>JMS只能在Java语言中使用；而AMQP只是协议，是跨语言的；</li><li>JMS规定了两种消息模型；而AMQP的消息模型则更加丰富；</li></ul><h3 id="常见的AMQP"><a href="#常见的AMQP" class="headerlink" title="常见的AMQP"></a>常见的AMQP</h3><ul><li>ActiveMQ：基于JMS</li><li>RabbitMQ：基于AMQP协议，稳定性好</li><li>RocketMQ：基于JMS，是阿里开发的，由Apache维护</li><li>Kafka：分布式的消息系统，高吞吐量</li></ul><h2 id="消息队列的应用场景"><a href="#消息队列的应用场景" class="headerlink" title="消息队列的应用场景"></a>消息队列的应用场景</h2><p>一个大型的软件系统，会有很多的组件或者模块或者子系统，如果将这些模块进行通信呢？传统的IPC是很多都在单一系统上，模块耦合性很大，不适合拓展；如果使用Socket进行通信，那么又需要考虑到以下一些问题：</p><ul><li>信息的发送者和接收者如何维持这个连接，如果一方连接中断，丢失的数据怎么办</li><li>如何降低发送者和接收者的耦合度</li><li>如何让Priority高的接收者更先接受到数据</li><li>如果做到负载均衡？</li><li>如何做到可拓展，甚至可以将该通信模块发送到集群cluster上？</li><li>如何保证接收者接受到了完整、正确的数据</li></ul><p>AMQP协议就解决了以上问题，而RabbitMQ就是基于AMQP实现的。</p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><blockquote><p>RabbitMQ is the most widely deployed open source message broker.</p></blockquote><p>RabbitMQ就是在AMQP的基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持<strong>高并发</strong>，支持可拓展。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>启动rabbitmq：<code>rabbitmq-service start</code></li><li>关闭rabbitmq：<code>rabbitmq-service stop</code></li><li>启动监控管理器：<code>rabbitmq-plugins enable rabbitmq_management</code></li><li>关闭监控管理器：<code>rabbitmq-plugins disable rabbitmq_management</code></li><li>关闭应用：<code>rabbitmqctl stop_app</code></li><li>启动应用：<code>rabbitmqctl start_app</code></li></ul><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li>Broker：消息队列服务器实体</li><li>Exchange：消息交换机，指定消息按什么原则，路由由哪个队列（用于转发消息，但是不会被存储）</li><li>Queue：消息队列载体，每个消息都会被投入到一个或者多个队列中</li><li>Binding：将exchange和queue按照路由的规则绑定起来</li><li>Rounting Key：路由的关键字，exchange就是根据这个关键字进行消息投递</li><li>vhost：虚拟主机，一个broker里可以开启多个vhost，用作不同用户的权限分离</li><li>producer：消息生产者，就是投递消息的程序</li><li>consumer：消息消费者，就是接受消息的程序</li><li>channel：消息通道，在客户端的每个连接里，可以建立多个channel，每个channel代表一个任务</li></ul><h3 id="四种交换机Exchange"><a href="#四种交换机Exchange" class="headerlink" title="四种交换机Exchange"></a>四种交换机Exchange</h3><h4 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h4><p>其行为是「先匹配，再投送」。绑定时会设定一个rounting key，只有消息的rounting key匹配时，才会被交换机投送到绑定的队列中去。这是RabbitMQ默认的交换机模式，也是最简单的模式，是根据key全文匹配去寻找队列。</p><h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p>按规则转发消息主要是<strong>根据通配符</strong>。在这种交换机下，队列和交换机的绑定会定义一种路由模式。通配符需要在这种路由模式和路由键之间匹配后，交换机才能转发消息。</p><p>路由键必须是一串字符，用句号（.）隔开。</p><p>路由模式必须包含一个星号（*），主要是用于匹配路由键指定位置的一个单词，（#）表示相当于一个或者多个单词</p><h4 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h4><p>设置header attribute参数类型的交换机，headers是一个自定义匹配规则的类型。在队列与交换器绑定时，会设定一组键值对规则，消息中也包括了一组键值对属性，当有一对或者全部匹配时，消息就会被投送到对应的队列中。</p><h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><p>转发消息到所有绑定队列中，消息广播的模式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列。</p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><blockquote><p>消息在Producer中产生，发送到消息队列的Exchange上，Exchange根据配置的路由方式Rounting Key，发送到并绑定Queue。Queue将消息通过push或者pull的方式传递给Consumer。</p></blockquote><ol><li>客户端连接到消息队列的服务器，开启一个channel</li><li>客户端声明一个exchange，并设置相关属性</li><li>客户端声明一个queue，并设置相关属性</li><li>客户端使用rounting key，在exchange和queue之间建立好绑定关系</li><li>客户端投递信息到exchange</li><li>exchange收到信息后，根据rounting key和binding关系，将消息传递到queue中</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Testing)</title>
      <link href="/2020/11/19/Interview-Review(Testing)/"/>
      <url>/2020/11/19/Interview-Review(Testing)/</url>
      
        <content type="html"><![CDATA[<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按开发阶段</strong>：</p><ul><li>单元测试</li><li>集成测试</li><li>系统测试</li><li>验收测试</li></ul><p><strong>按是否运行</strong>：</p><ul><li>静态测试：不实际运行被测试的软件，而是只检查程序代码、界面或者文档中的错误</li><li>动态测试：实际运行被测试的软件，输入相应的测试数据，检查输出结果和预期结果是否符合</li></ul><p>所以，他两的区别是<strong>检测软件是否运行</strong>。</p><p><strong>按是否查看源代码</strong>：</p><ul><li>白盒测试：把被测软件当成黑盒子，只关心输入数据和输出结果，常用于软件的功能和性能</li><li>黑盒测试：把“盒子”打开，研究里面的源代码和程序结构，常用于软件的源代码<ul><li>功能<ul><li>逻辑功能测试</li><li>界面测试</li><li>易用性测试</li><li>安装测试</li><li>兼容性测试</li></ul></li><li>性能<ul><li>一般性能测试</li><li>稳定性测试</li><li>负载测试</li><li>压力测试</li></ul></li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>单元测试$\rightarrow$集成测试$\rightarrow$确认测试$\rightarrow$系统测试</p><ul><li>单元测试：对源程序中每一个程序单元（最小可测试单元）进行测试，检查各个模块是否正确实现规定的功能，从而发现错误。（该阶段涉及到编码和详细设计文档）</li><li>集成测试：为了检查与设计相关的软件体系结构的有关问题，检查概要设计是否合理。</li><li>确认测试：主要是检查已实现的软件是否满足需求规格说明书中确定的各种需求。</li><li>系统测试：把已确认的软件与其它系统元素（例如硬件、数据、人工等）结合在一起进行测试，以确定软件是否可以正常使用。</li></ul><h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><ol><li><strong>校正性维护</strong>：在软件交付使用后，一些隐含的错误在某些特定的使用环境下出现。校正性维护就是为了识别和纠正错误，修改软件性能上的缺陷，确定和修改错误。</li><li><strong>适应性维护</strong>：为了使应用软件适应计算机硬件、软件环境以及数据环境的变化而修改软件的过程就是适应性维护。</li><li><strong>完善性维护</strong>：为了增加软件功能、增强软件性能、提高运行效率而进行的维护活动就是完善性维护。</li><li><strong>预防性维护</strong>：为了提高软件的可维护性和可靠性而对软件进行的修改是预防性维护。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Software Engineering)</title>
      <link href="/2020/11/19/Interview-Review(Software%20Engineering)/"/>
      <url>/2020/11/19/Interview-Review(Software%20Engineering)/</url>
      
        <content type="html"><![CDATA[<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><blockquote><p>软件工程就是用科学的知识和技术原理来定义、开发、维护软件的一门学科。</p></blockquote><p>软件工程的三要素：<strong>工具</strong>、<strong>方法</strong>、<strong>过程</strong></p><p>软件开发中常见的软件过程模型有：</p><ul><li><strong>瀑布模型</strong></li><li><strong>快速原型模型</strong></li><li><strong>增量模型</strong></li><li><strong>螺旋模型</strong></li><li><strong>喷泉模型</strong></li><li><strong>统一软件过程</strong></li></ul><p>其中<strong>喷泉模型</strong>、<strong>统一软件过程</strong>适用于面向对象的软件开发。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><blockquote><p>瀑布模型（Waterfall Model）是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈</p></blockquote><p><strong>优点</strong>：</p><ol><li>为项目提供了按阶段划分的检查点</li><li>当前一阶段完成后，就只需要去关注后续阶段的实现</li><li>可在迭代模型中应用瀑布模型</li></ol><p><strong>缺点</strong>：</p><ol><li>在项目各个阶段之间极少有反馈</li><li>只有在项目生命周期的后期才能看到结果</li><li>需要通过过多的强制完成日期和<strong>里程碑</strong>来跟踪各个项目的阶段</li><li>不适应用户需求的变化</li></ol><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><blockquote><p>快速原型是快速建立起来的，可以在计算机运行的程序，它所能完成的功能往往是最终产品所完成的功能的一部分。</p></blockquote><p>它允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，这样就可以快速设计开发出软件系统的原型。该原型向用户展示待开发软件的全部或者部分功能和性能；然后，用户对该原型进行测试评定，给出具体的改进以及丰富细节化的需求；开发人员再根据此软件进行修改和完善，直到用户满意认可之后进行软件的完整实现以及测试、维护。</p><p><strong>开发步骤</strong></p><ol><li><p>快速分析</p><p> 在分析人员与用户密切配合下，迅速确定系统的基本需求，根据原型需要体现的特征描述基本需求以满足开发原型的需要</p></li><li><p>构造原型</p><p> 在快速分析的基础上，根据基本需求说明尽快实现一个可行的系统（要求具有强有力的软件工具的支持，并暂时忽略系统在某些细节上的要求）</p></li><li><p>运行原型</p><p> 发现问题，消除误解，需要开发者与用户充分地协调</p></li><li><p>评价原型</p><p> 在运行的基础上，考核评价原型的特性，分析运行效果是否满足用户的愿望，纠正过去交互中的误解和分析中的错误，增添新的要求，并满足因环境变化或用户的新想法引起的系统要求变动，提出全面的修改意见</p></li><li><p>修改</p><p> 根据评价原型的结果进行修改</p></li></ol><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><blockquote><p>使用增量模型开发软件时能把软件产品作为一系列的增量构件来设计、编码、集成和测试，每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</p></blockquote><p>所以，瀑布模型或者快速模型的目标都是一次就把一个满足所有需求的产品提交给用户，而<strong>增量模型是把整个软件产品分解成多个增量构件，分批地逐步向用户提交产品</strong>。</p><p><strong>优点</strong>：</p><ol><li>能够在较短的时间内向用户提交可完成部分工作的产品</li><li>将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时地了解软件项目的进展</li><li>以组件为单位就可以降低软件开发的风险，一个开发周期内的错误不会影响到整个软件系统</li><li>开发顺序灵活，开发人员可以对组件的实现顺序进行优先级排序，可以选择先完成需求稳定的核心组件。当优先级发生变化时，还可以及时地对实现顺序进行调整</li></ol><p><strong>缺点</strong>：</p><ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件很容易破坏已经构造好的系统部分，这需要软件具备开放式的体系结构</li><li>在开发的过程中，需求的变化是不可避免的，增量模型的灵活性可以适应这种变化，但是也容易退化为边做边修改模型，从而使控制失去整体性</li></ul><p><strong>缺点</strong>：</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><blockquote><p>螺旋模型是一种演化软件开发过程的模型，它兼顾了<strong>快速原型</strong>的迭代的特征和<strong>瀑布模型</strong>的系统化与严格监控的特征。</p></blockquote><p>它最大的特点在于引入了其它模型不具备的风险分析，使软件在无法排除重大风险时就有机会停止，以减小损失。</p><p>它分为<strong>四个象限</strong>：<strong>制定计划</strong>、<strong>风险分析</strong>、<strong>实施工程</strong>、<strong>客户评估阶段</strong>。螺旋模型在每个阶段之前以及经常发生的循环之前，都必须进行风险评估。</p><p><strong>优点</strong>：</p><ol><li>设计上的灵活性，可以在项目的各个阶段进行变更；</li><li>以小的分段来构建大型系统，使得成本计算更加容易；</li><li>客户始终参与到了每个阶段的开发，保证了项目不偏离正确方向；</li></ol><p><strong>缺点</strong>：建设周期太长，而软件技术发展较快。因此会出现软件开发和当前的技术水平有了较大的差距，无法满足当前用户需求。</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>喷泉模型（fountain model）是一种以用户需求为动力，以对象为驱动的模型，主要用于描述<strong>面向对象</strong>的软件开发过程。</p><p><strong>优点</strong>：</p><p>喷泉模型不像瀑布模型那样，需要一个阶段结束后才能进行下一个阶段。喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行开发。优点是可以提高软件项目的开发效率，节省开发的时间。</p><p><strong>缺点</strong>：</p><p>因为喷泉模型在各个开发阶段是重叠的，所以在开发过程中需要大量的开发人员，不利于项目的管理。此外，这种模型要求严格管理文档，使得审核的难度加大。</p><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><blockquote><p>敏捷开发以用户的需求进化为核心，采用迭代、循环渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试。</p></blockquote><p>敏捷框架除了Scrum以外，例如看板（Kanbab），测试驱动开发（TDD）和功能驱动开发（FDD）。</p><h3 id="统一软件过程"><a href="#统一软件过程" class="headerlink" title="统一软件过程"></a>统一软件过程</h3><blockquote><p>统一软件过程，不仅仅是一个简单的软件过程，而且是一个通用的过程框架，可以用于不同类型的应用系统、各种不同的应用领域、各种不同类型的组织、各种不同功能和规模的项目。它是基于构件的，即所构造的软件系统是由软件构件通过明确的定义的接口来相互连接所建造起来的。它可以使用统一建模语言（Unified Modeling Language，UML）来制定系统的所有蓝图。</p></blockquote><p>统一软件过程的特点：用例驱动、以构架为中心、迭代和增量的软件过程框架。</p><h4 id="统一过程是用例驱动的"><a href="#统一过程是用例驱动的" class="headerlink" title="统一过程是用例驱动的"></a>统一过程是用例驱动的</h4><p><strong>用户（User）</strong>：软件系统是为了解决用户的需求的，因此对于一个系统必须首先确定它的使用者——用户。</p><p><strong>用例（User Case）</strong>：是用户对系统的业务需求，即用例是能够像用户提供有价值结果的系统中的一种功能。</p><p>所有的用户和用例组合在一起就是用例模型，它描述了系统的全部功能。</p><h4 id="统一过程是以构架为中心的"><a href="#统一过程是以构架为中心的" class="headerlink" title="统一过程是以构架为中心的"></a>统一过程是以构架为中心的</h4><p>软件系统的构架是从不同的角度描述即将构造的系统。软件构架包含了系统中最重要的静态和动态的特征。<strong>构架刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性</strong>。</p><h4 id="统一过程是迭代和增量的过程"><a href="#统一过程是迭代和增量的过程" class="headerlink" title="统一过程是迭代和增量的过程"></a>统一过程是迭代和增量的过程</h4><ul><li><strong>迭代</strong>：工作流中的步骤</li><li><strong>增量</strong>：产品中增加的部分</li></ul><p>为了获得最佳的效果，迭代过程必须是受控的，即必须按照计划好的步骤有选择地执行。那么，迭代就是以选定的构架为向导，用构件来实现设计前期已经标识并详细描述好的有关用例。</p><h4 id="统一开发过程包含哪些阶段"><a href="#统一开发过程包含哪些阶段" class="headerlink" title="统一开发过程包含哪些阶段"></a>统一开发过程包含哪些阶段</h4><p>一次典型的迭代阶段有以下四个阶段：</p><ul><li>初始阶段（inception phase）：这个阶段主要是确定项目的风险以及其优先次序，并对细化阶段进行详细规划和对整个项目进行粗略地计算。</li><li>细化阶段（elaborattion phase）：这个阶段主要是解决用例、构架和计划是否足够稳定可靠，风险释放得到了充分控制，以便能够按照规定完成整个开发任务。</li><li>构造阶段（construction phase）：将构造出整个产品。</li><li>移交阶段（transition phase）：开发人员改正用户报告产品的缺陷和不足。</li></ul><h3 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h3><blockquote><p>结构化分析是指面向数据流进行数据分析的方法，采用了<strong>自顶向下</strong>逐层分解的分析策略。顶层抽象地描述整个系统，底层具体地画出系统工程的每个细节。中间层则是从抽象到具体的过渡，使用了<strong>数据流图</strong>、<strong>数据字典</strong>，使用<strong>结构化语言</strong>、<strong>判定表</strong>、<strong>判定树</strong>描述加工逻辑。</p></blockquote><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><blockquote><p>软件生命周期：一个软件从提出开发要求开始直到该软件废弃为止的整个时期，包括了三个大阶段、8个任务。</p></blockquote><p><strong>三大阶段</strong>：</p><ul><li>软件定义：</li><li>软件开发：</li><li>软件维护：</li></ul><p><strong>各阶段的任务</strong>：</p><ul><li>问题定义：要解决的问题是什么</li><li>可行性研究：问题是否有可行的解决办法</li><li>需求分析：目标系统必须要做什么（规格说明书）</li><li>总体设计：概况地说要怎么实现目标系统（概要设计）（确定程序由哪些模块组成以及各个模块间的关系）</li><li>详细设计：应该具体怎样实现系统（模块设计）（详细地设计每个模块，确定每个模块功能所需的算法和数据结构）</li><li>编码和单元测试：编写易理解、易维护的程序，并测试每个模块</li><li>综合测试：集成测试、验收测试、现场测试</li><li>软件维护：使系统持久地满足用户的需要</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Spring的控制反转和依赖注入以及AOP</title>
      <link href="/2020/11/15/%E7%90%86%E8%A7%A3Spring%E7%9A%84IOC%E5%92%8CDI%E4%BB%A5%E5%8F%8AAOP/"/>
      <url>/2020/11/15/%E7%90%86%E8%A7%A3Spring%E7%9A%84IOC%E5%92%8CDI%E4%BB%A5%E5%8F%8AAOP/</url>
      
        <content type="html"><![CDATA[<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>在了解控制反转之前，有必要了解软件设计里的一个重要思想：<strong>依赖倒置原则</strong>。</p><p>这里可以举一个汽车的例子来说明。假如我们来设计一辆汽车，先设计轮子，再根据轮子的大小去设计底盘，根据底盘去设计车身，最终根据车身来设计好整个车子。这样就会形成了一个如下的依赖关系：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/10/FKdvwgxujbYtLNR.png" alt=""></p><p>这种设计的维护性非常低。假如完工之后，需要更改轮子的设计，那么轮子上层的所有事物的设计都得修改，即整个设计都需要修改。</p><p>所以，我们需要换一种思路来实现。先设计出汽车的模型，再设计车身，根据车身设计底盘的大小，最后设计底层的轮子。那么，依赖关系就导致了。轮子的设计取决于底盘，底盘取决于车身，车身依赖车子的设计。所以，依赖关系变成了这样：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/10/MWhrfDItc6p8SV7.png" alt=""></p><p>这样，当需要修改轮子时，只要改动轮子自己的设计就可，因为没有实物是依赖于轮子的。如果是修改底盘，也只会影响到它底层的轮子，高层的事物不会被影响，就不会出现「牵一发而动全身」的情况了。</p><p>所以，原本是「高层建筑依赖底层建筑」，而现在变成了「底层建筑依赖于高层建筑」。</p><h2 id="控制反转和依赖注入"><a href="#控制反转和依赖注入" class="headerlink" title="控制反转和依赖注入"></a>控制反转和依赖注入</h2><p>Spring中经常提到的控制反转（Inversion of Control，IOC）和依赖注入（dependency injection-DI）是等同的概念，<strong>控制反转是通过通过依赖注入实现的</strong>。所谓的依赖注入指的是：</p><blockquote><p><strong>容器</strong>负责创建对象和维护对象间的依赖关系，而不是通过<strong>对象本身</strong>来负责自己的创建和解决自己的依赖。</p><p>即Spring这个容器替开发者管理着一系列的类，需要的时候，就不用自己去定义，而是直接向Spring容器去索取。</p></blockquote><p>依赖注入的主要目的是为了<strong>解耦</strong>，这是一种<strong>组合</strong>的概念。举个例子，如果一个类要具有某个功能时，如果是继承具有此功能的父类，那么该子类就与父类耦合。而如果这个类是去<strong>组合</strong>具有这个功能的其它类，那么耦合度就会大大降低。</p><p><strong>注入方式</strong>：</p><ul><li>set方式注入</li><li>构造方法注入</li><li>字段注入</li></ul><p><strong>注入类型</strong>：</p><ul><li>值类型注入</li><li>引用类型注入</li></ul><p>Spring IoC容器（ApplicationContext）是负责创建Bean，并通过容器将功能类Bean注入到自己需要的Bean中。Spring提供了多种不同的方式，如使用XML、<strong>注解</strong>、Java配置等来实现Bean的创建和注入。以上的这些配置方式都被称为是<strong>配置元数据</strong>，即<strong>描述数据的数据</strong>。Spring容器通过解析这些配置元数据就可以进行Bean的初始化、配置和管理依赖等。</p><p><strong>声明Bean的注解</strong>：</p><ul><li><code>@Component</code>组件：没有明确的角色。</li><li><code>@Service</code>：在业务逻辑层（Service层）中使用</li><li><code>@Repository</code>：在数据访问层（dao层）中使用</li><li><code>@Controller</code>：在表现层（MVC -&gt; SpringMVC）中使用</li></ul><p><strong>注入Bean的注解</strong>，一般情况下通用（下面三个注解都可以注解在<code>set</code>方法或者属性上，优点是代码少，层次清晰）：</p><p><code>@Autowired</code>：Spring提供的注解<br><code>@Inject</code>：JSR-330提供的注解<br><code>@Resource</code>：JSR-250提供的注解</p><h3 id="ApplicationContext和BeanFactory的区别"><a href="#ApplicationContext和BeanFactory的区别" class="headerlink" title="ApplicationContext和BeanFactory的区别"></a>ApplicationContext和BeanFactory的区别</h3><p><strong>ApplicationContext接口</strong></p><ol><li>每次容器启动时，就会创建容器中配置的所有对象</li><li>提供了更多的功能</li></ol><p><strong>BeanFactory接口</strong></p><ol><li>是Spring的原始接口，针对原始接口的实现类的功能较为单一</li><li>BeanFactory接口实现类的容器，特点是每次在获得对象时才会创建对象</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP即面向切面编程。Spring的AOP是用来解耦，<strong>AOP可以让一组类共享相同的行为</strong>。</p><p>面向对象是通过继承类和接口的方式，会使代码的耦合度增加。AOP就是弥补了OOP的不足之处。它能够让那些与业务无关，<strong>但是却被业务模块共同调用的逻辑或者责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，降低模块间的耦合度，有利于未来的拓展性和可维护性。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例如，银行系统里会有一个「取款」的流程和「查询余额」的流程。如果把它们两个的步骤都列举出来，会发现有一个相同的「验证流程」。那么，这个验证用户的代码是否可以提取出来，不放进主流程里呢？这里AOP就起到作用了。</p><p>在编写上述这个例子时，我们可以完全不考虑验证用户的步骤。我们可以在另外一个地方，写好验证用户的代码，然后通过，比如Spring，告知这段代码会被添加到哪些地方，Spring就会帮助我们copy过去。这样就降低了模块间的耦合度。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><strong>横切关注点</strong>：要对哪些方法进行拦截，拦截后怎么处理，这些关注点都是<strong>横切关注点</strong>。</li><li><strong>切面（aspect）</strong>：切面是指对横切关注点的抽象</li><li><strong>连接点（joinpoint）</strong>：指被拦截到的点，即<strong>被拦截的方法</strong></li><li><strong>切入点（pointcut）</strong>：对连接点进行拦截的定义</li><li><strong>通知（advice）</strong>：拦截到连接点之间要执行的代码</li><li><strong>目标对象</strong>：代理的目标对象</li><li><strong>织入</strong>：将切面应用到目标对象并导致代理对象创建的过程</li><li><strong>引入</strong>：引入可以在运行期为类动态地添加一些方法或者字段</li></ul><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ul><li><code>@Controller</code>：表明这个类是Spring里的Controller，将其声明为Spring的一个Bean，Dispatcher Servlet会自动扫描注解了解此注解的类，并且会把Web请求映射到注解<code>@RequestMapping</code>中。</li><li><code>@RequestMapping</code>：该注解是用来映射Web请求、处理类和方法的，可注解在类，也可注解在方法上。</li><li><code>@ResponseBody</code>：允许请求的参数放在请求体中</li><li><code>@PathVariable</code>：通过path可以看出，是用来接收路径参数的。</li><li><code>@RestController</code>：这其实是一个组合注解，组合了<code>@Controller</code>和<code>@ResponseBody</code>，所以如果是编写一个与界面交互数据有关的类，那么其实可以直接使用此注解。否则，就需要加<code>@Controller</code>和<code>@ResponseBody</code>的注解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池————建服务器应用程序的有效方法</title>
      <link href="/2020/11/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/"/>
      <url>/2020/11/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当需要频繁地创建多个线程进行耗时操作，每次都通过<code>new Thread</code>的方式去创建显然不是一种好的方式，因为每次<code>new Thread</code>新建和销毁对象性能较差，线程缺乏统一地管理，可能线程之间会竞争，可能会占用过多系统资源导致死锁，并且缺乏定时执行、线程中断等功能。</p><a id="more"></a><p>Java提供了<strong>4种</strong>线程池，它能够有效地管理、调度线程，避免过多的资源消耗。</p><p>它的优点如下：</p><ul><li>重用存在的线程，减少对象的创建、销毁的开销；</li><li>可有效地控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免阻塞；</li><li>可以提供定时执行、定期执行、单线程、并发数控制等功能；</li></ul><p>线程池都实现了<code>ExecutorService</code>接口，该接口定义了线程池需要实现的接口，比如<code>submit</code>、<code>execute</code>、<code>shutdown</code>等方法。它的实现有<code>ThreadPoolExecutor</code>以及<code>ScheduledThreadPoolExecutor</code>等等。JDK还提供了一个<code>Executors</code>的工厂类来简化创建线程池的流程。</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>一个线程包括以下四个基本组成部分：</p><ul><li>线程池管理器（ThreadPool）：用于创建并管理线程池，包括<strong>创建线程池</strong>、<strong>销毁线程池</strong>、<strong>添加新任务</strong>等；</li><li>工作线程（WorkThread）：线程池中线程，在没有任务时是处于等待状态，可以循环地执行任务；</li><li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行。它规定了任务的入口，任务执行完成后的收尾工作，任务的执行状态等等；</li><li>任务队列（TaskQueue）：用于存放没有处理的任务，提供一个缓冲机制。</li></ul><h3 id="设置线程数"><a href="#设置线程数" class="headerlink" title="设置线程数"></a>设置线程数</h3><ol><li><p>高并发、任务执行时间短的业务怎么使用线程池</p><p> <strong>线程池线程数可以设置为CPU核心数+1，减少线程上下文的切换</strong></p></li><li><p>并发不高、任务执行时间长的业务怎样使用线程池</p><ul><li>如果业务时间是集中在IO操作上，就是<strong>IO密集型的任务</strong>。因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，<strong>可以适当加大线程池中的线程数目（2 * CPU核心数）</strong>，让CPU可以处理更多的业务</li><li>如果是业务时间集中在计算操作上，那么就是<strong>CPU密集型的任务</strong>。所以同样设置为<strong>CPU核心数+1</strong>，减少线程上下文的切换即可。</li></ul></li><li><p>并发高、业务执行时间长的业务怎样使用线程池</p><p> 如果既是并发程度高，又是业务执行时间长的话，解决的关键在于整体架构的设计而不是线程池。</p></li></ol><h2 id="启动指定数量的线程——ThreadPoolExecutor"><a href="#启动指定数量的线程——ThreadPoolExecutor" class="headerlink" title="启动指定数量的线程——ThreadPoolExecutor"></a>启动指定数量的线程——ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的主要实现之一，功能是启动指定数量的线程以及将任务添加到一个队列中，并且将任务分发给空闲的线程。<code>Executors</code>的生命周期包括3种状态：运行、空闲、终止。</p><p>ThreadPoolExecutor的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="workingQueue"><a href="#workingQueue" class="headerlink" title="workingQueue"></a>workingQueue</h3><p>workingQueue有下列几个常用的实现：</p><p><code>ArrayBlockingQueue</code>：基于<strong>数组</strong>结构实现的有界队列，按照FIFO原则对任务进行排序。如果队列满了还有任务进来，就调用拒绝策略。<br><code>LinkedBlockingQueue</code>：基于<strong>链表</strong>结构实现的无界队列，按照FIFO原则对任务进行排序。因为是<strong>无界</strong>，所以肯定不会满，所以采用此队列会忽略拒绝策略。<br><code>SynchronousQueue</code>：直接将任务提交给线程而不是将它加入到该队列中，所以实际上这个队列是空的。当新任务来了，但是线程池中不存在任何可以被调用的线程时，就会调用拒绝策略。<br><code>PriorityBlockingQueue</code>：具有优先级的有界队列，可以自定义优先级。</p><p>当线程池与工作队列都满了的情况，对于新添加任务也有一些默认实现的处理策略，例如拒绝策略等。</p><ul><li><code>AbortPolicy</code>：拒绝任务，会抛出异常，是线程池默认的策略</li><li><code>CallerRunsPolicy</code>：拒绝新任务进入，如果该线程池还没有被关闭，那么新任务执行在调用线程中。</li><li><code>DiscardOldestPolicy</code>：如果执行程序尚未关闭，那么工作队列头部的任务将被删除，然后重试执行程序（如果失败，继续反复重试）。这样的结果会导致最后加入的任务反而可能被执行到，而先前加入的任务都被抛弃了。</li><li><code>DiscardPolicy</code>：加不进的任务都会被抛弃，不会抛出异常。</li></ul><h2 id="可缓存线程池——CachedThreadPool"><a href="#可缓存线程池——CachedThreadPool" class="headerlink" title="可缓存线程池——CachedThreadPool"></a>可缓存线程池——CachedThreadPool</h2><blockquote><p>任务线程传入时自动分配线程，线程不够时自动创建新的线程</p></blockquote><ul><li>线程数无限制</li><li>有空闲线程就复用空闲线程，若无空闲线程则新建线程，一定程度上减少频繁创建/销毁线程，减少系统开销</li></ul><h2 id="固定长度的线程池——FixedThreadPool"><a href="#固定长度的线程池——FixedThreadPool" class="headerlink" title="固定长度的线程池——FixedThreadPool"></a>固定长度的线程池——FixedThreadPool</h2><blockquote><p>指定线程池线程的个数，任务线程传入时自动分配线程，线程不够时，剩余的任务线程排队等待线程池中的线程执行完毕</p></blockquote><ul><li>可控制线程最大的并发数（即同时执行的线程数）</li><li>超出的线程会在队列中等待</li></ul><h2 id="定时执行一些任务——ScheduledThreadPoolExecutor"><a href="#定时执行一些任务——ScheduledThreadPoolExecutor" class="headerlink" title="定时执行一些任务——ScheduledThreadPoolExecutor"></a>定时执行一些任务——ScheduledThreadPoolExecutor</h2><blockquote><p>指定线程池中线程的个数，任务线程传入时自动分配线程，可以设定任务线程第一次执行时的延时时间和之后每次执行的间隔时间。</p></blockquote><p>当需要定时地执行一些任务时，就可以通过<code>ScheduledThreadPoolExecutor</code>来实现，只需要通过<code>Executors</code>的<code>new ScheduledThreadPool</code>函数就可以创建定时执行任务的线程池。</p><ul><li>不要对那些同步等待其他任务结果的任务排队，否则可能导致死锁。在死锁中，所有线程都被一些任务所占用，而这些任务依次排队等待，又无法执行，这样所有的线程都属于忙碌状态。</li><li>理解任务————要有效地调整线程池的大小。</li><li>避免线程太少或者线程太多。</li></ul><h2 id="单线程化的线程池——SingleThreadExecutor"><a href="#单线程化的线程池——SingleThreadExecutor" class="headerlink" title="单线程化的线程池——SingleThreadExecutor"></a>单线程化的线程池——SingleThreadExecutor</h2><ul><li>有且仅有一个工作线程在执行任务</li><li>所有任务按照指定的顺序执行，即遵循队列的先入队出队的原则</li></ul><h2 id="有效的方法——BlockingQueue"><a href="#有效的方法——BlockingQueue" class="headerlink" title="有效的方法——BlockingQueue"></a>有效的方法——BlockingQueue</h2><p>阻塞队列提供了一系列有用的特性。例如，当队列满了时再调用<code>put</code>函数添加元素时，调用线程将被堵塞，直到队列不再是填满状态为止。</p><p>BlockingQueue中重要的方法有：</p><ul><li><code>add(e)</code></li><li><code>offer(e)</code></li><li><code>offer(e,time,unit)</code></li><li><code>put(e)</code></li><li><code>take()</code></li><li><code>poll(time,unit)</code></li><li><code>element()</code></li><li><code>peek()</code></li><li><code>remove()</code></li></ul><p>BlockingQueue主要有三种：</p><ul><li>基于数组的先进先出队列，有界：ArrayBlockingQueue</li><li>基于链表的先进先出队列，无界：LinkedBlockingQueue</li><li>无缓冲的等待队列，无界：SynchronousQueue</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>之前已经介绍了，ArrayBlockingQueue是一个基于<strong>数组</strong>结构实现的有界环形队列，按照FIFO原则对任务进行排序。如果队列满了还有任务进来，就调用拒绝策略。其原理就是利用了Lock锁的Condition通知机制进行阻塞控制。</p><p>那么，它主要使用<code>ReentrantLock</code>类中有一个<code>Condition</code>，它用于实现线程间的通信，是为了解决<code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code>难以使用的问题。</p><ul><li><code>await()</code>：线程等待的方法</li><li><code>await(int time, TimeUnit unit)</code>：线程等待特定的时间，超过时间则为超时</li><li><code>signal()</code>：随机唤醒某个等待线程</li><li><code>signalAll()</code>：唤醒所有等待中的线程</li></ul><p>当MyArrayBlockingQueue的元素为最大容量时，如果再往该队列中添加元素，就会调用<code>notFull.await()</code>函数使得线程阻塞，直到其它线程调用了<code>take()</code>方法从该队列中取出了元素，才不是已满状态。可以使用<code>notFull.signalAll()</code>方法唤醒所有的等待线程，使得添加元素的操作得以进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayBlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队满的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队空的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的头部索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的尾部索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyArrayBlockingQueue&lt;Integer&gt; aQueue = <span class="keyword">new</span> MyArrayBlockingQueue&lt;&gt;();</span><br><span class="line">        aQueue.put(<span class="number">3</span>);</span><br><span class="line">        aQueue.put(<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(aQueue.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == getCapacity()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数据已满，等待"</span>);</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[tail] = t;</span><br><span class="line">            <span class="keyword">if</span> (++tail == getCapacity()) &#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// 唤醒等待数据的线程</span></span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"还没有数据，请等待"</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = items[head];</span><br><span class="line">            items[head] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++head == getCapacity()) &#123;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// 唤醒添加数据的线程</span></span><br><span class="line">            notFull.signalAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ol><li>拿到了线程竞争lock锁，拿到了lock锁的线程就进入下一步，没有拿到lock锁的线程就自旋竞争锁；</li><li>判断阻塞队列是否已满，如果满了就调用<code>await()</code>方法阻塞这个线程，notFull（生产者）挂起，最后释放lock锁，等待被消费者线程唤醒；</li><li>如果没有满，则调用<code>enqueue()</code>方法将元素put进阻塞队列；</li><li>唤醒一个标记为<code>notEmpty()</code>（消费者）的线程。</li></ol><h4 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h4><ol><li>拿到了线程竞争lock锁，拿到了lock锁的线程就进入下一步，没有拿到lock锁的线程就自旋竞争锁；</li><li>判断阻塞队列是否为空，如果为空就调用<code>await()</code>方法阻塞这个线程，notEmpty（生产者）挂起，最后释放lock锁，等待被生产者线程唤醒；</li><li>如果没有空，则调用<code>dequeue()</code>方法将元素take出阻塞队列；</li><li>唤醒一个标记为<code>notFull()</code>（消费者）的线程。</li></ol><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue是基于链表的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表组成），当生产者往队列中放入一个数据时，队列会从生产者中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者队列消费了数据，生产者才能继续工作。反之消费者端也是同样的。</p><p>LinkedBlockingQueue之所以能够高效处理并发数据，是因为对生产者端和消费者端都分别采用了独立的锁来控制数据同步，所以在高并发的情况下，生产者和消费者可以并行地操作队列中的数据，以此提高整个队列的并发性能。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue中的元素只有当自己指定的延迟时间到了，才可以从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据是不会被阻塞的，只有获取数据会被阻塞。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是基于优先级的阻塞队列（优先级的判断是通过构造函数传入的<code>Compator</code>对象来决定的）。PriorityBlockingQueue不会阻塞生产者，只会当没有可消费的数据时，才会阻塞消费者。所以，<strong>生产者生产数据的速度绝对不能快于消费者数据的速度</strong>，否则时间长了后会耗尽所有的可用的堆内存空间（因为不会阻塞生产者）。</p><blockquote><p>实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p></blockquote><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue是一种无缓冲的等待队列，类似于无中介的直接交易，生产者直接与消费者交易，少了一个中间经销商的环节（缓冲区）。</p><p>声明一个SynchronousQueue有两种不同的方式：公平模式和非公平模式。</p><p><strong>公平模式</strong>：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略。</p><p><strong>非公平模式</strong>：SynchronousQueue会采用非公平锁，同时配合一个LIFO的队列来管理多余的生产者和消费者。</p><h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><blockquote><p>丢弃任务并抛出RejectedExecutionException异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task"</span> + r.toString()</span><br><span class="line">        + <span class="string">" rejected from "</span> + e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><blockquote><p>丢弃任务，但是并不抛出异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DisCardOldSetPolicy"><a href="#DisCardOldSetPolicy" class="headerlink" title="DisCardOldSetPolicy"></a>DisCardOldSetPolicy</h3><blockquote><p>丢弃队列最前面的任务，然后提交新来的任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        e.executor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CallerRunPolicy"><a href="#CallerRunPolicy" class="headerlink" title="CallerRunPolicy"></a>CallerRunPolicy</h3><blockquote><p>由调用线程（提交任务的线程，主线程）处理该任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>141.Linked List Cycle</title>
      <link href="/2020/11/05/141.Linked-List-Cycle/"/>
      <url>/2020/11/05/141.Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个链表，判断链表中是否有环。</p></blockquote><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/LinkedListRing.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/LinkedListRing.java</a></p><p>这个题目可以衍生为三个问题。</p><ol><li>判断一个带头节点的单链表L是否有环</li><li>假如有环，找出环的入口节点</li><li>求环的长度</li></ol><p>要判断单链表是否有环，肯定要判断两个指针是否相等。可以用到「<strong>快慢指针法</strong>」。设置两个指针fast和slow，都是从头节点触发往后走，slow每次走一步，fast每次走两步，这两个指针一直往后面走，直到后面fast为空，则说明单链表没有环。如果直到fast走到与slow相等，则说明单链表有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasRing</span><span class="params">(LNode l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都指向头节点开始</span></span><br><span class="line">    LNode p = head;</span><br><span class="line">    LNode q = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快指针</span></span><br><span class="line">        q = q.next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针</span></span><br><span class="line">    p = p.next;</span><br><span class="line">    <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当p=q时，说明相遇，则有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找入口节点则是在上面的程序后添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (head != p) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">    head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>求环的长度是在找到入口节点后，再绕一圈回到入口节点时，走过的路程就是环的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p是上面的程序中找到的入口节点的指针；</span></span><br><span class="line">LNode p;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LNode q = p.next;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">    length++;</span><br><span class="line">    q = q.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当p=q时，说明回到了入口节点</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>136. Single Number</title>
      <link href="/2020/11/05/136.Single-Number/"/>
      <url>/2020/11/05/136.Single-Number/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗<br>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote><p>因为要求「不使用额外的空间」，所以使用集合、HashMap等方式都是不可取的。不然的话，思路大概有以下几种：</p><ul><li>使用<strong>集合</strong>存储数字。遍历数组中的每个数字，如果集合中没有该数字，就将其加入集合，如果已存在，就将它从集合中删除。这样最后剩下的数字就是只出现了一次的数字。</li><li>使用HashMap来存储<strong>每个数字</strong>和<strong>该数字出现的次数</strong>。遍历数组，就可以得到每个数字出现的次数，然后更新HashMap的值，最终为1的就是只出现一次的数字。</li><li>使用Set集合存储数组中出现的所有数字，并计算数组中的元素之和。由于Set集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</li></ul><p>上述的三种方法都需要$O(n)$的空间，所以并不满足此题的要求。</p><p>这里需要注意的是如果是List，则<code>remove()</code>方法需要是移除元素而不是索引，因为是一个整型数组，所以需要用<code>indexOf()</code>的方法获取具体的元素值，不然就默认是索引值。而如果是Set，则没有<code>get()</code>方法，需要用<code>iterator()</code>的方法去显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniqueAward1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.contains(nums[i])) &#123;</span><br><span class="line">            list.remove(list.indexOf(nums[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashSet方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniqueAward2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) &#123;</span><br><span class="line">            set.remove(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用集合数组相减的方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniqueAward3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> countArray = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countSet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sets.add(nums[i]);</span><br><span class="line">        countArray += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = sets.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        countSet += it.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * countSet - countArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用<strong>位运算</strong>。对于这道题，可使用<strong>异或运算</strong>$\oplus$。异或运算有以下三个性质。</p><ul><li>任何数和0做异或运算，结果仍然是原来的数，即 $a \oplus 0=a$。</li><li>任何数和其自身做异或运算，结果是0，即$a \oplus a=0$。</li><li>异或运算满足交换律和结合律，即$a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=b$。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        single ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148.Sort List</title>
      <link href="/2020/11/05/148.Sort-List/"/>
      <url>/2020/11/05/148.Sort-List/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表的排序"><a href="#单链表的排序" class="headerlink" title="单链表的排序"></a>单链表的排序</h2><blockquote><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>具体思路是：</p><ul><li>定义一个辅助节点aux，永远指向链表头结点，即aux.next=head;</li><li>定义当前节点cur和它的上一个节点pre，如果<code>pre.next&lt;=cur.next</code>,那么pre节点和cur节点同时向后移动</li><li>如果<code>pre.next&gt;cur.next</code>，切断pre节点和cur节点的引用关系，令<code>pre.next=cur.next</code>，把cur节点插入前面恰当位置</li><li>定义节点<code>node1=aux</code>和<code>node2=aux.next</code>，同时向后移动node1和node2，当出现<code>cur.val&lt;node2.val</code>时，把cur插入node1和node2之间</li><li><code>cur节点变为pre.next</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">sortLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    Node aux = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 辅助节点永远指向头节点</span></span><br><span class="line">    aux.next = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果cur节点的值比前一节点的值小</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; pre.val) &#123;</span><br><span class="line">            <span class="comment">// 前一节点直接跳过cur，指向cur的后一节点</span></span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            Node node1 = aux;</span><br><span class="line">            Node node2 = aux.next;</span><br><span class="line">            <span class="comment">// 遍历，找到一个节点的值要比cur更小的节点</span></span><br><span class="line">            <span class="keyword">while</span> (cur.val &gt; node2.val) &#123;</span><br><span class="line">                node1 = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到后，就将这两个值排序</span></span><br><span class="line">            node1.next = cur;</span><br><span class="line">            cur.next = node2;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 往后移动，接着查找</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aux.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22.Generate Parenttheses</title>
      <link href="/2020/11/05/22.Generate-Parentheses/"/>
      <url>/2020/11/05/22.Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GenerateParentheses.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GenerateParentheses.java</a></p><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</p></blockquote><p>假如输入n=3，结果会输出5，因为结果：”((()))”, “(())()”, “(()())”, “()(())”, “()()()”。</p><p>即输入一个数，会返回所有可能的括号组合的数量。</p><p>通过观察，会有以下规律：</p><ul><li>左括号的数量总是与右括号的数量相等</li><li>左括号总是位于右括号的左侧</li><li>必须要形成合理的包含关系</li></ul><p>这里可以使用递归帮助解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String str, List&lt;String&gt; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        lists.add(str);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        str = str + <span class="string">"("</span>;</span><br><span class="line">        dfs(str, lists, left - <span class="number">1</span>, right);</span><br><span class="line"><span class="comment">//            str = str.substring(0, str.length() - 1);</span></span><br><span class="line">        System.out.println(<span class="string">"字符串1："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">        str = str + <span class="string">")"</span>;</span><br><span class="line">        dfs(str, lists, left, right - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//            str = str.substring(0, str.length() - 1);</span></span><br><span class="line">        System.out.println(<span class="string">"字符串2："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果左括号大于0，则加上一个左括号，说明左括号有的多，然后数量减1。</p><p>如果右括号数量大于左括号，则说明右括号需要跟前面的左括号相匹配，则右括号数量减1。</p><p>当<code>left == 0 &amp;&amp; right == 0</code>时，说明已经不剩下括号了，那么就将最后的字符串加入到list中。</p><p>例如，n=2，则排列出的组合有：</p><script type="math/tex; mode=display">L\qquad R</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">2\qquad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">1\qquad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">0\qquad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">1\qquad1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">0\qquad1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">0\qquad0</script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268.Missing Number</title>
      <link href="/2020/11/05/268.Missing-Number/"/>
      <url>/2020/11/05/268.Missing-Number/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349.Intersection of Two Arrays</title>
      <link href="/2020/11/05/349.Intersection-of-Two-Arrays/"/>
      <url>/2020/11/05/349.Intersection-of-Two-Arrays/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>547.Find Circle Num</title>
      <link href="/2020/11/01/547.Find-Circle-Num/"/>
      <url>/2020/11/01/547.Find-Circle-Num/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>朋友圈</strong><br>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1：</p><p>输入：<br>[[1,1,0],<br> [1,1,0],<br> [0,0,1]]</p><p>输出：2 </p><p>解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回 2 。</p><p>示例 2：</p><p>输入：<br>[[1,1,0],<br> [1,1,1],<br> [0,1,1]]</p><p>输出：1</p><p>解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。</p><p>提示：</p><p>1 &lt;= N &lt;= 200</p><p>M[I][I] == 1</p><p>M[I][j] == M[j][I]</p></blockquote><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>可以用邻接矩阵的方式将其看成是一个图，所以其实就是寻找连通顶点的个数。</p><p>通过创建一个大小等于邻接矩阵大小的visited数组，例如$M=N*N$，<code>visited[i]</code>用来存储第i个元素是否被深度优先遍历搜索过。</p><p>我们首先选择一个节点，访问任一相邻的节点。然后再访问这一节点的任一相邻节点。这样不断遍历到没有未访问的相邻节点时，回溯到之前的节点进行访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个长度大小为M的visited数组</span></span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(M, visited, i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 当M[i][j]==1说明有朋友圈，并且如果visited数组元素为0时，说明未被遍历过</span></span><br><span class="line">        <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 令visited元素为1</span></span><br><span class="line">            visited[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 继续深度遍历</span></span><br><span class="line">            dfs(M, visited, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：因为要遍历整个矩阵的每一个元素，所以是$O(n^2)$</li><li><strong>空间复杂度</strong>：创建了一个visited数组来存储元素，所以是$O(n)$</li></ul><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>如果把矩阵看成的图的邻接矩阵，就是计算连通块的个数。那么，可以用到图中的<strong>广度优先搜索</strong>。</p><p>在广度优先搜索中，从一个特定点开始，访问所有邻接的节点。然后对于这些邻接节点，我们依然通过访问邻接节点的方式，直到访问所有可以到达的节点。因此，我们按照一层一层的方式访问节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="comment">// 如果队列不为空</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = queue.remove();</span><br><span class="line">                visited[s] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (M[s][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">                        queue.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(JVM)</title>
      <link href="/2020/10/29/Interview-Review(JVM)/"/>
      <url>/2020/10/29/Interview-Review(JVM)/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM内存共分为<strong>虚拟机栈</strong>、<strong>堆</strong>、<strong>方法区</strong>、<strong>程序计数器</strong>、<strong>本地方法栈</strong>五个部分。</p><p><strong>线程私有的</strong>：</p><ul><li>程序计数器 Program Counter Register</li><li>虚拟机栈 VM Stack</li><li>本地方法栈 Native Method Stack</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆 Heap</li><li>方法区 Method Area</li><li>直接内存（直接内存并不是运行时数据区域的一部分）</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块<strong>较小的内存空间</strong>，是当前线程所执行的字节码的行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都要依赖这个计数器来完成。</p><p>每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，所以这块内存区域被称为<strong>线程私有</strong>的内存。</p><p><strong>作用</strong>：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制：顺序执行、选择、循环等。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而线程被切换回来可以知道上次运行到哪。</li></ul><blockquote><p>程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></blockquote><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java内存可以分为<strong>堆内存</strong>和<strong>栈内存</strong>，这里的栈指的就是<strong>虚拟机栈</strong>。</p><p>虚拟机栈中的<strong>局部变量表</strong>主要存放了各种数据类型（八种基本数据类型）、对象引用（可能是指向对象起始地址的引用指针）等。</p><blockquote><p>Java虚拟机会出现两种错误：<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>。</p></blockquote><p>Java栈类比数据结构中的栈，保存的主要内容是栈帧，每次的函数调用都有对应的栈帧被压入Java栈，而每次函数的调用结束，都会有一个栈帧被弹出。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈的区别在于：本地方法栈是为虚拟机使用到的Native方法服务，而虚拟机栈是为执行Java（字节码）服务。「HotSpot」虚拟机中，这两个栈合二为一。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是Java虚拟机中所管理的内存最大的一块，是所有线程都共享的一块区域。这块区域的目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java堆是垃圾收集器管理的主要区域，所以也被称作<strong>GC堆</strong>。因为垃圾回收器都基本采用分代垃圾回收算法，所以Java堆还可细分为：<strong>新生代</strong>和<strong>老年代</strong>，目的是为了更好地回收内存，或者更快地分配内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也是所有线程都共享的一块区域，用于<strong>存储已被虚拟机加载的类信息、常量、静态便令、即时编译后的代码等数据</strong>。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存被频繁地使用。它避免了在Java堆和Native堆之间来回复制数据。</p><h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfFknK.png" alt="Java创建对象的过程"></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>虚拟机遇到一条new指令时，会去首先检查这个指令的参数能否在常量池定位到这个类的符号引用，并检查这个符号引用代表的类是否被加载过、解析过和初始化过。如果没有，就要执行类的加载过程。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：这个类加载器由C++实现，是虚拟机自身的一部分；启动类加载器无法被Java程序直接引用的。</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个加载器由sun.misc.Launcher$ExtClassLoader实现，开发者可以直接使用该扩展类加载器。</li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：这个类加载器由sun.misc.Launcher$AppClassLoader实现。它一般被称为系统类加载器，负责加载用户类路径上所指定的类库。开发者可以直接使用这个类加载器，一般就是程序中默认的类加载器。</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>类加载器之间的层次关系，被称为是类加载器的双亲委派模型。其中，除了顶层加载器之外，其余的类加载器都会有自己的父类加载器。它们之间的父子关系不是<strong>继承</strong>，而是以<strong>组合</strong>的关系来复用父类加载器的代码。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/PWeOThwsN7BSRck.png" alt="双亲委派模型"></p><p>双亲委派模型的工作过程是：</p><blockquote><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求都委派给父类加载器去完成，每一个层次的类加载器都是如此。所以所有的加载请求最终都会被传送到顶层的启动类加载器中。只有当父类加载器无法完成这个加载请求时（即它的搜索范围类没有找到这个类），子加载器才会尝试自己去完成这个加载请求。</p></blockquote><p>双亲委派模型的好处就是<strong>Java随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。比如Object类在各种类加载环境中都是同一个类，即<code>java.lang.Object</code>。</p><p>而如果没有双亲委派模型的话，如果开发者自己编写了一个同名的Object类，那么系统中会有多个Object类，那么需要加载哪个类就很混乱。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>之所以有时候要破坏双亲委派模型，是因为在某些情况下，父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器可能会无法加载到需要的文件，这时候就需要启动类加载器来委托子类来加载实现，从而破坏了双亲委派模型（<strong>上述的只是一个例子</strong>）。</p><p>到目前为止，双亲委派模型出现过三次较大规模的「<strong>被破坏</strong>」情况：</p><ul><li>第一次其实出现在双亲委派模型之前，即JDK1.2发布之前。当时，用户必须去重写<code>loadClass</code>方法去继承<code>java.lang.ClassLoader</code>。</li><li>第二次是由于这个模型自身的缺陷导致的。双亲委派模型很好地解决了各个类加载器的基础类的统一问题，但是当基础类又要调回到用户的代码中，该怎么办？为了解决这个问题，Java设计团队引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置。如果创建线程时还没有设置，它将会从父线程中继承一个，如果整个应用程序的全局范围内都没设置过的话，那么这个类加载器默认就是应用程序类加载器。</li><li>第三次是因为用户对于程序动态性的追求导致的。因为用户最求一些例如：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，不需要重启服务器就能立即使用的情况。</li></ul><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载检查过后，就要为新生对象分配内存。分配方式有两种：</p><ul><li>指针碰撞</li><li>空闲列表</li></ul><blockquote><p>具体选择哪种方式由Java堆是否规整来决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理的功能来决定。</p></blockquote><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、对象的哈希码、对象GC分代等信息，都存储在信息头中。</p><h3 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行<code>init</code>方法</h3><p><code>new</code>指令之后会接着执行<code>init</code>方法，初始化之后对象才算完全生产出来。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包括两部分信息：</p><ul><li>第一部分：用于存储对象自身的运行时数据（哈希码、GC分代年龄、锁标志）等</li><li>第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是<strong>对象真正存储的有效信息</strong>，也是程序中所定义的各种类型的字段内容。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充部分不是必然存在的，也没有特别的含义，仅仅起到占位作用。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>对于对象的访问方式，主流的有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p><h3 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h3><p>使用句柄的话，Java堆中会划分出一块内存来作为句柄池，<strong>引用存储的就是对象的句柄地址</strong>，句柄中包括了对象实例数据与类型数据鸽子的具体地址信息；</p><p><a href="https://imgchr.com/i/BfLnns" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfLnns.png" alt="使用句柄"></a></p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针，那么<strong>引用存储的就是对象的地址</strong></p><p><a href="https://imgchr.com/i/BfLuBn" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfLuBn.png" alt="直接指针"></a></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>两种对象的访问方式各有优劣。使用句柄的好处是引用存储的是稳定的句柄地址，那么对象移动时只会改变句柄中的实例数据指针。</p><p>使用直接指针访问的最大好处是速度快，节省了一次指针定位的时间花销。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>垃圾回收（Garbage Collection）是一种自动的内存管理机制。当动态内存不再需要时，就应当予以释放，以让出内存，这就是<strong>垃圾回收</strong>。</p><p>垃圾回收算法的优缺点主要看以下几个方面：</p><ul><li><strong>吞吐量</strong></li><li><strong>最大暂停时间</strong></li><li><strong>堆使用效率</strong></li><li><strong>访问的局部性</strong></li></ul><h2 id="引用计数算法-Reference-Counting"><a href="#引用计数算法-Reference-Counting" class="headerlink" title="引用计数算法 Reference Counting"></a>引用计数算法 Reference Counting</h2><blockquote><p>记录每个对象被引用的次数。每次新建对象、赋值引用和删除引用的同时都要更新计数器，如果计数器的值为0就直接回收内存。</p></blockquote><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器的值就减1。当计数器的值为0时，这个对象就是不可再被使用的。</p><p>主流Java虚拟机里并没有选择引用计数法来管理内存，主要原因是「它很难解决对象之间互相循环引用的问题」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为objA.instance = objB, objB.instance = objA;</span></span><br><span class="line"><span class="comment"> * 之后令objA = null, objB = null，这两个对象就不可能再被访问了</span></span><br><span class="line"><span class="comment"> * 但因为它们互相引用着对方，导致引用计数都不为0，导致无法通知GC收集器回收它们</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line"></span><br><span class="line">    objA = <span class="keyword">null</span>;</span><br><span class="line">    objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可达性分析算法-Reachability-Analysis"><a href="#可达性分析算法-Reachability-Analysis" class="headerlink" title="可达性分析算法 Reachability Analysis"></a>可达性分析算法 Reachability Analysis</h2><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为<strong>引用链</strong>（Reference Chain），当一个对象到达GC Roots时都没有任何引用链与其相连时，就证明该对象是不可用的，将会被判定是可回收的对象。</p><h2 id="标记-清除算法-Mark-Sweep-GC"><a href="#标记-清除算法-Mark-Sweep-GC" class="headerlink" title="标记-清除算法 Mark-Sweep GC"></a>标记-清除算法 Mark-Sweep GC</h2><blockquote><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p></blockquote><ol><li><strong>标记阶段</strong>：从根集合出发，将所有的活动对象及其子对象打上标记</li><li><strong>清除阶段</strong>：遍历堆，将所有的非活动对象（未打上标记的对象）连接到空闲链表上</li></ol><p><strong>不足之处</strong>：</p><ul><li>效率问题：标记和清除的两个过程效率都不高</li><li>空间问题：标记清除之后会产生大量的不连续的内存碎片，空间碎片太多就会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="标记-压缩（整理）算法-Mark-Compact-GC"><a href="#标记-压缩（整理）算法-Mark-Compact-GC" class="headerlink" title="标记-压缩（整理）算法 Mark-Compact GC"></a>标记-压缩（整理）算法 Mark-Compact GC</h2><p>后续步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，即将所有的活动对象紧密地排在堆的一端（压缩），然后直接清理掉端边界以外的内存，消除了内存碎片，但压缩需要成本。</p><h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法 Copying"></a>复制算法 Copying</h2><p>将堆分为两个大小相等的From和To两块，每次只使用其中的一块。利用From空间进行分配，当From空间满了，就将其中的活动对象复制到To空间，之后将两个空间互换即完成GC。</p><blockquote><p>每次都是对整个半区进行内存回收，分配内存时也就不用考虑内存碎片等复杂情况。</p></blockquote><p>但这种算法的代价是将内存缩小到了原来的一半，因为分成了两块相等的内存空间。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><blockquote><p>垃圾回收器是内存回收的具体体现。Java虚拟机中对垃圾收集器应该如何实现是没有任何固定的规定的，所有不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/aDxytVcrLp3mb45.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>如上图所示，展示了<strong>7种</strong>作用于不同分代的收集器，如果两个收集器之间存在连线，就说明可以搭配使用。处于上面区域的是<strong>新生代</strong>收集器，下面区域的是<strong>老年代</strong>收集器。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、历史最久的收集器，曾经是JDK1.3.1版本之前的虚拟机新生代收集的唯一选择。这个收集器是一个<strong>单线程</strong>的收集器，这意味着<strong>它只会使用一个CPU或者一条收集线程去完成垃圾收集工作</strong>，同时，<strong>在它进行垃圾收集的时候，它必须暂停其它所有的工程线程，直到它收集结束</strong>。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/w3ED8n6UOHmRvz4.png" alt="Serial/Serial Old收集器运行示意图"></p><p>当然，它也是有优点的：简单而高效（与其他垃圾收集器的单线程相比），对于限定了单个CPU的环境来说，Serial收集器由于没有线程之间监护的开销，专心从事垃圾收集工作，自然就会有更高的单线程收集效率。所以，它依然是<strong>虚拟机运行在Client模式下的默认新生代收集器</strong>。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器其实是Serial收集器的<strong>多线程版本</strong>。ParNew除了使用多线程进行垃圾收集之外，其余行为还有Serial收集器可用的所有控制参数、收集算法、对象分配规则、回收策略等。</p><p>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为目前，除了Serial收集器之外，只有它可以与CMS收集器相互配合。而CMS收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户工作线程同时工作，具有划时代的意义。</p><p>ParNew收集器在单CPU的环境中的运行效果不会比Serial收集器更好，但是随着使用的CPU数量的增加，它对GC的系统资源的有效利用还是有很多好处的。它默认开启的收集线程数与CPU的数量相同，如果CPU数量飞铲过，就可以使用<code>-XX:ParallelGCThreads</code>；参数来限制垃圾收集的线程数。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Ltmbg1spWojvnAX.png" alt="ParNew/Serial Old收集器运行示意图"></p><p>除此之外，我们需要理解两个概念：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，也可以是交替执行），但用户程序的确是在继续执行，而垃圾收集程序运行在另一个CPU上。</li></ul><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><blockquote><p>Parallel Scavenge收集器是一个新生代收集器，也是同样使用复制算法，也是并行多线程的收集器，但它的关注点是<strong>达到一个可控制的吞吐量（Throughput）</strong>。所以，Parallel Scavenge收集器也被称为<strong>吞吐量优先</strong>收集器。</p><p>吞吐量就是CPU用于运行用户代码的时间与CPU消耗时间的比值，即$吞吐量=\frac{运行用户代码时间}{运行用户代码时间 + 垃圾收集时间}$。</p></blockquote><p>高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，适合<strong>在后台运算不需要太多交互的任务</strong>。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial收集器的老年代版本，是单线程的，使用标记-整理算法，也是主要提供给Client模式下的虚拟机使用的。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel收集器的老年代版本，是多线程的，采用标记-整理算法，同样是注重吞吐量。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><blockquote><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>。当一些应用十分重视服务的响应速度，希望系统停顿时间最短的话，CMS收集器就符合这类应用的需求。</p></blockquote><p>CMS收集器是基于<strong>标记——清除</strong>算法实现的，它的运作过程相比其它的收集器更发咋一些，分为<strong>4个步骤</strong>，包括：</p><ul><li><strong>初始标记（CMS inital mark）</strong></li><li><strong>并发标记（CMS concurrent mark）</strong></li><li><strong>重新标记（CMS remark）</strong></li><li><strong>并发清除（CMS concurrent sweep）</strong></li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>即Garbage First收集器，是一个里程碑的收集器，开创了面向局部收集的思路和基于Region的内存布局形式。在延迟可控的情况下，可以获得尽可能高的吞吐量。</p><p>G1收集器可以将连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要扮演新生代的Eden空间，Survivor空间或者老年空间。</p><p>收集过程也是4个步骤：</p><ul><li><strong>初始标记</strong>：标记GC Roots能够直接关联到的对象</li><li><strong>并发标记</strong>：并发进行可达性分析</li><li><strong>最终标记</strong>：短暂停顿，处理并发标记结束时遗留的少量对象</li><li><strong>筛选回收</strong>：更新Region统计数据，根据价值和回收成本机型排序，并依据用户期望的停顿时间来制定回收计划。</li></ul><p>所以，<strong>Java8以前是Parallel GC，Java9以后改为G1 GC</strong>。</p><p>G1收集器具有以下特点：</p><ul><li><strong>并行与并发</strong>：G1能够充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间。</li><li><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。</li><li><strong>空间整合</strong>：与CMS的「标记-清理」算法不同，G1从<strong>整体</strong>来看是基于「标记-整理」算法实现的收集器，从<strong>局部</strong>来看，则是基于「复制」算法来实现的。</li><li><strong>可预测的停顿</strong>：这个G1相对于CMS的另外一个优势，G1除了能够降低停顿时间之外，还可以建立可预测的停顿时间模型，能够让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非互联网企业手撕代码题</title>
      <link href="/2020/10/03/%E9%9D%9E%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
      <url>/2020/10/03/%E9%9D%9E%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>总的来说，非互联网企业，包括银行、运营商等公司的笔试编程题相对还是简单的，很多都是大一接触到的，例如斐波那契数列等类型的题。然而，由于太久未看到这些基础的提醒，在一时间也有可能会反应不过来。毕竟，时间是有限的。因此，在这里做一个简单的汇总和说明。</p><h2 id="定义一个小顶堆"><a href="#定义一个小顶堆" class="headerlink" title="定义一个小顶堆"></a>定义一个小顶堆</h2><h2 id="手写一个循环队列"><a href="#手写一个循环队列" class="headerlink" title="手写一个循环队列"></a>手写一个循环队列</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/tree/master/src/basic/LoopQueue" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/tree/master/src/basic/LoopQueue</a></p><p>一个队列是实行先进先出的原则，需要加上front和rear两个变量分别代表在数组中的位置，初值为0。</p><p>在非空队列中，front指向队首元素，rear指向队尾元素的下一个存储位置。</p><p>循环队列中会有一个问题：无法区分队空和队满的状态，因为条件都是<code>rear == front</code>。</p><p>所以这里少使用一个存储单元，即队空的条件为<code>rear == front</code>，队满的条件是<code>front == (rear + 1) % maxSize</code>。</p><p>编写队列接口，主要要实现<strong>入队</strong>、<strong>出队</strong>、<strong>长度</strong>、<strong>是否为空</strong>等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object x)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求两数的最大公约数和最小公倍数"><a href="#求两数的最大公约数和最小公倍数" class="headerlink" title="求两数的最大公约数和最小公倍数"></a>求两数的最大公约数和最小公倍数</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GCDAndLCM.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GCDAndLCM.java</a></p><p>这道题实际上就是实现现实中的求最大公约数和最小公倍数。那么，有些规律需要掌握，例如最小公倍数就等于两个数相乘再除以最大公约数，所以这道题的关键就是求最大公约数。</p><p>最大公约数即是用两个数中的更大的数除以最小的数取余数，然后反复除以，直到没有余数为止。有时会因为余数已经小于除数，所以需要更换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deff</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="comment">// 设计成x始终大于y</span></span><br><span class="line">        t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = x % y;</span><br><span class="line">            x = y;</span><br><span class="line">            y = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除特殊符号后的字符串再根据ASCII码值排序"><a href="#去除特殊符号后的字符串再根据ASCII码值排序" class="headerlink" title="去除特殊符号后的字符串再根据ASCII码值排序"></a>去除特殊符号后的字符串再根据ASCII码值排序</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ASCIISort.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ASCIISort.java</a></p><p>首先要掌握ASCII值的概念和规律。常见的ASCII值的大小顺序规律是：0～9 &lt; A~Z &lt; a~z。即数字要比字母小，大小字母要比小写字母小。</p><p>几个常见的ASCII值有：“A”：65， “a”：97，“0”：48</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ASCIISort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串拆分成一个个字符</span></span><br><span class="line">    <span class="keyword">char</span>[] test = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String a = str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            test[i] = a.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组排序</span></span><br><span class="line">        Arrays.sort(test);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加会StringBuilder里</span></span><br><span class="line">            sb.append(test[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// trim()是用来删除字符串的首尾空白符</span></span><br><span class="line">        String trim = sb.toString().trim();</span><br><span class="line">        <span class="keyword">return</span> trim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义去除特殊字符的方法，运用正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 运用正则表达式</span></span><br><span class="line">    String regEx = <span class="string">"[\\n`~!@#$%^&amp;*()+=|&#123;&#125;':;',\\\\[\\\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。， 、？]"</span>;</span><br><span class="line"></span><br><span class="line">    Pattern p = Pattern.compile(regEx);</span><br><span class="line">    Matcher m = p.matcher(str);</span><br><span class="line">    String string = <span class="string">""</span>;</span><br><span class="line">    string = m.replaceAll(string).trim();</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现字符串反转"><a href="#递归实现字符串反转" class="headerlink" title="递归实现字符串反转"></a>递归实现字符串反转</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ReverseStr.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ReverseStr.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originStr == <span class="keyword">null</span> || originStr.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> originStr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        System.out.println(originStr.substring(1));</span></span><br><span class="line"><span class="comment">//        System.out.println(originStr.charAt(0));</span></span><br><span class="line">    <span class="comment">// 递归截取第一个字符，然后递归依次相加</span></span><br><span class="line">    <span class="keyword">return</span> reverse(originStr.substring(<span class="number">1</span>)) + originStr.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设字符串为”123a6”，那么<code>substring(1)</code>的作用是截取掉第1个字符后剩下的字符串，<code>charAt(0)</code>是获得第一个字符。</p><p>所以顺序会是：</p><script type="math/tex; mode=display">23a6\quad1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">3a6\quad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">a6\quad3</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">6\quad a</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">\quad6</script><p>所以按照递归从后往前相加的顺序，就变成<code>6 + a + 3 + 2 + 1</code>，反转字符串后的最终结果就是<code>6a321</code>。</p><h2 id="两个有序数组的交集"><a href="#两个有序数组的交集" class="headerlink" title="两个有序数组的交集"></a>两个有序数组的交集</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/Intersection.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/Intersection.java</a></p><p>对于两个有序的数组，如何寻找它们之间的公共元素呢？</p><p>很容易想到的一个方法就是双重循环，然后条件语句判断元素是否相等，但如果要求时间复杂度不能超过$O(n)$呢？</p><p>所以这时候<strong>有序</strong>就成了一个非常关键的条件。因为有序，所以当<code>a[i] &gt; b[j]</code>时，我们就可以让<code>a[i]</code>与<code>b[j + 1]</code>进行比较；反之，则是<code>a[i + 1]</code>与<code>b[j]</code>进行比较。那么，我们只需要在<strong>一个循环</strong>里完成就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">intersection</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, List&lt;Integer&gt; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = b.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">            lists.add(a[i]);</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; b[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用的是<code>while</code>循环，所以为了防止数组越界，需要将数组的长度减1。当满足某个条件时，就把数组的index往后移一位。</p><hr><p>然而，上面这个方法适用于「两个数组长度接近的情况」，这样比较的过程就不会做很多无用功。如果两个数组之间的长度相差很大，那么可以直接遍历较短数组的元素，然后在长数组中对该元素进行查找，如果查找到，就说明是公共元素，反之则不是。这个思路就更加简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binaryIntersection</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, List&lt;Integer&gt; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] longArray;</span><br><span class="line">    <span class="keyword">int</span>[] shortArray;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt;= b.length) &#123;</span><br><span class="line">        shortArray = a;</span><br><span class="line">        longArray = b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shortArray = b;</span><br><span class="line">        longArray = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历短的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortArray.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用短数组中的每一个元素在长数组中进行二分查找，如果查找到了，说明有公共元素</span></span><br><span class="line">        <span class="keyword">int</span> result = Arrays.binarySearch(longArray, shortArray[i]);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lists.add(longArray[result]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩"><a href="#实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩" class="headerlink" title="实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩"></a>实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩</h2><h2 id="猴子吃桃问题"><a href="#猴子吃桃问题" class="headerlink" title="猴子吃桃问题"></a>猴子吃桃问题</h2><blockquote><p>猴子第一天摘下N个桃子，当时就吃了一半，还不过瘾，就又吃了一个。第二天又将剩下的桃子吃掉一半，又多吃了一个。以后每天都吃前一天剩下的一半零一个。到第n天在想吃的时候就剩一个桃子了,求第一天共摘下来多少个桃子？</p></blockquote><p>通过描述可以发现，递推公式是$f(n)=(f(n+1)+1)*2$，当n等于1时，就是第一个摘下来的桃子数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        x = (x + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单找零钱算法"><a href="#简单找零钱算法" class="headerlink" title="简单找零钱算法"></a>简单找零钱算法</h2><h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p><strong>解题思路</strong>：</p><blockquote><p>当n&gt;2时，第一次跳的时候就有两种不同的选择：</p><p>一是第一次只跳1级，此时跳法数目等于剩下的n-1级台阶的跳法数目，即$f(n-1)$</p><p>二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即$f(n-2)$</p><p>因此，n级台阶的跳法总数目$f(n)=f(n-1)+f(n-2)$</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过观察，发现其实一个 f(n)=f(n-1)+f(n-2) 的规律</span></span><br><span class="line">        <span class="keyword">return</span> frogJump(n - <span class="number">1</span>) + frogJump(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="男女排队问题"><a href="#男女排队问题" class="headerlink" title="男女排队问题"></a>男女排队问题</h2><blockquote><p>幼儿园有n个小朋友排为一个队伍，男生用“B”表示，女生用“G”表示。当男女同挨着时便会发生矛盾。需要对所排的队伍进行调整，每次调整只能让相邻的小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：GGBGG-&gt;GGBGB-&gt;GGGBB这样就能使之前的两处男女相邻变为一处男女相邻，需要调整队形两次<br>程序输入：输入一个数据包括一个长度为N且只包含Ｇ和Ｂ的字符串。<br> 输入：ＧＧＢＢＧ<br>输出：２</p></blockquote><p>这道题的思路主要是有两种情况来解决：</p><ul><li>将所有的G排在前面，每次都移动G</li><li>将所有的B排在前面，每次都移动B</li></ul><p>最后再比较两种情况下的移动次数，选择最少的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">lineup</span><span class="params">(String peoples)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> numG = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> numB = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len = peoples.length();</span><br><span class="line">    <span class="comment">// 将字符串转化为字符数组</span></span><br><span class="line">    <span class="keyword">char</span>[] line = peoples.toCharArray();</span><br><span class="line">    <span class="keyword">int</span> k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="comment">// 每次都移动B，将所有的B移到前面，G移到后面</span></span><br><span class="line">        <span class="keyword">if</span> (line[i] == <span class="string">'B'</span>) &#123;</span><br><span class="line">            <span class="comment">// 将B移动到前面所需要的次数</span></span><br><span class="line">            numB = numB + i - k;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    k = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">        <span class="comment">// 每次都移动G，将所有的G移到前面，B移到后面</span></span><br><span class="line">        <span class="keyword">if</span> (line[j] == <span class="string">'G'</span>) &#123;</span><br><span class="line">            <span class="comment">// 将G移动到前面所需要的次数</span></span><br><span class="line">            numG = numG + j - k;</span><br><span class="line">            k++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 判断移动G和移动B哪个次数最少，返回最少的次数</span></span><br><span class="line">    <span class="keyword">return</span> numG &gt; numB ? numB : numG;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求两个日期之间的工作日"><a href="#求两个日期之间的工作日" class="headerlink" title="求两个日期之间的工作日"></a>求两个日期之间的工作日</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Git)</title>
      <link href="/2020/09/23/Interview-Review(Git)/"/>
      <url>/2020/09/23/Interview-Review(Git)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的Git部分。</p><h2 id="Git回滚以前的某个版本"><a href="#Git回滚以前的某个版本" class="headerlink" title="Git回滚以前的某个版本"></a>Git回滚以前的某个版本</h2><ol><li><p>查找历史版本</p><p> 使用<code>git log</code>命令查看所有的历史版本，获取该仓库git的某个历史版本的id。例如，假设id是fae6966548e3ae76cfa7f38a461c438cf75ba965。</p></li><li><p>恢复到历史版本</p><p> <code>$ git reset --hard fae6966548e3ae76cfa7f38a461c438cf75ba965</code></p></li><li><p>把修改推送到远程的服务器</p><p> <code>git push -f -u origin master</code></p></li></ol><h2 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h2><p><code>git merge</code>和<code>git rebase</code>都是用于合并分支的，不同之处在于对于commit记录的处理上是不同的。</p><p>例如，原始分支如下所示，一个是master(origin)分支，一个是dev(mywork)分支：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/uQjfncJy7GVTKLC.png" alt=""></p><p>当使用<code>git merge</code>的话，会新建一个新的commit对象，然后两个分支以前的commit记录都会指向这个新建的commit记录。这个方式可以保留之前的每一个分支中的commit的历史，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/nobMpWH8wT4YCuk.png" alt=""></p><p>当使用<code>git rebase</code>命令时，可以让两个分支合并后呈线性记录，和没有合并一样。<code>git rebase</code>会先找到两个分支的第一个<strong>共同的</strong>commit的祖先记录，然后提取这个祖先记录之后的所有的commit记录，将这个commit记录添加到目标分支的最新提交的后面。「它会指向新的提交，而那些老的提交会被丢弃」。经过这个合并之后，两个分支合并后的commit记录会变成线性记录了。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/YGS2bc3PkCEMtog.png" alt=""></p><h2 id="git-pull和git-fetch的区别"><a href="#git-pull和git-fetch的区别" class="headerlink" title="git pull和git fetch的区别"></a>git pull和git fetch的区别</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查之后再决定是否合并到工作主机的分支中。</p><p><code>git pull</code>是将远程主机的最新内容拉下来之后就直接合并了，所以可以理解为：<code>git pull</code>=<code>git fetch</code>+<code>git merge</code>。因为直接合并是可能会产生冲突的，所以需要手动解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack组件</title>
      <link href="/2020/09/22/Android%20Jetpack%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/22/Android%20Jetpack%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h1><p>Jetpack是Google推出的一个框架，主要是可以对代码的逻辑和UI界面实现深层的解耦，打造数据驱动型的UI界面。Android Architecture组件是Android Jetpack的一部分，包含以下组件等：</p><ul><li><strong>Lifecycle</strong>：能够处理Activity和Fragment的生命周期，在AndroidX中，Fragment和Activity已经对Lifecycle提供了默认的支持。</li><li><strong>ViewModel</strong>：当做MVVM的ViewModel层，并具有生命周期意识的处理和UI相关的数据。</li><li><strong>LiveData</strong>：和RxJava的作用是一样的，对数据进行监听，优点是无需处理生命周期、无内存泄漏等。</li><li><strong>Paging</strong>：是一个易于使用的数据分页库，支持RecyclerView。</li><li><strong>Room</strong>：强大的ORM数据库框架。</li><li><strong>Navigation</strong>：一个用于管理Fragment切换的工具类，可视化、可绑定控件、支持动画等优点。</li><li><strong>WorkManager</strong>：灵活、简单、延迟和保证执行的后台任务处理库。</li><li><strong>DataBinding</strong>：加速MVVM的创建。</li></ul><p>使用Android Jetpack组件具有以下优势：</p><ul><li>轻松管理应用程序的生命周期</li><li>构建可观察的数据对象，以便在基础数据库更改时通知视图</li><li>存储在应用程序轮换中未销毁的UI相关数据，在界面重建后恢复数据</li><li>轻松地实现SQLite数据库</li><li>系统自动调度后台任务的执行，优化使用性能</li><li>支持RxJava：由于RxJava强大的生态环境，几乎和数据相关的组件都对RxJava提供了支持。</li><li>减少代码量：以Data Binding + ViewModel + LiveData或者RxJava构建的MVVM模式能够显著地减少代码量，比平时用的MVP模式也会更加方便，无需主动更新UI。</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/cSOh1EUeYDV3K68.png" alt="Android JetPack组件"></p><p>上述组件的架构功能如下：</p><ul><li>Activity和Fragment负责产品与用户的交互</li><li>ViewModel作为数据的存储和驱动</li><li>Resposity负责调度数据的获取</li><li>Room储存本地序列化的数据</li><li>Retrofit获取远程数据的数据</li></ul><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycler是一个生命周期的感知组件，执行操作以响应另一个组件（例如Activity和Fragment）的生命周期状态的更改，可以监听Activity组件生命周期的变化，在每个生命周期执行相应的方法。</p><p>不同于以往会在生命周期中执行相应的方法时，需要设置接口，然后在生命周期中回调接口，这样会造成代码的耦合，也会引发生命周期的问题。Lifecycle的<strong>优点</strong>是实现了执行的逻辑和活动的分离，代码解耦并且增加了代码的可读性。Lifecycle在活动结束时会自定义移除监听。</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>一个应用肯定要进行数据的更新。当用户执行某种操作或者服务器端的数据发生改变后，都需要重新获取数据，再次刷新界面的UI。那么，每改变一次就需要重复一次，如何使用一个方式可以监听数据状态，在数据变化时就自动更新UI呢？LiveData就是用来实现此功能的，它解决了数据展示和刷新的问题：只需要创建LiveData实例后，为可观察的数据添加观察者，在数据改变时会自动回调观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>用户在使用应用的过程中，可能随时会被中断或者界面发生了重建，如果重新进入后数据丢失了就会造成不好的用户体验。我们可以使用<code>onSaveInstanceState()</code>方法来保存数据，然后在界面重建后使用<code>onRestoreInstanceState()</code>方法来恢复数据。这种方式虽然可以解决问题，但是如果过于频繁，在每个界面都要编写重建和恢复的代码，就会造成十分繁琐，且数据量过大时会影响执行性能。ViewModel就是来解决这个问题的。</p><p>ViewModel会在活动重建时仍然保存数据，在活动创建完成后从中获取数据。</p><p>ViewModel的优点：</p><ul><li>数据和界面的分离，使数据驱动界面</li><li>解决了运行中断和界面重建时的数据保存问题</li><li>配合LiveData实时地获取最新的数据</li><li>实现了Activity和Fragment之间的数据交互</li></ul><p>ViewModel的<strong>原理</strong>：将数据保存到ViewModel中，然后为活动中添加一个HolderFragment，HolderFragment中保存了ViewStore的实例，ViewStore中使用Map保存了ViewModel，从而在活动重新创建时获取到原来的ViewModel。</p><hr><blockquote><p>一般ViewModel会和LiveData组合，保存可观察的数据</p></blockquote><p>在研究生毕业设计的项目中，我在安卓端的代码中就使用到了LiveData搭配ViewModel的组合。</p><p>在<code>ContractViewModel</code>类中的代码如下。这里主要是使用到了一个<code>MutableLiveData</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContractViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData contractModel = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData callContractResult = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData proofPlace = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;ContractModel&gt; <span class="title">getContractModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contractModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;Boolean&gt; <span class="title">getCallContractResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callContractResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getProofPlace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proofPlace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在Fragment中这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ContractViewModel mViewModel;</span><br><span class="line"></span><br><span class="line">mViewModel = ViewModelProviders.of(fragmentActivity).get(ContractViewModel.class);</span><br><span class="line"></span><br><span class="line">mViewModel = mViewModel.getContractModel().observe(<span class="keyword">this</span>, o -&gt; &#123;</span><br><span class="line">    CertificateModel certificateModel = (CertificateModel) o;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mViewModel.getCallContractResult().postValue(XXX);</span><br><span class="line">mViewModel.getProofPlace().postValue(XXX);</span><br></pre></td></tr></table></figure><p>从上面可以看出，<code>mViewModel</code>可以通过<code>ViewModelProviders</code>与<code>fragmentActivity</code>，再与<code>ContractViewModel</code>绑定。<code>mViewModel.getContractModel().observe()</code>的方式。除此之外，可以使用<code>postValue()</code>的方式去传递值。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的String为什么是不可变的</title>
      <link href="/2020/09/22/Java%E4%B8%AD%E7%9A%84String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/"/>
      <url>/2020/09/22/Java%E4%B8%AD%E7%9A%84String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>在Java中，String类是不可变的，即String中的对象是不可变的。</p><h3 id="区别对象和对象的引用"><a href="#区别对象和对象的引用" class="headerlink" title="区别对象和对象的引用"></a>区别对象和对象的引用</h3><p>对于Java初学者， 对于String是不可变对象总是存有疑惑。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p>打印出的结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure></p><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。从打印结果可以看出，s的值确实改变了，那么为什么说String对象是不可变的呢？其实这里存在一个误区：<strong>s只是一个String对象的引用，并不是对象本身</strong>。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当<code>s=“123456”;</code>这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个心的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/OL8ekRVIM6mwpsP.png" alt="String真实的内存结构"></p><h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><blockquote><p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。即不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能再指向其它的对象，引用类型指向的对象的状态也不能改变。</p></blockquote><p>《Effective Java》中第 15 条<strong>使可变性最小化</strong>中对<strong>不可变类</strong>的解释：</p><blockquote><p>不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并且在对象的整个生命周期内固定不变。为了使类不可变，要遵循下面五条规则：</p><ol><li>不要提供任何会修改对象状态的方法。</li><li>保证类不会被扩展。一般的做法是让这个类称为<code>final</code>的，防止子类化，破坏该类的不可变行为。</li><li>使所有的域都是<code>final</code>的。</li><li>使所有的域都成为私有的。防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。</li><li>确保对于任何可变性组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。</li></ol></blockquote><p>在 Java 平台类库中，包含许多不可变类，例如<code>String</code>, 基本类型的包装类，<code>BigInteger</code>, <code>BigDecimal</code>等等。综上所述，不可变类具有一些显著的通用特征：类本身是<code>final</code>修饰的；所有的域几乎都是私有<code>final</code>的；不会对外暴露可以修改对象属性的方法。通过查阅String的源码，可以清晰的看到这些特征。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>通过查看Java中String的源码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，String类是通过<code>final</code>修饰的，满足了第二条的：类不能被拓展。</p><p>其次，在类中，最重要的一条<code>private final byte[] value;</code>中，我们可以看到Java是使用<strong>字节数组</strong>（Java9，之前的版本是采用字符char数组实现）来实现字符串的，并且使用了<code>final</code>修饰，这就是String为什么不可变的原因。</p><p>因为它使用了<code>private final</code>，导致正常情况下外界没有办法去修改它的值。这满足了第三条：使所有的域都是<code>final</code>的，和第四条：使所有的域都是私有的。然而仅仅这样也仍然不是万无一失的。</p><p>第一条原则是：不要提供任何会修改对象状态的方法。String类在这点中做得很好。在String类中许多会对字符串进行操作的方法中，例如<code>replaceAll()</code>或者<code>substring()</code>等，其中的每一步实现都不会对<code>value</code>产生任何影响。即String类中并没有提供任何可以改变其值的方法，这比<code>final</code>更能确保其是不变的。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>《Effective Java》一书中总结了不可变类的特点：</p><ul><li>不可变类比较简单。</li><li>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享。</li><li>不仅可以共享不可变对象，甚至可以共享它们的内部信息。</li><li>不可变对象为其他对象提供了大量的构建。</li><li>不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。</li></ul><h3 id="String真的不可变吗"><a href="#String真的不可变吗" class="headerlink" title="String真的不可变吗"></a>String真的不可变吗</h3><p>其实可以通过<strong>反射机制</strong>来破坏String的不可变性。可以反射出String对象中的value属性，进而改变通过获得的value引用改变数组的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);<span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">// 变成Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别是最残忍的告白</title>
      <link href="/2020/08/21/%E5%91%8A%E5%88%AB%E6%98%AF%E6%9C%80%E6%AE%8B%E5%BF%8D%E7%9A%84%E5%91%8A%E7%99%BD/"/>
      <url>/2020/08/21/%E5%91%8A%E5%88%AB%E6%98%AF%E6%9C%80%E6%AE%8B%E5%BF%8D%E7%9A%84%E5%91%8A%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>穿过树丛田野</p><p>风景向身后凛冽</p><p>铁轨伸长了双臂</p><p>向黎明驶去</p><p>窗外的世界</p><p>是从没见过的新奇</p><p>淡蓝色的月亮</p><p>城市在黎明处张望</p><p>铁轨扑向更远更长</p><p>车灯照着未知的彷徨</p><p>汽笛遮掩的话语</p><p>琐碎在肩上的行李</p><p>霓虹向后飞越</p><p>向昨晚的梦告别</p><p>淡淡的晨光</p><p>匍匐在身后的家乡</p><p>忽明忽暗的远方</p><p>在行驶的路上</p><p>珍藏的记忆都装进背包</p><p>挥手告别旧时光的美好</p><p>拥抱迎面的翻山越岭</p><p>好好告别就不会有遗憾吗</p><hr><p>那茶杯还留着酣畅的清香</p><p>而回忆却是说忘就忘</p><p>在黑色的夜晚摇月亮</p><p>我该去哪里走一走逛一逛</p><p>哪里的集市丰盛有眼光</p><p>哪里的酒好喝到能一醉方休</p><p>哪里的人不问来路与归途</p><p>我该去哪里看一看 想一想</p><p>哪里的前程值得被信仰</p><p>哪里的水清的 仿佛能看到希望</p><p>哪里的风拂晓坦荡愿与你戏攘</p><p>自在的不觉得虚妄</p><p>时间无谓无果无需隐藏</p><p>一无所有所得所期所想</p><p>尘嚣倾吐残余的伤</p><p>黄昏后回归故乡</p><p>愿你有故乡</p><hr><p>👋再见啦，🇬🇧UK</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(BlockChain)</title>
      <link href="/2020/06/07/Interview-Review(BlockChain)/"/>
      <url>/2020/06/07/Interview-Review(BlockChain)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的区块链部分。</p><a id="more"></a><ol><li><p><strong>什么是区块链</strong></p><p> 区块链是不间断的经济交易数字分类账本，可以进行编程，以记录不仅是金融交易，还可以记录几乎所有有价值的东西。它是<strong>一个不可变记录的分散式、分布式数据库</strong>，该数据库由计算机集群管理，但不属于任何单个实体。</p></li><li><p><strong>区块链是如何工作的</strong></p><p> 区块链由不可变的数据记录（称为<strong>数据块</strong>）组成，这些数据使用<strong>密码学</strong>进行链接。密码学不过是在读取私人消息时对第三方进行加密和保护数据通信的过程。在区块链中，<strong>一旦记录了数据，就不会更改</strong>。区块链就像带有<strong>时间戳</strong>的数学公证人一样工作，以避免篡改信息。</p></li><li><p><strong>为什么区块链是一种值得信赖的方法</strong></p><ul><li>它具有开源特性，与其它业务应用程序相互兼容</li><li>透明度和安全性</li><li>提高效率和速度</li><li>无需依赖任何中央权威</li></ul></li><li><p><strong>什么是区块链中的区块，如何识别</strong></p><p> 区块链中的<strong>区块用于存储数据并永久锁定</strong>。添加在块上的数据是<strong>不可变的</strong>，即<strong>不能更改或删除数据</strong>。可以通过块的<strong>高度</strong>和<strong>块头哈希</strong>来识别块。块中的数据通过称为哈希函数的计算机算法进行检测。它不仅锁定了区块链参与者可以看到的数据，而且使数据不可变。<strong>每个块都有哈希函数</strong>。</p></li><li><p><strong>块的主要元素是什么</strong></p><p> 以下是块的主要元素：</p><ul><li><strong>指向上一个块的哈希指针</strong></li><li><strong>时间戳</strong> Timestamp</li><li><strong>交易</strong> Transaction</li></ul></li><li><p><strong>是否可以从区块链的网络中删除一个或多个块</strong></p><p> 可以的，因为有时只需要考虑在线分类账本的特定部分。通过使用默认过滤器和选项，可以删除这些块。</p></li><li><p><strong>将数据写入块后是否可以更改数据</strong></p><p> 不可以。</p></li><li><p><strong>区块链数据库中可用的记录类型是什么</strong></p><p> 区块链数据库中有两种类型的记录。他们是：</p><ul><li>交易记录</li><li>阻止记录</li></ul></li><li><p><strong>有哪些不同类型的区块链</strong></p><ul><li>公有区块链（公有链）：没有人负责，任何人都可以读写/审核区块链。</li><li>私有区块链（私有链）：它是个人或者组织的私有财产。</li><li>联合区块链（联盟链）：选定的成员可以读取/写入/审核区块链。</li></ul></li><li><p><strong>什么是分类账本，并命名区块链中用户考虑的常见分类账类型</strong></p><p>分类账是一个不断增长的文件，它存储了在区块链网络上两方之间的所有交易的永久记录。</p><p>用户考虑的常见分类帐类型：</p><ul><li><strong>集中式分类账</strong></li><li><strong>分散的分类帐</strong></li><li><strong>分布式分类账</strong></li></ul></li><li><p><strong>公钥和私钥有什么区别</strong></p><p>在区块链中，需要使用<strong>公钥进行标识</strong>，而使用<strong>私钥进行加密和身份验证</strong>。发送方可以使用接收方的公钥发送消息，而接收方可以使用私钥对消息或交易进行解密。通过同时使用两个密钥，可以确保通信或交易的安全和防篡改。</p></li><li><p><strong>区块链以什么顺序连接</strong></p><p>区块链中的所有区块都以反向顺序连接，或者每个区块都与其前一个区块连接。</p></li><li><p><strong>区块链分类账和普通分类账有何不同</strong></p><p>区块链是一种数字账本，可以很容易地分散，与原始账本相比，区块链账本中的错误机会要少得多。区块链自动执行其所有任务，而在普通分类账本中，每项任务都是手动或者人工完成的。</p></li><li><p><strong>什么是共识算法</strong></p><p>共识算法是一种方法，通过该方法，区块链网络的所有对等方都可以达成分布式账本当前状态的标准协议。它可实现高可靠性，并在分布式计算环境中的未知对等方之间建立信任。</p></li><li><p><strong>共识算法有哪些</strong></p><ul><li>工作量证明PoW</li><li>容量证明PoC</li><li>活动证明PoA</li><li>委托权益证明DPoS</li><li>股权证明PoS</li><li>权威证明</li><li>燃烧证明</li><li>唯一节点列表</li><li>重量证明</li><li>拜占庭容错PBFT</li></ul></li><li><p><strong>什么是加密货币</strong></p><p>加密货币是一种数字资产，可以用作使用加密功能进行金融交易的交换媒介。加密货币利用区块链技术获得透明度，去中心化和不变性。加密货币可以使用公钥和私钥在两方之间直接发送，而手续费极低。</p></li><li><p><strong>区块链架构的核心组件是什么</strong></p><ul><li><strong>节点</strong>：区块链结构中的用户/计算机</li><li><strong>交易</strong>：区块链系统的最小组成部分</li><li><strong>块</strong>：用于维护一组分配给网络中所有节点的事务</li><li><strong>链</strong>：块顺序</li><li><strong>矿工</strong>：在添加到区块链结构之前执行块验证过程的特定节点</li><li><strong>共识协议</strong>：进行区块链操作的规则集</li></ul></li><li><p><strong>区块链的一个区块永远不能有多个父区块吗</strong></p><p><strong>区块链永远不会有父区块</strong>，每个区块在区块链中都会独立的。</p></li><li><p><strong>什么是51%攻击</strong></p><p>51%攻击或者双花攻击是指区块链上的单个或者一组矿工，他们试图控制超过50%的网络挖掘哈希率或计算能力。这些攻击者试图阻止新交易获得确认，并使他们停止某些或所有用户之间的付款。它们还能够撤销在控制网络时完成的交易。这意味着他们可以双倍花费硬币。</p></li><li><p><strong>什么是RAS算法</strong></p><p>RSA算法也被称为非对称密码算法，它对两个不同的密钥（即公共密钥和私有密钥）起作用。公共密钥可以与任何人共享，并且私有密钥必须保密。公有密钥可以与任何人共享，而私有密钥必须保密。</p><p>该算法是用于签名数据和加密的第一个算法。它最广泛运用于保护敏感数据。</p></li><li><p><strong>RSA会受到攻击吗</strong></p><p>RAS可能会遭到攻击。通常，有两种攻击RSA的方法：</p><ul><li>蛮力：包括所有潜在的秘密密钥。</li><li>数学攻击：在这种情况下，需要使用不同的技术来近似地计算两个素数的乘积。</li></ul></li><li><p><strong>什么是双重支出</strong></p><p>双倍支出被认为是数字现金计划的潜在缺陷，因为多次使用相同的数字令牌。令牌通常由可以轻松克隆的数字文件组成。比特币用户通过在区块链上付款时等待确认来保护自己免受双重支出欺诈；随着确认的增加，交易变得不可逆转。</p></li><li><p><strong>什么是盲目签名</strong></p><p>盲目签名是密码术中数字签名的一种形式，其中消息的内容在签名或者考虑之前是不可见的。它主要用于作者和签名方不同的隐私相关协议中，这是一种经过验证的方法。</p></li><li><p><strong>区块链中有助于消除安全威胁的关键原则是什么</strong></p><ul><li>连续性计划</li><li>稽核</li><li>确保测试和类似方法</li><li>数据库安全</li><li>保护应用程序</li><li>数字化劳动力培训</li></ul></li><li><p><strong>权益证明和工作量证明有什么区别</strong></p><ul><li><strong>工作量证明</strong>是区块链中的原始共识算法。它用于确认交易并为链产生新的区块。矿工相互竞争以完成网络上的交易并获得奖励。</li><li><strong>股权证明</strong>使共识机制完全虚拟。在这种情况下，一组节点决定放样其交易验证的加密货币。</li></ul></li><li><p><strong>什么是默克尔树，它在区块链中的重要性是什么</strong></p><p>Merkle树也称为哈希树，主要由以太坊和比特币使用。区块链中的Merkle树的重要性在于，<strong>如果有人想验证某个区块中的特定交易，他们可以下载区块头链，而不必下载每个交易和每个区块</strong>。</p><p>默克尔树在区块链技术中起着重要作用。它描述了由各种数据块组成的数据结构。它还通过提供整个交易集的数字指纹来汇总一个块中的所有交易。它可以对大量数据进行有效且安全的内容验证。</p></li><li><p><strong>什么是秘密共享</strong></p><p>秘密共享是用于在区块链中提供数据安全性的主要方法之一。这种方法将个人信息或机密信息分为不同的单元，然后将其发送给网络上的用户。原始信息共享给分配了秘密共享的参与者。</p></li><li><p><strong>什么是安全策略</strong></p><p>安全策略是一个正式且简短的计划，其中包含组织的目标，目的和信息安全程序。简而言之，它定义了确切地需要保护免受威胁的条件以及在威胁发生时如何处理情况。</p></li><li><p><strong>为什么区块链需要硬币或者代币</strong></p><p>令牌/代币被视为是交换媒介。它们是内置的数字资产，可在区块链内执行特定的功能。某人进行交易时，状态会发生变化，coin会从一个地址转移到另外一个地址。</p></li><li><p><strong>什么是采矿</strong></p><p>挖掘是通过向网络提供工作证明来向大型分布式公共分类账添加交易的过程，即生成的区块是有效的。它还将新硬币添加到生成的块中。</p></li><li><p><strong>脱链交易和链上交易有什么不同</strong></p><p><strong>链上交易</strong>：这些交易在区块链上可用，并且对区块链网络上的所有节点都是可见的。包括由一定数量的参与者对交易进行身份验证和确认；<br><strong>链下交易</strong>：这些交易处理区块链外部的值，可以使用多种方法进行。</p></li><li><p><strong>集中式网络，分散式网络和分布式分类账之间有什么区别</strong></p><p><strong>集中式网络</strong>：具有中央机构以方便其操作；<br><strong>分散网络</strong>：分散网络中的连接节点不依赖于单个服务器点，并且每个节点都拥有网络配置的整个副本；<br><strong>分布式分类账</strong>：这是共享分类帐，不受任何中央机构的控制。本质是分散的，并充当金融、法律或电子资产的数据库。</p></li><li><p><strong>区块链生态系统的主要元素是什么</strong></p><ul><li><strong>共享账本</strong>：本质上是分散的，是区块链的核心组成部分；</li><li><strong>节点应用程序</strong>：一种软件，可以让计算机与区块链连接；</li><li><strong>虚拟应用程序</strong>：处理区块链承担的所有任务；</li><li><strong>共识算法</strong>：用于管理区块链规则，通过该规则每个节点都可以得出结论。</li></ul></li><li><p><strong>在保护交易记录时，如何进行风险管理</strong></p><p>基于数据的价值。</p><ul><li>第一种，确定与组织的财务记录相关的威胁和漏洞，并相应地采取正确的对策。</li><li>第二种，注意备份计划。</li><li>第三种，购买新的风险管理软件。</li></ul></li><li><p><strong>在组织中采用区块链技术是否有特定于网络的条件</strong></p><p>使用区块链没有特定的网络条件。但是，该网络必须是特定协议下的对等网络。</p></li><li><p><strong>区块链有哪些框架</strong></p><ul><li>Hyperledger Fabric：是区块链技术的一种实现，旨在作为开发区块链应用程序或解决方案的基础。</li><li>Hyperledger Iroha：是一个分布式分类帐项目，旨在简化并易于整合到需要分布式分类帐技术的基础设施项目中。</li><li>Chain：Chain Core 的基础设施使企业能够在许可网络上发布和转移金融资产，仅允许授权和识别的实体成为区块链网络的一部分。</li><li>IOTA：IOTA的分类帐非常适合需要小额支付和连接设备的场景。</li><li>以太坊：是一个运行智能合约的去中心化平台：完全按照设定程序运行的应用程序，不涉及任何停机、审查、欺诈或第三方干扰。</li><li>Libra：Facebook推出的区块链框架。</li></ul></li><li><p><strong>如何在保证所有人都可以访问的情况下防止篡改</strong></p><p>区块链主要是依靠加密技术来保障数据的安全，主要使用到了加密哈希函数。</p><p>哈希算法是无论输入的大小如何，输出始终是相同的字节。但如果输入发生变化，输出将完全不相同。只要输入不变，则不管运行多少次哈希函数，输出的哈希值都是始终相同的。</p><p>在区块链中，输出值（即哈希）是数据块的唯一标识符。每个区块的哈希是相对于前一个区块的哈希生成的。区块的哈希值是由其所包含的哈希函数决定的，任何数据的改变都会更改哈希值。所以，该区块的哈希值是由所包含的数据和前一区块的哈希值决定的。这就确保了区块链的安全性和不可篡改性。</p></li><li><p><strong>描述一下从交易发出到交易上链，以及如何实现共识</strong></p><p>区块“链”的链，包含“<strong>数据链</strong>”和“<strong>节点链</strong>”。“数据链”指用链式结构组织区块数据，构成数据校验和追溯的链条；“节点链”指多个节点通过网络连接在一起，互相共享信息，其中的共识节点则联合执行共识算法，产生并确认区块。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/2uz8cQTtSWNUqRx.png" alt=""></p><p>交易“上链”的简要过程如下：</p><ol><li><p>记账者们收录交易，按链式数据结构打包成“区块”。</p></li><li><p>共识算法驱动大家验证新区块里的交易，确保计算出一致的结果。</p></li><li><p>数据被广播到所有节点，稳妥存储下来，每个节点都会存储一个完整的数据副本。</p></li></ol><p>交易一旦“上链”，则意味着得到完整执行，达成了“分布式事务性”，即永久可见且无法更改。</p><p>“上链”意味着“<strong>共识</strong>”和“<strong>存储</strong>”，两者缺一不可。交易不经过共识，则不能保证一致性和正确性，无法被链上所有参与者接受；共识后的数据不被多方存储，意味着数据有可能丢失或被单方篡改，更谈不上冗余可用。</p><p>除此之外，如果仅仅是调用接口查询一下，没有改变任何链上数据，也不需要进行共识确认，则不算“上链”。</p><hr><p>区块链是通过共识算法来让不同的节点之间达成共识。例如PoW、PoS等。</p></li><li><p><strong>区块链有哪些应用场景</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(BigData)</title>
      <link href="/2020/06/06/Interview-Review(BigData)/"/>
      <url>/2020/06/06/Interview-Review(BigData)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的大数据部分。</p><a id="more"></a><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><ol><li><p>什么是Hadoop</p><blockquote><p>Hadoop是一个开源软件框架，用于存储大量数据，并发处理/查询在具有多个商用硬件节点的集群上的那些数据。</p></blockquote><p> HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）：HDFS允许以一种分布式和冗余的方式存储大量数据。例如，1024MB可以拆分为16*128MB文件，并存储在Hadoop集群中的8个不同的节点上。每个分裂可以复制3次，以实现容错，以便如果1个节点故障的话，也有备份。</p><p> MapReduce：是一个计算框架（Google三剑客之一：GFS、BigTable、MapReduce）。它以分布式和并行的方式处理大量的数据。例如，当对所有年龄大于18的用户在上面的1024MB文件中查询时，会有8个Map函数并行运行，以在其128MB拆分文件中提取年龄大于18的用户，然后Reduce函数将运行以将所有单独的输出组合成单个最终结果。Map就是拆解，Reduce就是组装，本治就是分治法。</p></li><li><p>正常工作的Hadoop集群中都需要启动哪些进程，作用分别是什么</p><ul><li>NameNode：是HDFS的守护进程，负责记录文件是如何分割成数据块，以及这些数据块分别被存储到哪些数据节点上，它的主要功能是对内存以及IO进行集中管理；</li><li>Secondary NameNode：辅助后台程序，与NameNode进行通信，以便定期保存HDFS元数据的快照；</li><li>DataNode：负责把HDFS数据块读写到本地的文件系统；</li><li>JobTracker：负责分配task，并监控所有运行的task；</li><li>TaskTracker：负责执行具体的task，并与JobTracker进行交互；</li></ul></li><li><p>列举出流行的Hadoop调度器，并简要说明其工作方法</p><p> Hadoop调度器的基本作用就是根据节点资源使用情况和作业的要求，将任务调度到各个节点上执行；</p><p> <strong>调度器需要考虑的因素有三种</strong>：</p><ul><li>作业优先级：作业优先级越高，能够获取到的资源也越多。Hadoop提供了5种作业优先级，分别是<code>VERY_HIGH</code>、<code>HIGH</code>、<code>NORMAL</code>、<code>LOW</code>、<code>VERY_LOW</code>、<code>VERY_LOW</code>，通过<code>mapreduce.job.priority</code>属性来设置。</li><li>作业提交时间：作业提交的时间越早，就越先执行；</li><li><p>作业所在队列的资源限制：调度器可以分为多个队列，不同的产品线放到不同的队列里运行。<strong>不同的队列会设置一个边缘限制</strong>，这样不同的队列就会有自己独立的资源，不会出现抢占和滥用资源的情况。</p><p><strong>自带调度器有三种</strong>：</p></li><li><p>先进先出调度器（FIFO）：</p><p>  FIFO是Hadoop中默认的调度器，也是一种<strong>批处理调度器</strong>。它先按照作业的优先级高低，再按照到达时间的先后选择被执行的作业。</p></li><li><p>容量调度器（Capacity Scheduler）：</p><p>  支持多个队列，每个队列可以配置一定的资源量，每个队列采用FIFO调度策略，<strong>为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定</strong>；</p></li><li><p>公平调度器（Fair Scheduler）：</p><p>  支持多队列多用户，每个队列中的资源量可以配置，<strong>同一队列中的作业公平共享队列中的所有资源</strong>。</p></li></ul></li><li><p><strong>简要说一下Hadoop的MapReduce编程模型</strong></p><p> 首先Map task会从本地文件系统读取数据，转换成key-value形式的键值对集合。使用的是Hadoop内置的数据类型，比如longwritable、text等。然后将键值对集合输入mapper进行业务处理过程，将其转换成需要的key-value再输出。</p><p> 之后会进行一个partition的分区操作，默认使用的是hashpartitioner，可以通过重写hashpartitioner的getpartition方法来自定义分区的规则；</p><p> 之后会对key进行sort排序，grouping分组操作将相同key的value合并分组输出；</p><p> 之后进行combiner归约操作，即一个本地段的reduce预处理，以减小后面shuffle和reducer的工作量；</p><p> reduce task通过网络将各个数据收集进行reduce处理，最后将数据保存或者显示，结束整个job。</p></li><li><p>MapReduce的大致过程：</p><p> MapReduce大致可以分为<strong>input</strong>、<strong>split</strong>、<strong>map</strong>、<strong>shuffle</strong>、<strong>reduce</strong>、<strong>output</strong>六个步骤。</p><ul><li>输入input：输入数据，一般是HDFS上的文件或目录</li><li>拆分split：切割文件，例如将字符串分割成每个单词</li><li>映射map：将拆分的内容转换成key-value形式</li><li>派发shuffle：将key相同的放到一起value是一个序列，这步涉及到数据移动，会将key相同的数据移动到一台机器上</li><li>缩减recude：将同样key的value序列进行计算</li><li>输入output：输出结果</li></ul></li><li><p>为什么要用flume导入HDFS，HDFS的架构是怎么样的</p><p> flume是可以实时地导入数据到hdfs中，当hdfs上的文件达到一个指定大小的时候，就会形成一个文件，超过指定时间的话，也会形成一个文件。</p><p> 文件是存储在DataNode上，NameNode记录着DataNode的元数据信息，而NameNode的元数据信息是存在内存中的。所以，当文件切片很小或者很多的时候，就会卡死。</p></li><li><p>MapReduce程序运行的时候会有什么比较常见的问题</p><p> 比如键值对对任务分配不均匀造成的<strong>数据倾斜</strong>问题。解决的办法是在分区的时候，重新定义分区规则，对于value数据很多的key可以进行拆分、均匀打散等处理，或者是在map端的Combiner中进行数据预处理的操作。</p></li><li><p>Hadoop的性能调优</p><ol><li>从应用角度进行优化：<ol><li>避免不必要的reduce任务</li><li>为job添加一个Combiner</li><li>根据处理数据特征使用最适合和最简洁的Writable类型</li><li>重用Writable类型</li><li>使用StringBuffer而不是String</li></ol></li><li>对Hadoop参数进行调优：<ol><li>关闭不必要的linux服务</li><li>关闭ipv6</li><li>调整文件最大打开数</li><li>修改linux内核参数</li></ol></li><li>从系统实现角度进行调优：从Hadoop实现机制的角度，发现当前Hadoop设计和实现上的缺点，然后进行源码级的修改。</li></ol></li><li><p>HDFS的特点</p><ul><li>处理超大文件</li><li>高容错性，运行在廉价机器上</li><li>横向扩展</li><li>流式数据处理，而不是随机读写（流式数据读取指的是一个文件只能写一次，后面一直追加，所以每次读取只需要从头开始一直往后读即可）</li><li>不支持文件修改，只能追加写入</li><li>对大量的小文件性能不好</li></ul><ol><li>主从架构，有两种角色namenode和datanode。namenode负责管理存储元数据，处理客户端读写请求；datanode存储真正的数据，执行读写操作；</li><li>读流程：客户端访问namenode，验证权限，返回数据具体的datanode的地址，客户端访问datanode读取数据；</li><li>写流程：客户端访问namenode，验证权限并确定文件是否存在，然后先记录到editLog返回输出流对象，客户端最近的一个datanode写数据，每写一个数据块，其余的datanode自己同步</li></ol></li><li><p>YARN的工作原理，简述其工作方法</p><p>YARN全称yet another resource negotiator，即另一种资源调度器。</p><p><strong>ResourceManager</strong>：</p><p>ResourceManager有为所有应用程序仲裁资源的权限的功能，用来代替JobTracker，主要由schedule和ApplicationManager组成。</p><p>schedule通过container来分配资源，封装了磁盘、内存、CPU等资源。</p><p>ApplicationManager负责接收作业的提交，并申请第一个container来执行作业的ApplicationMaster，并提供失败时重启ApplicationManager的container，而作业的ApplicationMaster向schedule申请资源。</p><p><strong>NodeManager</strong>：</p><p>NodeManager是YARN在每台机器上的代理，负责启动并管理节点上的container，container执行具体的由ApplicationMaster划分的任务。</p><p><strong>整体流程</strong>：</p><ol><li>客户端向ResourceManager的ApplicationManager提交程序；</li><li>ResourceManager的ApplicationManager在NodeManager启动第一个container执行ApplicationManager</li><li>ApplicationManager拆分程序，划分成一个个的task，这些task可以在container上运行，然后向ResourceManager申请资源执行task，并向ResourceManager发送心跳；</li><li>申请到container后，ApplicationMaster会和NodeManager通信，并将task发送到对应的container执行，task会向ApplicationMaster发送心跳；</li><li>程序执行完成，ApplicationMaster会向ResourceManager注销并释放资源；</li></ol></li></ol><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ol><li><p>Spark有几种部署模式，每种模式的特点</p><ul><li>local模式（本地模式）：运行在一台机器上，常用于本地开发测试，本地模式还分为local单线程和local-cluster多线程；</li><li>standalone模式（集群模式）：典型的Master/Slave模式，起初Master是有单点故障的；</li><li>yarn模式（集群模式）：运行在yarn资源管理器框架之上，由yarn负责资源管理，Spark负责任务调度和计算；</li><li>mesos模式（集群模式）：运行在mesos资源管理器框架之上，由mesos负责资源管理，Spark负责任务调度和计算；</li></ul></li><li><p>Spark为什么比MapReduce快（Run workloads 100x faster）</p><ul><li><p>Spark是基于内存计算的，减少了低效的磁盘交互；而MapReduce是基于磁盘的迭代。</p><ul><li>MapReduce的设计：中间结果保存在文件中，提高了可靠性，减少了内存占用，但是牺牲了性能；</li><li>Spark的设计：数据在内存中进行交换，要更快一些，所以性能要比MapReduce好，但是内存的可靠性不如磁盘；</li></ul></li><li><p>高效的调度算法，基于DAG；</p></li><li>容错机制Linage；</li></ul></li><li><p>Spark有哪些组件</p><ul><li><code>master</code>：管理集群和节点，不参与计算</li><li><code>worker</code>：计算节点，进程本身不参与计算</li><li><code>driver</code>：运行程序的Main方法，创建spark context对象</li><li><code>spark context</code>：控制整个application的生命周期，包括dag sheduler和task scheduler等组件</li><li><code>client</code>：用户提交程序的入口</li></ul></li><li><p>Hadoop和Spark的shuffle相同和差异</p><ul><li>高层面：两者并没有太大的差别，都是将<code>mapper</code>的输出进行<code>partition</code>，不同的是<code>partition</code>是送到不同的<code>reducer</code>里。</li><li>低层面：Hadoop是<code>sort-based</code>，在进入<code>combine()</code>和<code>reduce()</code>之后，<strong>必须先排序</strong>；Spark默认是<code>hash-based</code>，通常使用HashMap来对shuffle来的数据进行汇总，<strong>不需要提前排序</strong>；</li><li>实现角度：Hadoop MapReduce需要将处理流程划分成明显的几个部分：<code>map</code>、<code>split</code>、<code>merge</code>、<code>shuffle</code>、<code>sort</code>、<code>recude</code>，而Spark没有这样功能明确的阶段；</li></ul></li><li><p>RDD宽依赖和窄依赖</p><ul><li>窄依赖：每一个parent RDD的Partition最多被子RDD的一个Partition使用（即<strong>一父一子</strong>）</li><li>宽依赖：多个子RDD的Partition会依赖同一个parent RDD的Partition（<strong>一父多子</strong>）</li></ul></li><li><p>cache和pesist的区别</p><p> cache和persist都是用于缓存RDD，避免重复计算，<code>.cache()==.persist(MEMORY_ONLY)</code></p></li><li><p>RDD有哪些缺陷</p><ul><li>不支持细粒度的写和更新操作：Spark写数据是粗粒度的，就是批量写入数据，但是读数据可以细粒度</li><li>不支持增量迭代计算（Flink）支持</li></ul></li><li><p>RDD有哪几种操作类型</p></li><li><p>Spark的工作机制</p></li><li><p>Spark的优化怎么做</p></li><li><p>Spark中数据的位置是被谁管理的</p></li><li><p>Spark的数据本地性有哪几种</p></li><li><p>Spark的常用算子区别</p></li><li><p>Transformation和action是什么，有什么区别，举出一些常用方法</p></li><li><p>Spark on Yarn模式有哪些优点</p></li><li><p>描述Yarn执行一个任务的过程</p></li></ol><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ol><li>Storm的工作原理是什么</li><li>流的模式是什么？默认是什么？</li><li>Storm Group分类</li><li>Storm的特点和特性是什么<ul><li>编程简单：开发人员只需要关注应用逻辑，而且跟Hadoop类似，Storm提供的编程语言也很简单</li><li>高性能，低延迟：可以应用于广告搜索引擎等要求实时响应的场景</li><li>分布式：可以轻松应对数据量大，单机搞不定的场景</li><li>可拓展：随着业务的发展，数据量和计算量越来越大，系统可水平扩展</li><li>容错：单个节点挂了是不影响应用的</li><li>消息不丢失：保证了消息处理</li></ul></li><li>Storm组件有哪些</li></ol><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><blockquote><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。</p></blockquote><ol><li><p>Kafka的设计是怎么样的</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/n6oUKCm4tZrGTv3.png" alt="Kafka的设计结构"></p><ol><li>Kafka是可以配合zookeeper集群进行工作的</li><li>Kafka集群中有若干个Broker，<strong>其中一个是leader，其它的是follower</strong></li><li>Consumer外面还包裹了一层Consumer Group</li></ol></li><li><p>数据传输的事物定义有哪三种</p></li><li>Kafka判断一个节点是否还活着的两个条件</li><li>Kafka与传统消息系统之间的三个关键区别</li><li>Kafka高消息文件存储设计的特点</li><li><p>Kafka有哪几个组件</p><ul><li>Broker：Kafka集群包含一个或者多个服务器，这种服务器被称为broker</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，类别就被称为是topic（物理上topic是分开存储的）</li><li>Partition：是一个物理上的概念，每个Topic包含一个或者多个Partition</li><li>Producer：负责发布消息到Kafka broker上</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端</li><li>Consumer Group：每个Consumer都属于一个特性的Consumer Group</li></ul></li><li><p>Kafka的特性</p><ul><li>以时间复杂度为$O(1)$的方式提供消息持久化能力，即使TB以上的数据也能保证常数的时间复杂度的访问性能</li><li>高吞吐率：即使在廉价的机器上也能支持高吞吐率的传输</li><li>支持Kafka Server间的消息分区以及分布式消费，同时保证每个Partition内的消息<strong>顺序传输</strong></li><li>Scale out：支持在线水平扩展</li></ul></li><li><p>Kafka的应用场景</p><ul><li>构建可在系统或者应用程序之间可靠获取数据的<strong>实时流</strong>数据管道</li><li>构建实时流应用程序，可以转换或者响应数据流</li></ul></li><li><p>Kafka四个核心api</p><ul><li>Producer：使用Producer API发布消息到1个或者多个topic中</li><li>Consumer：应用程序使用Consumer API订阅一个或者多个topic，并处理产生的消息</li><li>Streams：使用Streams API充当一个流处理器，从1个或多个topic消息输入流，产生一个输出流到1个或者多个topic，有效地<strong>将输入流转化为输出流</strong></li><li>Connector：允许构建或者运行可重复使用的生产者或者消费者，将topic连接到现有的应用程序或者数据系统</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/OltHomjCFWpG2Sk.png" alt="Kafka的四个核心API"></p></li><li><p>Kafka分区的概念</p><p>大多数消息系统，在同一个topic下的消息，都会存储在一个队列中。而分区的概念就是**把这个队列划分为若干个小的队列，每一个小的队列就是一个分区。</p><p>创建分区的好处就是可以让多个消费者同时消费，这样速度就大大提升。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/hvbTipcM2yne87j.png" alt="Kafka分区的概念"></p><p>分区有以下几个特征：</p><ul><li>一个partition只能被同组的一个consumer对象消费</li><li>同一个组里的consumer可以消费多个partition</li><li>消费效率最高的情况是partition和consumer的数量相等，这样可以保证每个consumer都专职负责一个partition</li><li>consumer数量是不能大于partition的数量的，不然就会有consumer闲置</li><li>consumer group是一个订阅者的集群，其中的每个consumer负责自己消费的分区</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/N7KpFanochzJBM5.png" alt="Kafka分区的特征"></p></li></ol><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><blockquote><p>ZooKeeper是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。<br>分布式应用程序可以基于ZooKeeper实现数据发布与订阅、负责均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能。</p></blockquote><ol><li><p>ZooKeeper都要哪些功能</p><ol><li><p>统一命名服务（naming）</p><p> 分布式应用中，通常需要一套完整的命名规则，既能够产生唯一的命名便于记住，又不需要将名称关联到特定的资源上，类似数据库中产生的唯一的主键。</p></li><li><p>配置管理</p><p> 配置信息可以交个Zookeeper来管理，将配置信息保存在Zookeeper中的某个目录节点中，然后将所有需要修改的应用监控配置信息的状态。一旦配置信息发生变化，每台应用就会收到Zookeeper的通知，获取新的配置信息应用到系统中。</p></li><li><p>集群管理</p><p> Zookeeper不仅能够帮助维护当前的集群中机器的服务状态，而且能够帮助选出一个Master来管理集群。</p></li><li><p>对列管理</p><ul><li>当一个队列的成员都聚齐时，这个队列才可用，否则就需要一直等待，这就是<strong>同步队列</strong>。</li><li>队列按照FIFO方式进行出队和入队操作，例如实现生产者和消费者模型。</li></ul></li></ol></li><li><p>ZooKeeper怎么保证主从节点的状态同步</p></li><li>ZooKeeper有几种部署模式<ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群上运行；</li><li>伪集群部署：一台集群启动多个ZooKeeper实例运行</li></ul></li><li>ZooKeeper的通知机制</li><li>集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗</li><li>两阶段提交和三阶段提交的过程</li><li>ZooKeeper宕机如何处理</li><li>获得分布式锁的流程</li><li>ZooKeeper队列管理</li><li>ZooKeeper下Server的工作状态</li><li>ZooKeeper是如何保证事务的顺序一致性的</li><li>ZooKeeper负载均衡和nginx负载均衡区别</li></ol><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><ol><li><p>Hive中存放的是什么</p><p> Hive中存放的是<strong>表</strong>，存的是和hdfs的映射关系，hive是逻辑上的数据仓库，实际操作的是HDFS上的文件，HQL是用sql语法编写的MapReduce程序。</p></li><li><p>Hive与关系型数据库的关系</p><p> 没有任何关系，hive是数据仓库弥，不能和数据库一样进行实时的CRUD操作，是一次写入多次读取的操作。</p></li><li><p>Hive表关联查询，如何解决数据倾斜的问题</p><p> <strong>倾斜原因</strong>：map输出数据，按照key的Hash值分配到reduce中。由于key分布不均匀、业务数据本身的特性、建表时考虑不周等等原因造成的reduce上的数据量差异过大。</p><ul><li>key分布不均匀</li><li>业务数据本身的特性</li><li>建表时考虑不周</li><li><p>某些SQL语句本身就会有数据倾斜</p><p><strong>解决方案</strong>：</p></li><li><p>参数调节：有数据倾斜的时候进行负载均衡</p></li><li>SQL语句调节：<ul><li>选择<code>join key</code>分布最均匀的表作为驱动表，做好裁剪、filter等操作，以达到两表做<code>join</code>的时候，数据量相对变小的效果</li><li>大表<code>join</code>小表：把空值的key变成一个字符串加上随机数，把倾斜的数据分到不同的reduce上</li><li><code>count distinct</code>大量相同的特殊值</li><li>大小表<code>join</code>：使用<code>map join</code>让小的维度表先进内存，在map端完成reduce。</li></ul></li></ul></li><li><p>Hive的HSQL转换为<code>MapReduce</code>的过程</p><ol><li><strong>SQL Parser</strong>：（<strong>将HQL转换成抽象语法树</strong>）定义SQL的语法规则，完成SQL语法，语法解析，将SQL转化为抽象语法树AST Tree</li><li><strong>Semantic Analyzer</strong>：（<strong>将抽象语法树转换成查询块</strong>）遍历AST Tree，抽象出查询的基本组成单元QueryBlock</li><li><strong>Logical Plan</strong>：（<strong>将查询块转换成逻辑查询计划</strong>）遍历QueryBlock，翻译为执行操作树OperatorTree</li><li><strong>Logical Plan Optimizer</strong>：（<strong>重写逻辑查询计划</strong>）逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量；</li><li><strong>Physical Plan</strong>：（<strong>将逻辑计划转成物理计划</strong>）遍历OperatorTree，也就是翻译为MapReduce任务；</li><li><strong>Logical Plan Optimizer</strong>：物理层优化器进行MapReduce任务的变换，生成最终的执行计划；</li></ol></li><li><p>Hive特点</p><p> Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，无需专门开发MapReduce应用，但是<strong>不支持实时查询</strong>。</p></li><li><p>Hive内部表和外部表的区别</p><ul><li><strong>创建表时</strong>：创建内部表，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做出任何改变；</li><li><strong>删除表时</strong>：内部表的元数据会和数据一起删除，外部表只是删除数据元数据，不删除数据。</li></ul></li><li><p>Hive底层与数据库的交互原理</p><p> 由于Hive的元数据可能要面临不断地更新、修改和读取操作，所以它显然不适合使用Hadoop文件系统进行存储。所以，目前Hive是将元数据存储在RDBMS中，比如存储在MySQL中。元数据的信息包括：存在的表、表的列、权限和更多信息。</p></li></ol><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><h3 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h3><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><h3 id="Kylin"><a href="#Kylin" class="headerlink" title="Kylin"></a>Kylin</h3><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是一个节省空间的概率数据结构，用来测试一个元素是否在一个集合里。它实际上是一个很长的<strong>二进制向量</strong>和<strong>一系列随机映射函数</strong>。相比于传统的List、Set、Map等数据结构，它更高效、占用空间更少，但是缺点是<strong>返回的结果是概率性的，不是确定的</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/S4tU26X9d7Evpbw.png" alt=""></p><ol><li><p><strong>插入</strong></p><p> 当一个元素要被加入到集合中时，需要通过K个Hash函数将这个元素映射成一个位数组中的K个点，把它们置为1</p></li><li><p><strong>查找</strong></p><p> 当需要查找某个元素时，首先需要判断其是否存在，只要看这些点是不是都是1就可知道集合中是否含有它。如果这些点有任何一个0，都说明被查找的元素不存在；如果都是1，则被检的元素很可能存在。</p></li></ol><h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><ul><li>解决了redis等其它缓存穿透的问题</li><li>判断是否存在该行或者列，以减少对磁盘的访问，提高数据库的访问性能</li><li>分布式数据库BigTable使用了布隆过滤器来查找不存在的行或者列，可以减少磁盘查找的IO次数</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：</p><ul><li>节省存储空间</li><li>查找速度快</li></ul><p><strong>缺点</strong>：</p><ul><li>存在误判：因为可能hash之后得到的k个位置都是1，但是要查到的元素并没有在容器中</li><li>删除困难：一个放入的容器中的元素映射到bit数组的k个位置上都是1，所以删除的时候并不能简单地直接设置为0，因为这样会影响其它元素的判断</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Algorithm)</title>
      <link href="/2020/06/06/Interview-Review(Algorithm)/"/>
      <url>/2020/06/06/Interview-Review(Algorithm)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的算法部分。</p><a id="more"></a><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><h3 id="模型评估方法"><a href="#模型评估方法" class="headerlink" title="模型评估方法"></a>模型评估方法</h3><ol><li><p>Accuracy作为指标有哪些局限性</p><p> 准确率的定义是：分类正确的样本占总样本个数的比例，$Accuracy = \frac{n_{correct}}{n_{total}}$。但是此指标存在以下缺陷：</p><p> 当正负样本非常不均衡时，占比大的类别就成为了影响准确率的主要因素，比如负样本占90%时，即使把所有样本都预测为负样本，也可以轻松获得90%的准确率，而这样的准确率是没有意义的，不足以说明分类器的好坏。</p></li><li><p>ROC曲线和PR曲线各是什么</p></li><li><p>编程实现AUC的计算，复杂度是多少</p></li><li>AUC指标有什么特点？放缩结果对AUC是否有影响</li><li>余弦距离与欧氏距离有什么特点</li></ol><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol><li><p>如何划分训练集？如何选择验证集？</p><p> 有以下几种不同的方法划分训练集与验证集：</p><ul><li><p>留出法：</p><ol><li>把数据集划分成互不相交的两部分，一部分作为训练集，一部分作为测试集；</li><li>保持数据的分布大致一致，类似分层抽样；</li><li>训练集数据所占比例应该为2/3或4/5左右</li><li>为了保证随机性，将数据集多次随机划分为训练集和测试集，然后再对多次划分的结果去平均</li></ol></li><li><p>k折交叉验证法：</p><ol><li>将数据集随机分为互斥的k个子集，为保证随机性，使用p次随机划分取平均；</li><li>将k个子集随机分为k-1个组，剩下一个为另一组，有k种分法；</li><li>在每一种方法的分组结果中，那个k-1个子集的组都作为训练集，剩下的一个组作为测试集，这样就产生了k次预测，并对其取平均；</li><li>这种方法称为p次k折交叉验证，一般k取10</li></ol></li><li><p>自助法：</p><ol><li>当样本量足够时，使用自助法不如使用留出法和交叉验证法，因为无法满足数据分布一致。而如果样本量较小，无法划分，就可以使用自助法；</li><li>每次随机从数据集中抽取一个样本，然后再放回（可能会被重复抽出），m次之后会得到有m个样本的数据集，将其作为训练集；</li><li>始终没有抽到的样本的比例按概率算约是36.8%，这也保证了训练集占比大概在2/3左右</li></ol></li></ul></li><li><p>什么是偏差和方差？</p></li><li><p>什么是过拟合？在深度学习中，解决过拟合的方法有哪些？</p><p> 过拟合（overfitting）是指在模型参数拟合过程中的问题。由于训练数据包含了抽样误差，而训练时，复杂的模型将抽样的误差也考虑在内。</p><p> 过拟合具体的表现就是最终模型在<strong>训练集</strong>上效果很好，但<strong>测试集</strong>上效果很差。模型的泛化能力弱。</p><p> 产生过拟合的原因有：</p><ul><li>样本方面的原因。样本数量太少或者抽出的样本数据不能有效地代表场景；</li><li>样本里的噪声数据干扰过大，使得模型过分地记住了噪声特征，反而忽略了真实的输入输出间的关系；</li><li><p>参数太多以及模型复杂度高；</p><p>降低过拟合的方法有：</p></li><li><p>正则化：可以使用L0正则化、L1正则化或L2正则化，机器学习中一般采用L2正则化；</p></li><li>dropout：可以随机地，以一定的概率让一部分神经元失活或者丢弃；</li><li>batch normalization：BN在训练某层时，会对每一个batch数据都进行标准化或者叫归一化（normalization）处理，使得输出的规范呈正态分布；</li><li>early stopping：当随着模型的能力提升，训练集的误差会先减小后增大，所以可以提前终止算法缓解过拟合的现象（例如决策树的预剪枝方法）；</li><li>重新清洗数据：有可能是因为数据不纯导致的，所以需要重新清洗数据；</li><li>Data expending：增大数据的训练量。过拟合有可能是因为训练集的数据量太小导致的，或者训练数据占总数据的比例太小导致的；</li></ul></li><li><p>深度模型参数调整的一般方法论</p></li></ol><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li><p>简述了解的优化器</p><ol><li><p>SGD(Stochastic Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J\left(\theta ; x^{(i)} ; y^{(i)}\right)$</p><p> SGD随机梯度下降参数的更新原则是<strong>一条数据都可以对参数进行一次更新</strong>。其它的优化器都是在这个优化器的基础上改善得来的。</p><p> 优点：参数的更新速度快；</p><p> 缺点：由于每次参数更新时采用的数据量小，造成梯度更新时的震荡幅度较大，但是大多数情况是向着梯度较小的方向；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> data:</span><br><span class="line">        params_grad = eval_gradient(loss_function, example, params)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p> <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/25/tpQUgK.png" alt=""></p><p> 从上图可以看出，SGD的噪音较多，不是每次迭代都向着整体最优化方向。所以虽然训练速度快，但是准确率下降，并不是<strong>全局最优</strong>。</p></li><li><p>BGD(Batch Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J(\theta)$</p><p> BGD批量梯度下降的参数更新原则是：<strong>所有数据</strong>都参与梯度的每一次更新。</p><p> 优点：因为每次参数更新时采用的数据量都非常大，所以梯度更新时比较平滑；</p><p> 缺点：由于参数更新时需要的数据量大，所以更新的速度非常慢；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    params_grad = eval_gradient(loss_function, example, params)</span><br><span class="line">    params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure></li><li><p>MBGD(Mini-Batch Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J\left(\theta ; x^{(i: i+n)} ; y^{(i: i+n)}\right)$</p><p> MBGD是每一次利用一小批样本，即<strong>n个样本</strong>进行计算，这样就可以<strong>降低参数更新时的方差，收敛更稳定</strong>。</p><p> 优点：相比SGD，由于参与梯度更新的数据量大，所以梯度更新时较为平滑；相比BGD，参与梯度更新的数据量小，参数更新速度会更快一些。</p><p> 缺点：</p><ol><li>如果数据是稀疏的，希望对出现频率低的特征进行更大的更，learning_rate会随着更新的次数逐渐变小；</li><li><p>不能保证很好的收敛性，learning_rate如果选择得太小，收敛速度会很慢，如果太大，loss_function就会在极小值处不停地震荡甚至偏离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> get_batches(data, batch_size=n):</span><br><span class="line">        params_grad = eval_gradient(loss_function, batch, patams)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p>这里的<code>batch_size=n</code>的n一般取值在50~256之间。</p></li></ol></li><li><p>Momentum</p><p> $v_{n+1}=\gamma v_{n}+\eta \theta J(\theta)$</p><p> $\theta^{n+1}=\theta^{n}-v_{n+1}$</p><p> Momenntum通过引入$\gamma v_{n}$，加速SGD，并且抑制震荡。$\gamma$一般取值为0.9左右，</p><p> 优点：因为当我们将一个小球从山上滚下来时，没有阻力的话，它的动量就会越来越大，但是如果遇到了阻力，速度就会变小。所以加入了动量，**可以使得梯度方向不变的维度速度变快，梯度方向有所改变的维度上的更新速度变慢，这样就可以加快收敛并且减小震荡。</p><p> 缺点：当梯度方向改变时，梯度更新速度不能及时减小导致适应性差。</p></li><li><p>Adagrad(Adaptive gradient algorithm)</p><p> Adagrad解决了不能根据参数重要性而对不同参数进行不同程度更新的问题。它的参数更新原则是：对低频的参数做较大的更新，对高频的参数做较小的更新。一般超参数$\eta$取值0.01。</p><p> $\theta_{t+1, i}=\theta_{t, i}-\frac{\eta}{\sqrt{G_{t, i i}+\epsilon}} \cdot g_{t, i}$</p><p> 其中g是t时刻时参数$\theta_i$的梯度。</p><p> $g_{t, i}=\nabla_{\theta} J\left(\theta_{i}\right)$</p><p> 优点：对于稀疏的数据它的表现很好，很好地提高了SGD的鲁棒性。</p><p> 缺点：它的缺点是分母会不断的积累，这样学习率就会收缩最终会变得非常小。</p></li><li><p>Adadelta</p><p> Adadelta解决的就是Adagrad的缺点，即分母不断积累，导致学习率收缩变得非常小的问题。</p><p> Adadelta的参数更新原则就是和Adagrad相比，将分母的$G_{t, i i}$换成了过去的梯度平方的衰减平均值，指数衰减平均值。</p><p> $\Delta \theta_{t}=-\frac{\eta}{\sqrt{E\left[g^{2}\right]_{t}}+\epsilon} g_{t}$</p></li><li><p>RMSprop</p><p> 同样是为了解决Adagrad的学习率急剧下降的问题。参数更新原则同样是使用指数加权平均。</p><p> $E\left[g^{2}\right]_{t}=0.9 E\left[g^{2}\right]_{t-1}+0.1 g_{t}^{2}$</p><p> $\theta_{t+1}=\theta_{t}-\frac{\eta}{\sqrt{E\left[g_{t}^{2}\right]+\epsilon}} g_{t}$</p><p> 超参数$\gamma$为0.9，学习率$\eta$为0.001。</p></li><li><p>Adam(Adaptive Moment Estimation)</p><p> Adam相当于RMSprop+Momentum。</p></li></ol></li><li><p>常用的损失函数有哪些，分别适用于场景</p><p> 损失函数是用来<strong>估量模型的预测值$f(x)$与真实值Y的不一致程度</strong>。它是一个非负实值函数，通常使用$L(Y, f(x))$来表示。<strong>损失函数越小，模型的鲁棒性就越好</strong>。</p><ul><li><p>LogLoss对数损失函数</p><p>  可以适用于<strong>逻辑回归，交叉熵损失</strong>等。$\log$损失函数的标准形式是：</p><p>  $L(Y, P(Y | X))=-\log P(Y | X)$</p><p>  softmax使用的是<strong>交叉熵损失函数</strong>，binary_crossentropy使用的是<strong>二分类交叉熵损失函数</strong>，categorical_crossentropy使用的是<strong>多分类交叉熵损失函数</strong>。</p></li><li><p>平方损失函数</p><p>  可以适用于<strong>最小二乘法</strong>等。平方损失函数的标准形式如下：</p><p>  $L(Y, f(X))=(Y-f(X))^{2}$</p><p>  在实际应用中，通常使用均方差MSE作为一项衡量指标，公式如下：</p><p>  $M S E=\frac{1}{n} \sum_{i=1}^{n}\left(\tilde{Y}_{i}-Y_{i}\right)^{2}$</p></li><li><p>指数损失函数</p><p>  可以使用于Adaboost算法。</p></li><li><p>Hinge损失函数</p><p>  在机器学习算法中，hinge损失函数与SVM是息息相关的。其标准形式是：</p><p>  $L(y)=\max (0,1-y \tilde{y}), y=\pm 1$</p></li><li><p>其它损失函数</p><p>  0-1损失函数：$L(Y, f(X))=\left\{\begin{array}{ll}</p><pre><code>          1, &amp; Y \neq f(X) \\          0, &amp; y=f(X)          \end{array}\right.$</code></pre><p>  绝对值损失函数：$L(Y, f(X))=|Y-f(X)|$</p></li><li><p>Keras/Tensorflow中常用的cost function：</p><ul><li>mean_squared_error或者MSE</li><li>mean_absolute_error或者MAE</li><li>mean_absolute_percentage_error或者MAPE</li><li>mean_squared_logarithmic_error或者MSLE</li><li>squared_hinge</li><li>hinge</li><li>categorical_hinge</li><li>binary_crossentropy</li><li>logcosh</li><li>categorical_crossentropy</li></ul></li></ul></li><li><p>梯度下降与牛顿法、拟牛顿法的异同</p></li><li><p>L1和L2正则分别有什么特点？为什么L1更稀疏</p></li><li><p>如何提高小型网络的精度</p></li></ol><h3 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h3><ol><li>用一层隐藏层的神经网络，以ReLU作为激活函数，MSE作为损失函数推导反向传播</li><li>NN的权重参数能否初始化为0</li><li>什么是梯度消失和梯度爆炸，梯度爆炸的解决方法</li><li>常用的激活函数和导数</li><li>ReLU的优点和局限性，改进方法是什么</li><li>sigmoid和tanh为什么会导致梯度消失</li><li>相比sigmoid激活函数，ReLU激活函数有什么优势</li><li>一个隐藏层需要多少个节点能实现包含n元输入的任意布尔函数</li><li>多个隐藏层实现包含n元输入的任意布尔函数，需要多少个节点和网络层</li><li>Dropout为什么能够防止过拟合</li><li>Dropout和BN在前向传播和反向传播阶段的区别</li><li>解释批量归一化的原理</li><li>什么是反卷积，有哪些用途</li></ol><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><ol><li>给定卷积核的尺寸，特征图大小的计算方法</li><li>网络容量的计算方法</li><li>共享参数有什么优点</li><li>常用的池化操作有哪些，有什么特点，池化层有什么作用</li><li>CNN如何用于文本分类</li><li>ResNet提出的背景和核心理论是什么</li><li>空洞卷积是什么？有什么应用场景，作用是什么</li></ol><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><ol><li>简述RNN，LSTM，GRU的区别和联系</li><li>画出LSTM的结构图，写出公式</li><li>RNN的梯度消失问题，如何解决</li><li>LSTM中是否可以用ReLU作为激活函数</li><li>LSTM各个门分别使用什么作为激活函数</li><li>简述seq2seq模型</li><li>seq2seq在解码的时候有哪些方法</li><li>注意力机制是什么</li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>样本不均衡如何处理（如何解决不平衡数据集的分类问题）</p><p> 样本不均衡是指不同类别样本的比例相差悬殊，就会对算法的学习过程造成重大的干扰。例如，有1000个样本，只有5个正样本，995个负样本，那么算法把所有的样本都预测为负样本，精度也能达到99.5%。虽然精度很高，但是没有任何意义。</p><p> 解决方法有：</p><ul><li><p>欠采样，减少数量较多的那一类的样本的数量，使得正负样本的比例均衡。</p><p>  欠采样又分为随机欠采样、EasyEnsemble和BalanceCascade以及基于KNN欠采样。</p><ul><li>随机欠采样是指随机从多数类样本中抽取一部分数据进行删除。缺点就是未考虑到样本的分布情况，而采样过程又具有很大的随机性，可能会误删多数类样本中的一些重要信息。</li><li>EasyEnsemble是通过从多数的那一类样本中<strong>有放回</strong>的随机抽取一部分样本生成多个子数据集，将每个子集与少数类数据联合起来进行训练生成多个模型，然后综合多个模型的结果进行判断。方法和随机森林的原理很相似。</li><li>BalanceCascade是通过一次随机欠采样产生训练集，训练一个分类器，对于那些分类正确的多数类的样本不放回，然后剩下的多数类样本再次进行欠采样产生第二个训练器，训练第二个分类器，同样进行操作，以此类推，直到满足某个停止条件。最终的模型也是多个分类器的组合。</li><li>基于KNN欠采样：有四种KNN欠采样的方法。<ul><li>NearMiss-1：选择到最近的三个少数类样本平均距离最小的那些多数类样本</li><li>NearMiss-2：选择到最远的三个少数类样本平均距离最小的那些多数类样本</li><li>NearMiss-3：为每个少数类样本选择给定数目的最近多数类样本，目的是保证每个少数类样本都被一些多数类样本包围</li><li>最远距离：选择到最近的三个少数类样本平均距离最大的那些多数类样本</li></ul></li></ul></li><li><p>过采样，增加数量较少的那一类的样本的数量，使得正负样本的比例均衡。</p><p>  过采样又分为随机过采样、SMOTE算法和Borderline-SMOTE算法以及基于K-means过采样。</p><ul><li>随机过采样是指多次随机从少数类样本中有放回的抽取数据，采取数量大于原有的少数类样本的数量。其中的有一部分数据会出现重复，而重复数据的出现会增大方差造成模型的过拟合。</li><li>SMOTE的全称是Synthetic Minority Oversampling Technique，即合成少数类过采样技术。它是基于随机过采样算法的一种改机方案。SMOTE算法的基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中。</li><li>Borderline-SMOTE算法较SMOTE算法提升的地方是只为那些K近邻中有一半以上多数类样本的少数类样本生成新样本，因为这些样本容易被错分，而在这些少数类样本附近生存人工合成样本，有助于少数类样本的分类正确。而如果少数类样本周围全是多数类样本，这种情况下，这个样本会被认定为噪声样本。</li><li>基于K-means聚类过采样方法是首先分别对正负例进行K-means聚类，聚类之后，对其中较小的蔟进行上面的过采样方法扩充样本数量。然后再进行正负类样本的均衡扩充。</li></ul></li><li><p>不处理样本，样本分类阈值移动。</p></li></ul></li><li><p>什么是生成模型什么是判别模型</p></li><li><p>什么是鞍点问题</p></li><li><p>集成学习的分类？有什么代表性的模型和方法</p></li><li><p>常用的特征筛选方法有哪些</p></li><li><p>文本如何构造特征</p></li><li><p>类别变量如何构造特征</p></li><li><p>连续值变量如何构造特征</p></li><li><p>哪些模型需要对特征进行归一化</p></li><li><p>什么是组合特征？如何处理高维组合特征</p></li></ol><h3 id="处理分类问题常用算法"><a href="#处理分类问题常用算法" class="headerlink" title="处理分类问题常用算法"></a>处理分类问题常用算法</h3><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><ol><li><p>逻辑回归怎么实现多分类</p><p> 我们知道，普通的逻辑回归只能解决二分类问题。要想实现多分类，就要改进逻辑回归。</p><ol><li>第一种方式是One-Vs-All（或者叫One-Vs-Rest）。直接根据每个类别，都建立一个二分类器。带有这个类别的样本标记为1，带有其它样本的标记为0。如果有k个类别，那么最终就得到了k个针对不同标记的普通的逻辑分类器。</li><li>第二种方式是One-Vs-One。让不同类别的数据两两组合训练分类器。</li><li>第三种方式是修改逻辑回归的损失函数，让其适应多分类问题。即softmax回归。</li></ol></li><li><p>交叉熵公式</p></li><li><p>LR公式，LR的推导和损失函数</p></li><li><p>LR与SVM的区别和联系</p><p> 相同点有：</p><ul><li>都是<strong>监督</strong>的分类算法</li><li>都会线性分类算法</li><li><p>都会判别模型</p><p>不同点有：</p></li><li><p>损失函数不同。LR的损失函数是cross entropy：，SVM的损失函数是最大化间隔距离：</p></li><li>SVM不能产生概率，LR可以产生概率</li><li>SVM依赖于数据的测度，而LR不受影响</li><li>SVM自带结构风险最小化，LR是经验风险最小化</li><li>SVM会用核函数而LR一般不用核函数的原因</li></ul></li><li><p>LR和线性回归的区别</p></li><li><p>为什么正则化可以防止过拟合（为什么L1和L2正则化可以降低过拟合）</p></li><li><p>L1正则和L2正则有什么区别</p></li><li><p>L1正则化不可导，怎么求解</p></li><li><p>逻辑回归为什么一般性能差</p></li><li><p>如何使用LR解决非线性问题</p></li></ol><h4 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h4><ol><li>SVM什么时候使用线性核，什么时候使用高斯核</li><li>SVM的作用和基本实现原理</li><li>SVM的硬间隔和软间隔表达式</li><li>SVM使用对偶计算的目的是什么，如何推导出来的，手写推导</li><li>SVM为什么要求解决对偶问题？为什么对偶问题与原问题等价</li><li>SVM的物理意义是什么</li><li>SVM的核函数的选择</li><li>SVM的核函数的作用</li><li>SVM的核函数的原理</li><li>SVM为什么采用间隔最大化（与感知机的区别）</li><li>为什么SVM对缺失数据敏感</li><li>SVM的优缺点</li><li>SVM如何调节惩罚因子C</li><li>如何处理SVM中样本不平衡的问题</li><li>SVM如何处理多分类问题</li><li>SVM对噪声敏感的原因</li><li>如何使用SMO最优化方法求解SVM模型</li><li>SMO算法优化的终止条件是什么</li><li>是否一定存在参数使得SVM的训练误差到0</li></ol><h4 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h4><ol><li>随机森林与SVM的区别</li><li>随机森林不会发生过拟合的原因</li><li>随机森林与梯度提升树（GBDT）的区别</li><li>随机森林是怎么避免ID3算法信息增益的缺点的</li><li>为什么随机森林能降低方差</li></ol><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><ol><li>朴素贝叶斯的要求（前提假设）是？</li><li>朴素贝叶斯算法原理和工作流程</li><li>什么是先验概率和后验概率</li><li>什么是条件概率</li><li>朴素贝叶斯为什么“朴素”</li><li>朴素贝叶斯可以做多分类吗</li><li>什么是朴素贝叶斯中的零概率问题？如何解决</li><li>朴素贝叶斯中概率计算的下溢问题如何解决</li><li>朴素贝叶斯分类器对异常值敏感吗</li><li>朴素贝叶斯对缺失值敏感吗</li><li>朴素贝叶斯有哪几种常用的分类模型</li><li>朴素贝叶斯算法中使用拉普拉斯平滑，拉普拉斯因子的大小如何确定</li><li>为什么说是朴素贝叶斯是高偏差低方差的</li><li>朴素贝叶斯为什么是增量计算</li><li>高度相关的特征对朴素贝叶斯有什么影响</li><li>朴素贝叶斯有什么优缺点</li></ol><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><ol><li>ID3，C4.5和CART三种决策树的区别</li><li>简述决策树的原理</li><li>简述决策树的构建过程</li><li>决策树有哪些划分指标，其区别和联系</li><li>信息增益率有什么优缺点</li><li>如何对决策树进行剪枝操作，为什么要进行剪枝</li><li>树模型如何调参</li><li>树模型如何剪枝</li><li>预剪枝和后剪枝</li><li>简述一下分类树和回归树</li><li>决策树对缺失值如何处理</li><li>如果决策树属性用完了，但仍未对决策树完成划分该怎么办</li><li>如何避免决策树的过拟合</li><li>决策树需要进行归一化处理吗</li><li>与其它模型比较，决策树有哪些优点和缺点</li></ol><h3 id="处理回归问题常用算法"><a href="#处理回归问题常用算法" class="headerlink" title="处理回归问题常用算法"></a>处理回归问题常用算法</h3><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><ol><li>简单介绍一下线性回归的原理（什么是线性回归）</li><li>线性回归的求解方法有哪些</li><li>线性回归为什么用均方差</li></ol><h4 id="普通最小二乘回归"><a href="#普通最小二乘回归" class="headerlink" title="普通最小二乘回归"></a>普通最小二乘回归</h4><ol><li>最小二乘法的推导</li><li>最小二乘法和梯度下降法有哪些区别</li></ol><h4 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h4><ol><li>简述逐步回归算法</li></ol><h4 id="多元自适应回归样条"><a href="#多元自适应回归样条" class="headerlink" title="多元自适应回归样条"></a>多元自适应回归样条</h4><ol><li>简述多元自适应回归样条</li></ol><h3 id="处理聚类问题常用算法"><a href="#处理聚类问题常用算法" class="headerlink" title="处理聚类问题常用算法"></a>处理聚类问题常用算法</h3><h4 id="K均值（基于划分的聚类）"><a href="#K均值（基于划分的聚类）" class="headerlink" title="K均值（基于划分的聚类）"></a>K均值（基于划分的聚类）</h4><ol><li>简述一下K-means算法的原理和工作流程</li><li>K-means有什么缺点</li><li>K值如何确定</li><li>初始点选择方法</li><li>K-means不能处理哪种数据</li><li>K-means如何处理大数据（几十亿）</li><li>K-means与KNN有何不同</li></ol><h4 id="DBSCAN（基于密度的聚类）"><a href="#DBSCAN（基于密度的聚类）" class="headerlink" title="DBSCAN（基于密度的聚类）"></a>DBSCAN（基于密度的聚类）</h4><ol><li>DBSCAN与传统的K-means的不同</li><li>DBSCAN的聚类法原理</li></ol><h4 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h4><h3 id="推荐系统常用算法"><a href="#推荐系统常用算法" class="headerlink" title="推荐系统常用算法"></a>推荐系统常用算法</h3><h4 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h4><ol><li>itemCF与userCF的区别和适用场景</li></ol><h4 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h4><h3 id="模型融合和提升的常用算法"><a href="#模型融合和提升的常用算法" class="headerlink" title="模型融合和提升的常用算法"></a>模型融合和提升的常用算法</h3><h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><h4 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h4><h4 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h4><h4 id="GBRT"><a href="#GBRT" class="headerlink" title="GBRT"></a>GBRT</h4><h4 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h4><h4 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h4><h4 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h4><h3 id="其它重要算法"><a href="#其它重要算法" class="headerlink" title="其它重要算法"></a>其它重要算法</h3><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><ol><li>word2vec的原理</li><li>glove的原理</li><li>fasttext的原理</li><li>了解elmo和bert吗？简述与word embedding的联系与趋避</li></ol><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="搜索回溯"><a href="#搜索回溯" class="headerlink" title="搜索回溯"></a>搜索回溯</h3><ol><li>八皇后，全排列，组合</li><li>重复数字的排列，重复数字的组合</li><li>图的搜索</li><li>A star</li></ol><h3 id="概率题"><a href="#概率题" class="headerlink" title="概率题"></a>概率题</h3><ol><li>用rand7构造rand10</li><li>轮盘赌</li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>编辑距离</li><li>背包问题</li><li>LCS</li><li>备忘录方法</li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>给定字符串是否符合正则表达式</li><li>给定字符串是否是数字</li><li>KMP</li><li>超大数相加</li></ol><h3 id="海量数据"><a href="#海量数据" class="headerlink" title="海量数据"></a>海量数据</h3><ol><li>海量日志的出现最多的K个字符串</li><li>10亿个1-10的数字排序</li><li>trie树</li><li>布隆过滤器</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>算法的几个特征是什么</li><li>算法复杂性的定义，大O、θ、Ω、小o分别表示的含义</li><li>递归算法的定义、递归算法的两个要素</li><li>分治算法的思想</li><li>动态规划算法的两个要素是什么</li><li>贪心算法的思想，贪心算法的两个要素</li><li>回溯法的思想，回溯法中有哪两种典型的模型</li><li>分支限界法思想，有哪两种分支限界法</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(CloudComputing)</title>
      <link href="/2020/06/06/Interview-Review(CloudComputing)/"/>
      <url>/2020/06/06/Interview-Review(CloudComputing)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的云计算部分。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>云计算中弹性与可拓展性的区别是什么<br>可拓展性通过增加资源容量的比例来处理不断增加的工作量。通过使用可拓展性，如果流量引发需求，则体系结构提供随需应变的资源。</p><p>弹性是一种特征，它提供动态调试和退役大量资源容量的概念。它通过资源的需求速度和资源的使用来衡量。</p></li><li>使用云计算的优点<ul><li>数据备份和数据存储</li><li>强大的服务器功能</li><li>提高生产力</li><li>非常划算且节省时间</li></ul></li><li>哪些平台可用于大规模云计算<ul><li>Apache Hadoop</li><li>MapReduce</li></ul></li><li>云计算部署的不同模型<ul><li>私有云</li><li>公共云</li><li>混合云</li><li>社区云</li></ul></li><li>云计算与移动计算有何区别<br>移动计算和云计算在概念上略有相同。移动计算使用云计算的概念。云计算为用户提供他们在移动计算中所需的数据，在远程服务器上运行的应用程序以及为用户提供存储和管理的访问权限。</li><li>用户如何得益于公益计算（Utility Computing）<br>公用计算让用户可以只需要为使用的资源付费。它是由决定从云端部署哪种类型的服务的企业组织管理的一种插件。</li><li>云在安全方面的措施有哪些<ul><li>身份管理：授权应用程序服务</li><li>访问控制：将权限授予用户，用户就可以控制进入到云环境的另一个用户的访问</li><li>验证和授权：只允许通过授权和验证的用户访问数据和应用程序</li></ul></li><li>虚拟化平台在实施云中的主要用途（有何要求）<ul><li>它用于管理服务级别策略</li><li>云操作系统</li><li>虚拟化平台有助于保持后端级别和用户级别概念彼此不同</li></ul></li><li>在使用云计算平台前，用户需要考虑哪些必要的方面<ul><li>合规</li><li>数据丢失</li><li>数据存储</li><li>业务连续性</li><li>正常运行时间</li><li>云计算的数据完整性</li></ul></li><li>开源的云计算平台数据库有哪些<ul><li>MongoDB</li><li>CouchDB</li></ul></li><li>解释软件即服务（SaaS）的不同模式<ul><li>简单的多租户模式：在该模式中，每个用户有独立的资源，与其它用户分开来，是一种高效的模式；</li><li>细粒度的多租户模式：在该模式中，资源由许多租户共享，功能仍然一样；</li></ul></li><li>API在云服务中有何用途<br>API用于云平台，它提供了一种替代方法，无需编写完全成熟的应用程序，它可以在一个或者多个应用程序之间进行通信。</li><li>为云计算部署了哪些不同的数据中心<ul><li>集装箱式数据中心</li><li>低密度数据中心</li></ul></li><li>云计算中有哪些不同的层<ul><li>SaaS：软件即服务，它让用户可以直接访问云应用程序，不必在系统上安装任何东西</li><li>IaaS：基础设施即服务，它从硬件等层面提供了基础设施</li><li>PaaS：平台即服务，它为开发人员提供了云应用程序平台</li></ul></li><li>云服务是什么<br>云服务用来通过互联网，使用网络中的服务器来构建应用程序，它提供了这种便利：不必将云应用程序安装到计算机上，即可直接使用。它还减少了维护和支持使用云服务开发的应用程序的工作。</li><li>云架构具有的好处<ul><li>无需基础设施投入</li><li>适时的基础设施</li><li>更高效地利用资源</li></ul></li><li>云架构有别于传统架构的特点<ul><li>按照需求，云架构满足硬件要求</li><li>云架构能够按需增减资源</li><li>云架构能够管理和处理动态工作负载，顺畅无阻</li></ul></li><li>在云架构中，必须的不同部分有哪些<ul><li>云入站</li><li>处理器速度</li><li>云存储服务</li><li>云提供商服务</li><li>云间通信</li></ul></li><li>在云架构中，经历的不同阶段有哪些<ul><li>启动阶段</li><li>监测阶段</li><li>关闭阶段</li><li>清理阶段</li></ul></li></ol><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><ol><li>Kubernetes与Docker Swarm的区别如何</li><li>Kubernetes与Docker有什么关系</li><li>在主机和容器上部署应用程序有什么区别</li><li>什么是Container Orchestration</li><li>Container Orchestration需要什么</li><li>Kubernetes Architecture的不同组件有哪些</li><li>Kubernetes包含几个组件，各个组件的功能是什么，组件之间是如何交互的</li><li>k8s中的pod内几个容器之间的关系是什么</li><li>一个经典pod的完整生命周期</li><li>容器编排的价值和好处是什么</li><li>如何在 Kubernetes 中实现负载均衡</li></ol><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ol><li>OpenStack及其主要组件</li><li>什么服务通常在控制节点上运行</li><li>什么服务通常在计算节点上运行</li><li>计算节点上虚拟机的默认地址是什么</li></ol><h3 id="OpenNebula"><a href="#OpenNebula" class="headerlink" title="OpenNebula"></a>OpenNebula</h3><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121.Best Time to Buy and Sell Stock</title>
      <link href="/2020/03/12/121.Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2020/03/12/121.Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><a id="more"></a><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>最容易想到的暴力法就是比较每个元素与后面的元素的差值。假设数组长度为n，则第一次要比较n-1次，第二个要比较n-2次，以此类推，第n个要比较n-(n-1)=1次。所以总次数也就是时间复杂度为$O(n^2)$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 记录差值</span></span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="comment">// 如果当前差值比maxprofit大，就将maxprofit替换成当前差值</span></span><br><span class="line">            <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：$O(n^2)$，循环进行了$(n-1)+(n-2)+…+1=\frac{n(n-1)}{2}$次。</li><li><strong>空间复杂度</strong>：$O(1)$。因此只使用了常数个变量。</li></ul><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>遍历一次数组，在遍历每一天时，既要用一个变量判断历史最低价格<code>minprice</code>，也要在当天判断当天与历史最低价格的差值是否是最大利润。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，设置<code>minprice</code>为最大值，<code>maxprofit</code>为0。然后开始遍历数组。</p><p>如果当前数组的值比<code>minprice</code>小，就发生替换；如果更大就不替换。这样就能得到这个数组中最小的值。然后用当前数组的值减去<code>minprice</code>，如果得到的利润大于最大利润，就得到最大利润。因为这个都放在同一个<code>for</code>循环里，所以遍历的顺序是从0从n，从前往后，所以是不存在前面一个数减后面一个数的情况。</p><p>这道题评论有质疑这种做法是话如果最小值在数组的最后一位会不成立。实际上亲测是不影响的。可以通过下图说明。</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seb1x0.jpg" alt=""></p><p>由上图可发现，尽管最后一位才是数组的最小值，最后的<code>minprice</code>也更新为了1，但是因为之前已经保留了<code>maxprofit</code>的值为4，所以最后一位的最小值被当前元素相减，结果为1仍然小于4，所以不会更新替换<code>maxprofit</code>的值，所以结果仍然是正确的。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：因为只使用了一次<code>for</code>循环遍历了整个数组，所以时间复杂度是$O(n)$。</li><li><strong>空间复杂度</strong>：是使用了常数个变量，所以是$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>463.Island Perimeter</title>
      <link href="/2020/03/12/463.Island-Perimeter/"/>
      <url>/2020/03/12/463.Island-Perimeter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 :</p><p>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p><p>输出: 16</p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p></blockquote><a id="more"></a><p>这道题的思路是总的正方形块树的数量乘以4条边，然后减去重合的边树乘以2，就是岛屿的周长。所以解题的关键就是在于<strong>有规律的找到有多少次的重叠</strong>，这样能够避免重复的计算。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>最开始想到的代码写法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该矩阵为空</span></span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 陆地的数量</span></span><br><span class="line">    <span class="keyword">int</span> land = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重叠的数量</span></span><br><span class="line">    <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 规定数组元素为1时是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                land++;</span><br><span class="line">                <span class="comment">// 分别找上下左右是否是陆地，如果是陆地就意味着有重合</span></span><br><span class="line">                <span class="comment">// 下</span></span><br><span class="line">                <span class="comment">// 因为判断下边，所以i要小于grid.length-1，不然就已经是最下边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右</span></span><br><span class="line">                <span class="comment">// 因为判断右边，所以j要小于grid[i].length-1，不然就已经是最右边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左</span></span><br><span class="line">                <span class="comment">// 因为判断左边，所以j要大于0，不然就已经是最左边了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 上</span></span><br><span class="line">                <span class="comment">// 因为判断上边，所以i要大于0，不然就已经是最上边了</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * land - <span class="number">2</span> * overlap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始想到的就是上下左右进行判断是否是陆地，如果是陆地，就说明了有重叠部分。但是这样去提交代码测试结果却发现是错误的。后来才想明白，其实上下左右只要判断两个方向就可以了。</p><p>例如判断左边的部分，首先条件<code>j &gt; 0</code>本来就是恒成立的，因为<code>for</code>循环是从0开始递增的，所以这里是多余的。然后，在双层循环了里，判断<code>grid[i][j] == grid[i][j + 1]</code>和判断<code>grid[i][j] == grid[i][j - 1]</code>其实是一样的效果。所以如果在这里判断了两侧，就会造成<code>overlap</code>累加了两次，从而计算错误。</p><p><strong>正确的代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该矩阵为空</span></span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 陆地的数量</span></span><br><span class="line">    <span class="keyword">int</span> land = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重叠的数量</span></span><br><span class="line">    <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 规定数组元素为1时是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                land++;</span><br><span class="line">                <span class="comment">// 分别找上下左右是否是陆地，如果是陆地就意味着有重合</span></span><br><span class="line">                <span class="comment">// 纵向</span></span><br><span class="line">                <span class="comment">// 因为判断下边，所以i要小于grid.length-1，不然就已经是最下边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 横向</span></span><br><span class="line">                <span class="comment">// 因为判断右边，所以j要小于grid[i].length-1，不然就已经是最右边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * land - <span class="number">2</span> * overlap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return 4 * land - 2 * overlap</code>的原因是根据规律得知，最终的周长就是陆地的数量乘以4条边然后减去重合数量的2倍（因为重复计算了2条边）。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：如果这个二维矩阵的宽高分别为m和n，那么进行了双层循环，所以时间复杂度为$O(mn)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题02.03.Delete Middle Node</title>
      <link href="/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%9802.03.Delete-Middle-Node/"/>
      <url>/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%9802.03.Delete-Middle-Node/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure></blockquote><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>最简单直接的想法就是遍历一遍链表，得出链表的长度，然后一半即是链表一半的长度，也就是中间节点所在的位置。但是这样缺点也是很明显的，就是在时间复杂度上。假设链表的长度为n，则遍历一遍链表的长度需要$O(n)$的时间，然后又重新遍历一半链表的长度获得中间节点，这里又需要$O(\frac{n}{2})$的时间，总时间即为$O(\frac{3n}{2})$。</p><a id="more"></a><h3 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h3><p>在很多场景下都可以用到快慢指针法。在这里设置两个指针，一个指针A每次指向下一个节点，一个指针B指向下两个节点，这样当B走到链表的末尾时，A才走到链表的中间节点（因此B是A速度的两倍）。所以这样A指针走到的位置就是链表的中间节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delete_Middle_Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 慢指针</span></span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        <span class="comment">// 快指针</span></span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：因为两个指针是同时进行的，快指针遍历了整个链表，慢指针遍历了半个链表，所以时间复杂度仍然是$O(n)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经收集</title>
      <link href="/2020/03/03/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/"/>
      <url>/2020/03/03/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里钉钉三面"><a href="#阿里钉钉三面" class="headerlink" title="阿里钉钉三面"></a>阿里钉钉三面</h2><ol><li>自我介绍</li><li>对MVC和MVP的理解</li><li>Handler的内存泄漏问题具体是什么，解决方案知道有什么，空数据的时候Handler的阻塞问题</li><li>为什么使用MVP，它的优势是什么，内存泄漏是什么样的</li><li>http长连接和短连接的这两个概念</li><li>RecyclerView的复用机制，和ListView的一个区别在哪里</li><li>HashMap和ConcurrentHashMap和HashTable问题</li><li>一个app的启动流程，冷启动和热启动</li></ol><a id="more"></a><h2 id="腾讯电话面一面"><a href="#腾讯电话面一面" class="headerlink" title="腾讯电话面一面"></a>腾讯电话面一面</h2><ol><li>Class编译过程</li><li>自定义View要经过哪些过程吗？</li><li>如何绘制圆形、曲线等？</li><li>自定义View是如何绘制在屏幕上的？</li><li>简述Activity的生命周期</li><li>应用切换到后台，前台Activity的生命周期经过哪些变化？</li><li><code>onNewIntent()</code>方法什么时候会触发？</li><li><code>singleTask</code>和<code>singleTop</code>有什么区别？</li><li>两个Activity如何进行跨进程通信？</li><li>一个进程进行文件读取时，如何设置权限（不让其他进程访问）？</li><li>Android如何实现多线程？</li><li>简述Handler如何实现多线程？</li><li>JVM是什么？为什么需要JVM？</li><li>简述客户端网络请求架构？</li><li>如何保证客户端网络请求的安全性？</li><li>HTTP长连接和短连接的不同</li><li>简述三次握手</li><li>HTTPS是何如加密的</li><li>DNS是什么</li><li>如何从一亿个QQ号中筛选出五个指定的QQ号》</li><li>快排算法实现过程，时间复杂度是多少？有什么弊端</li><li>简述归并排序算法，时间复杂度是多少？</li></ol><h2 id="腾讯暑期Android实习一二面"><a href="#腾讯暑期Android实习一二面" class="headerlink" title="腾讯暑期Android实习一二面"></a>腾讯暑期Android实习一二面</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li><p>ArrayList和LinkedList的区别，它们各自的优缺点是什么以及它们有什么异同点</p></li><li><p>进程和线程的区别</p></li><li><p><code>static</code>这个命名的变量和类有什么不同？</p></li><li><p>二叉树有几种遍历方式？</p><ul><li><p>先序遍历：根、左、右</p></li><li><p>中序遍历：左、根、右</p></li><li><p>后序遍历：左、右、根</p></li><li><p>层次遍历：从上往下层次遍历</p></li></ul></li><li><p>堆和栈的特点</p><ol><li>栈内存是用来存储局部变量和方法调用的，堆内存是用来存储Java中对象的。无论是成员变量、局部变量还是类变量，它们指向的对象都存储在堆内存中。</li><li>栈内存远远小于堆内存。</li><li>数据结构方面：堆可以看成一颗树，栈是一个先进后出的数据解耦股。</li></ol></li><li><p>队列和栈，它们在数据进出顺序的方面有什么不同点？</p><p> 先进先出和先进后出</p></li><li><p>Java有几种内存模式，其中变量/方法/类分别储存在哪里？栈内存主要用来存放什么？</p></li><li><p>介绍一个Java的垃圾回收机制</p><p> 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源。可以调用<code>System.gc()</code>方法或者<code>Runtime.getRuntime().gc()</code>方法。</p></li><li><p>说一下去MVC是什么？</p></li><li><p>Android六大布局，线性布局和相对布局哪个效率高？</p></li><li><p>Activity生命周期</p></li><li><p>Activty从打开状态到运行状态经历了哪几个方法？</p></li></ol><h2 id="阿里淘系技术部Android实习一二面"><a href="#阿里淘系技术部Android实习一二面" class="headerlink" title="阿里淘系技术部Android实习一二面"></a>阿里淘系技术部Android实习一二面</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ol><li><p>简历项目介绍</p></li><li><p>看过哪些Android或者Java的书籍</p><p> 《第一行代码》、《Android进阶之光》</p></li><li><p>设计一个图片加载框架需要考虑到哪些方面</p><p> 图片加载包含封装、解析、下载、解码、变换、缓存、显示等操作。</p><ol><li>封装参数：这些参数会贯穿整个过程</li><li>解析路径：图片的来源有很多种，格式也不尽相同，需要规范化</li><li>读取缓存：同样的请求，可以从缓存中读取图片</li><li>查找文件/下载文件：如果是本地的文件，直接解码；如果是网络图片，需要先下载</li><li>解码：</li><li>变换：通过解码成bitmap，可能要做一些变换处理（例如圆角等）</li><li>缓存：得到最终的bitmap后，可以缓存起来，以便下次可以使用</li><li><p>显示：显示图片，可能会添加一些动画</p><p>为了防止图片分辨率过大，出现OOM，还需要进行进一步处理。比如说用到<code>BitmapFactory</code>类对大图片进行压缩处理后再放到内存中。</p></li></ol></li><li><p>场景：找出海量字符里面出现次数最多的那个字符</p><ol><li><p>分治法+HashMap：</p><p> 比如说分为很多批，1批有100个字符。这100个字符可以存进<code>String</code>类型的字符串数组中，每批使用循环遍历一次，存入<code>HashMap&lt;String, Integer&gt;</code>里面，<code>String</code>对应这个数的字符串，<code>Integer</code>对应它出现的次数，最后最大的字符就是出现次数最多的。</p></li></ol></li><li><p>Activity的启动流程</p><p> 当在Activity中调用<code>startActivity</code>方法来启动另一个Activity时，调用流程：<code>startActivity$$\rightarrow$$startActivity(intent, bundle)$$\rightarrow$$startActivityForResult(intent, -1, bundle)</code>。最后去调用<code>Instrumentation.execStartActivity</code>方法。</p><p> <code>Instrumentation</code>有什么作用呢？为什么要在<code>Instrumentation</code>中去执行<code>execStartActivity</code>方法呢？</p><p> <code>Instrumentation</code>是在任何应用程序运行前进行初始化的，可以用它来检测系统和应用程序之间的交互。每一个Activity都会持有<code>Instrumentation</code>的引用，但是整个进程只有一个<code>Instrumentation</code>实例，所以<code>Instrumentation</code>相当于一个大管家，管理着Activity和Application的生命周期，包括着Activity的创建。</p></li><li><p>Android性能优化</p></li><li><p>算法：找出单向链表的中间节点</p></li><li><p>算法：单向链表的头尾节点交换</p></li><li><p>算法：给定N个<code>int</code>型的数组，每个数组的元素个数不确定也不一定相同，请将N个<code>int</code>类型的数组合并成一个数组，同时进行降序的排列</p></li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li><p>为什么学习Android</p></li><li><p>Android看的书籍，收获？</p></li><li><p>最满意的项目</p></li><li><p>项目里的多线程</p></li><li><p>Activity启动过程</p></li><li><p>内存泄漏，用什么工具检测？</p><p> <strong>内存泄漏</strong>是指：对象在它有限的生命周期结束后，它们将被垃圾回收，如果在回收时，这个对象还在被一系列的引用，就会导致该对象不会被回收，就会导致内存泄漏。随着泄漏的累积，应用将消耗完内存，应用的流畅性就会大大减弱。</p><p> 可以使用<strong>LeakCanary</strong>检测内存泄漏。当发生内存泄漏时，会进入内存泄漏报告分析。</p></li><li><p>Android页面的刷新频率</p></li><li><p>Android如何发现性能问题</p></li><li><p>操作系统死锁</p><p>死锁的四个条件：</p><ol><li>互斥：该资源任意时刻都只由一个线程占用；</li><li>持有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不可抢占：线程已获得的资源在未使用完之前不能被其它资源所侵占，只有自己使用完毕才能释放资源；</li><li>环路等待：形成进程和请求资源之间的环路，呈一种头尾相接的循环等待资源关系。</li></ol></li><li><p>树的区别（大小顶堆、AVL、排序树）</p><ol><li><p>AVL树：即平衡二叉树，AVL得名于其发明者的名字。</p><p>平衡二叉树的定义：</p><ol><li>左右子树的高度差都小于等于1</li><li>其每一个子树均为平衡二叉树</li></ol></li><li><p>二叉堆：是一种特殊的堆，具有堆的性质（父节点的键值总是大于等于或者小于等于任何一个子节点的键值）。二叉堆又具有二叉树的性质（二叉堆是完全二叉树或者是近似完全二叉树。）</p><ol><li>最大堆：当父节点的键值总是大于等于它的每一个子节点的键值时就是最大堆</li><li>最小堆：当父节点的键值总是小于等于它的每一个子节点的键值时就是最小堆</li></ol><p>二叉堆查找的时间复杂度是$O(n)$，创建二叉堆、插入节点、删除节点的时间复杂度都是$O(\log2n)$。</p></li><li><p>排序树：二叉排序树又叫做二叉查找树或二叉搜索树。它满足以下性质：</p><ol><li>若它的左子树不为空，则左子树的所有节点的值都要小于它的根节点的值；</li><li>若它的右子树不为空，则右子树的所有节点的值都要大于它的根节点的值；</li><li>它的左、右子树也都分别为二叉排序树。</li></ol><p>当然，如果这棵树是一颗空树，那也满足是二叉排序树。</p></li></ol></li><li><p>算法：矩阵逆时针打印每一个元素</p></li></ol><h2 id="CVTE-Android实习一二面"><a href="#CVTE-Android实习一二面" class="headerlink" title="CVTE Android实习一二面"></a>CVTE Android实习一二面</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><ol><li><p>自我介绍</p></li><li><p>Retrofit源码</p></li><li><p>Java线程同步的方法</p><ol><li><p>同步方法<code>synchronized</code>修饰方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> Java的每个对象都有一个内置锁，如果使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就会处于阻塞状态。</p></li><li><p>同步代码块<code>synchronized</code>修饰代码块</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;&#125;</span><br></pre></td></tr></table></figure><p> 被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。</p><p> 同步是一种高开销的操作，所以应该尽量减少同步的内容。</p></li><li><p>使用特殊域变量<code>volatile</code>实现线程同步</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p> 只需要加上<code>volatile</code>就可以实现线程同步。</p><ol><li><code>volatile</code>关键字为域变量的访问提供了一种免锁机制</li><li>使用<code>volatile</code>修饰域相当于告诉虚拟机该域可能会被其它线程更新，因此每次使用该域都要重新计算，而不是使用寄存器的值</li><li><code>volatile</code>不会提供任何原子操作，也不能用来修饰<code>final</code>类型的变量</li></ol></li><li><p>使用重入锁实现线程同步</p></li><li><p>使用局部变量实现线程同步</p></li><li><p>使用阻塞队列实现线程同步</p></li><li><p>使用原子变量实现线程同步</p></li></ol></li><li><p><code>Synchronized</code>和<code>Lock</code>的区别</p><p> <code>Synchronized</code>：是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻只有一个线程执行改该段代码。</p><p> <code>Lock</code>：是一个接口，主要有<code>Lock</code>、<code>ReadWriteLock</code>、<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>等。</p><p> <strong>区别</strong>：</p><ul><li><code>Lock</code>是一个接口，而<code>Synchronized</code>是Java中的关键字，是内置的语言实现；</li><li><code>Synchronized</code>在发生异常的时候，会自动释放线程占有的锁，所以不会产生死锁现象；而<code>Lock</code>在发生异常的时候，如果没有主动通过<code>unLock()</code>方法去释放锁，则有可能会造成死锁现象，因此使用<code>Lock</code>时需要在<code>finally</code>块中释放锁；</li><li><code>Lock</code>可以让等待的锁的线程响应中断，而<code>Synchronized</code>不能；使用<code>Synchronized</code>时，等待的线程会一直等待下去，不能响应中断；</li><li><code>Lock</code>可以提高多个线程进行读操作的效率，通过<code>ReadWriteLock</code>去实现读写分离；</li></ul></li><li><p>锁的类型（悲观、乐观、可重入、可中断、公平、读写）</p><p> 见<a href="">Java锁的原理与类型</a></p></li><li><p>四种引用</p><ol><li><p>强引用：</p><p> 使用强引用时，属于不可回收的资源，垃圾回收器绝不会回收它。当内存空间不足时，Java虚拟机宁愿抛出<code>OutOfMemoryError</code>的异常，使程序终止，也不会回收具有强引用的对象来解决内存不足的问题。这是最常使用到的引用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p>软引用：</p><p> 如果一个对象具有软引用，那么如果此时内存空间足够，垃圾回收器就不会回收它。但如果内存空间不足时，就会回收这些对象的内存。只要垃圾回收器还没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列联合使用，如果软引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">SoftReference reference = <span class="keyword">new</span> SoftReference(obj, queue);</span><br><span class="line"><span class="comment">// 强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p> 当内存不足时，软引用对象被回收，<code>reference.get()</code>为<code>null</code>，将软引用的对象添加进ReferenceQueue队列中。</p></li><li><p>弱引用：</p><p> 弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间是否充足，都会回收它的内存。同理，弱引用也可以和引用队列一起使用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">WeakReference reference = <span class="keyword">new</span> WeakReference(obj, queue);</span><br><span class="line"><span class="comment">// 强引用对象滞空，保留弱引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>虚引用：</p><p> 虚引用不影响对象的生命周期，如果一个对象与虚引用关联，则相当于没有引用与之关联，虚引用在任何时候都可能被垃圾回收器回收。</p><p> 但是注意，虚引用必须和引用队列关联使用，当垃圾回收器准备与虚引用关联的对象时，会把这个虚引用添加到与之关联的引用队列中。</p><p> 因此，程序可以通过判断引用队列中是否已经加入了虚引用来判断对象是否要被垃圾回收。如果某个对象的虚引用已经被加入到引用队列中，那么就可以在该对象的内存被回收之前采取必要的行动。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference reference = <span class="keyword">new</span> PhantomReference(obj, queue);</span><br><span class="line"><span class="comment">// 强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>引用总结：</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/ONnoTAVLWFbpEqw.png" alt="四种引用示例图1"></p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/cLdkAaRUzvtxwiG.png" alt="四种引用示例图2"></p></li></ol></li><li><p>GC机制</p></li><li><p>线程池（ThreadPoolExecutor参数、线程池类型、线程池工作策略）</p></li><li><p>binder（binder内部具体类和方法，工作流程，IPC方式的比较）</p></li><li><p>HTTP响应码</p><ul><li>1XX：表示请求已经被收到了，需要进一步的处理才能完成；</li><li>2XX：成功处理请求；</li><li>3XX：重定向使用Location指向的资源或者缓存中的资源；</li><li>4XX：客户端出现错误，请求失败；</li><li>5XX：服务端出现错误，请求失败</li></ul></li><li><p>cookie/session的区别</p><ul><li>cooike数据保存在用户的浏览器上（临时文件夹中），session数据保存在服务器上；</li><li>cookie是以明文的方式存放在客户端的，不是很安全，别人可以通过分析存在在本地的cookie来进行COOKIE诈骗；</li><li>cookie会传递消息给服务器；session本身存放在服务器中，不会有传送流量；</li><li>生命周期：<ul><li>cookie的生命周期是累加的，从创建时开始计时，20分钟后生命周期结束</li><li>session的生命周期是间隔的，创建后20分钟内没有访问session就会被销毁；但如果20分钟内访问了session，就又要重新计算session的生命周期；</li></ul></li><li>session是一定时间内会存储在服务器中。当访问增多时会增加服务器的性能消耗，此时就可以考虑使用cookie；</li><li>cookie为多个用户浏览器共享，session为一个用户浏览器独享；</li></ul></li><li><p>Handler消息传递机制（内部机制、执行流程、线层切换）</p><p>Android应用程序被创建的时候都会创建一个UI主线程，但有时会进行一些比较耗时的操作，为了防止阻塞UI主线程，会把耗时的操作放到子线程中进行处理，处理完之后操作UI，但是又因为Android规定UI只能在主线程中操作，所以消息传递机制是为了解决Android应用的多线程问题。Handler是一种异步回调机制，它可以在完成一个耗时任务后做出相应的通知。</p><blockquote><p>首先需要在主线程中创建一个Handler对象，并重写<code>handleMessage()</code>方法，然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler的<code>sendMessage()</code>方法把这个消息发送出去。这个消息会进入到<code>MessageQueue</code>队列中等待被处理，而<code>Looper</code>会一直尝试从<code>MessageQueue</code>中取出待处理信息，最后发送回Handler的<code>handleMessage()</code>方法。</p><p>因为<code>Handler</code>是在主线程中创建的，所以<code>handleMessage()</code>方法也会在主线程中执行，所以最后就可以进行UI操作了。一条Message经过这个流程从子线程进入到了主线程，从不能更新UI变成了可以更新UI，整个异步消息处理的核心就是这样。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/wpNqsob7YEMGAkT.png" alt="Handler消息传递机制示意图"></p></li><li><p>Android动画机制</p></li><li><p>自定义View</p></li></ol><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li><p>自我介绍</p></li><li><p>Retrofit源码（动态代理）</p></li><li><p>Glide源码</p></li><li><p>实现一个图片加载框架要考虑什么</p></li><li><p>HashMap源码，线程安全要用哪个（ConcurrentHashMap）</p><p> 官方文档中是这样描述HashMap的：</p><blockquote><p>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is <strong>unsynchronized</strong> and <strong>permits nulls</strong>.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p></blockquote><p> 这其中有几个关键的信息：基于Map接口实现、允许键/值为<code>null</code>、非同步、不保证有序（比如插入的排序）、也不保证序不随时间变化。</p><p> 所以：</p><ol><li><p>HashMap的特点：</p><p> 是基于Map接口时间的，存储键值对时，它接收键值对为<code>null</code>，是非同步的，HashMap存储着<code>Entry(hash, key, value, next)</code>对象。</p></li><li><p>HashMap的工作原理：</p><p> 通过hash的方法，通过put和get存储和获取对象。</p><p> 存储对象时，将键值对传递给put方法，它调用hashCode计算hash从而得到bucket的位置，进一步存储，HashMap会根据当前的bucket占用的情况自动调整容量（超过Load Factor则resize为原来的2倍）。</p><p> 获取对象时，把key传递给get，它调用hashCode计算hash从而得到bucket的位置，并进一步调用<code>equals()</code>方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来。如果一个bucket中碰撞冲突的元素超过某个限制（默认为8），则使用红黑树来替换链表，从而提高速度。</p></li><li><p>get和put的原理？<code>equals()</code>和<code>hashCode()</code>有什么作用？</p><p> 通过对key的<code>hashCode()</code>进行hashing，计算下标n-1和hash值，从而获得bucket的位置。如果产生碰撞，则利用<code>key.equals()</code>的方法去链表或树中去查找对应的节点。</p></li><li><p>hash如何实现的？</p><p> 在Java1.8中，是通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，这么做可以在bucket的n比较小时，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></li><li><p>如果HashMap大小超过了负载因子（load factor）定义的容量，怎么办？</p><p> 如果超过负载因子（默认为0.75），则resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p></li><li><p>想要线程安全是使用HashMap还是ConcurrentHashMap？</p><p> HashMap线程是不安全的。例如：</p><ol><li>多线程环境下，put的时候导致的多线程数据不一致</li><li><p>HashMap的get操作可能会因为resize而引起死循环</p><p>ConcurrentHashMap是线程安全的。因为：</p></li><li><p>分段机制：segment，每段加reentrantLock可重入锁</p></li><li>定位元素：找segment的数组下标；找segment的HashEntry数组下标</li><li>get方法：不需要加锁，value值使用了volatile关键字修饰</li><li>put方法：hash计算端，锁定段，hash计算HashEntry数组，若超多阈值，就扩容释放；put过程中会modCount+1，为了后续的计算大小</li><li>size方法：为了求Map的大小，需要全局锁，但是性能差；所以采用modCount计算器，用于记录段的大小</li><li>弱一致性：clear时是不加锁的，所以多线程中可能会出现数据不一致</li></ol></li></ol></li><li><p>事件分发机制</p></li><li><p>滑动冲突（手写外部拦截法的伪代码）</p></li><li><p>性能优化</p></li><li><p>手写快排</p></li></ol><h2 id="字节跳动Android实习一二面"><a href="#字节跳动Android实习一二面" class="headerlink" title="字节跳动Android实习一二面"></a>字节跳动Android实习一二面</h2><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><ol><li><p>Parcelable和Serializable是什么，做什么用，谁更高效？</p><p> <code>Serializable</code>是Java原生的接口，<code>Parcelable</code>是Android提供的接口。</p><ul><li><p><code>Parcelabel</code>：实现这个接口要重写三个方法，就是实现序列化过程要实现三个功能——<strong>序列化</strong>、<strong>反序列化</strong>、<strong>内容描述</strong>。</p><ul><li>序列化：由<code>writeToParcel()</code>方法完成，里面主要是<code>write</code>一些对象的属性</li><li>反序列化：由CREATOR完成，内部标明了如何创建序列化对象和数组，并通过<code>read</code>方法来完成反序列化过程</li><li><p>内容描述：重写<code>describeContents()</code>方法来完成，一般返回0，如果当前对象中存在文件描述时返回1</p><p><code>Parcelabel</code>开销小，效率高，使用场景为内存序列化。</p></li></ul></li><li><p><code>Serializable</code>：就是直接实现<code>Serializable</code>接口，无需实现方法，<code>Java</code>就会对这个对象进行高效的序列化操作。它简单，但是开销大，序列化过程的I/O操作过多，使用了反射，序列化过程慢，效率低，使用场景为序列化到本地或者通过网络传输。</p></li></ul></li><li><p>数据库中的事务</p><p> 数据库事务（Transaction）是访问并可能操作各种数据项的一个数据库操作序列，要么全部执行，要么全部不执行，是一个不可分割的工作单位。</p><ul><li>原子性：</li><li>一致性：</li><li>夺隔离性：</li><li>夺持久性：</li></ul></li><li><p>假如手机只有10M内存，想要申请1M的内存是否一定能成功？</p></li><li><p>讲一个时间片</p><p> 时间片表示进程在被抢占之前所能持续运行的时间。</p></li><li><p>对线程池的理解</p><p> 线程池就是事先将线程放到一个容器中，当使用线程的时候，就不用再新建一个线程，直接从线程中取出就好。可以用<code>execute()</code>方法启动线程池。</p><p> <strong>好处</strong>：</p><ol><li>降低资源消耗：重复利用线程池中的线程节省线程创建和销毁带来的消耗；</li><li>提高性能：当任务需求时，可以不用创建线程，而是可以直接从线程池中取出线程去执行，更高效；</li><li>提高线程的可管理性：如果频繁无限制地创建线程会消耗系统资源，降低系统稳定性导致系统崩溃、内存溢出等问题；</li></ol></li><li><p>想要在一个图片的右上角实现一个圆角是怎么实现的？</p></li><li><p>Java的四种引用</p></li><li><p>抖音无限上滑是怎么实现的？</p></li><li><p>什么时候会发生内存泄漏？</p></li><li><p>算法题：两数之和（时间复杂度）</p></li></ol><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><ol><li><p>自我介绍，做过的项目</p></li><li><p>数据库频繁读取数据，可以用什么方式来优化（索引）</p></li><li><p>死锁的四个条件，开发过程中什么情况容易造成死锁</p></li><li><p>手机端应用和电脑端应用的注意事项和区别</p></li><li><p><code>public</code>父类中子类重写能不能用<code>protected</code>，反过来呢？</p></li><li><p>场景题：抖音开屏广告是如何实现的（包括倒计时和要播放的视频），倒计时点击跳过的时候应该如何实现？</p><p> 倒计时用Handler，播放的视频用url打开保存在本地的视频</p></li><li><p>算法题：二叉树的最长路径（DP）</p></li></ol><h2 id="字节跳动Android实习一二三四面"><a href="#字节跳动Android实习一二三四面" class="headerlink" title="字节跳动Android实习一二三四面"></a>字节跳动Android实习一二三四面</h2><h3 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h3><ol><li>自我介绍</li><li>操作系统线程和进程的同步机制和通信机制</li><li>手写Java双重检验的单例模式</li><li>数据库的索引和它的原理</li><li>Java的四种引用方式</li><li>OSI和TCP/IP的网络模型，路由器和交换机位于哪一层</li><li><code>synchronized</code>的类锁和对象锁的区别，哪些是对象锁，哪些是类锁</li><li>算法题：给一对无序数组，给一个target整数，然后找出数组中两个数字相加为target，并输出下标</li><li>给两对有序的数组，给出合并后有序的数组（数组合并）</li><li>http和https的区别</li><li>HTTP1和HTTP2的区别，HTTP2和HTTPS的关系</li><li>操作系统的分页分段管理，虚拟内存</li><li>Java的GC机制，引用计数和可达性分析算法，<code>finlize()</code>方法，四种回收算法，哪些对象可以作为GC ROOTS的对象</li><li>说一下Java的<code>synchronized</code>和<code>volatile</code>关键字，可见性、重排序、原子性</li><li>智力题：8个物品，有一个质量较大，如何两次称出它</li><li>算法题：最长连续子序列</li></ol><h3 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h3><ol><li>缓存溢出</li><li>Android中常用哪些控件</li><li>Glide的使用</li><li>RxJava的通信机制</li><li>Android四大组件</li><li>手写SQL语句，分组查询</li><li>中断是什么</li><li>算法题：汉诺塔</li></ol><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol><li>了解bitmap的解析吗</li><li>设计一个自定义View，View中包含图片和文字，并且只能继承View</li><li>用过约束布局吗？它的特点和原理，比起相对布局的优势</li><li>Glide相关</li><li>https的加密过程，为什么要这么做</li><li>浏览器输入一个url后发生了什么，DNS协议的原理</li><li><code>get</code>和<code>post</code>的区别</li><li>封装一个单链表，要求实现删除，添加，反转的方法</li><li>算法题：数组反转，给定一个target整数，每target长度反转一次</li></ol><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><ol><li>看过哪些Android源码</li><li>OkHttp的缓存策略</li><li>除了Glide还用过哪些图片加载框架</li><li>Activity的四种启动方式，区别</li><li>Android的线程同步机制和进程通信机制</li><li>Java中的泛型，类型擦除</li></ol><h2 id="阿里河马Java实习一面"><a href="#阿里河马Java实习一面" class="headerlink" title="阿里河马Java实习一面"></a>阿里河马Java实习一面</h2><ol><li>自我介绍</li><li>面向对象三大特性</li><li>继承和接口的区别</li><li>重写、重载的原理，重载和重写各自应用的场景</li><li><code>int</code>和<code>Integer</code>的区别，为什么会有<code>Integer</code>缓冲池？<code>Integer</code>缓冲池细节，比如<code>Integet a = 1; Integer b = new Integet(1)</code>，a和b比较返回true还是false？</li><li>Object类有什么方法？</li><li><code>HashCode</code>有什么作用？<code>equals</code>和<code>HashCode</code>有什么关系？</li><li><code>HashCode</code>在<code>HashMap</code>中的作用？<code>HashMap</code>和<code>ConcurrentHashMap</code>的区别？</li><li>什么是线程安全的？操作变量情景下怎么样才是线程安全的？怎么样是线程不安全的？</li><li>多个线程操作局部变量，静态变量的情况下，虚拟机是怎么分配内存的？</li><li><code>Synchronized</code>的实现原理，锁的升级过程，修饰实例对象和<code>class</code>的区别</li><li>讲一下<code>wait</code>、<code>notify</code>、<code>notifyAll</code>，<code>notify</code>能具体指定唤醒一个实例吗？为什么是随机唤醒，底层是如何实现的？</li><li>讲一下<code>ClassLoader</code>，jre下的jar包是由什么加载的？</li><li>讲一下<code>Exception</code>和<code>Error</code></li><li>用户线程和守护线程的区别和使用场景？守护线程能否访问数据库？</li><li>TCP三次握手。为什么不能只用两次和四次？TCP四次挥手</li><li>HTTP和HTTPS的区别。给你一个网站，考虑使用HTTP还是HTTPS？</li><li>讲一下你理解的MVC，SpringMVC的处理流程，拦截请求是怎么实现的？</li><li>讲一下IOC和AOP编程</li><li>什么时候用索引？什么时候不用？</li><li>分布式事务如何保证一致性？</li><li><code>HashMap</code>的实现原理？<code>get</code>和<code>put</code></li></ol><h2 id="京东数科一面"><a href="#京东数科一面" class="headerlink" title="京东数科一面"></a>京东数科一面</h2><ol><li>常见的集合<code>collection</code>和<code>collections</code>的区别</li><li><code>list</code>和<code>set</code>的区别，以及各自的子类</li><li><code>HashMap</code>的原理</li><li><code>ConcurrentHashMap</code>的原理</li><li><code>start</code>和<code>run</code>的区别，线程状态等</li><li>线程池工作原理，核心参数，阻塞队列；常见的两种阻塞队列有何不同？</li></ol><h2 id="字节跳动后端实习一二面"><a href="#字节跳动后端实习一二面" class="headerlink" title="字节跳动后端实习一二面"></a>字节跳动后端实习一二面</h2><h3 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h3><ol><li>数据库隔离级别</li><li>数据库事务特性</li><li><code>select</code>、<code>epoll</code>、<code>poll</code></li><li>Java运行时内存区域</li><li>避免死锁的方式</li><li>手撕代码：<font color="red">最长上升子序列的个数</font></li></ol><h3 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h3><ol><li>手撕代码：最长的不包含重复字符的子串长度</li><li>DNS解析过程</li></ol><h2 id="美团Java实习一面"><a href="#美团Java实习一面" class="headerlink" title="美团Java实习一面"></a>美团Java实习一面</h2><ol><li><code>Integer</code>缓冲池，<code>long</code>是否有？</li><li><code>HashMap</code>底层实现</li><li><code>HashMap</code>线程安全吗？解释一下发生链表死循环？</li><li><code>Map</code>下有哪些线程安全？</li><li><code>ConcurrentHashMap</code>的实现，<code>HashTable</code>和<code>HashMap</code>的区别</li><li><code>ConcurrentHashMap</code>的<code>size</code>操作是怎么做的？需要加锁吗？</li><li>Java的内存回收，什么时候会内存回收？</li><li>GC算法</li><li>Java垃圾回收器</li><li>MySQL的引擎</li><li>事务的概念</li></ol><h2 id="字节跳动测试开发实习一二面"><a href="#字节跳动测试开发实习一二面" class="headerlink" title="字节跳动测试开发实习一二面"></a>字节跳动测试开发实习一二面</h2><ol><li>Git常用命令，有冲突时会怎么做？</li><li>UDP和TCP的区别？</li><li>进程和线程</li><li>手撕代码：链表判断入环点</li><li>手撕代码：翻转句子中的单词</li><li>Java的<code>int</code>的取值范围</li><li>Java的内存模型</li><li><code>Student s = new Student()</code>在内存中都经历了什么</li><li><code>get</code>和<code>post</code>请求</li><li>输入一个url到显示网页的过程</li><li>编程题：字符串中的英文单词逆序，可能包含N个</li><li>编程题：数组重排，将当前数字成为后面第一个比自己打的数字，如果没有填-1，要求最优的时间复杂度</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经历</title>
      <link href="/2020/03/03/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
      <url>/2020/03/03/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p><strong>以下是秋招的面试经历。</strong></p><h2 id="微博"><a href="#微博" class="headerlink" title="微博"></a>微博</h2><ol><li>Activity启动模式的singleInstance是怎么样的？使用场景</li><li>Android中数据存储的方式</li><li><p>Android中进程通信的方式</p><ul><li>ContentProvider是一个<strong>进程间数据共享</strong>的方式</li></ul></li><li><p>多线程开启的方式</p></li><li>线程池的了解</li><li>Android中有哪些动画</li><li>margin和padding的区别</li><li>了解哪些设计模式</li><li>单例模式的几种形式</li><li>枚举和饿汉模式的区别</li><li>双重检验模式中，<code>volatile</code>的作用？不加会怎么样</li><li>自己讲讲计算机网络</li><li>自己讲讲操作系统</li><li><code>synchronized</code>和<code>Lock</code>锁有什么区别</li><li>自己讲讲数据结构</li><li>静态内部类和非静态内部类的区别</li><li>说一说Java的集合</li><li>遍历List，可能会报的异常</li><li>IO流读写文件有了解吗</li></ol><h2 id="海康威视"><a href="#海康威视" class="headerlink" title="海康威视"></a>海康威视</h2><ol><li>Activity生命周期中，什么情况下会<code>onPause()</code>之后继续调用<code>onResume()</code>，而不是调用<code>onStop()</code>方法</li><li>ConstraintLayout与RelativeLayout的区别，说一说ConstraintLayout的写法</li><li>Service的启动方式</li><li><code>startService()</code>还是<code>bindService()</code>的启动方式的生命周期更长</li><li>广播的两种注册方式以及区别</li></ol><h2 id="中信银行信用卡中心"><a href="#中信银行信用卡中心" class="headerlink" title="中信银行信用卡中心"></a>中信银行信用卡中心</h2><ol><li>Github主页</li><li>数据库MySQL的底层引擎</li><li>安卓端Java与后端Java有啥区别</li><li>快速排序的原理</li><li>使用$O(n)$的时间复杂度，搭配快速排序的原理，找出第K大的元素</li><li>熟悉设计模式</li><li>机器学习相关的</li></ol><h2 id="交行软开"><a href="#交行软开" class="headerlink" title="交行软开"></a>交行软开</h2><ol><li><p>JVM有了解吗？内存泄漏与内存溢出的区别</p><ul><li><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；</p></li><li><p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。</p></li></ul><hr><p> 内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。</p></li><li><p>垃圾回收机制，算法</p></li><li>数据库的主键和索引的区别</li><li><p>了解哪些设计模式？一个计算器，有加减乘除的功能，去计算最终的值，要用到哪中设计模式合适？</p><ul><li>单例模式</li><li>观察/订阅模式</li><li>建造者模式</li><li><p>适配器模式</p><p>我认为可以使用到简单工厂模式。</p></li></ul><hr><p> 经过查找网上类容，发现是使用<strong>解释器模式</strong>。不得不说这个问的模式相对较冷门。</p></li><li><p>熟悉哪些Linux命令</p><ul><li><code>ls</code>：列举出当前工作目录的内容</li><li><code>mkdir</code>：创建一个新的目录</li><li><code>pwd</code>：显示当前工作目录</li><li><code>cd</code>：切换文件路径</li><li><code>rm</code>：删除给定的文件</li><li><code>cp</code>：复制文件</li><li><code>mv</code>：移动文件</li><li><code>cat</code>：在标准输出上查看文件内容</li><li><code>find</code>：在给定位置搜寻与条件匹配的文件</li><li><code>tar</code>：创建、查看和提取tar格式的压缩文件</li><li><code>help</code>：在终端列出所有可用的命令</li><li><code>exit</code>：结束当前的终端会话</li><li><code>ping</code>：通过发送数据报ping远程主机（服务器）</li><li><code>su</code>：切换不同的用户</li><li><code>shutdown</code>：用于关闭计算机</li></ul></li><li><p>JVM的内存区域</p></li><li>堆是用来存储什么的</li><li>堆的大小如何改变</li></ol><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>ArrayBlockingQueue</li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li><p>合并两个有序数组的序列</p><p> Leetcode 21.</p></li></ol><h2 id="永辉超市"><a href="#永辉超市" class="headerlink" title="永辉超市"></a>永辉超市</h2><ol><li>JVM内存区域</li><li>HashMap的实现原理</li><li>红黑树有了解吗</li></ol><h2 id="浙商银行"><a href="#浙商银行" class="headerlink" title="浙商银行"></a>浙商银行</h2><ol><li>安卓端与后端怎么交互的</li><li><p>后端交互数据的时候，是怎么加密的？是明文传输吗？没有用到Https吗？</p><ul><li>通信请求使用https</li><li>对请求参数进行签名，防止数据被踹改</li><li>对请求参数以及响应进行加密解密处理</li><li>APP中使用ssl pinning防止抓包操作</li></ul></li></ol><h2 id="万物心选"><a href="#万物心选" class="headerlink" title="万物心选"></a>万物心选</h2><ol><li>了解红黑树吗</li><li>了解动态规划吗</li><li>OkHttp与Retrofit的原理</li><li>HttpConcention的原理</li><li>Handler的原理</li><li>ThreadLocal了解吗</li><li>RecyclerView与ListView的区别</li></ol><h2 id="格力"><a href="#格力" class="headerlink" title="格力"></a>格力</h2><ol><li>MVP架构的理解</li><li>设计数据库</li></ol><h2 id="金山WPS"><a href="#金山WPS" class="headerlink" title="金山WPS"></a>金山WPS</h2><ol><li><p>怎么判断图的两个节点是否是连通的</p><ul><li>深度优先遍历：从根开始深度优先遍历，设置一个全局变量count去记录。如果最终count的值与顶点的数量是相同的，则是连通图，反之则不是。</li><li>广度优先遍历</li><li>并查集</li></ul></li><li><p>介绍一下TCP三次握手</p></li><li><p>类加载的过程，了解双亲委派模型吗</p><p> 类加载的全过程分为：「<strong>加载、验证、准备、解析和初始化</strong>」这5个阶段。</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/ilxgTsyHKdXJ4a3.png" alt="类加载的全过程"></p><p> 类加载器的作用是将编译器编译生成的二进制.class文件加载到内存中，进而转化成虚拟机中的类。Java内置了三种类加载器：</p><ul><li>启动类加载器 Bootstrap Class Loader：负责Java核心类</li><li>扩展类加载器 Extensions Class Loader：负责加载<code>\jre\lib\ext</code>目录下的JAR包</li><li><p>系统类加载器 System Class Loader：负责加载所有应用程序级别的类到JVM</p><p>除此之外，还可以自定义类加载器。</p></li></ul><hr><p> <strong>双亲委派模型</strong>的工作过程如下：</p><p> 当类加载器收到类的加载请求时，首先不会自己去加载这个类，而是会把这个请求委派给父类加载器去完成。每个层次的类加载器都是这样的，所有的加载请求都会传送到顶层的启动类加载器，只有父类加载器无法完成时，才会交给子加载器去完成。</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/PWeOThwsN7BSRck.png" alt="双亲委派模型的过程"></p><p> 双亲委派模型遵循三个原则：</p><ul><li>「委托性原则」：当子类加载器收到类的加载请求时，会将加载请求向上委托给父类加载器。</li><li>「可见性原则」：允许子类加载器查看父类加载器加载的所有类，但是父类加载器不能查看子类加载器加载的类。</li><li>「唯一性原则」：双亲委派的机制保证了Java类的唯一性。比如写了一个和JRE核心类同名的Object类，这时候双亲委派机制就会发挥作用了，避免自定义的类覆盖核心类。它会首先将加载类的请求，委托给Application ClassLoader去加载，再被其委托给Extension ClassLoader去加载，再被委托给BootStrap ClassLoader。因为启动类加载器发现已经加载了核心类Object类，就不会再去加载自定义的Object类。</li></ul></li><li><p>能举例子说明一下多态吗</p><p> Java的多态主要是指在运行时才知道调用哪个方法而不是编译时就能得知的一种机制。</p><p> 方法的<strong>重载</strong>和<strong>重写</strong>就是典型的Java多态性的不同变现。重写是父类与子类的多态表现，重载是一个类的多态的表现。</p></li><li><p>泛型的类型擦除</p><p> 如果一个方法接收<code>List&lt;Object&gt;</code>作为形参，而如果传递<code>List&lt;String&gt;</code>进去作为实参，是无法通过编译的，尽管String是Object的子类。</p></li></ol><h2 id="卓盟科技"><a href="#卓盟科技" class="headerlink" title="卓盟科技"></a>卓盟科技</h2><h2 id="农业银行数据中心"><a href="#农业银行数据中心" class="headerlink" title="农业银行数据中心"></a>农业银行数据中心</h2><p>线下面</p><h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li>问项目</li><li>手写一个数据结构</li></ol><h2 id="多益网络"><a href="#多益网络" class="headerlink" title="多益网络"></a>多益网络</h2><ol><li>自我介绍</li><li><p>介绍自己的项目，项目中用到了谷歌的ZXing库，如果自己实现这个扫描二维码的框架，因为外界条件不清晰，如何改进</p><p> 面试官给提供的思路是，由于光线或者手机摄像头对准的位置等外界因素，所以会导致二维码模糊不清无法读取，那么改进方法就是精准地显示二维码的位置。常用的技术是界面上会出现一个正方形的框，然后当摄像头识别到二维码后，会放大到二维码那里，聚焦。</p></li><li><p>TCP和UDP的区别</p></li><li><p>现在视频是用TCP还是UDP？如果UDP发送数据丢包，怎么解决这个问题</p><p> UDP丢包率高的原因有：</p><ul><li>接收端处理时间过长导致丢包</li><li>发送的包巨大丢包</li><li>发送的包较大，超过接受者缓存导致丢包</li><li><p>发送的包频率太快</p><p>解决方法有：</p></li><li><p>控制报文大小</p></li><li>增加系统发送或者接受缓冲区的大小</li><li>增加应答机制，处理完一个包后，再继续发包</li><li>在应用层实现丢包重发机制和超时机制，确保数据包不丢失。</li></ul></li><li><p>http和https的区别</p></li><li><p>HashSet了解吗，介绍一下原理是如何实现的</p><p> HashSet实现自set接口，set集合中元素无序且不能重复；</p><p> HashSet底层是基于HashMap实现的，当你new一个HashSet时，实际上是new一个map，执行add方法时，实际上是调用map的put方法；将key-value放入HashMap中，根据key的hashCode返回值决定存储位置，如果hash相同，则存储位置相同。如果两个key的equals比较返回true，那么新添加的value就会覆盖原有的value，key不会覆盖。如果向HashSet中添加一个已经存在的元素，则不会覆盖原有的集合元素。</p></li><li><p>HashMap原理是如何实现的，是线程安全的吗？如果让你来写，怎么实现线程安全</p></li><li><p>RecyclerView怎么实现树形结构TreeView</p><p> 需要构造节点类Node，含有的属性包括：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String id;  <span class="comment">// 节点的唯一标识</span></span><br><span class="line"><span class="keyword">private</span> String pid; <span class="comment">// 当前节点的父节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;  <span class="comment">// 所在层级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> expand; <span class="comment">// 当前是否是展开的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> choosed;    <span class="comment">// 选中的状态</span></span><br><span class="line"><span class="keyword">private</span> String showText;    <span class="comment">// 展示的文本</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Node&gt; childs = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 子节点</span></span><br></pre></td></tr></table></figure></li><li><p>RecyclerView的item复用怎么实现</p></li><li>AsyncTask的底层是如何实现的（原理）</li><li>与Handler之间的区别，Handler消息传递机制</li><li>常用的设计模式怎么写，单例模式怎么写，工厂模式，观察者模式</li><li><p>Retrofit和OkHttp之间的区别</p><p>Retrofit底层对网络的访问默认是基于OkHttp，不过Retrofit非常适合于Restful url风格的请求，更多使用注解的方式提供功能，下面这个网络请求流程图，可以更直观的理解OkHttp和Retrofit的关系。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/1IBnhOsxvdTclg6.png" alt="Retrofit底层"></p><p>网络请求：App发起网络请求，Retrofit通过注解配置请求参数、Header、BaseUrl之后，通过OkHttp发送网络请求给服务器；</p><p>服务器响应：服务器返回响应数据，OkHttp将数据传递给Retrofit，再把数据直接传递给应用，界面刷新反馈结果给用户；</p><ul><li>Retrofit主要负责应用层面的封装，主要方便使用，比如请求参数、响应数据的处理，错误处理等等；</li><li>OkHttp主要负责socket部分的优化，比如多路复用、buffer缓存、数据压缩等；</li></ul><p>网上一般推荐RxJava + Retrofit + OkHttp框架，Retrofit负责请求的数据和请求的结果，使用接口的方式呈现，OkHttp负责请求的过程，RxJava负责异步，各种线程之间切换。</p></li><li><p>OkHttp的实现原理</p></li><li>Service的两种启动方式，两种方式之间的区别</li><li>广播的类型和注册方式，静态注册和动态注册之间的区别</li><li>Glide的原理，缓存机制</li><li>Lru算法是如何实现的</li><li>如何判断一个单向链表是否有环，并返回环的长度</li></ol><h2 id="墨迹天气"><a href="#墨迹天气" class="headerlink" title="墨迹天气"></a>墨迹天气</h2><ol><li>自己说项目经历，说一下在项目中遇到的难点并且怎么解决的</li><li>职业规划是什么，为什么选择做移动端</li><li>自定义View的流程</li><li><code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code></li><li><p>事件分发机制有了解吗</p><p> Android事件分发总是遵循Activity =&gt; ViewGroup =&gt; View的传递顺序；</p><p> 三个与事件分发机制有关的方法：</p><ul><li><code>dispatchTouchEvent()</code>：事件分发</li><li><code>onTouchEvent()</code>：事件处理</li><li><code>onInterceptTouchEvent()</code>：事件拦截</li></ul><hr><p> <code>dispatchTouchEvent()</code>是负责事件分发的。当点击事件发生后，事件首先会传递给当前的Activity，然后会调用Activity的<code>dispatchTouchEvent()</code>方法。</p><p> <code>onTouch()</code>执行总优先于<code>onClick()</code></p></li><li><p>点击一个Button，发起网络请求，将获取到的数据展示到页面上，怎么优化它的速度/流程？</p><p> 从点击按钮出现点击时间，开启子线程发起网络请求，这是一个优化点。</p><p> 请求到的数据如何显示在页面上，这是一个优化点，例如三级缓存机制。</p></li><li><p>Handler的消息传递机制</p></li><li><p>MessageQueue中是以什么样的策略去存储消息的</p><p> MessageQueue实际上是以单链表的形式存储Handler发送过来的消息，有利于插入、删除的操作，主要有两个操作：</p><ul><li>通过<code>enqueueMessage(Message msg, long when)</code>向队列插入一个消息</li><li>通过<code>next()</code>从无限循环队列中取出消息，并从消息队列中删除。</li></ul></li><li><p>进程调度策略</p></li><li><p>内存泄露有了解吗？怎么样去处理内存泄漏</p><blockquote><p>内存泄漏：程序申请的内存空间，在使用完毕后未释放，一直占据内存单元。</p></blockquote><p>我们创建了一个对象，会在<strong>堆内存</strong>中给这个对象申请一块内存空间，假如调用了一次或者几次，之后就没有再调用，但仍然占据着内存。</p><p>Java可以使用垃圾回收机制。</p></li><li><p>三级缓存机制</p></li><li>有了解Glide框架中的最少未使用机制Lru算法吗？</li><li>怎么设计一个数据结构去实现Lru算法</li><li><p>RxJava里的操作符，如果是进行多个网络请求，用哪个操作符</p><p>RxJava操作符<code>zip()</code>：使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。</p><blockquote><p>通过<code>Observable.zip()</code>方法把多个Observable组合成新的Observable。</p></blockquote></li><li><p>了解哪些设计模式</p></li><li>介绍一下快速排序算法，还了解哪些排序算法</li></ol><h2 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h2><ol><li>ArrayList和LinkedList的区别，它们哪个插入元素是可重复的和不可重复的，哪个是线程安全的</li><li>数据结构中有一个哈希表HashMap，它是不是线程安全的，怎么变成线程安全的</li><li><p>List中存入数据，例如int类型的数据，是直接存入int类型吗？</p><p> 不是，因为存在自动装箱与拆箱，所以是存入它们的引用类型。</p></li><li><p>最近看过什么技术书，说说MVC、MVP和MVVM</p></li><li>图片框架的缓存机制。</li><li>Glide如果加载9张图片，那么是从上往下加载吗？</li><li>除了Http连接和TCP连接之外，还有什么连接</li><li><p>RxJava和Retrofit用到的一些基本的方法</p><p> RxJava的三个概念：</p><ul><li>Observable：被观察者（主题Subject）</li><li>Observer/Subscriber：观察者</li><li><p>Subscribe：订阅</p><blockquote><p>Observable和Observer通过subscribe()方法实现订阅关系</p></blockquote><p>使用的一种简单方法：</p></li></ul><ol><li><p>创建被观察者Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">getObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObserableEmitter e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 只需要三个方法onNext | onError | onCompleted</span></span><br><span class="line">            e.onNext(<span class="string">""</span>);</span><br><span class="line">            e.onNext(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            e.onComplete();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.onError();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建观察者Observer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observer&lt;String&gt; <span class="title">getObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 发生错误时调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 数据接收完成时调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 移除订阅关系</span></span><br><span class="line">            <span class="comment">// d.dispose();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否取消订阅关系</span></span><br><span class="line">            <span class="comment">// d.isDisposed();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 正常接收数据时调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable = getObservable();</span><br><span class="line">Observer&lt;String&gt; observer = getObserver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联观察者和被观察者 -&gt; 订阅</span></span><br><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></li></ol><hr><p> Retrofit的使用方法：</p><ol><li><p>创建接口，设置请求类型和参数，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"userInfo/login"</span>)</span><br><span class="line"><span class="function">Call <span class="title">login</span><span class="params">(@Query(<span class="string">"username"</span>)</span> String username, @<span class="title">Query</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建Retrofit对象，设置数据解析器等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BASE_URL).addConverterFactory(GsonConverterFactory.create()).build();</span><br></pre></td></tr></table></figure></li><li><p>生成接口对象，调用接口方法获取Call对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">My my = retrofit.create(My.class);</span><br><span class="line">Call call = my.login(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>TCP的三次握手</p></li><li><p>了解什么Jetpack组件吗</p><p>LifeCycle、ViewModel、LiveData、Paging、Room、Navigation、DataBinding等</p></li><li><p>了解Comparable接口吗</p><p>Comparable &amp; Comparator 接口都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序。</p></li><li><p><code>git merge</code>和<code>git rebase</code>的区别</p></li><li><p>使用了哪种Git图形界面客户端</p><p>SourceTree</p></li></ol><hr><p>以下是春招的面试经历。</p><h2 id="华为海思"><a href="#华为海思" class="headerlink" title="华为海思"></a>华为海思</h2><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><ol><li><p>算法题：</p><p> 输入一维数组array和n，找出和值为 n 的任意两个元素。例如：</p><p> array = [2, 3, 1, 10, 4, 30]</p><p> n = 31</p><p> 则结果应该输出1, 30 顺序不重要</p><p> 如果有多个满足条件的，返回任意一对即可。要求空间复杂度为 O(1)。</p></li><li><p>自我介绍</p></li><li><p>公司负责了哪些工作？怎么重构的？</p></li><li><p>MVP和MVC的区别？Model层的作用呢？</p></li><li><p>UI界面有哪些布局？</p></li><li><p>约束布局与相对布局有什么不同？</p></li><li><p>线性布局：如果有两个控件，一个宽度固定，一个宽度不固定，怎么让它们横向充满整个父布局？</p></li><li><p>RecyclerView有100个item，怎么让它们显示出来还不会内存泄漏？怎么直接跳转到第53个item？</p><p> 分页显示。</p><p> 第一种：「<strong>能够实现指定位置处于屏幕顶部，但是不具有平滑滚动的视觉效果</strong>」。即使用<code>scrollToPosition()</code>的方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (position != -<span class="number">1</span>) &#123;</span><br><span class="line">    mRecycleview.scrollToPosition(position);</span><br><span class="line">    LinearLayoutManager mLayoutManager = (LinearLayoutManager) mRecycleview.getLayoutManager();</span><br><span class="line">    mLayoutManager.scrollToPositionWithOffset(position, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二种：「<strong>能够实现指定位置处于屏幕顶部，具有平滑滚动视觉的效果</strong>」。</p><ol><li>如果跳转位置在第一个可见位置之前，就用<code>smoothScrollToPosition()</code>方法就可以直接跳转；</li><li>如果跳转位置在第一个可见项之后，最后一个可见项之前，就需要用<code>smoothScrollBy</code>来滑动到指定位置；</li><li>如果要跳转的位置在最后可见项之后，则先调用<code>smoothScrollToPosition()</code>将跳转的位置滚动到可见位置，再<code>addOnScrollListener()</code>里通过<code>onScrollStateChanged()</code>控制，调用<code>smoothMoveToPosition()</code>再次执行判断。</li></ol></li><li><p>Handler的消息传递机制</p></li><li><p>Activity的生命周期？启动方式？</p></li><li><p>从Activity A跳转到Activity B，两个Activity的生命周期？</p></li><li><p>Service的启动方式？</p></li><li><p>Broadcast的相关知识点？</p></li><li><p>Java有哪几种引用？</p></li><li><p>接触过哪些容器类？HashMap的原理有了解吗？如果Hash值计算相同，会发生哈希碰撞吗？怎么解决？</p></li><li><p>泛型的原理与使用</p></li><li><p>http与https的区别</p></li><li><p>https是怎么加密的</p></li><li><p>死锁是什么？死锁的条件</p></li><li><p>操作系统的进程调度策略有哪些？</p><p>FCFS（先来先服务）、优先级、时间片轮转、多级反馈</p></li><li><p>数据库的索引，主键与事务</p></li><li><p>数据库的<code>join()</code>方法</p><p>数据库中的<code>join()</code>方法是连接，主要作用是根据两个或者多个表中的列之间的关系，获取存在于不同表中的数据，有全连接、内连接、外连接等。</p></li></ol><h2 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a>微信读书</h2><h2 id="腾讯教育"><a href="#腾讯教育" class="headerlink" title="腾讯教育"></a>腾讯教育</h2><ol><li><p>自我介绍</p></li><li><p>实习经历简介，负责了哪些？</p></li><li><p>MVP模式</p><p> 模型层（Model）：主要是获取数据功能，业务逻辑和实体模型。</p><p> 视图层（View）：对应于Activity或Fragment，负责视图的部分展示和业务逻辑用户交互。</p><p> 控制层（Presenter）：负责完成View层与Model层之间的交互，通过Presenter获取Model的数据返回给View，使得View与Model之间没有耦合。</p></li><li><p>网络请求框架有了解过内部的原理吗？</p></li><li><p>主线程怎么把数据交给子线程？Handler和AsyncTask？</p></li><li><p>除了约束布局，还有什么线性布局还是相对布局？它们之间的区别是什么？</p><p> LinearLayout是将多个View水平或者垂直排列；RelativeLayout可以通过确定两个或多个组件的相对位置来摆放组件。</p></li><li><p>有没有遇到过一个布局中嵌套的布局非常多？会出现什么情况？</p><p> Android界面的布局太复杂，嵌套层次过深，会使得整个界面的测量、布局和绘制变得更复杂，对性能会造成影响。</p></li><li><p>有没有遇到过界面卡顿的情况吗？什么情况会造成界面卡顿？</p></li><li><p>View的绘制流程？执行的顺序？</p></li><li><p>有没有了解过一些事件传递机制？</p></li><li><p>Java虚拟机有哪几种内存？哪些内存是独立的，哪些是共享的？方法区分为哪些？</p><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>运行时常量池</strong>是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</p></li><li><p>HashMap的原理？<code>put</code>方法发生冲突会怎么样？</p></li><li><p>垃圾回收机制？怎么判断什么时候会被回收？</p></li><li><p>https和http的区别？</p></li><li><p>Socket有了解吗？</p><p><strong>Socket相关面试题</strong>：</p><p>Socket是对TCP/IP协议簇的一种封装，是应用层与TCP/IP协议簇通信的中间软件抽象层。</p><p>TCP和UDP的区别：</p><ol><li>TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；UDP提供无连接的传输，通信前不需要建立连接；</li><li>TCP提供可靠的传输（有序、无差错、不丢失、不重复）；UDP提供不可靠的传输；</li><li>TCP是面向字节流的传输，所以能将信息分隔成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销；</li><li>TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和流量控制机制</li></ol></li><li><p>长连接和短连接的区别？HTTPS是长连接吗？</p><p>在HTTP/1.0中，默认使用短连接。就是浏览器和服务器每进行一次HTTP操作，都会建立一次连接，任务结束后就会断开连接。</p><p>在HTTP/1.1中。默认使用长连接。使用长连接的情况下，当某个网页打开完毕之后，客户端和服务器之间的TCP连接不会关闭，如果客户端再次访问该服务器上的网页，会使用上一次已经建立的连接。但是长连接不是永久的连接，它有一个保持时间</p></li><li><p>Activity生命周期？切换横竖屏的生命周期？</p><p>切换横竖屏的生命周期：</p><p><code>onPause</code>$\rightarrow$ <code>onSaveInstanceState</code>$\rightarrow$ <code>onStop</code>$\rightarrow$ <code>onDestory</code>$\rightarrow$ <code>onCreate</code>$\rightarrow$ <code>onStart</code>$\rightarrow$ <code>onRestoreInstanceState</code>$\rightarrow$ <code>onResume</code></p></li><li><p>进程和线程的区别是什么？</p></li><li><p>介绍下快排，时间复杂度？</p></li><li><p>如何快速找到一个单链表的中间节点？</p><p>快慢指针法。当快指针遍历完整个链表后，慢指针才遍历到一半的链表，则正好是单链表中间节点的位置。</p></li></ol><h2 id="阿里飞猪"><a href="#阿里飞猪" class="headerlink" title="阿里飞猪"></a>阿里飞猪</h2><ol><li><p>自我介绍</p></li><li><p>问项目相关的。第一个项目，一个做还是团队？练手的还是可以商用的？你做了其中的哪几个部分？给我讲一下，然后看一下代码的风格；</p></li><li><p>第二项目，这个其中的文章是通过url打开webview实现的吗？介绍其中用到的框架？为什么要用这些网络框架，不用自带的网络请求方式？网络框架这么多，为什么选用这个框架？</p><p> Retrofit是一个封装了Http请求的框架，底层的网络请求也是使用OkHttp实现的。使用它主要是能与RxJava配合使用。</p><p> 它的原理大致是：</p><blockquote><ol><li>通过建造者模式构建一个Retrofit实例，配置baseUrl，convertfactory（用来将请求的结果转化为特定的对象，例如GsonConverterFactory）等；</li><li>通过Retrofit对象的create(Class<T> service)方法返回一个Service的动态代理对象，在调用service的方法时去调用动态代理的invoke方法；</li><li>invoke方法会把method进行解析，解析我们在接口中配置的各种注解，最后构造成ServiceMethod对象，并将结果缓存起来，下次调用就不用再解析了。ServiceMethod对象可以生成Request对象，将对象注入到OkHttpCall中，然后通过callAdapter转化为用户希望得到的返回对象，默认直接返回Call对象。</li><li>得到Call对象之后，再调用execute或者enqueue方法，前者是同步请求，后者异步请求，这个方法里面就封装了OkHttp的方法。</li></ol></blockquote></li><li><p>Glide框架你了解多少，大概是怎么实现的？缓存机制有几级缓存？</p><p> Glide的缓存机制分为2种缓存，一种是内存缓存，一种是磁盘内存。</p><p> 用内存缓存的原因是：防止应用重复将图片读入到内存中，造成内存资源浪费；</p><p> 用内存缓存的原因是：防止应用重复的从网络或者其它地方下载和读取数据；</p><p> <strong>缓存机制中有三级缓存原理</strong>：</p><p> 读取一张图片的时候，获取顺序：Lru算法缓存$\rightarrow$ 弱引用缓存$\rightarrow$ 磁盘缓存（如果设置了）。</p><blockquote><p>当想要加载某些图片的时候，先去LruCache中寻找图片，如果LruCache中有图片，就直接取出来用，并将图片放入到WeakReference中，如果LruCache中没有，则去WeakReference中寻找，如果WeakReference中有，就从WeakReference中取出图片使用，如果WeakReference中没有图片，那么就从磁盘缓存/网络中加载图片。</p></blockquote></li><li><p>如果有一张100M的图片，直接打开肯定会造成OOM，那么要怎么实现才能打开？</p><p> 得将该图片进行压缩，可以使用<code>BitmapFactory</code>这个类。首先，获取远图片的大小（这里是100M），然后获取要显示这个图片的控件比如<code>ImageView</code>的大小，然后可以计算出图片和控件的比例，根据这一比例，将图片压缩为适合显示的大小。</p></li><li><p>第三个项目，介绍一个。其中的生成二维码是在端生成吗？</p></li><li><p>Activity的生命周期。假设一个场景，用户按Home键回到桌面后，在后台久了之后点击icon打开这个应用，这个Activity已经被杀掉，那么打开应用后怎么重新恢复到杀掉前的Activity？</p><p> Android系统的回收机制提供了<code>onSaveInstanceState(Bundle outState)</code>和<code>onRestoreInstanceState(Bundle savedInstanceState)</code>方法用于保存和恢复数据。</p><p> 这两个方法主要会在Activty被系统回收，又重新创建了一个新的Activity的时候调用，可能是以下几种情况：</p><ol><li>当用户按下HOME键时</li><li>按下电源锁屏键</li><li>从最近应用中运行其它程序</li><li>从当前Activity启动一个新的Activity</li><li><p>屏幕方向切换（竖屏切横屏或者横屏切竖屏）</p><p>异常生命周期大概如下：</p></li><li><p>当Activity被系统自动回收时，<code>onPause()$$\rightarrow$$onSaveInstanceState()$$\rightarrow$$onStop()$$\rightarrow$$onDestory()$$\rightarrow$$onCreate()$$\rightarrow$$onStart()$$\rightarrow$$onRestoreInstanceState()$$\rightarrow$$onResume()</code></p></li><li>当Activity是用户主动销毁，比如按下back键或者调用<code>finish()</code>方法的话，就不会在<code>onPause()</code>和<code>onStop()</code>方法中调用<code>onSaveInstanceState()</code>方法，所以就是<code>onCreate()$$\rightarrow$$onStart()$$\rightarrow$$onRestoreInstanceState()</code>方法重新创建Activty，其中恢复数据是用<code>onRestoreInstanceState()</code>方法中的<code>Bundle</code>参数恢复。</li></ol></li><li><p>关于RecyclerView，假设一个场景，如果item有不同的类别从而要显示不同的样式，怎么显示？</p><p> <code>RecyclerViewAdapter</code>要继承<code>RecyclerView.Adapter&lt;ViewHolder&gt;</code>这个类，重写三个方法：<code>onCreateViewHolder(ViewGroup parent, int viewType)</code>、<code>onBindViewHolder(ViewHolder holder, int position)</code>和<code>getItemCount()</code>这三个方法，其中的<code>onCreateViewHolder</code>中可以根据<code>viewType</code>的类型去加载不同的布局。</p></li><li><p>有没有写过自定义View？</p><p> 自定义View要实现三个方法，按照执行顺序依次是<code>onMeasure()$$\rightarrow$$onLayout()$$\rightarrow$$onDraw()</code>。其中，<code>onDraw()</code>方法必须要重写，因为这个方法是用来绘制View图像的。如果要改变View的大小，就重写<code>onMeasure()</code>方法；如果要改变View在父控件中的位置，就要重写<code>onLayout()</code>方法。</p></li><li><p><code>public</code>、<code>protected</code>和<code>private</code>的区别</p><p><code>public</code>可以被其它任何类访问；<code>private</code>只能自己访问和自己内部的成员访问；<code>protected</code>就是自身、子类和同一个包中的类都可以访问；默认就是同一个包中的类都可以访问。</p></li><li><p>接口和抽象类的异同？让一个类不能被其它类继承怎么做？</p><ul><li>接口中的方法都是抽象的，抽象类中可以有抽象方法也可以有非抽象方法</li><li>类可以实现多个接口，但只能继承一个抽象类</li><li>Java接口声明的变量默认都是<code>final</code>的</li><li>如果一个类不实现抽象类或者接口中的全部方法，那么它必须也是抽象的；反之，它必须实现所有方法</li><li>接口和抽象类都不能实例化</li></ul></li><li><p>有用过final修饰吗？final能修饰类吗？</p><ul><li><code>final</code>修饰类表示此类不能被继承，不能拥有自己的子类</li><li><code>final</code>修饰方法表示此方法不能重写</li><li><code>final</code>修饰变量表示一旦定义并在首次为其显示初始化之后，<code>final</code>修饰的变量值就不可被改变</li></ul></li><li><p>介绍一下Java的引用</p></li></ol><h2 id="三七互娱"><a href="#三七互娱" class="headerlink" title="三七互娱"></a>三七互娱</h2><p>其实我的毕业时间并不满足三七互娱的春招要求，但是还是收到了三七互娱的笔试机会。</p><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><ol><li><p>一个n个节点的二叉树，每个节点要么没有子节点要么两个子节点，问树的最大高度？</p><p> 这里容易混淆高度和深度的区别，不过不影响，因为<strong>树的高度和深度是相等的</strong>。高度是从下往上数，深度是从上往下数。例如：</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/LQc8BwO6rDvhHd7.png" alt=""></p><p> 这里G的高度为3，B的深度为2。所以这里答案应该是$(n+1)/2$。</p></li><li><p>android判断手机电池状态级别的广播action？</p><p> <code>ACTION_BATTERY_CHANGED</code></p></li><li><p>以下是<font color="red">私有IP地址</font>的是？</p><p> 私有IP地址的范围：</p><ul><li>A类私有IP地址：<strong>10.0.0.0~10.255.255.255</strong></li><li>B类私有IP地址：<strong>172.16.0.0~172.31.255.255</strong></li><li>C类私有IP地址：<strong>192.168.0.0~192.168.255.255</strong></li></ul></li><li><p>软件测试的目的？</p><p> 证明软件存在缺陷，使软件中的缺陷降低到一定程度</p></li><li><p><font color="red">Arraylist与linkedlist查找、添加删除区别</font>？</p><p> ArrayList的实现是通过数组，LinkedList的实现是通过链表，ArrayList适用于查找，LinkedList适合增删改。</p></li><li><p><font color="red">HashMap与HashTable键值是否为空</font>？</p><p> HashMap对象的key和value均可为<code>null</code>，HashTable对象的key和value均不可为<code>null</code>。HashTable是Java中的遗留类，目前不太实用。而HashMap的设计者认为<code>null</code>作为key和value是有实际意义的，所以允许其为<code>null</code>。</p></li><li><p>activity的分类是什么？</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/iDSIJcsvXlwp2oK.png" alt="Activity的分类"></p></li><li><p>数据库删除test表的语句？</p><p> 这道选择的选项中有<code>drop</code>和<code>delete</code>和<code>truncate</code>。通过查询，发现：</p><ul><li><code>drop</code>：是删除表test，并释放空间，将test完全删除</li><li><code>truncate</code>：删除表test中的内容，并释放空间，但是不删除表的定义，表结构还有，所以test表还在，只是内容为空</li><li><code>delete</code>：可以删除指定数据，也可以删除整个表。如果删除表也是仅删除表test内的所有内容，保留表的定义，也不释放空间</li></ul></li><li><font color="red">针对二叉查找树增加、删除、查找的最坏时间复杂度</font></li><li><p><font color="red">jvm垃圾回收器</font>有哪些？</p><p>常见的垃圾回收器分为3类：</p><ol><li>新生代垃圾回收器：Serial、ParNew、Parallel Scavenge</li><li>新生代和老年代垃圾回收器：Serial Old、Parallel Old、CMS</li><li>老年代垃圾回收器：G1收集器</li></ol></li><li><p>ContentProvider的作用是？</p><p>跨进程通信，不同应用之间可以互相访问对应的数据库</p></li><li><p>袋子里有2个红球，3个绿球，2个蓝球，从中取两个，求一个蓝球都没有的概率？</p></li><li><p>xml布局文件放在哪个目录下</p><p><code>res/layout</code></p></li><li><p>ABCDEF依次入栈，出栈序列为CBDFEA，问栈的最小容量</p></li><li><p>数组未初始化就输出的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">System.out.println(a[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li><li><p>类未构造访问其成员变量的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">&#125;</span><br><span class="line">T t;</span><br><span class="line">System.out.println(t.n);</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>2道算法题全部来自Leetcode。</p><ol><li>买卖股票问题求最大利润</li><li>求岛屿的周长</li></ol><h2 id="Taptap"><a href="#Taptap" class="headerlink" title="Taptap"></a>Taptap</h2><ol><li><p>自我介绍</p></li><li><p>为什么不做人工智能方向</p></li><li><p>介绍自己的实习经历，都负责了什么</p></li><li><p>接触Android多久了，Android最新的版本号是什么，<font color="red">Android10相对Android9改进</font>了什么？</p><p> Android10，暗黑模式、更安全的位置权限获取等。</p></li><li><p>讲一讲实习中接触到的网络封装类的用法</p></li><li><font color="red">Activity的生命周期</font><p> 这是面试必问问题，虽然不深究的话其实不难，但是我总感觉我的回答每次都差点意思。</p><p> <strong>Activity的四种状态</strong>：</p><ul><li>running状态：Activity处于活跃状态，位于Activitiy返回栈的栈顶</li><li>paused状态：Activity仍然可见，但是不能与用户交互，比如表面覆盖了一层，此时这个Activity的状态信息和成员变量等都是保存的；但当内存紧张时，这个Activity会被回收</li><li>stopped状态：Activity完全不可见，比如被另外一个Activity覆盖了，但是它的状态信息和成员变量还是被保存的；当内存紧张时，这个Activity会被回收</li><li>killed状态：Activity被系统回收，它保存的信息和成员变量也被回收</li></ul></li><li><p><font color="red">http和https的区别，越详细越好，用到了什么加密算法</font>？</p><p> 因为超文本传输协议HTTP协议以明文形式发送内容，不提供任何方式的数据加密，所以不适合传递一些敏感信息，例如银行卡号、密码等信息。所以采用安全套接字层超文本传输协议HTTPS。HTTPS在HTTP的基础之上，加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><ul><li>https协议需要到ca申请证书，一般免费证书较少，所以是需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用到的端口也不一样，前者是80，后者是443。</li><li><p>http连接简单，无状态；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><p>SSL协议是一种安全保密协议，在浏览器和服务器之间构造安全通道来进行数据传输，SSL运行在TCP/IP层之上，应用层之下，为应用程序提供加密数据通道。它采用了RC4、MD5和RSA的加密算法。</p><p>HTTPS的工作原理：<a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">详细解析HTTP与HTTPS的区别</a></p></li></ul></li><li><p><font color="red">自定义View要用到哪些方法</font>，有没有写过什么自定义控件</p><p> 自定义View可以重写三个方法：<code>onDraw()</code>、<code>onMeasure()</code>、<code>onLayout()</code>。其中，<code>onDraw()</code>方法必须要重写，因为这个方法是用来绘制View图像的。如果要改变View的大小，就重写<code>onMeasure()</code>方法；如果要改变View在父控件中的位置，就要重写<code>onLayout()</code>方法。</p></li></ol><h2 id="堆糖"><a href="#堆糖" class="headerlink" title="堆糖"></a>堆糖</h2><p>这是大四时找实习的面试。</p><ol><li><p>自我介绍</p></li><li><p>介绍一个自己实际动手做过的项目与项目中遇到的问题</p></li><li><p>Volley的原理</p><p> 已在Notion中记录。</p></li><li><p>OOM内存溢出的解决办法</p><p> 已在Notion中记录。</p></li><li><p>Activity的生命周期</p></li><li><font color="red">Activity的四种启动方式</font></li><li><p>Spring的机制特征，解释一下依赖注入、IOC容器和AOP面向切面编程</p></li><li><p>Spring的依赖注入与ButterKnife依赖注入是否相同或者不同的话有何区别</p></li><li><p>Android滑动遇到的冲突，比如NavigationView与ViewPager的冲突</p></li><li><p>是否写过BaseActivity</p></li><li><p>ANR错误的原因</p><p>已在Notion中记录。</p></li><li><p>View的绘制机制，自定义View的方法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to PyTorch</title>
      <link href="/2020/02/20/Introduction-to-PyTorch/"/>
      <url>/2020/02/20/Introduction-to-PyTorch/</url>
      
        <content type="html"><![CDATA[<p>This notebook covers:</p><ul><li>Tensors</li><li>Gradients</li><li>Datasets</li><li>Neural networks</li><li>Training(+ training on a GPU)</li><li>Calculating</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>代码见<a href="https://github.com/HurleyJames/GoogleColabExercise/blob/master/Intro_to_PyTorch.ipynb" target="_blank" rel="noopener">Intro_to_Pytorch</a>。</p><a id="more"></a><h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p>Tensor is a basic building block.</p><p>它和Numpy的<code>ndarrays</code>相似，但是相比后者，它可以在GPU上使用。</p><p><code>torch.Tensor</code>是一种包含单一数据类型元素的多维矩阵。</p><h3 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h3><p>相比Numpy，PyTorch在传播梯度方面更加强大。它可以前向传播也可以反向传播。</p><p>Both the gradient, and forward and backward pass functions are attached to PyTorch’s Tensor object.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>如果设置<code>requires_grad=True</code>，那么将会追踪对于该张量的操作。当完成计算后，通过调用<code>.backward()</code>，自动计算所有梯度，而这个张量的所有梯度将会自动积累到<code>.grad</code>属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.grad_fn</span><br></pre></td></tr></table></figure><p><code>Tensor</code>和<code>Function</code>是互联的并且构成了一个无环计算图，以此来实现对完整计算历程的编码。每个Tensor都有一个<code>.grad_fn</code>属性指向一个<code>Function</code>，正是这个<code>Function</code>创建了那个Tensor。</p><hr><p>然后通过Numpy和Tensor分别创建了两个相同的数组，Numpy通过<code>grad_w = v * w</code>得到的结果与Tensor通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = w * x</span><br><span class="line">y.backward(v)</span><br><span class="line">w.grad</span><br></pre></td></tr></table></figure><p>得到的结果是相同的。</p><p>可以看到，PyTorch中的<code>backward</code>函数是一个反向求导的函数，通过反向传播的方式，使用链式法则求导。</p><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p><strong>Transforms</strong> are common image transformations which can be chained together using Compose().</p><p><code>torchvision.transforms</code>是PyTorch中的图像预处理包，包含了很多种对图像数据进行变换的函数。而<code>Compose</code>方法则是把多种变换组合在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>,), (<span class="number">0.5</span>,))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>.ToTensor()</code>的变换操作是将PILImage转变为<code>torch.FloatTensor</code>的数据形式。然后的<code>.Normalize</code>方法是用给定的均值和标准差分别对每个通道的数据进行正则化，即使用如下公式进行归一化：</p><p><code>channel = (channel - mean) / std</code></p><p><code>DataLoader</code>是PyTorch中的一种数据类型，主要包含以下几个参数：</p><ol><li><p><code>dataset</code>：数据类型<code>dataset</code></p><p> 输入数据类型。例如<strong>数据集</strong>。</p></li><li><p><code>batch_size</code>：数据类型<code>int</code></p><p> 每次输入数据的行数，默认为1。即定义每次喂给神经网络多少行数据，如果是1，那么就是一行一行的进行（效率太低）。</p></li><li><p><code>shuffle</code>：数据类型<code>bool</code></p><p> 洗牌。默认设置为<code>False</code>。如果设置为<code>True</code>，那么系统在返回之前会将张量数据Tensors复制到CUDA内存中。</p></li><li><p><code>batch_sampler</code>：数据类型<code>Sampler</code></p><p> 批量采样，默认设置为<code>None</code>。每次返回的是一批数据的索引。<strong>和<code>batch_size</code>和<code>sampler</code>和<code>drop_last</code>不兼容</strong>。</p></li><li><p><code>sampler</code>：数据类型<code>Sampler</code></p><p> 采样，默认设置为<code>None</code>。根据定义的策略从数据集中采样输入。如果定义了采样规则，则洗牌设置必须为<code>False</code>。</p></li><li><p><code>num_workers</code>：数据类型<code>int</code></p><p> 工作者数量，默认为0。即<strong>使用多少个子进程来导入数据</strong>。如果设置为0，就是使用主进程来导入数据（这个数字必须大于0）。</p></li></ol><p>例如，如果想</p><ul><li>打乱数据的顺序，可以设置<strong>shuffle</strong>为<code>True</code></li><li>改变数据输入的数量，可以设置<strong>batch_size</strong>的数目</li><li>想多线程输入，可以设置<strong>num_workers</strong>的数目</li><li>想随机抽取的模式输入，可以设置<strong>sampler</strong>或者<strong>batch_sampler</strong>。</li></ul><p>然后<code>classes = np.arange(0, 10)</code>的方法就是创建一个数组，默认步长为1，所以这个数组就是<code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code>。这个的作用主要是后面的绘制混淆矩阵要用到。</p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>这里主要有两个步骤：</p><ul><li>构建网络</li><li>构建损失函数和优化器</li></ul><p>所有的网络都继承至<code>nn.Module</code>，然后总是需要用到以下两个函数：</p><ul><li><strong>init</strong>, which will be called the moment you instantiate the class.</li><li><strong>forward()</strong> function which will be called during training.</li></ul><h4 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearClassifier</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes=<span class="number">10</span>)</span>:</span></span><br><span class="line">        <span class="comment"># Calls __init__() on the parent class, which is nn.Module</span></span><br><span class="line">        super(LinearClassifier, self).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define each layer of the network as a class variable</span></span><br><span class="line">        <span class="comment"># fc1 stands for first fully-connected layer</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span> * <span class="number">28</span>, num_classes)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = x.reshape(x.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="comment"># TODO what does this do? Why do we need it?</span></span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>这部分代码没有加上卷积层、池化层等操作，而是只有一个简单的全连接层。</p><p>而后面又问了一个问题：<code>out = x.reshape(x.size(0), -1)</code>这句代码的作用是什么？为什么要这样写？</p><p>如果数据集最后一个batch样本数量小于定义的batch_batch大小，会出现mismatch问题。可以自己修改下，如只传入后面的shape，然后通过x.szie(0)，来输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这行的代码是因为在神经网络中，参数默认是进行随机初始化的。而不同的初始化参数往往会导致不同的结果，而在得到好的结果时我们都希望这个结果是能够<strong>复现</strong>的。因为通过设置<strong>随机数种子</strong>可以达到这个目的。</p><h4 id="损失函数和优化器部分"><a href="#损失函数和优化器部分" class="headerlink" title="损失函数和优化器部分"></a>损失函数和优化器部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stochastic gradient descent</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p>这里用到的损失函数是<code>CrossEntropyLoss()</code>，然后优化器是用<code>SGD</code>，学习率为0,001，动量为0.9。</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p><code>optimizer.zero_grad</code>是将梯度重置为0，其余部分主要就是设置epoch次数，然后打印出每轮的损失率。最后通过计算<code>accuracy = correct / total</code>来得到准确率。</p><p>然后可以通过<code>matplotlib.pyplot</code>来生出具体的特征图，例如混淆矩阵。</p><h3 id="Calculating"><a href="#Calculating" class="headerlink" title="Calculating"></a>Calculating</h3><h4 id="卷积操作输出的计算公式"><a href="#卷积操作输出的计算公式" class="headerlink" title="卷积操作输出的计算公式"></a>卷积操作输出的计算公式</h4><p>首先，定义一下参数的概念。</p><p><code>width</code>、<code>height</code>、<code>depth</code>、<code>filter</code>、<code>stride</code>、<code>padding</code></p><p>W：图像的宽；H：图像的高；D：图像的深度（通道数）</p><p>F：卷积核的宽和高；N：卷积核（过滤器）的个数</p><p>S：步长；P：用零填充的个数</p><p>因此，卷积输出的公式为：</p><!-- more --><p><code>output_shape = (input_shape - filter_size + 2 * padding) / stride + 1</code></p><p>即<code>卷积输出大小=(输入大小 - 卷积核大小 + 2 * padding) / 步长 + 1</code></p><h4 id="池化操作输出的计算公式"><a href="#池化操作输出的计算公式" class="headerlink" title="池化操作输出的计算公式"></a>池化操作输出的计算公式</h4><p>同样，W：图像宽；H：图像高；D：图像深度（通道数）</p><p>F：<code>MaxPooling</code>中的卷积核的宽高；S：步长</p><p>因此，池化后输出大小为：</p><p><code>(input_shape - filter_size) / stride + 1</code></p><p>值得注意的是，这里的filter_size不是<code>Conv2d</code>中的卷积核大小，而是池化层中的卷积核大小。例如<code>MaxPool2d(2, 2)</code>这里的卷积核大小就是<code>2x2</code>。</p><h4 id="nn-Conv2d简单说明"><a href="#nn-Conv2d简单说明" class="headerlink" title="nn.Conv2d简单说明"></a>nn.Conv2d简单说明</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li><code>in_channels(int)</code></li><li><code>out_channels(int)</code></li><li><code>kernel_size(int or tuple)</code></li><li><code>stride(int or tuple, optional)</code></li><li><code>padding(int or tuple, optional)</code></li><li><code>groups(int, optional)</code></li><li><code>bias(bool, optional)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206.Reverse Linked List</title>
      <link href="/2020/02/15/206.Reverse-Linked-List/"/>
      <url>/2020/02/15/206.Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>反转链表</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="方法一：递归法"><a href="#方法一：递归法" class="headerlink" title="方法一：递归法"></a>方法一：递归法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为之前做了比较多树的题目，发现树的题目都是用递归遍历的方式比用迭代的方式要简单的多。但是对于这题，递归反而更难理解。</p><p>这题的递归主要是通过一个判断条件，当当前节点或者当前节点的下一个节点为<code>null</code>时，就改变节点的指向，将head的下一个节点指向head，具体是用如下一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head;</span><br></pre></td></tr></table></figure><p>我们先看一个动态图来知道大概流程，然后再具体分析代码是如何实现的。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法一：递归</span></span><br><span class="line">    <span class="comment">// 如果头结点为空，或者只有一个头结点，那么翻转过来就是头结点本身</span></span><br><span class="line">    <span class="comment">// 终止条件是，当前节点或者下一个节点为 null</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    <span class="comment">// 改变节点的指向</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以根据代码和上面的动图来一步一步走一下这个程序。首先，这句代码<code>ListNode p = reverseList(head.next)</code>采用了递归的方式，假设这个链表是<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>，那么<code>head</code>最开始是1，<code>head.next</code>则是2，那么上面这句递归的代码就跳转去执行<code>reverseList(head.next)</code>即<code>reverseList(2)</code>，这样递归下去最终会执行<code>reverseList(4.next)</code>即<code>reverseList(5)</code>。因为当头结点为5时，<code>5.next</code>为<code>null</code>，所以满足第一行代码<code>if</code>语句的终止条件，就会返回<code>head</code>即返回5。</p><p>然后跳出这最后一层递归，即执行完了<code>reverseList(5)</code>，去接着执行<code>reverseList(4)</code>。这里有一句重要的<strong>改变节点指向</strong>的代码<code>head.next.next = head</code>。我们知道这时候的head是4，所以这句代码其实就是<code>4.next.next = 4</code>，而<code>4.next</code>在该链表中即为5，所以最终就是<code>5.next = 4</code>，即<code>5-&gt;4</code>，5的下一个节点又指向了4。</p><p>这里再注意题目的要求是翻转链表。而我们经过上面的操作后就变成了<code>4-&gt;5</code>，而且<code>5-&gt;4</code>，这就变成了双向链表了，所以我们要解除4指向5的关系，就通过这句代码<code>head.next =  null</code>，即<code>4.next  = null</code>，就把这个关系解除了（具体可以通过观察动图来理解）。</p><p>这样最终会返回原链表的头结点即1，然后头结点的下一个节点为<code>null</code>，就结束翻转了。</p><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为将链表从头走到尾，所以时间复杂度为$O(n)$，n为链表的长度。</li><li><strong>空间复杂度</strong>：因为这个方法使用了递归，递归会使用到<strong>隐式栈空间</strong>，所以递归的深度可能会达到n层，所以是$O(n)$。</li></ul><h3 id="方法二：双指针迭代法"><a href="#方法二：双指针迭代法" class="headerlink" title="方法二：双指针迭代法"></a>方法二：双指针迭代法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>我们可以申请两个指针，<code>prev</code>和<code>curr</code>。<code>prev</code>最初指向<code>null</code>，而<code>curr</code>指向<code>head</code>。然后遍历<code>curr</code>，并通过一个临时指针<code>temp</code>来储存<code>curr</code>的下一个节点即<code>curr.next</code>，然后让这个临时指针记录下一个节点<code>temp = curr.next</code>，然后让<code>curr</code>指向<code>prev</code>。最后继续遍历，让<code>prev</code>和<code>curr</code>都向前进一位，<code>prev = curr; curr = temp</code>。</p><p>具体演示效果如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt=""></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：迭代</span></span><br><span class="line">    <span class="comment">// 申请节点，pre 和 curr，pre 指向 null</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">        tmp = curr.next;</span><br><span class="line">        <span class="comment">// 然后将当前节点指向 pre</span></span><br><span class="line">        curr.next = prev;</span><br><span class="line">        <span class="comment">// pre 和 curr 节点都前进一位</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这个过程同样是将链表从头遍历到尾，所以时间复杂度为$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="方法三：遍历法"><a href="#方法三：遍历法" class="headerlink" title="方法三：遍历法"></a>方法三：遍历法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>递归反转法是从前往后开始依次反转各个节点的指针域的指向。</p><p>就是将当前节点<code>cur</code>的下一个节点<code>cur.next</code>缓存到temp后，然后更改当前节点的指针指向前一个节点<code>pre</code>。结束之后，再往后移，让<code>pre</code>变成<code>cur</code>，<code>cur</code>变成<code>temp</code>。</p><ul><li>pre：上一结点</li><li>cur: 当前结点</li><li>tmp: 临时结点，用于保存当前结点的指针域（即下一结点）</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseByTraverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pre指向前一个节点</span></span><br><span class="line">    Node pre = head;</span><br><span class="line">    <span class="comment">// cur指向后一个节点</span></span><br><span class="line">    Node cur = head.getnext();</span><br><span class="line">    <span class="comment">// tmp是临时节点，用来储存cur的下一个节点的</span></span><br><span class="line">    Node tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用来存储cur的下一个节点</span></span><br><span class="line">        tmp = cur.getnext();</span><br><span class="line">        <span class="comment">// 反转指针的指向</span></span><br><span class="line">        cur.setnext(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针都向后移动</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">        <span class="comment">// 循环反转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将原链表的头节点的指针域置为null，还回新链表的头结点，即原链表的尾结点</span></span><br><span class="line">    <span class="comment">// 因为head相当于尾节点了</span></span><br><span class="line">    head.setnext(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.Merge Two Sorted Lists</title>
      <link href="/2020/02/15/21.Merge-Two-Sorted-Lists/"/>
      <url>/2020/02/15/21.Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>合并两个有序链表</strong></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="方法一：递归法"><a href="#方法一：递归法" class="headerlink" title="方法一：递归法"></a>方法一：递归法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题的递归法同样不好理解。之前我一直认为递归是一个比较容易的方法，而迭代更难。看来面对不同的数据结构其实并不相同，树由于其特殊性，采用递归即深度遍历的方式是十分好理解的，而采用迭代则必须要用一个栈或者队列去保存元素反而更加繁琐。但是对于链表这种数据结构，递归反而值得更多的思考。</p><p>首先，这道题采用递归的终止条件是当<code>l1</code>或者<code>l2</code>为空时，结束。而返回值则是<strong>每一层调用都返回排序好的链表头</strong>。</p><p>通俗来说，就是如果<code>l1.val</code>比<code>l2.val</code>更小，那么就将<code>l1.next</code>与排序好的链表头相接；反之，如果<code>l2.val</code>更小，则将<code>l2.next</code>与排序号的链表头相连。具体是通过<code>l1.next = mergeTwoLists(l1.next, l2)</code>这句代码来实现的。</p><p>具体过程如下（但实际上仍然不是很好理解，具体还是要分析代码）：</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHdjf.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seH0u8.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHBDS.png" alt=""></p><p>通过以上图片过程可以发现，<code>l2.next = merge(l1, l2.next)</code>这句代码就是让原有的<code>l2.next</code>指向的那个链条断开，指向了新的<code>merge(l1, l2.next)</code>。虽然目前我们暂时不知道这个<code>merge(l1, l2.next)</code>是什么，但是这其实是一个持续递归的函数，最终会返回已经排序好的值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        <span class="comment">// 如果 l1 的 val 更小，则将 l1.next 等于排序好的链表头</span></span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 l2 的 val 更小，则将 l2.next 等于排序号的链表头</span></span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过一个例子来走一遍整个代码的流程。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>现在有两个链表<code>l1</code>和<code>l2</code>，分别为<code>1-&gt;2-&gt;5</code>和<code>0-&gt;3-&gt;4</code>。</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHagP.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHU3t.jpg" alt=""></p><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：很明显，这个过程要把两个链表都走一遍。假设它们的长长度分别为m和n，则时间复杂度为$O(m+n)$。</li><li><strong>空间复杂度</strong>：因为这个过程会调用$m+n$个栈，所以会消耗$O(m+n)$的空间。</li></ul><h3 id="方法二：迭代法"><a href="#方法二：迭代法" class="headerlink" title="方法二：迭代法"></a>方法二：迭代法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>关于链表的合并问题，我们都可以想到去设置一个<strong>哨兵节点</strong>。比如，链表<code>l1</code>和<code>l2</code>分别为<code>1-&gt;2-&gt;4</code>和<code>1-&gt;3-&gt;4</code>，然后设置一个<code>prehead</code>的哨兵节点，如下所示：</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHDHg.jpg" alt=""></p><p>然后我们主要关注<code>prehead</code>节点，调整它的<code>next</code>指针，让它总是指向<code>l1</code>和<code>l2</code>中较小的那个节点，直到两个链表中的某一条指向<code>null</code>为止。</p><p>我在这里把步骤一步一步地写出来：</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHsEQ.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seHyNj.jpg" alt=""></p><p>完整的过程如下：</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seH64s.jpg" alt=""></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.迭代法</span></span><br><span class="line">    ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ListNode prev = prehead;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            prev.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prehead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法的算法看起来是十分清晰明了的，如果<code>l1.val &lt;= l2.val</code>，则让哨兵节点指向<code>l1</code>即值更小的节点，反之一样，然后再将那个更小的节点往后走一位，再重新判断值的大小。</p><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这个方法要比较两条链表的每一个节点，所以时间复杂度为$O(m+n)$，即循环的次数等于两个链表的总长度。</li><li><strong>空间复杂度</strong>：迭代的过程会产生几个指针，所以所需空间是常数级别的，为$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160.Intersection of Two Linked Lists</title>
      <link href="/2020/02/14/160.Intersection-of-Two-Linked-Lists/"/>
      <url>/2020/02/14/160.Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>相交链表</strong></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p></blockquote><a id="more"></a><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>非常容易想到的就是暴力法。采用双重遍历的方式，先从链表A中选出一个节点，然后遍历整个链表B，看是否能找到与之相同的节点。如果能的话，就返回该节点；如果不能，则继续遍历链表A，然后重复。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果某个链表为空，是肯定不会相交的</span></span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode newHead = headB;</span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，就找到了相交点</span></span><br><span class="line">            <span class="keyword">if</span> (headA == newHead) &#123;</span><br><span class="line">                <span class="keyword">return</span> newHead;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完了都没有找到，说明没有相交点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种方法思路上十分简单清晰，但是在代码中仍然有需要注意的地方。</p><ol><li><p>这里判断节点相同，可以直接采用<code>nodeA == nodeB</code>的方式去判断，而不是通过他们的值<code>val</code>去判断。因为，这里仅仅是值相等并没有用，必须要它们的下一个节点以及之后的节点都相等，才是找到了相交节点。</p></li><li><p>在第一层循环的里面，我们又定义了<code>ListNode newHead = headB</code>。这一步看起来是多余的，但是如果不这么定义一个新的变量的话，那么在第二层循环的判断条件那里，就会变成是<code>while (headB != null)</code>。那么当第一遍遍历整个链表B却没有找到与链表A中一个节点$a_i$相同的节点的话，<code>headB = headB.next</code>最终会使得<code>headB == null</code>，即遍历到链表B的末尾。这样就没有再为链表B从头开始遍历了。</p><p> 所以，必须要使用其它元素来保存遍历的链表B的节点。这里用的是<code>ListNode newHead = headB</code>。</p></li></ol><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这里采用的双重循环遍历两个链表。假设链表A的长度为m，链表B的长度为n，所以时间复杂度为$O(mn)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="方法二：哈希法"><a href="#方法二：哈希法" class="headerlink" title="方法二：哈希法"></a>方法二：哈希法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先遍历链表A，把链表A的所有节点放入一个set中。然后再遍历链表B，判断如果链表B中的某个节点出现在set中，那么这就是相交节点。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    Set s = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="comment">// 遍历链表A，把链表A的节点全部存入set中</span></span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">        s.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历链表B，判断set中是否存在相同的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s.contains(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这里用到的HashSet的底层是通过HashMap来实现的，所以进行<code>add</code>或者<code>contains</code>等操作的时间复杂度都是$O(1)$。因为进行了两次不是嵌套的循环，所以假设链表A的长度为m，链表B的长度为n，则时间复杂度为$O(m+n)$。</li><li><strong>空间复杂度</strong>：因为这里用了HashSet去存储节点，所以要么存储了链表A的长度要么存储了链表B的长度。所以空间复杂度为$O(m)$或者$O(n)$。</li></ul><h3 id="方法三：双指针法"><a href="#方法三：双指针法" class="headerlink" title="方法三：双指针法"></a>方法三：双指针法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在LeetCode的评论区，看到很多人评论这是一种很浪漫的方法。即</p><blockquote><p>错的人迟早会走散，而对的人迟早会相逢！</p></blockquote><p>双指针的方式其实思考起来还是很清晰的。用两个指针a和b分别从链表A和链表B开始遍历，当a遍历完链表A之后，就去遍历链表B；同样的，当b遍历完链表B之后，就去遍历链表A。这样，如果它们是相交的，则最终走过的长度肯定是一样的，即会在交点相遇。可以用下图一样，将两个链表连成一个环。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/6d24c0d2f451f8cfccea0edaff474d5d1e834d2199272974915d80e332f5fb50-1571538464(1" alt="">.jpg)</p><p>然后遍历过程如下动图所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/396526c47e043feb977e59f98d8df9165ae249d5042ca60ee4d3121c05fea067-%E5%8A%A8%E6%80%81%E5%9B%BE.gif" alt=""></p><p>因为连成一个环后，假设有相交的节点，则最终走过的链表A加上链表B的长度是一样，最终都会相遇于交点。</p><p>（今天<strong>情人节</strong>，值得反思一下🤔）</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode a = headA;</span><br><span class="line">    ListNode b = headB;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 继续遍历链表A</span></span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去遍历链表B，从头结点开始</span></span><br><span class="line">            a = headB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 继续遍历链表B</span></span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去遍历链表A，从头节点开始</span></span><br><span class="line">            b = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这个方法同样遍历了链表A和链表B，所以时间复杂度为$O(m+n)$。</li><li><strong>空间复杂度</strong>：这里没有去存储节点，所以空间复杂度为$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572.Subtree of Another Tree</title>
      <link href="/2020/02/08/572.Subtree-of-Another-Tree/"/>
      <url>/2020/02/08/572.Subtree-of-Another-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>另一个树的子树</strong></p><p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p><p><strong>Example 1:</strong><br>Given tree s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Given tree t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 </span><br><span class="line">/ \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Return <strong>true</strong>, because t has the same structure and node values with a subtree of s.</p><p><strong>Example 2:</strong><br>Given tree s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Given tree t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Return <strong>false</strong>.</p></blockquote><a id="more"></a><h3 id="方法一：先序遍历"><a href="#方法一：先序遍历" class="headerlink" title="方法一：先序遍历"></a>方法一：先序遍历</h3><p>因为我们知道树的表示方式的一种就是以先序遍历的方式表示出来。所以，我们把两棵树s和t分别以先序遍历的方式表示（以字符串表示），然后判断t是否是s的子字符串即可判断出是否是其的子树。</p><p>通常，如果左节点或者右节点为空，我们就会把它以<code>null</code>的形式表示，但是在这里是要判断结构和节点是否相同，所以不能简单地用<code>null</code>来区分。</p><p>当左孩子为空时，要赋值为<code>lnull</code>；当右孩子为空时，要赋值为<code>rnull</code>。</p><p>还有一点非常重要的是，因为我们是把它转化为字符串，用字符串<code>contains</code>的方式来判断是否是子串，这样容易把更小的数字认为是更大的数字的子串。例如，会把<code>3</code>认为是<code>23</code>的子串，但是在这里显然是不同的，如果一个是<code>3</code>，一个是<code>23</code>，那么就不是子树了。所以，我们要为每个节点前加一个<code>#</code>，就可以解决这个问题了。</p><p>关于以上<code>contains</code>方法的问题，如果含有空左孩子或右孩子时，即有<code>lnull</code>或者<code>rnull</code>时也不会有问题，但是如果没有，那么当两棵树为<code>[12]</code>和<code>[2]</code>时，就会输出<code>true</code>，然而实际是<code>false</code>。<strong>所以一定要为数字前加上一个字符</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subtree_of_Another_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        String tree1 = preOrder(s, <span class="keyword">true</span>);</span><br><span class="line">        String tree2 = preOrder(t, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (tree1.contains(tree2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">preOrder</span><span class="params">(TreeNode node, <span class="keyword">boolean</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是左孩子节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 设置为 lnull</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"lnull"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右孩子节点为空，设置为 rnull</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"rnull"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给每个节点前加上 # 号</span></span><br><span class="line">        <span class="comment">// 如果 preOrder 的第一个参数是 left，那么就是 true</span></span><br><span class="line">        <span class="comment">// 如果 preOrder 的第一个参数是 right，那么就是 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + node.val + <span class="string">" "</span> + preOrder(node.left, <span class="keyword">true</span>) + <span class="string">" "</span> + preOrder(node.right, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：采用先序遍历的方式表示树，那么两棵树的花费的时间为$O(m)$和$O(n)$。最后用字符串判断是否包含的方式花费的时间为$O(mn)$，所以总的时间复杂度为$O(m+n+mn)$。</li><li><strong>空间复杂度</strong>：主要取决于哪棵树的空间更大。所以是$O(max(m,n))$。</li></ul><h3 id="方法二：比较节点"><a href="#方法二：比较节点" class="headerlink" title="方法二：比较节点"></a>方法二：比较节点</h3><p>我们可以把每个给定节点t的子树都作为根，然后判断以t为根的子树是否与给定的子树相同。为了检查是否完全相同，我们就需要比较两个子树的所有节点。</p><p>首先，我们定义一个<code>equals(x,y)</code>函数去检查两个树是否相等。它先检查两个树的根是否相等，然后再递归判断左子树和右子树。</p><p>然后，使用一个函数<code>traverse(s,t)</code>，遍历给定的树s并将每个节点都当作子树的根。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subtree_of_Another_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> traverse(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">traverse</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s != <span class="keyword">null</span> &amp;&amp; (equals(s, t) || traverse(s.left, t) || traverse(s.right, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较两个树是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果节点值相同，且左孩子和右孩子的节点值也相同，则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> t1.val == t2.val &amp;&amp; equals(t1.left, t2.left) &amp;&amp; equals(t1.right, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：在最坏的情况下，即一棵树为倾斜树时，需要$O(mn)$时间。</li><li><strong>空间复杂度</strong>：如果n为树的节点数，那么空间复杂度为$O(n)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>437.Path Sum III</title>
      <link href="/2020/02/07/437.Path-Sum-III/"/>
      <url>/2020/02/07/437.Path-Sum-III/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>路径总和III</strong></p><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><a id="more"></a><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">/  \</span><br><span class="line">5   -3</span><br><span class="line">/ \    \</span><br><span class="line">3   2   11</span><br><span class="line">/ \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题的描述中没有要求路径的开头必须是根节点，结尾也没有要求是叶子节点，只要求了是从上往下。</p><p>所以，所有情况就分为以根节点开始的，和以根节点的左孩子和右孩子开始这三种。</p><p>具体过程同样是采取了递归的思想，当找到一条值等于sum，就让路径树加1。但需要注意的是递归的循环中，应该是<code>pathSum(root.left/right, sum - root.val)</code>这种形式。因为在递归后，后面一个参数应该从<code>sum</code>变成<code>sum - root.val</code>，因为已经经过了一个节点，需要减去这个节点的值再进行递归。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path_Sum_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出根节点的所有路径，再找出以根节点的左孩子和右孩子开始的所有路径</span></span><br><span class="line">        <span class="keyword">return</span> path(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">path</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == sum) &#123;</span><br><span class="line">            pathSum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum = pathSum + path(root.left, sum - root.val);</span><br><span class="line">        pathSum = pathSum + path(root.right, sum - root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pathSum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里刚开始有些疑惑的是为什么一个方法的返回值是<code>return path(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</code>，而不是都调用<code>path</code>函数。</p><p>我认为实际上这是把<code>path(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum)</code>看成一个整体，分别是根节点root和它的左孩子A和右孩子B。第一个<code>path(root, sum)</code>是为了找出以根节点为路径开头的路径数量，第二个<code>pathSum(root.left, sum)</code>就是以左孩子节点作为新的根节点，然后递归，又以这个A作为根节点，找出它作为路径开头的路径数量，依次递归下去。右孩子B同理。</p><p>但是细想起来，这个做法存在着大量的重复计算，其实在效率上还是可以改进的。因为比如第一步，以根节点root作为路径的开头，去遍历可能值等于sum的路径，这时候就已经遍历过一次了，如果在这个遍历的过程中，能够发现路径中的某一部分（即不以根节点作为开头）的值正好等于sum，就明显提高了效率。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617.Merge Two Binary Trees</title>
      <link href="/2020/02/04/617.Merge-Two-Binary-Trees/"/>
      <url>/2020/02/04/617.Merge-Two-Binary-Trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>合并二叉树</strong></p><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">trueTree 1                     Tree 2                  </span><br><span class="line">       1                         2                             </span><br><span class="line">      / \                       / \                            </span><br><span class="line">     3   2                     1   3                        </span><br><span class="line">    /                           \   \                      </span><br><span class="line">   5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">true     3</span><br><span class="line">true    / \</span><br><span class="line">true   4   5</span><br><span class="line">true  / \   \ </span><br><span class="line">true 5   4   7</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p></blockquote><a id="more"></a><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果两棵树的当前节点均不为空，就将它们的值相加，然后继续对它们的左孩子和右孩子进行递归合并；如果有一棵树为空，就直接返回另一颗树的值。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weka中实现J48决策树算法</title>
      <link href="/2020/02/04/Weka%E4%B8%AD%E5%AE%9E%E7%8E%B0J48%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/04/Weka%E4%B8%AD%E5%AE%9E%E7%8E%B0J48%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="WEKA"><a href="#WEKA" class="headerlink" title="WEKA"></a>WEKA</h2><p>WEKA（Waikato Environment for Knowledge Analysis）诞生于University of Waikato（新西兰），并在1997年首次以现代的格式实现。</p><p>为了将数据加载到WEKA，我们必须将数据放入一个我们能够理解的格式。WEKA建议加载的数据格式是Attribute Relation File Format（ARFF）。其中含有三个重要的注解：</p><ul><li>@RELATION</li><li>@ATTRIBUTE</li><li>@DATA</li></ul><a id="more"></a><h2 id="J48决策树算法"><a href="#J48决策树算法" class="headerlink" title="J48决策树算法"></a>J48决策树算法</h2><p>J48的全名是<code>weka.classifiers.trees.J48</code>。J48算法是著名的C4.5算法的改进，Weka对于这个算法赋予了默认的参数：-C 0.25 -M 2。该命令给出了分类器的默认参数配置，一般很少需要为提高性能而修改参数配置。前者是用于剪枝的置信因子，后者指定了每个叶结点最小的实例数。</p><p>通过运行weather.nominal.arff文件，在分类器面板的Test options部分选择Use training set，然后点击Start按钮创建分类器并进行评估。</p><p>运行完成后，可以在右侧的Classifier output中查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">=== Run information ===</span><br><span class="line"></span><br><span class="line">Scheme:       weka.classifiers.trees.J48 -C 0.25 -M 2</span><br><span class="line">Relation:     weather.symbolic</span><br><span class="line">Instances:    14</span><br><span class="line">Attributes:   5</span><br><span class="line">              outlook</span><br><span class="line">              temperature</span><br><span class="line">              humidity</span><br><span class="line">              windy</span><br><span class="line">              play</span><br><span class="line">Test mode:    evaluate on training data</span><br><span class="line"></span><br><span class="line">=== Classifier model (full training set) ===</span><br><span class="line"></span><br><span class="line">J48 pruned tree</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">outlook = sunny</span><br><span class="line">|   humidity = high: no (3.0)</span><br><span class="line">|   humidity = normal: yes (2.0)</span><br><span class="line">outlook = overcast: yes (4.0)</span><br><span class="line">outlook = rainy</span><br><span class="line">|   windy = TRUE: no (2.0)</span><br><span class="line">|   windy = FALSE: yes (3.0)</span><br><span class="line"></span><br><span class="line">Number of Leaves  : 5</span><br><span class="line"></span><br><span class="line">Size of the tree : 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time taken to build model: 0.01 seconds</span><br><span class="line"></span><br><span class="line">=== Evaluation on training set ===</span><br><span class="line"></span><br><span class="line">Time taken to test model on training data: 0 seconds</span><br><span class="line"></span><br><span class="line">=== Summary ===</span><br><span class="line"></span><br><span class="line">Correctly Classified Instances          14              100      %</span><br><span class="line">Incorrectly Classified Instances         0                0      %</span><br><span class="line">Kappa statistic                          1     </span><br><span class="line">Mean absolute error                      0     </span><br><span class="line">Root mean squared error                  0     </span><br><span class="line">Relative absolute error                  0      %</span><br><span class="line">Root relative squared error              0      %</span><br><span class="line">Total Number of Instances               14     </span><br><span class="line"></span><br><span class="line">=== Detailed Accuracy By Class ===</span><br><span class="line"></span><br><span class="line">                 TP Rate  FP Rate  Precision  Recall   F-Measure  MCC      ROC Area  PRC Area  Class</span><br><span class="line">                 1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     yes</span><br><span class="line">                 1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     no</span><br><span class="line">Weighted Avg.    1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     </span><br><span class="line"></span><br><span class="line">=== Confusion Matrix ===</span><br><span class="line"></span><br><span class="line"> a b   &lt;-- classified as</span><br><span class="line"> 9 0 | a = yes</span><br><span class="line"> 0 5 | b = no</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="Instances"><a href="#Instances" class="headerlink" title="Instances"></a>Instances</h4><p>代表输入的数据量</p><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>代表数据中有哪些数据分类，即属性</p><h4 id="Number-of-Leaves"><a href="#Number-of-Leaves" class="headerlink" title="Number of Leaves"></a>Number of Leaves</h4><p>叶子树</p><h4 id="Size-of-the-tree"><a href="#Size-of-the-tree" class="headerlink" title="Size of the tree"></a>Size of the tree</h4><p>决策树大小</p><h4 id="Kappa-statistic"><a href="#Kappa-statistic" class="headerlink" title="Kappa statistic"></a>Kappa statistic</h4><p>这个参数是把分类器与随机分类器作比较得出的一个对分类器的评价值。</p><h4 id="Mean-absolute-error和Root-mean-squared-error"><a href="#Mean-absolute-error和Root-mean-squared-error" class="headerlink" title="Mean absolute error和Root mean squared error"></a>Mean absolute error和Root mean squared error</h4><p>平均绝对误差，用来衡量分类器预测值和实际结果的差异，越小越好。</p><h4 id="Relative-absolute-error和Root-relative-squared-error"><a href="#Relative-absolute-error和Root-relative-squared-error" class="headerlink" title="Relative absolute error和Root relative squared error"></a>Relative absolute error和Root relative squared error</h4><p>有时候绝对误差不能体现误差的真实大小，而<strong>相对误差</strong>通过体现误差占真值的比重来反映误差大小的效果会更好。</p><h4 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h4><p>混淆矩阵。这个矩阵上对角线的数字越大，说明预测得越好。</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543.Diameter of Binary Tree</title>
      <link href="/2020/02/03/543.Diameter-of-Binary-Tree/"/>
      <url>/2020/02/03/543.Diameter-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>二叉树直径</strong></p><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关于二叉树直径的定义是：<strong>二叉树中从一个结点到另一个结点最长的路径</strong>，叫做二叉树的直径。</p><p>这里存在一个陷阱，就是容易受到题目中例子的影响，认为二叉树的直径就是左子树的深度+右子树的深度。实际上，二叉树的直径<strong>不一定经过根节点root</strong>。有个例子如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_8D22A19495F3-1.jpeg" alt=""></p><p>所以，采用<strong>分治</strong>和<strong>递归</strong>的思想：二叉树的直径=$Max$（左子树的直径，右子树的直径，左子树的最大深度+右子树的最大深度+1）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diameter_of_Binary_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> diameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="comment">// 获得右子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        diameter = Math.max(diameter, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>因为这题需要对左、右子树都进行递归遍历操作，所以每个节点都要访问一次，因为是$O(n)$。</li><li><strong>空间复杂度：</strong>主要是进行DFS深度优先搜索的栈开销，为$O(n)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226.Invert Binary Tree</title>
      <link href="/2020/02/03/226.Invert-Binary-Tree/"/>
      <url>/2020/02/03/226.Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>翻转二叉树</strong></p><p>Invert a binary tree.</p><p><strong>Example:</strong></p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line">/   \</span><br><span class="line">2     7</span><br><span class="line">/ \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line">/   \</span><br><span class="line">7     2</span><br><span class="line">/ \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>通过观察输入和输出，可以发现就是把所有的子树的左右结点都互换位置。所以可以使用<strong>递归</strong>的方法交换左节点和右节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invert_Binary_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左右子树节点</span></span><br><span class="line">        swap(root);</span><br><span class="line">        <span class="comment">// 递归当前节点的左子树</span></span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="comment">// 递归当前节点的右子树</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换左右子树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的三行代码就是<code>swap(root)</code>和<code>invertTree(root.left)</code>以及<code>invertTree(root.right)</code>。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>因为要递归所有的左子树节点和右子树节点，所有时间复杂度为$O(n)$。</li><li><strong>空间复杂度：</strong>假设树的高度为h，则最坏情况下需要$O(h)$个函数存放。</li></ul><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>递归的实现方式其实就是深度优先搜索BFS的方式，而迭代法就是广度优先搜索DFS的方式。</p><p>广度优先搜索需要额外的数据结构——队列，来存放临时遍历的元素。</p><p>首先将根节点放入到队列中，然后对当前元素调换其左右子树的位置，然后再判断其左子树是否为空，不为空就放入队列中；然后判断其右子树是否为空，不为空就放入到队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invert_Binary_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 每次从队列中拿出一个节点，并交换这个节点的左右子树</span></span><br><span class="line">            TreeNode tmp = queue.poll();</span><br><span class="line">            swap(tmp);</span><br><span class="line">            <span class="comment">// 如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点的右子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换左右子树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态图如下：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif" alt=""></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>因为每个节点都要判断是否子树为空，即每个节点都被入队出队一次，所以时间复杂度为$O(n)$。</li><li><strong>空间复杂度：</strong>在最坏的情况下，队列里会包含树中的所有的节点。而如果是一颗完整二叉树，那么叶子节点那一层就拥有$[\frac{n}{2}]=O(n)$个节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100.Same Tree</title>
      <link href="/2020/02/02/100.Same-Tree/"/>
      <url>/2020/02/02/100.Same-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>相同的树</strong></p><p>Given two binary trees, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">       / \       / \</span><br><span class="line">      2   3     2   3</span><br><span class="line">     [1,2,3],   [1,2,3]</span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">       /           \</span><br><span class="line">      2             2</span><br><span class="line">     [1,2],     [1,null,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">       / \       / \</span><br><span class="line">      2   1     1   2</span><br><span class="line">     [1,2,1],   [1,1,2]</span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一棵树要么是空树，要么有两个指针，每个指针指向一颗树。树是一种递归结构，很多树的问题都可以使用递归来处理。</p><p>判断两个数是否是相同的树的终止条件时：</p><ol><li>当两颗数的节点都为<code>null</code>时，返回<code>true</code></li><li>当两棵树的节点一个为<code>null</code>一个不为<code>null</code>时，返回<code>false</code></li><li>当两个节点都不为<code>null</code>但是值不等时，返回<code>false</code></li><li>当两个节点都不为<code>null</code>且值相等时，递推判断接下来的节点，如果全部相同，则返回<code>true</code></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Same_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree1</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递推判断</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree1(p.right, q.right) &amp;&amp; isSameTree1(p.left, q.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义树结构</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>$O(n)$，n为节点的数量，因为每个节点都要判断是否相同。</li><li><strong>空间复杂度：</strong>在最优情况下（完全平衡二叉树）时为$O(log(n))$，最坏情况下（完全不平衡二叉树）时为$O(n)$。</li></ul><h4 id="完全二叉树和平衡二叉树"><a href="#完全二叉树和平衡二叉树" class="headerlink" title="完全二叉树和平衡二叉树"></a>完全二叉树和平衡二叉树</h4><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>只有树最下面的两层的节点度小于2，并且最下面一层的节点都集中在该层的最左边的若干位置的二叉树。</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/sebu5j.png" alt=""></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><p>平衡二叉树是为了保证树不至于太倾斜。所以定义如下：</p><p>平衡二叉树要么是一颗空树，要么保证左右子树的高度之差不大于1，同时子树也必须是一颗平衡二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>785.Is Graph Bipartite</title>
      <link href="/2020/02/02/785.Is-Graph-Bipartite/"/>
      <url>/2020/02/02/785.Is-Graph-Bipartite/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>判断二分图</strong></p><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p><p>Recall that a graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists. Each node is an integer between <code>0</code> and <code>graph.length - 1</code>. There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.</p></blockquote><a id="more"></a><p>这其实可以看做是一个着色问题，即可以转化为「<strong>如果这个图中每个相邻的节点间的颜色都是不一样的，那么就是二分图</strong>」。</p><h3 id="邻接表表示矩阵"><a href="#邻接表表示矩阵" class="headerlink" title="邻接表表示矩阵"></a>邻接表表示矩阵</h3><p>因为LeetCode上图的画法问题，导致我一开始没有看懂这个图是什么形状，是怎么用邻接表形式表示的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><p>如上所示，如果输入<code>[[1,3], [0,2], [1,3], [0,2]]</code>，那么这个邻接表表示的是图的节点有<code>1-&gt;3,0-&gt;2</code>，因此画出的图其实是如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_9C75CB36F198-1.jpeg" style="zoom:50%;" /></p><p>同理，如果输入<code>[[1,2,3], [0,2], [0,1,3], [0,2]]</code>，那么说明<code>1-&gt;2,1-&gt;3,0-&gt;2,0-&gt;1,0-&gt;3</code>，所以图如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_FB44338948F8-1.jpeg" style="zoom:50%;" /></p><h3 id="方法：DFS搜索着色"><a href="#方法：DFS搜索着色" class="headerlink" title="方法：DFS搜索着色"></a>方法：DFS搜索着色</h3><p>如果节点属于第一个集合，将其设置为颜色0，否则为颜色1。当这个图为二分图时，就可以使用<strong>贪心思想</strong>给图着色：比如一个节点的颜色为0，则其所有的邻接点的颜色为1，其所有的邻接点的邻接点的颜色为0，以此类推。</p><p>先找到一个未着色的节点$u$，把它染上一种颜色，比如颜色1黑色，然后遍历所有与它相连的节点$v$，如果节点$v$已经被染色并且颜色和$u$是一样的，那么就不是二分图。如果这个节点$v$没有被染色，则先把它染成与节点$u$不同的颜色，例如颜色2红色，然后再遍历所有节点$v$的邻接点，依次递推。</p><p>可以使用数组或者哈希表来记录每个节点的颜色：<code>colors[node]</code>。颜色有两种，分别为1黑色和2红色，0表示未着色。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Is_Graph_Bipartite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="comment">// 设置 color 数组，0 表示未着色，1 黑，2 红</span></span><br><span class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// Arrays.fill 方法将 color 数组中的所有元素的值设置为 0，表示未着色</span></span><br><span class="line">        Arrays.fill(colors, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(graph, i, colors, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> i, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> preColor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果未被染色</span></span><br><span class="line">        <span class="keyword">if</span> (colors[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 与相邻节点进行相反的染色</span></span><br><span class="line">            colors[i] = (preColor == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果不能够再往下递推</span></span><br><span class="line">                <span class="keyword">if</span> (!dfs(graph, graph[i][j], colors, colors[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已染色</span></span><br><span class="line">            <span class="comment">// 如果颜色和邻接点颜色一致</span></span><br><span class="line">            <span class="keyword">if</span> (colors[i] == preColor) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudSim NetworkExample1</title>
      <link href="/2020/02/02/CloudSim-NetworkExample1/"/>
      <url>/2020/02/02/CloudSim-NetworkExample1/</url>
      
        <content type="html"><![CDATA[<p>CloudSim中的Network包同样含有很多个Example。在NetworkExample1.java文件中，与Example1.java的不同，主要在于模拟之前，需要初始化网络拓扑。即有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load the network topology file</span></span><br><span class="line"><span class="comment">// 直接运行有可能会运行失败，报错找不到toplogy.brite文件</span></span><br><span class="line"><span class="comment">// 方法一：buildNetworkTopology()中的参数改为topology.brite的绝对路径</span></span><br><span class="line"><span class="comment">// 方法二：把topology.brite拷贝到项目的根目录下</span></span><br><span class="line">NetworkTopology.buildNetworkTopology(<span class="string">"topology.brite"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// maps CloudSim entities to BRITE entities</span></span><br><span class="line"><span class="comment">// PowerDatacenter will correspond to BRITE node 0</span></span><br><span class="line"><span class="keyword">int</span> briteNode=<span class="number">0</span>;</span><br><span class="line">NetworkTopology.mapNode(datacenter0.getId(),briteNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broker will correspond to BRITE node 3</span></span><br><span class="line">briteNode=<span class="number">3</span>;</span><br><span class="line">NetworkTopology.mapNode(broker.getId(),briteNode);</span><br></pre></td></tr></table></figure><a id="more"></a><p>那么，NetworkTopology这个类的作用是什么呢？</p><p>它的实现主要是根据一个brite文件建立一个网络拓扑模型，topology.brite文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Topology: ( 5 Nodes, 8 Edges ) </span><br><span class="line">Model (1 - RTWaxman): 5 5 5 1 2 0.15000000596046448 0.20000000298023224 1 1 </span><br><span class="line">10.0 1024.0 </span><br><span class="line"></span><br><span class="line">Nodes: ( 5 ) </span><br><span class="line">0 1 3 3 3 -1 RT_NODE </span><br><span class="line">1 0 3 3 3 -1 RT_NODE </span><br><span class="line">2 4 3 3 3 -1 RT_NODE </span><br><span class="line">3 3 1 3 3 -1 RT_NODE </span><br><span class="line">4 3 3 4 4 -1 RT_NODE </span><br><span class="line"></span><br><span class="line">Edges: ( 8 ) </span><br><span class="line">0 2 0 3.0 1.1 10.0 -1 -1 E_RT U </span><br><span class="line">1 2 1 4.0 2.1 10.0 -1 -1 E_RT U </span><br><span class="line">2 3 0 2.8284271247461903 3.9 10.0 -1 -1 E_RT U </span><br><span class="line">3 3 1 3.605551275463989 4.1 10.0 -1 -1 E_RT U </span><br><span class="line">4 4 3 2.0 5.0 10.0 -1 -1 E_RT U </span><br><span class="line">5 4 2 1.0 4.0 10.0 -1 -1 E_RT U </span><br><span class="line">6 0 4 2.0 3.0 10.0 -1 -1 E_RT U </span><br><span class="line">7 1 4 3.0 4.1 10.0 -1 -1 E_RT U</span><br></pre></td></tr></table></figure><p>程序运行后会寻找标记<code>Nodes</code>和<code>Edges</code>，<code>Nodes</code>是节点信息，其中第一列是节点序号，第二列是节点的横坐标，第三列是节点的纵坐标；<code>Edges</code>是边信息，第一列是边序号，第二列是始节点序号，第三列是终节点序号，第四列是边长度，第五列是边时延，第六列是边带宽。</p><p>这里有一个关键类<code>ToplogicalGraph</code>，描绘了图的拓扑的数据结构。这里面包含两个链表，分别用来存储节点<code>ToplogicalNode</code>和边<code>ToplogicalLink</code>。</p><p>在<code>ToplogicalGraph</code>中通过<code>readGraphFile</code>方法，将文件中的描述，转化为网络拓扑模型。接着用得到的网络拓扑，通过<code>generateMatrices()</code>和<code>createBwMatrix()</code>生成一个是实体间的时延矩阵和带宽矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudSim Example1</title>
      <link href="/2020/02/01/CloudSim-Example1/"/>
      <url>/2020/02/01/CloudSim-Example1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CloudSim是一个云计算基础架构和服务的建模和仿真框架，由Java语言编写，提供给研究人员做仿真实验。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li>支持大型云计算数据中心的建模和仿真</li><li>支持对虚拟服务器主机进行建模和仿真，并具有可自定义的策略，用于向虚拟机提供主机资源</li><li>支持对应用程序容器进行建模和仿真</li><li>支持能源感知计算资源的建模和仿真</li><li>支持对数据中心网络拓扑和消息传递应用程序进行建模和仿真</li><li>支持动态插入模拟元素，停止和继续模拟</li><li>支持用于将主机分配给虚拟机的用户定义策略以及用于将主机资源分配给虚拟机的资源</li></ul><a id="more"></a><h2 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h2><p>Inspect <strong>ClouldSimExample1.java</strong>. Study the code and try to get an overall feel for what it is doing (or supposed to do). You should focus on the following aspects: </p><ul><li>Virtual Machine creation </li><li>Virtual Machine description</li><li>Broker</li><li>Cloudlet</li><li>Data centre</li><li>Simulation parameter setting</li><li>Simulation output</li></ul><p><code>CloudSimExample1.java</code>主要创建了一个含有一个云主机的数据中心，并在其上运行一个云任务。以下是部分代码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudSimExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 云用户数量</span></span><br><span class="line">            <span class="keyword">int</span> num_user = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 用当前日期和时间初始化字段的日历</span></span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            <span class="comment">// 事件追踪</span></span><br><span class="line">            <span class="keyword">boolean</span> trace_flag = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 初始化 CloudSim 工具包</span></span><br><span class="line">            CloudSim.init(num_user, calendar, trace_flag);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建数据中心</span></span><br><span class="line">            Datacenter datacenter0 = createDatacenter(<span class="string">"Datacenter 0"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建 Broker 代理</span></span><br><span class="line">            DatacenterBroker broker = createBroker();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个虚拟机列表</span></span><br><span class="line">            vmlist = <span class="keyword">new</span> ArrayList&lt;Vm&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个虚拟机</span></span><br><span class="line">            Vm vm = <span class="keyword">new</span> Vm(vmid, brokerId, mips, pesNumber, ram, bw, size, vmm, <span class="keyword">new</span> CloudletSchedulerTimeShared());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将虚拟机添加到虚拟机列表中</span></span><br><span class="line">            vmlist.add(vm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将虚拟机列表提交到数据中心代理</span></span><br><span class="line">            broker.submitVmList(vmlist);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建云任务列表</span></span><br><span class="line">            cloudletList = <span class="keyword">new</span> ArrayList&lt;Cloudlet&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建云任务</span></span><br><span class="line">            Cloudlet cloudlet = <span class="keyword">new</span> Cloudlet(id, length, pesNumber, fileSize, outputSize, utilizationModel, utilizationModel, utilizationModel);</span><br><span class="line">truetruetruecloudlet.setUserId(brokerId);</span><br><span class="line">truetruetruecloudlet.setVmId(vmid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将云任务添加到列表中</span></span><br><span class="line">            cloudletList.add(cloudlet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将云任务列表提交到数据中心代理</span></span><br><span class="line">            broker.submitCloudletList(cloudletList);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 开始模拟</span></span><br><span class="line">            CloudSim.startSimulation();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 结束模拟</span></span><br><span class="line">            CloudSim.stopSimulation();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            List&lt;Cloudlet&gt; newList = broker.getCloudletReceivedList();</span><br><span class="line">            printCloudletList(newList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建数据中心</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Datacenter <span class="title">createDatacenter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建列表用于储存机器，简称主机列表</span></span><br><span class="line">        List&lt;Host&gt; hostList = <span class="keyword">new</span> ArrayList&lt;Host&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建处理器，并添加到Pe列表中</span></span><br><span class="line">        peList.add(<span class="keyword">new</span> Pe(<span class="number">0</span>, <span class="keyword">new</span> PeProvisionerSimple(mips)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建处理器，并将其添加到主机列表中</span></span><br><span class="line">        <span class="keyword">int</span> hostId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ram = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">long</span> storage = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">int</span> bw = <span class="number">10000</span>;</span><br><span class="line">        </span><br><span class="line">        hostList.add(<span class="keyword">new</span> Host(hostId, <span class="keyword">new</span> RamProvisionerSimple(ram), <span class="keyword">new</span> BwProvisionerSimple(bw), storage, peList, <span class="keyword">new</span> VmSchedulerTimeShared(peList)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建数据中心特征，它表示了数据中心的静态属性：体系架构、操作系统、主机列表、分配策略、时间或空间共享、时区、价格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Power数据中心</span></span><br><span class="line">        Datacenter datacenter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datacenter = <span class="keyword">new</span> Datacenter(name, characteristics, <span class="keyword">new</span> VmAllocationPolicySimple(hostList), storageList, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> datacenter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建代理，可以根据特定需求发展自己的代理协议来提交虚拟机和云任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DatacenterBroker <span class="title">createBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCloudletList</span><span class="params">(List&lt;Cloudlet&gt; list)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>墨染霜——曹植</title>
      <link href="/2020/01/22/%E5%A2%A8%E6%9F%93%E9%9C%9C%E2%80%94%E2%80%94%E6%9B%B9%E6%A4%8D/"/>
      <url>/2020/01/22/%E5%A2%A8%E6%9F%93%E9%9C%9C%E2%80%94%E2%80%94%E6%9B%B9%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>昔年风骨皆建安</p><p>点墨琳琅耀星汉</p><p>拂袖长歌醉青衫</p><p>夜听闲棋敲纹盘</p><p>微婉雅韵自悠然</p><a id="more"></a><p>天地初入胸臆缓登台</p><p>援笔千言尽华彩</p><p>青眼景慕庙堂寒</p><p>犹映余晖自烛堪</p><p>深恭敛退情义难</p><p>雨打江山</p><p>半纸盛藻 半枕黄粱 聚散俱无端</p><p>半生锦繁 半世离乱 杯中尽余欢</p><p>今古粲溢流年</p><p>卓尔怎居偏安</p><p>何如飘摇随长风</p><p>百载相传</p><p>为君不易 为臣独难 忠信事不显</p><p>悲歌长吟 悲风弦断 泪下冠缨沾</p><p>忆昔踌躇临轩</p><p>而今凌云志短</p><p>旦暮间参商相槛</p><p>千秋一叹</p><p>昔年征伐非沙场</p><p>俯仰沉浮尽炎凉</p><p>一朝青鸾平步升</p><p>明夕同袍隔阋墙</p><p>九重宫阙降离殃</p><p>迷津漫漫一苇独难航</p><p>若枕相思入他乡</p><p>城头不复汉时月</p><p>金銮青冥两茫茫</p><p>不如怀佩归苍黄</p><p>洛川雪扬</p><p>一步一怅 一字一憾 墨染殿前霜</p><p>一言一人 一生一心 道斯人未忘</p><p>长门火映微光</p><p>冷寂漠然空响</p><p>物是人非事亦休</p><p>七步成殇</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础（二）</title>
      <link href="/2020/01/13/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/13/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="可空和非可空类型"><a href="#可空和非可空类型" class="headerlink" title="可空和非可空类型"></a>可空和非可空类型</h2><p>在Kotlin中，对于<code>null</code>安全类型是一种消除代码中空引用风险的过程。如果Kotlin编译器发现任何<code>null</code>参数而仍然执行<code>null</code>引用相关语句，则会立即抛出<code>NullPointerException</code>。</p><p>Kotlin类型系统区分可以保持<code>null</code>（可空引用）和不能保持<code>null</code>（非<code>null</code>引用）的引用。通常，<code>String</code>类型是不可为<code>null</code>的。要创建保存<code>null</code>值的字符串，必须要放置一个<code>?</code>来明确定义。例如，<code>String?</code></p><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>通过放置一个<code>?</code>来声明可空类型<code>?</code>在String后面</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1: String? = <span class="string">"hello"</span></span><br><span class="line">str1 = <span class="literal">null</span><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>这时候<code>str1</code>可以等于<code>null</code>。</p><h3 id="非可空类型"><a href="#非可空类型" class="headerlink" title="非可空类型"></a>非可空类型</h3><p>非可空类型是普通字符串，它们声明为<code>String</code>类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: String = <span class="literal">null</span><span class="comment">// compile error</span></span><br><span class="line">str = <span class="string">"hello"</span><span class="comment">// compile error Val cannot be reassign</span></span><br><span class="line"><span class="keyword">var</span> str2: String = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="literal">null</span><span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>第一行的错误是没有将<code>str</code>定义为可空类型就令它为<code>null</code>。第二行的错误是使用<code>val</code>定义<code>str</code>，那么之后<code>str</code>的值是不可更改的。第三、四行虽然用<code>var</code>定义<code>str2</code>，但是同样没有定义为可空类型，所以不可令<code>str2 = null</code>。</p><h2 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h2><p>在没有安全转换的情况下访问可空类型的<code>String</code>时，它将生成编译错误。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string: String? = <span class="string">"Hello"</span></span><br><span class="line">print(string.length)<span class="comment">//compile error</span></span><br></pre></td></tr></table></figure><p>如上代码会报错，因为没有判断字符串是否为空。</p><p>而使用安全转换为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> string: String? = <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">if</span> (string != <span class="literal">null</span>) &#123;</span><br><span class="line">    print(string.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断string不为空后，就可以正常执行。</p><h3 id="使用is或-is来智能转换"><a href="#使用is或-is来智能转换" class="headerlink" title="使用is或!is来智能转换"></a>使用is或!is来智能转换</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> obj: Any = <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    println(<span class="string">"字符串长度：<span class="subst">$&#123;obj.length&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不安全和安全类型转换"><a href="#不安全和安全类型转换" class="headerlink" title="不安全和安全类型转换"></a>不安全和安全类型转换</h2><h3 id="不安全转换操作符：as"><a href="#不安全转换操作符：as" class="headerlink" title="不安全转换操作符：as"></a>不安全转换操作符：as</h3><p>有时无法转换变量并抛出异常，这称为不安全转换。例如，可以为空的字符串<code>String?</code>不能转换成非null字符串<code>String</code>，这会造成异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> obj: Any? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">val</span> str: String = obj <span class="keyword">as</span> String</span><br><span class="line">  println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码把<code>Any</code>类型转换为字符串类型会造成<code>ClassCastException</code>异常。</p><h3 id="安全转换操作符：as"><a href="#安全转换操作符：as" class="headerlink" title="安全转换操作符：as?"></a>安全转换操作符：as?</h3><p>Kotlin提供一种安全转换操作符：<code>as?</code>。如果无法进行转换，则返回<code>null</code>，而不是抛出异常。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> location: Any = <span class="string">"Kotlin"</span></span><br><span class="line">  <span class="keyword">val</span> safeString: String? = location <span class="keyword">as</span>? String</span><br><span class="line">  <span class="keyword">val</span> safeInt: <span class="built_in">Int</span>? = location <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">  println(safeString)</span><br><span class="line">  println(safeInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码得到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kotlin</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>因为<code>Any</code>类型的<code>Kotlin</code>可以转换成<code>String</code>类型但是不能转换成<code>Int</code>类型，所以第二个输入为<code>null</code>。</p><h2 id="Elvis运算符"><a href="#Elvis运算符" class="headerlink" title="Elvis运算符"></a>Elvis运算符</h2><p>Elvis运算符用来返回非<code>null</code>值，即使条件表达式为<code>null</code>。可以用来<strong>检查值的空安全性</strong>。</p><p>假设一个包含空引用的变量<code>str</code>，在程序中使用<code>str</code>之前要检查它的可空性。如果发现变量<code>str</code>不为<code>null</code>，则其属性可以使用，否则就得返回其它非空值。<strong>（总之不能返回<code>null</code>）</strong>。</p><p>Kotlin还提供称为Elvis运算符(<code>?:</code>)的高级运算符，即使条件表达式为空，也返回非空值。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> str2: String? = <span class="string">"nullable string"</span></span><br><span class="line"><span class="keyword">var</span> len1: <span class="built_in">Int</span> = str?.length ?: -<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> len2: <span class="built_in">Int</span> = str2?.length ?: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过Elvis运算符就相当于使用传统的<code>if...else</code>语句执行此安全检查。</p><p>上述代码通过判断<code>str</code>是否为空，如果为空，就返回正常的<code>str.length</code>，否则返回<code>?:</code>后的值-1。</p><p>除此之外，Elvis运算符后还可以使用<code>throw</code>和<code>return</code>表达式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text1 = text1 ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> text2 = text2 ?: IllegalArgumentException(<span class="string">"text exception"</span>)</span><br></pre></td></tr></table></figure><h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><p>Kotlin类不支持静态方法和成员，但是Kotlin支持全局函数和变量，所以可以直接使用全局函数和变量来代替类中静态方法和静态成员变量。</p><p>Kotlin中有一个有趣的语法糖：<code>Objects</code>。它可以解决由于没有<code>static</code>而造成的麻烦。</p><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>指类中所有的方法都为静态方法的情况，例如工具类一般是静态类。</p><p><strong>把类名<code>class</code>改成<code>object</code>即可</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DateUtil &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>这里又要引入Kotlin另一个语法糖：<code>Companion Objects</code>。在类的内部可以用<code>companion object{}</code>包裹所需的静态方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">"LoginActivity"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>companion object</code>中定义的成员变量就可以通过类名直接访问。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Longest Substring Without Repeating Characters</title>
      <link href="/2020/01/12/3.Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2020/01/12/3.Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>无重复字符的最长子串</strong></p><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="方法一：暴力法-Naive-brute-force"><a href="#方法一：暴力法-Naive-brute-force" class="headerlink" title="方法一：暴力法(Naive brute force)"></a>方法一：暴力法(Naive brute force)</h3><p>可以使用暴力法逐个检查所有的子字符串，然后记录长度，最终选择长度最大的。</p><p>因为字符长度为$n$的字符串，会有$n^2$个<code>subString</code>，然后检查每一个<code>subString</code>中是否含有重复字符又得遍历该<code>subString</code>,所以又需要$O(n)$，所以总的时间复杂度就是$O(n^3)$。</p><p>首先写一个对获得不重复子字符串的方法。定义一个HashSet，然后对字符串进行遍历操作，如果HashSet中不含有该元素，就添加到HashSet中；如果有，就返回false。</p><p>然后使用两层循环，去判断是否是不重复子串并记录长度。假设开始和结束的索引分别为i和j，那么就使用i从0~n-1以及j从i+1~n这两个嵌套的循环，就可以枚举出所有的子字符串。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.暴力法</span></span><br><span class="line"><span class="comment"> * 返回最长子穿的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// n是字符串的长度</span></span><br><span class="line">    <span class="keyword">val</span> n = s.length</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allUnique(s, i, j)) &#123;</span><br><span class="line">                ans = Math.max(ans, j - i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">allUnique</span><span class="params">(s: <span class="type">String</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashSet: HashSet&lt;<span class="built_in">Char</span>&gt; = HashSet();</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start until end) &#123;</span><br><span class="line">        <span class="keyword">val</span> ch = s[i]</span><br><span class="line">        <span class="comment">// 如果HashSet中含有该元素，就返回false</span></span><br><span class="line">        <span class="keyword">if</span> (hashSet.contains(ch)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果HashSet中不含有该元素，就添加到这个HashSet中</span></span><br><span class="line">        hashSet.add(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n^3)$</p><p>这里使用了三层循环，遍历了三次字符串。所以时间复杂度显然是$O(n^3)$。</p></li><li><p><strong>空间复杂度：</strong>$O(k)$</p><p>因为需要$O(k)$的空间来检查子字符串中是否有重复字符，其中k表示的是HashSet的大小。</p></li></ul><p>但暴力法的效率实在太低，当长度过长时可能会出现<strong>TLE</strong>(Time Limit Exceeded)。不推荐使用。</p><h3 id="方法二：滑动窗口-Sliding-Window"><a href="#方法二：滑动窗口-Sliding-Window" class="headerlink" title="方法二：滑动窗口(Sliding Window)"></a>方法二：滑动窗口(Sliding Window)</h3><p>在暴力法中，枚举出所有子字符串之后，第3步要<strong>从首到尾的元素</strong>去检查每一个子字符串是否有重复元素。</p><p>但其实没有必要遍历一个子字符串的所有元素。</p><p>例如：字符串qwekq，子字符串qwe、qwek等。</p><p>如果子字符串qwe已经检查过是没有重复元素的，那么在检查qwek时，就没有必要从头到尾，将qwe之间再检查一遍。只需要检查新添加的元素k是否与之前的字符串有重复元素即可。</p><p>即，<strong>如果从索引i到j-1之间的子字符串$S_{ij}$已经被检查为没有重复字符，只需要检查$S[j]$对应的字符是否已经存在于子字符串$S_{ij}$中。</strong></p><p><strong>窗口</strong>通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即$[i,j)$。滑动窗口是可以将两个边界向某一方向<strong>“滑动”</strong>的窗口。滑动窗口通常用来求解数组和<code>String</code>。</p><p>例如：将$[i,j)$向右滑动1个元素$\Rightarrow[i+1,j+1)$</p><p>所以，这题可以使用HashSet将字符存储在当前窗口$[i,j)$（最初j=i）中，然后向右滑动索引j，如果它不在HashSet中，继续滑动j，直到$S[j]$已经存在于HashSet中。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>一个字符串abcb，求最大子串。</p><p>n等于字符串长度等于4，然后令ans=0，i=0，j=0。</p><ol><li>因为初始的HashSet为空，所以肯定不含有$S[j]$即$S[0]$。所以把$S[0]$添加到HashSet中，然后j++。这时候ans=max(0, j-i)=max(0,1)=1。Set中有[a]。</li><li>$S[1]$为b，HashSet不含有，则把$S[1]$添加到HashSet中，然后j++。这时候ans=max(1,j-i)=max(1,2-0)=2。Set中有[a,b]。</li><li>$S[2]$为c，HashSet中没有，则把$S[2]$添加到HashSet中，然后j++。这时候ans=max(2,3-0)=3。Set为[a,b,c]。</li><li>$S[3]$为b，HashSet中已经含有b，因此<code>set.remove(s[0])</code>，然后i++。即把HashSet的第一个元素a去掉，这时候Set为[b,c]。</li><li>接着进行判断，$S[3]$是b，HashSet中仍然含有b，所以<code>set.remove(s[1])</code>，然后i++。这样就是把HashSet的第二个元素b去掉了。</li><li>接着判断，$S[3]$是b，这时候HashSet已经不包含b了。所以把b添加到Set中，然后j++。这时候j=4，已经不能再进行下一次循环了。这时候的Set是[c,b]，ans=max(3, 4-2)=3。</li><li>所以最终得到的最长子串的长度是3。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.滑动窗口</span></span><br><span class="line"><span class="comment"> * 返回最长子串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = s.length</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span>: HashSet&lt;<span class="built_in">Char</span>&gt; = HashSet()</span><br><span class="line">    <span class="comment">// 默认长度为0，i和j从0开始向右移</span></span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">set</span>.contains(s[j])) &#123;</span><br><span class="line">            <span class="keyword">set</span>.add(s[j++])</span><br><span class="line">            print(<span class="keyword">set</span>)</span><br><span class="line">            ans = Math.max(ans, j - i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">set</span>.remove(s[i++])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)=O(2n)$</p><p>可以从代码中看出，使用while进行了一次遍历，长度是n。但是因为条件是<code>i &lt; n &amp;&amp; j &lt; n</code>，所以最坏的情况下可能判断了两遍n，即从i遍历到n和由j遍历到n。所以最坏情况的时间复杂度是$O(2n)$。</p></li><li><p><strong>空间复杂度</strong>：$O(k)$</p><p>滑动窗口法仍然需要$O(k)$的空间，其中k的表示Set的大小。</p></li></ul><h3 id="方法三：优化的滑动窗口"><a href="#方法三：优化的滑动窗口" class="headerlink" title="方法三：优化的滑动窗口"></a>方法三：优化的滑动窗口</h3><p>从方法二的例子的步骤分析上就可以看出，<strong>步骤4-6</strong>其实有一些冗余。当发现$S[j]$在$[i,j)$范围有重复字符时，不需要让i=0开始，使用i++逐步增加i，可以直接跳过$[i,j’]$范围内的所有元素，并将i变成j’+1。</p><h4 id="图解（转载至LeetCode：灵魂画师牧码）"><a href="#图解（转载至LeetCode：灵魂画师牧码）" class="headerlink" title="图解（转载至LeetCode：灵魂画师牧码）"></a>图解（转载至LeetCode：灵魂画师牧码）</h4><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7c6K.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se76l6.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7ySx.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7gOO.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7rf1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7RmD.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7W0e.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring3</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = s.length</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> map: HashMap&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt; = HashMap()</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s[j])) &#123;</span><br><span class="line">            i = Math.max(map.getValue(s[j]), i)</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        map.put(s[j], j + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)$</p><p>可以很明显看到，j由0遍历到n，循环了n次。</p></li><li><p><strong>空间复杂度：</strong>$O(k)$</p><p>滑动窗口法仍然需要$O(k)$的空间，其中k的表示Set的大小。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础（一）</title>
      <link href="/2020/01/12/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/12/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fun main(args: Array&lt;String&gt;)</code>也可以直接写成<code>fun main()</code>。</p><a id="more"></a><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在Kotlin中，使用关键字<code>var</code>和<code>val</code>声明变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language = <span class="string">"Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> salary = <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>Kotlin中不需要明确指定变量的类型。Kotlin编译器通过<code>initilizer</code>表达式自动识别推断变量的类型。当然，在声明变量时也可以明确指定变量的类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language: String = <span class="string">"Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> salary: <span class="built_in">Int</span> = <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="关键字var和val的区别"><a href="#关键字var和val的区别" class="headerlink" title="关键字var和val的区别"></a>关键字var和val的区别</h3><ul><li>val用来定义常量，即恒定不变的量。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constant = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>var定义变量，即可变动的量。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable = <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="如何分清"><a href="#如何分清" class="headerlink" title="如何分清"></a>如何分清</h4><p>如果不清楚什么时候使用常量什么时候使用变量时，可以优先使用常量val，如果IDE提示错误则改为var。</p><p>当使用val定义为常量时，常量是不能变动的，只能为其赋值一次。所以如果要改变它的值，需要使用var改成变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = &quot;abc&quot; =&gt; public String str = &quot;abc&quot;</span><br><span class="line">val str: String = &quot;abc&quot; =&gt; public final String str = &quot;abc&quot;</span><br></pre></td></tr></table></figure><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>实际上，val表示的是<strong>只读（read-only）</strong>，即不能再将值写入val，并不意味着其是不可变的。</p><p>在Kotlin的类中，val和var用于表示属性是否有getter/setter：</p><ul><li>var：同时有getter和setter</li><li>val：只有getter</li></ul><h3 id="lateinit和lazy"><a href="#lateinit和lazy" class="headerlink" title="lateinit和lazy"></a>lateinit和lazy</h3><p>如果不想在一开始就对一个属性进行初始化，那么可以使用以下两个关键字。</p><ul><li>lateinit</li><li>lazy</li></ul><h4 id="lateint"><a href="#lateint" class="headerlink" title="lateint"></a>lateint</h4><p>通常情况下，声明为非null类型的属性必须初始化，可以使用<code>lateinit</code>修饰符修饰属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user: User</span><br></pre></td></tr></table></figure><ul><li><code>lateinit</code>只能用于<code>var</code>声明的类变量，并且属性没有自定义<code>getter</code>和<code>setter</code>方法</li><li>属性的类型必须是非空的，并且不能是原始类型</li></ul><h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p><code>lazy()</code>是一个函数，它接收一个<code>lambda</code>并返回一个<code>lazy</code>实例，它可以作为一个实现<code>lazy</code>属性的委托。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String <span class="keyword">by</span> lazy &#123;<span class="string">"Android Developer"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><code>lazy</code>只能用于<code>val</code>属性，而<code>lateinit</code>只能用于<code>var</code>属性</li><li><code>lateinit var</code>可以从任何能看到对象的地方进行初始化。如果想要属性在外部被初始化，可以使用<code>lateinit</code></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数字类型</li><li>字符类型</li><li>布尔类型</li><li>数组类型</li><li>字符串类型</li></ul><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>分为整数和浮点数。</p><ul><li>Byte</li><li>Short</li><li>Int</li><li>Long</li><li>Float</li><li>Double</li></ul><h3 id="字符类型-Char"><a href="#字符类型-Char" class="headerlink" title="字符类型(Char)"></a>字符类型(Char)</h3><p>使用关键字<code>char</code>表示，使用单引号<code>&#39;&#39;</code>声明。</p><h3 id="布尔数据类型-Boolean"><a href="#布尔数据类型-Boolean" class="headerlink" title="布尔数据类型(Boolean)"></a>布尔数据类型(Boolean)</h3><p>使用关键字<code>Boolean</code>表示，包含<code>true</code>和<code>false</code>。</p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>Kotlin中的数组用<code>Array</code>表示。使用库函数<code>arrayOf()</code>和<code>Array()</code>构造函数创建数组。<code>Array</code>中有<code>get()</code>、<code>set()</code>函数，<code>size</code>属性等。</p><h4 id="使用arrayOf创建数组"><a href="#使用arrayOf创建数组" class="headerlink" title="使用arrayOf创建数组"></a>使用<code>arrayOf</code>创建数组</h4><p>例如<code>arrayOf(1,2,3)</code>，它创建一个数组<code>[1,2,3]</code>。通过索引值<code>array[index]</code>访问数组的元素，索引从0开始。</p><h4 id="使用Array-创建数组"><a href="#使用Array-创建数组" class="headerlink" title="使用Array()创建数组"></a>使用<code>Array()</code>创建数组</h4><p>使用<code>Array()</code>构造函数创建数组时，需要在<code>Array()</code>构造函数中使用两个参数：</p><ul><li>第一个参数作为数组的大小</li><li>第二个参数作为函数，用于初始化并返回给定索引的数组元素的值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123;i -&gt; i * <span class="number">2</span>&#125;) <span class="comment">// asc[0,2,4,6,8]</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>使用<code>String</code>表示。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><code>toByte()</code></li><li><code>toShort()</code></li><li><code>toInt()</code></li><li><code>toLong()</code></li><li><code>toFloat()</code></li><li><code>toDouble()</code></li><li><code>toChar()</code></li></ul><h2 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h2><p>Kotlin中的<code>when</code>表达式相当于<code>switch</code>语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> numberProvided = <span class="keyword">when</span>(number) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">"One"</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">"Two"</span></span><br><span class="line">    <span class="number">3</span> -&gt; <span class="string">"Three"</span></span><br><span class="line">    <span class="number">4</span> -&gt; <span class="string">"Four"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"invalid number"</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"You provide <span class="variable">$numberProvided</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">5</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Add Two Numbers</title>
      <link href="/2020/01/11/2.Add-Two-Numbers/"/>
      <url>/2020/01/11/2.Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>两树相加</strong></p><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p></blockquote><a id="more"></a><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>这道题主要考察了两个知识点。第一个就是<strong>链表</strong>，链表的遍历和链表的创建。第二个就是高精度加法的模拟，因为题目中数字的长度<strong>其实可以很长</strong>。</p><h3 id="方法：初等数学"><a href="#方法：初等数学" class="headerlink" title="方法：初等数学"></a>方法：初等数学</h3><p>用初等数学的方法，相当于进行<strong>加法</strong>的计算。</p><p>上图的carry=1的意思是，前一位4+6=10进了1位，所以进位让carry从默认值0变为1。然后3+4+1=8。</p><h4 id="图解（转载至LeetCode：灵魂画师牧码）"><a href="#图解（转载至LeetCode：灵魂画师牧码）" class="headerlink" title="图解（转载至LeetCode：灵魂画师牧码）"></a>图解（转载至LeetCode：灵魂画师牧码）</h4><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seTzQK.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7SsO.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seTvz6.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seTjRx.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seTXJ1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7pLD.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7Cee.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/se7PdH.png" alt=""></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><ul><li>将进位值carry设置为0</li><li>将p和q分别初始化为$l_1$和$l_2$的头部</li><li>遍历$l_1$和$l_2$直至到达它们的尾端<ul><li>将x设置为结点p的值。如果p已经到达$l_1$的末尾，则将其值设置为0</li><li>将y设置为结点q的值。如果q已经到达$l_2$的末尾，则将其值设置为0</li><li>设定sum=x+y+carry</li><li>carry=sum/10，将carry取整。这里的carry要么为0，要么为1</li><li>创建一个数值为(sum mod 10)的新结点（mod为求余数），将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点</li><li>同时，将p和q前进到下一个结点</li></ul></li><li>检查carry=1是否成立（可以通过判断carry是否大于0），如果成立，则追加一个为1的新结点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dummy = tail = ListNode(0)</span><br><span class="line">while l1 or l2 or carry:</span><br><span class="line">truesum = l1?.val + l2?.val + carry</span><br><span class="line">truetail.next = ListNode(sum % 10)</span><br><span class="line">truetail = tail.next</span><br><span class="line">truecarry = sum /= 10</span><br><span class="line">truel1, l2 = l1?.next, l2?.next</span><br><span class="line">return dummy.next</span><br><span class="line"></span><br><span class="line">Time complexity: O(max(n,m))</span><br><span class="line">Space complexity: O(max(n,m))</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> medium._002</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You may assume the two numbers do not contain any leading zero, except the number 0 itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span></span><br><span class="line"><span class="comment"> * Output: 7 -&gt; 0 -&gt; 8</span></span><br><span class="line"><span class="comment"> * Explanation: 342 + 465 = 807.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> head = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> p = l1</span><br><span class="line">    <span class="keyword">var</span> q = l2</span><br><span class="line">    <span class="keyword">var</span> curr: ListNode? = head</span><br><span class="line">    <span class="comment">// 进位carry初始化为0</span></span><br><span class="line">    <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果p不为空，将x设为结点p的值；如果p已到达l1的末尾，则p=null，则x=0</span></span><br><span class="line">        <span class="keyword">val</span> x = p?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">        <span class="comment">// q同理</span></span><br><span class="line">        <span class="keyword">val</span> y = q?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> sum = x + y + carry</span><br><span class="line">        <span class="comment">// 将carry取整</span></span><br><span class="line">        carry = sum / <span class="number">10</span></span><br><span class="line">        curr!!.next = ListNode(sum % <span class="number">10</span>)</span><br><span class="line">        curr = curr.next</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">            q = q.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查carry是否等于1</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr!!.next = ListNode(carry)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> last</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">(last: <span class="type">ListNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> last = last</span><br><span class="line">    <span class="keyword">while</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是最后一位，则不输出逗号，</span></span><br><span class="line">        <span class="keyword">if</span> (last.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            print(last.`<span class="keyword">val</span>`)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是最后，则输入逗号，分隔</span></span><br><span class="line">            print(last.`<span class="keyword">val</span>`.toString() + <span class="string">","</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        last = last.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 原测试用例：l1=[2,4,3]，l2=[5,6,4]，输出结果为[7,0,8]</span></span><br><span class="line">    <span class="keyword">val</span> l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">    l1.next = ListNode(<span class="number">4</span>)</span><br><span class="line">    l1.next!!.next = ListNode(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">    l2.next = ListNode(<span class="number">6</span>)</span><br><span class="line">    l2.next!!.next = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 测试用例1：l1=[0,1]，l2=[0,1,2]，输出结果应为[0,2,2]</span></span><br><span class="line"><span class="comment">//        ListNode l1 = new ListNode(0);</span></span><br><span class="line"><span class="comment">//        l1.next = new ListNode(1);</span></span><br><span class="line"><span class="comment">//        ListNode l2 = new ListNode(0);</span></span><br><span class="line"><span class="comment">//        l2.next = new ListNode(1);</span></span><br><span class="line"><span class="comment">//        l2.next.next = new ListNode(2);</span></span><br><span class="line"><span class="comment">// 测试用例2：l1=[]，l2=[0,1]，输出结果为[0,1]</span></span><br><span class="line"><span class="comment">//        ListNode l1 = new ListNode();</span></span><br><span class="line"><span class="comment">//        ListNode l2 = new ListNode(0);</span></span><br><span class="line"><span class="comment">//        l2.next = new ListNode(1);</span></span><br><span class="line"><span class="comment">// 测试用例l3：l1=[9,9]，l2=[1]，输出结果为[0,0,1]</span></span><br><span class="line"><span class="comment">//        ListNode l1 = new ListNode(9);</span></span><br><span class="line"><span class="comment">//        l1.next = new ListNode(9);</span></span><br><span class="line"><span class="comment">//        ListNode l2 = new ListNode(1);</span></span><br><span class="line">    printList(addTwoNumbers(l1, l2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListNode是自己定义的Java中的链表对象</span></span><br><span class="line"><span class="comment"> * 类结构如下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> `<span class="keyword">val</span>`: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: ListNode? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        `<span class="keyword">val</span>` = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        `<span class="keyword">val</span>` = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `<span class="keyword">val</span>`<span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> `<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(max(m,n))$</p><p>该算法使用了一次whlie循环，且判断条件是<code>p != null || q != null</code>。假设链表p和q的长度分别为m和n，则该循环最多重复$max(m,n)$次。</p></li><li><p><strong>空间复杂度</strong>：$O(max(m,n))$</p><p>新链表的长度也同样取决于p和q的长度，但由于相加后有可能产生进位，所以长度可能加1。所以长度最多为$max(m,n)+1$。</p><p>如果仅仅是把结果打印出来，那么空间复杂度就是$O(1)$，因为不需要额外的存储。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Two Sum</title>
      <link href="/2020/01/10/1.Two-Sum/"/>
      <url>/2020/01/10/1.Two-Sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>两树之和</strong></p><p>Give an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:</p><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,</p><p>return [0, 1].</p></blockquote><a id="more"></a><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>暴力法就是遍历每个元素x，并查找是否存在一个值与target-x相等的目标元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j &amp;&amp; (nums[i] + nums[j] == target)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Two numbers: "</span> + nums[j] + <span class="string">" and "</span> + nums[i]);</span><br><span class="line">                System.out.println(<span class="string">"Indices of the two numbers: "</span> + j + <span class="string">" and "</span> + i);</span><br><span class="line">                <span class="keyword">return</span> nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n^2)$</p><p>对于每个元素，通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费$O(n)$的时间。所以两个循环遍历的时间复杂度为$O(n^2)$。</p></li><li><p><strong>空间复杂度：</strong>$O(1)$。</p></li></ul><h3 id="方法二：两遍哈希表"><a href="#方法二：两遍哈希表" class="headerlink" title="方法二：两遍哈希表"></a>方法二：两遍哈希表</h3><p>因为该题是检查数组中是否存在目标元素满足条件。如果满足，则找出该目标元素的索引。所以可以使用<strong>哈希表</strong>来保持数组中的每个元素与其索引相互对应（键值对）。</p><p>使用两次迭代。在第一次迭代中，将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，将检查每个元素所对应的目标元素(target-nums[i])是否存在于表中（该目标元素不能是nums[i]本身）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Two numbers: "</span> + nums[i] + <span class="string">" and "</span> + complement);</span><br><span class="line">            System.out.println(<span class="string">"Indices of the two numbers: "</span> + i + <span class="string">" and "</span> + map.get(complement));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(complement)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)$</p><p>从代码中可以看到，运行了两次<code>for (int i = 0; i &lt; nums.length; i++)</code>代码，即将n个元素遍历的两次。但是因为哈希表将查找的时间降低到$O(1)$，所以时间复杂度是$O(n)$。</p></li><li><p><strong>空间复杂度：</strong>$O(n)$</p><p>所需的空间是因为定义了一个哈希表存储数组的元素及其索引。所以空间大小取决于哈希表中存储的元素数量，即n个元素。所以是$O(n)$。</p></li></ul><h3 id="方法三：一遍哈希表"><a href="#方法三：一遍哈希表" class="headerlink" title="方法三：一遍哈希表"></a>方法三：一遍哈希表</h3><p>观察方法二的代码，发现其实运行了两遍<code>for (int i = 0; i &lt; nums.length; i++)</code>代码，所以其实可以一次就完成。</p><p>首先创建一个map，然后在数组中进行循环，令complement=target-nums[i]。如果map中含有complement，就已找到目标元素。如果没有找到，那么就把这个元素的索引和值都添加到map中。</p><p>所以，其实一开始的时候是肯定找不到目标元素的，因为map中并没有蒜素。等到map中添加了两个元素和索引之后，map中就有可能含有正好等于差的complement了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Two numbers: "</span> + complement + <span class="string">" and "</span> + nums[i]);</span><br><span class="line">            System.out.println(<span class="string">"Indices of the two numbers: "</span> + map.get(complement) + <span class="string">" and "</span> + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(complement), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)$</p><p>与方法二同理。</p></li><li><p><strong>空间复杂度：</strong>$O(n)$</p><p>空间仍然是需要元素的数量n去用哈希表进行存储。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP完全性证明</title>
      <link href="/2019/12/24/NP%E5%AE%8C%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/"/>
      <url>/2019/12/24/NP%E5%AE%8C%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="NP完全性的证明"><a href="#NP完全性的证明" class="headerlink" title="NP完全性的证明"></a>NP完全性的证明</h2><p><strong>引理</strong>：如果语言L是一种满足对任意$L’\in NPC$都有$L’\le_{p}L$的语言，则L是NP-hardness。此外，如果$L\in NP$，则$L\in NPC$。</p><p><strong>证明</strong>：</p><p>$\because L’\in NPC\\<br>\therefore 对于所有L’’\in NP，都有L’’\le _{p}L’\\<br>根据假设，L’\le _{p}L\\<br>\therefore 根据传递性，L’’\in _{p}L\\<br>\therefore L是NP-hardness\\<br>那么，如果L\in NP，且L是NP-hardness\\<br>\therefore L\in NPC$</p><a id="more"></a><h3 id="证明某种语言L是NP完全问题的方法"><a href="#证明某种语言L是NP完全问题的方法" class="headerlink" title="证明某种语言L是NP完全问题的方法"></a>证明某种语言L是NP完全问题的方法</h3><ol><li>证明$L\in NP$</li><li>选取一种已知的NP完全语言L’</li><li>描述一种可计算函数f(x)的算法，其中f可将L’中每一个实例$x\in \left\{0,1\right\}^*$映射为L中的实例$f(x)$</li><li>证明函数f满足$x\in L’$当前仅当对于所有的$x\in \left\{0,1\right\}^*$都有$f(x)\in L$</li><li>证明计算函数$f(x)$的算法具有多项式运行时间</li></ol><p>第2步~第5步是为了证明L是NP-hardness，然后结合第一步的L是NP问题，就可以得出$L\in NPC$。</p><h2 id="典型NPC问题"><a href="#典型NPC问题" class="headerlink" title="典型NPC问题"></a>典型NPC问题</h2><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/wkGF648EsRtgl3B.png" alt="一些典型的NPC问题"></p><ul><li><strong>SAT</strong>：布尔公式的可满足性问题</li><li><strong>3-CNF-SAT</strong>：3合取范式的布尔公式的可满足性问题</li><li><strong>团问题CLIQUE</strong>：寻找无向图中的最大团</li><li><strong>顶点覆盖问题VERTEX COVER</strong>：在无向图中找出最小规模的顶点覆盖</li><li><strong>哈密顿回路问题HAM-CYCLE</strong>：无向图中是否存在哈密顿回路，即通过每个顶点的简单回路</li><li><strong>旅行商问题TSP</strong>：寻找通过无向图每个顶点一次的最小回路</li><li><strong>子集和问题SUBSET-SUM</strong>：给定正整数集合和正整数t，判断是否存在一个子集的元素和为t</li></ul><h2 id="布尔组合电路"><a href="#布尔组合电路" class="headerlink" title="布尔组合电路"></a>布尔组合电路</h2><p>布尔组合电路由一个或多个布尔组合元素通过线路连接而成，布尔组合电路是不包括回路的。</p><p>一个布尔组合电路的<strong>真值赋值</strong>是指一组布尔输入值。如果一个单输出布尔组合电路具有可满足性赋值，则称该布尔组合电路是可满足的。</p><p>布尔值取自集合$\left\{0,1\right\}$，0代表false，1代表true。</p><p>布尔组合元素称为逻辑门：$\begin{cases}与门\quad AND\\或门\quad OR\\非门\quad NOT\end{cases}$</p><p>For example：</p><ol><li>对此电路的输入赋值$<x_1=1, x_2=1, x_3=0>$，使得电路的输出为1，那么电路是可满足的。</li><li>如果对此电路输入的任何一种赋值都不能使得输出为1，则电路不满足。</li></ol><h3 id="NP完全性证明"><a href="#NP完全性证明" class="headerlink" title="NP完全性证明"></a>NP完全性证明</h3><p>给定一个电路C，通过检查输入的所有可能赋值来确定它是否来自可满足性电路。</p><p>那么，如果有k个输入，就有检查$2^k$种可能，因为$\begin{cases}1\\0\end{cases}$</p><p>所以当电路C的规模为k的多项式时，对每个电路的检查要花费$\Omega(2^k)$的时间，呈多项式关系。</p><p>$\therefore$ 该问题是NP完全的</p><h2 id="布尔可满足性问题SAT"><a href="#布尔可满足性问题SAT" class="headerlink" title="布尔可满足性问题SAT"></a>布尔可满足性问题SAT</h2><p><strong>定理</strong>：布尔公式的可满足性问题是NP完全的。</p><p><strong>证明</strong>：</p><ol><li>证明$SAT\in NP$，即证明对于输入公式$\phi$，由它的一个可满足性赋值所组成的证书可以在多项式时间内得到验证</li><li>证明$CIRCUIT-SAT\le _{p}SAT$从而得出SAT是NP-hard</li><li>根据语言$L\in NP$且$L\in NP-hard$能推出$L\in NPC$，得证</li></ol><h2 id="3-CNF可满足性"><a href="#3-CNF可满足性" class="headerlink" title="3-CNF可满足性"></a>3-CNF可满足性</h2><p>即布尔公式中的一个文字（literal）是指一个变量或非“$\neg$”。</p><h3 id="合取范式"><a href="#合取范式" class="headerlink" title="合取范式"></a>合取范式</h3><p>如果一个布尔公式可以表示为所有子句的“与”，并且每个字句都是一个或多个文字的“或”，则称该布尔公式为合取范式。</p><p>如果每个字句恰好有三个不同的<strong>“文字”</strong>，则该布尔公式为3合取范式，即3-CNF。</p><p>For example：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kZuHzcObLqvSj9h.png" alt="合取范式"></p><p><strong>定理</strong>：3合取范式形式的布尔公式的可满足性是NP完全的。</p><p><strong>证明</strong>：要证明$3-CNF-SAT\le NP$，仅需证明$SAT\le _{p}3-CNF-SAT$。</p><h2 id="团问题CLIQUE"><a href="#团问题CLIQUE" class="headerlink" title="团问题CLIQUE"></a>团问题CLIQUE</h2><p>无向图G=(V,E)的团(clique)是一个顶点子集$V’\subseteq V$，其中每一对顶点之间都由E中的一条边来连接。</p><p>一个团是G中的一个完全子图，<strong>图的规模是指它所包含的顶点数</strong>。</p><p>团问题就是关于寻找图中规模最大的团的优化问题。</p><p>事实上，团问题的有效算法是不大可能存在的。因为要确定一个具有$|V|$个顶点的无向图G=(V,E)是否包含一个规模为k的团，有一种朴素算法：</p><p>列出V的所有规模为k的子集，对其中的每一个进行检查，看它是否是一个团。这个算法的运行时间是与k有关。如果k是常数，那么该算法的运行时间是多项式时间的。然而，在一般情况下，k可能接近于$|V|/2$。这样的话，运行时间就是超多项式时间。所以，团问题的有效算法是不大可能存在的。</p><h3 id="形式语言定义"><a href="#形式语言定义" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$CLIQUE=\left\{<G,k>:G是一个包含规模为k的团的图\right\}$</p><p><strong>定理</strong>：$CLIQUE\subseteq NP-Complete$</p><p><strong>证明</strong>：首先，证明$CLIQUE\in NP$。然后，证明$CLIQUE\in NP-hard$</p><ol><li>对于一个给定的图G=(V,E)，用图中顶点集$V’\subseteq V$作为G的一个证书。对于任意一对顶点$\mu,\nu\in V’$，通过检查边$(\mu,\nu)$是否属于E，就可以在多项式时间内确定V’是否是团。</li><li>通过证明$3-CNF-SAT\le _{p}CLIQUE$来说明$CLIQUE\in NP-hard$。</li></ol><h2 id="顶点覆盖问题Vertex-Cover"><a href="#顶点覆盖问题Vertex-Cover" class="headerlink" title="顶点覆盖问题Vertex Cover"></a>顶点覆盖问题Vertex Cover</h2><p>无向图G=(V,E)的顶点覆盖是一个子集$V’\subseteq V$，满足如果有$(\mu,\nu)\in E$，则$\mu\in V’$或$\nu\in V’$（或两者同时成立）。</p><p>顶点覆盖的规模是指它所包含的顶点数。顶点覆盖问题就是在一个给定的图中，找出具有最小规模的顶点覆盖。</p><h3 id="形式语言定义-1"><a href="#形式语言定义-1" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$VERTEX-COVER=\left\{<G,k>:图G有一个规模为k的顶点覆盖\right\}$</p><p><strong>定理</strong>：$VC\subseteq NP-Complete$</p><p><strong>证明</strong>：首先，证明$VC\in NP$。然后证明$CLIQUE\le _{p}VC$从而得到$VC\in NP-hard$</p><h2 id="哈密顿回路问题HAM-CYCLE"><a href="#哈密顿回路问题HAM-CYCLE" class="headerlink" title="哈密顿回路问题HAM-CYCLE"></a>哈密顿回路问题HAM-CYCLE</h2><p><strong>定理</strong>：哈密顿回路问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$HAM-CYCLE\in NP$。然后通过证明$VC\le _{p}HAM-CYCLE$从而得到$HAM-CYCLE\in NP-hard$</p><h2 id="旅行商问题TSP"><a href="#旅行商问题TSP" class="headerlink" title="旅行商问题TSP"></a>旅行商问题TSP</h2><h3 id="形式语言定义-2"><a href="#形式语言定义-2" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$TSP=\left\{<G,c,k>:G=(V,E)是一个完全图，c是V*V\rightarrow Z上的一个函数，k\in Z，G中包含一个最大花费为k的旅行回路。\right\}$</p><p><strong>定理</strong>：旅行商问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$TSP\in NP$。然后通过证明$HAM-CYCLE\le _{p}TSP$从而得到$TSP\in NP-hard$</p><h2 id="子集和问题SUBSET-SUM-problem"><a href="#子集和问题SUBSET-SUM-problem" class="headerlink" title="子集和问题SUBSET-SUM problem"></a>子集和问题SUBSET-SUM problem</h2><p>给定一个正整数有限集S和一个整数目标t&gt;0，问是否存在一个子集$S’\subseteq S$，其元素和为t。</p><h3 id="形式语言定义-3"><a href="#形式语言定义-3" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$SUBSET-SUM=\left\{<S,t>:存在一个子集S’\subseteq S，使得t= \sum\limits_{S\in S’}S\right\}$</p><p><strong>定理</strong>：子集和问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$SUBSET-SUM\in NP$。然后，通过证明$3-CNF-SAT\le _{p}SUBSET-SUM$从而得到$SUBSET-SUM\in NP-hard$</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fault Tolerance</title>
      <link href="/2019/12/23/Fault%20Tolerance/"/>
      <url>/2019/12/23/Fault%20Tolerance/</url>
      
        <content type="html"><![CDATA[<h2 id="容错性描述"><a href="#容错性描述" class="headerlink" title="容错性描述"></a>容错性描述</h2><p>容错与可靠性（dependability）紧密相关。</p><ul><li><strong>可用性</strong>(availability)说明系统已准备好，马上就可以使用</li><li><strong>可靠性</strong>(reliability)指系统可以无故障地持续运行</li><li><strong>安全性</strong>(safety)指在系统偶然出现故障的情况下，仍然能够正确的操作而不会造成任何灾难</li><li><strong>可维护性</strong>(maintainability)是指发生故障的系统被恢复的难易程度</li></ul><a id="more"></a><h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><ul><li><strong>Fail</strong>：当一个系统不能兑现它的承诺时就被认为是失败了</li><li><strong>Error</strong>：是系统状态的一部分，它可能会导致失败</li><li><strong>Fault</strong>：是造成Error的原因</li></ul><h3 id="Handling-Faults"><a href="#Handling-Faults" class="headerlink" title="Handling Faults"></a>Handling Faults</h3><ul><li>Fault prevention：Prevent the occurrence of a fault</li><li>Fault tolerance：Build a component such that it can mask the occurrence of a fault</li><li>Fault removal：Reduce thte presence, number, or seriousness of a fault</li><li>Fault forecasting：Estimate current presence, future incidence, and consequences of faults</li></ul><h3 id="Failure-Models"><a href="#Failure-Models" class="headerlink" title="Failure Models"></a>Failure Models</h3><ul><li><p>崩溃性故障 Crash failure</p><p>服务器停机，但是在停机之前工作正常</p></li><li><p>遗漏性故障 Omission failure</p><p>服务器不能响应到来的请求</p><ul><li><p>接收故障 Receive omission</p><p>服务器不能接受到来的请求</p></li><li><p>发送故障 Send omission</p><p>服务器不能发送消息</p></li></ul></li><li><p>定时故障 Timing failure</p><p>服务器的响应在指定的时间间隔之外</p></li><li><p>响应故障 Response failure</p><p>服务器的响应不正确</p><ul><li><p>值故障 Value failure</p><p>响应的值错误</p></li><li><p>状态转换故障 State-transition failure</p><p>服务器偏离了正确的控制流</p></li></ul></li><li><p>随意性故障 Arbitrary (or Byzantine) failure</p><p>服务器可能在随意的时间产生随意的响应</p></li></ul><h3 id="冗余掩盖故障-Failure-Masking-by-Redundancy"><a href="#冗余掩盖故障-Failure-Masking-by-Redundancy" class="headerlink" title="冗余掩盖故障 Failure Masking by Redundancy"></a>冗余掩盖故障 Failure Masking by Redundancy</h3><ul><li>信息冗余 Information redundancy</li><li>时间冗余 Time redundancy</li><li>物理冗余 Physical redundancy</li></ul><h2 id="进程恢复-Process-Resilience"><a href="#进程恢复-Process-Resilience" class="headerlink" title="进程恢复 Process Resilience"></a>进程恢复 Process Resilience</h2><h3 id="平等组与等级组"><a href="#平等组与等级组" class="headerlink" title="平等组与等级组"></a>平等组与等级组</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/2MepDj9v3S5wrO7.png" alt=""></p><p><strong>平等组</strong>是对称的，没有单独的失败点。如果一个进程崩溃，组只是简单地变得更小，但是还可以继续。它的缺点是做出决定比较复杂，比如需要进行表决，会导致一些延迟和开销。</p><p><strong>等级组</strong>则相反。某个成员的故障会使整个组崩溃，但是只要它保持运行，就可以独自做出决定，不需要其他进程参加。</p><h3 id="故障掩盖和复制"><a href="#故障掩盖和复制" class="headerlink" title="故障掩盖和复制"></a>故障掩盖和复制</h3><p>如果系统能够经受k个组件的故障并且还能满足规范的要求，那么就被称为<strong>k容错</strong>（k fault tolerant）。</p><p>如果这些进程失败了，那么k+1个组件就能提供k容错。</p><p>另一方面，如果进程发生<strong>拜占庭失败</strong>，继续错误运行并发送出错误或随机的应答，最少需要2k+1个进程才能获得k容错。</p><h2 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h2><p>全称是<strong>拜占庭将军问题</strong>（Byzantine Generals Problem），是由莱斯利·兰波特提出的分布式对等网络通信容错问题。在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同的结论，从而破坏系统一致性。拜占庭问题被认为是容错性问题中最难的问题类型之一。</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>系统的问题在于，将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。<strong>假如那些忠诚（没有出错）的将军仍然能通过多数决定来决定他们的策略</strong>，那么就达到了<strong>拜占庭容错</strong>。</p><p>上述故事映射到计算机系统里，将军就是计算机，信差就是通信系统。在分布式对等网络中需要按照共同一致策略协作的<strong>成员计算机</strong>即为问题中的<strong>将军</strong>，而各成员赖以进行通讯的<strong>网络链路</strong>即为<strong>信使</strong>。拜占庭将军描述的就是某些成员计算机或网络链路出现错误、甚至被蓄意破坏者控制的情况。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>如何让忠诚者（非叛徒）达成一致。</p><p>假设节点总数为N，叛徒数为F，则当<strong>N&gt;=3F+1</strong>时，问题才有解，即<strong>Byzantine Fault Tolerant(BTF)</strong>算法。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>N=3, F=1, 不满足N&gt;=3F+1</p><ol><li>当提出方案的人<strong>不是叛徒</strong>时，提案人提出一个方案，叛徒就提出相反的方案，剩下一个人收到两个相反的意见，就无法判断谁是叛徒，也无法给出一致的意见。所以如果提案人提出方案，系统中就有N-F份确定的信息和F份不确定的信息，只有$N-F \ge F \Rightarrow N&gt;F$的情况下达成一致。</li><li>当提出方案的人是<strong>叛徒</strong>时，提案人提出方案，发送给另外两人。另外两人收到两份相反的消息，无法判断谁才是叛徒，系统也无法达成一致。因为提出方案的叛徒会尽量发送相反的消息给N-F个忠诚者，那么$\begin{cases}\frac{N-F}{2}个信息1\\ \frac{N-F}{2}个信息0\end{cases}$</li></ol><p>Leslie Lamport证明，当叛徒数不超过<strong>1/3</strong>时，存在有效的算法让忠诚者总能达成一致。然而，如果叛徒数过多，就无法保证能够达成一致。</p><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>如果叛徒数超过1/3时，有无解决方案？</p><p>设有f个叛徒和g个忠诚者，叛徒可以故意使坏，可以给出错误的结果也可以不响应请求。</p><ol><li>当f个叛徒不响应，则g个忠诚者占多数，仍然能够得到正确结果</li><li>当f个叛徒，每个叛徒都给出一个恶意提案，并且当g个忠诚者中有f个处于离线状态时，则剩下g-f个忠诚者想要占据多数保持正确结果，则必须有$g-f&gt;f \Rightarrow g&gt;2f$，而系统的整体规模：$g+f &gt; 2f+f=3f \Rightarrow g+f&gt;3f$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timing and Synchronisation</title>
      <link href="/2019/12/23/Timing%20and%20Synchronisation/"/>
      <url>/2019/12/23/Timing%20and%20Synchronisation/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Eight-Fallacies-of-Distributed-Computing"><a href="#The-Eight-Fallacies-of-Distributed-Computing" class="headerlink" title="The Eight Fallacies of Distributed Computing"></a>The Eight Fallacies of Distributed Computing</h2><ul><li>The network is reliable</li><li>Latency is zero</li><li>Bandwidth is infinite</li><li>The network is secure</li><li>Topology doesn’t change</li><li>There is one administrator</li><li>Transport cost is zero</li><li>The network is homogeneous</li><li><font color=red>All blocks are synchronized</font></li></ul><p>第9大悖论即<strong>所有时钟是同步的</strong>。</p><a id="more"></a><h2 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h2><p>In a DS, there is <font color=red>no global agreement on time.</font></p><h3 id="物理时钟"><a href="#物理时钟" class="headerlink" title="物理时钟"></a>物理时钟</h3><p>几乎所有的计算机都有一个计时电路。但它们不是通常意义上的时钟，称为<strong>计时器（timer）</strong>更为掐当。这里还有几个概念：</p><ul><li>有两个计数器与每个石英晶体相关联，一个是<strong>计数器（counter）</strong>，另一个是<strong>保持寄存器（holding register）</strong></li><li>每次的中断称为一个时钟滴答（When counter reaches zero, a <font color=red>timer interrupt</font> or <font color=red>clock tick</font> is generated and counter is reloaded from a holding register）</li><li>时钟偏移：In a DS with <em>n</em> machines, all <em>n</em> crystals will run at slightly different rates, resulting in <font color=red>clock skew</font>.</li></ul><h3 id="时钟同步算法"><a href="#时钟同步算法" class="headerlink" title="时钟同步算法"></a>时钟同步算法</h3><h4 id="Cristian’s-Algorithm"><a href="#Cristian’s-Algorithm" class="headerlink" title="Cristian’s Algorithm"></a>Cristian’s Algorithm</h4><p>Cristian提出让客户与<strong>时间服务器</strong>（time server）联系。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/KW4FhDvZsi2jcqz.png" alt=""></p><p>如图所示，best estimate of one-way propagation time is <strong><em>(T1-T0-I)/2</em></strong>.</p><p><strong>例题：</strong><br>The client’s clock reads 5:26:08. The server’s clock reads 5:16:44 when they synchronize using Cristian’s algorithm. Assume RTT is 2 seconds. What is the time at the client after synchronization? Note: the time format is HH:MM:SS.</p><p><strong>解答：</strong></p><p>Cristian’s algorithm assumes that the server has an accurate clock. The client requests the time and sets its clock to the server’s time $+\frac{1}{2}(RTT)$. In this case, the RTT is 2 seconds, so the client set time after synchronization: $5:16:44 + \frac{1}{2}*2seconds = 5:16:45$</p><h4 id="Berkeley-Algorithm"><a href="#Berkeley-Algorithm" class="headerlink" title="Berkeley Algorithm"></a>Berkeley Algorithm</h4><p>Berkeley UNIX系统中的时间服务器（实际上是时间守护程序）是主动的，它定期地询问每台机器的时间。基于这些回答，它计算出一个平均时间，并告诉所有其他机器将它们的时钟快拨到一个新的时间，或者拨慢时间。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/7wdnyTFM4ZmKPWq.png" alt=""></p><p><strong>例题1：</strong></p><p>The client’s clock reads 5:26:00. The server’s clock reads 5:14:00 when they synchronize using the Berkeley algorithm. Assume message delays are negligible. What is the time at the client after synchronisation? Note: the time format is HH:MM:SS.</p><p><strong>解答：</strong></p><p>The Berkeley algorithm averages clocks among the entire group. In this case, the group has two members: the client and the server. The average of the two clocks is $(5:26:00+5:14:00)/2=5:20:00$. Both the client and server will be set at $5:20:00$.</p><p><strong>例题2：</strong></p><p>Consider a network consisting of 5 computers, A (coordinator), B, C, D, and E. At 08:45 the coordinator decides to synchronise the clock of all computers in the network. The time format is HH:MM. At that moment, the clock of the computers in the network shows the following: B(08:43), C(08:49), D(08:42), E(08:46). Apply the Berkeley clock synchronisation algorithm to this situation, show the stages of computation, and explain the outcome of the synchronisation. You may assume that the time needed for computation and for network communication is negligible.</p><p><strong>解答：</strong></p><p>由上图给出的例子作为解释，这里的同步是指由coordinator服务器发起的。coordinator服务器发送请求到所有slave服务器，接收到所有的slave服务器时间后，计算时间的平均值，然后将这个值回填至所有的服务器。其中也包括coordinator服务器。A服务器即coordinator请求时的时间是08:45，B、C、D、E的服务器时间分别是08：43、08：49、08：42、08：46。所以这4台服务器收到请求后分别返回与coordinator的时间差-2、+4、-3、+1。coordinator接收到这两个值后进行计算$(-2+4-3+1)/3=0$。说明时钟走过的时间为0，可忽略。然后$0-(-2)=2，0-4=-4，0-(-3)=3，0-1=-1$。分别将这四个值回填给另外四台服务器。</p><h4 id="Bully-Algorithm"><a href="#Bully-Algorithm" class="headerlink" title="Bully Algorithm"></a>Bully Algorithm</h4><p>当任何一个进程发现协作者不再响应请求时，它就发起一次选举。进程P按如下过程主持一次选举：</p><ol><li>P向所有编号比它大的进程发送一个Election消息；</li><li>如果无人响应，P获胜并称为协作者;</li><li>如果有编号比它大的进程响应，则由响应者接管选举工作。P的工作完成。</li></ol><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/zOZ2jvY3sU9kKET.png" alt=""></p><h4 id="网络时间协议"><a href="#网络时间协议" class="headerlink" title="网络时间协议"></a>网络时间协议</h4><p>网络时间协议（network time protocol, NTP）在服务器之间创建了两条连接。换句话说，B也可以探查A的当前时间。</p><p>原则上，对称地应用NTP也可以让B参照A来调整它的时钟。但是，如果已知B的时钟更精确，那么这种调整就不应该了。所以，NTP把服务器分成多个层。含有<strong>参考时钟</strong>（reference clock）的服务器称为<strong>1层服务器</strong>（stratum-1 server）（时钟本身为0层）。</p><p>当A与B联系时，如果它的层比B的层要高，那么它就只调整自己的时间。经过同步化后，A将比B高一层。如果B是k层服务器，且A的初始层已经大于k，那么，经过时间调整后，A就变成（k+1）层服务器。由于NTP的对称性，如果A的层数比B的低，那么B将按照A来调整自己。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔可夫决策过程</title>
      <link href="/2019/12/20/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/12/20/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h2><p>某一状态信息包含了相关的历史，只要当前状态可知，所有的历史信息都不再需要，当前状态就可以决定未来，则认为该状态具有马尔可夫性（Markov Property）。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/fk6g5r3bL2QnpHZ.png" alt="马尔可夫性"></p><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><p>又叫马尔可夫链（Markov Chain）。它是一个无记忆的随机过程，可以用一个元组<S, P>表示，其中S是有限数量的状态集，P是状态转移概率矩阵。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kjVv3wCQdELxm8p.png" alt="马尔可夫过程"></p><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p>马尔可夫奖励过程（Markov Reward Process）在马尔可夫过程的基础上增加了奖励R和衰减系数V：<S, P, R, V>。R是一个奖励函数。S状态下的奖励是某一时刻（t）处所在状态s下在下一个时刻（t+1）能获得的奖励期望：</p><script type="math/tex; mode=display">R_s = E[R_{t+1}|S_t=s]</script><p>衰减系数（Discount Factor）：$\gamma\in[0, 1]$，避免无限循环。</p><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p>Markov Decision Process，MDP</p><p>多了一个行为集合A，元组<S, A, P, R, V>。</p><script type="math/tex; mode=display">P^a_{ss'} = P[S_{t+1}=s'|S_t=s, A_t=a]\\R^a_s=E[R_{t+1}|S_t=s, A=a]</script><p>当给定一个MDP： $<S, R, P,R, \gamma>$和一个策略$\pi$，那么状态序列$S_1，S_2$，是一个马尔可夫过程$<S, P^\pi>$。</p><p>下一个时刻的状态$S_{t+1}$和<strong>当前时刻的状态$S_t$以及动作$a_t$有关</strong>。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><script type="math/tex; mode=display">初始化状态agent所处状态s_0\\\Downarrow\\根据policy\quad\pi(a|s)采取动作a_0，a_0\sim\pi(a|s_0)\\\Downarrow\\根据转移概率p(s'|s,a)采取新状态s_1，s_1\sim p(s'|s,a)\\\Downarrow\\得到单步奖励r_1=R^{a_0}_{s_0s_1}\\\Downarrow\\持续，得到终止状态S_T，得到轨迹\gamma=(s_0,a_0,s_1,a_1,\dots,s_T)\\\Downarrow\\轨迹的联合概率：\\p(r)=p(S_0)·\prod^\pi_{t=1}p(a_{t-1}|S_{t-1})·p(S_t|S_{t-1},a_{t-1})\\\Downarrow对于每一条轨迹，累计奖励函数是关于单步奖励的函数\\R=f(r_0,r_1\dots r_{T-1})\\\downarrow\\可以是T步累计奖励函数R=\sum^{T-1}_{t=0}r_t，\\也可以是\gamma折扣奖励函数，R=\sum^{T-1}_{t=0}\gamma^t·r_t\\\Downarrow期望累计奖励是E_R=E_p(r)[\sum^{T-1}_{t=0}\gamma^t·r_t^T]\\\therefore agent的目标策略就是使得期望累计奖励最大的策略\\\pi=\max\limits_{\pi}E_{p(r)}^\pi[\sum^{T-1}_{t=0}\gamma^t·r_t]</script><h3 id="状态state"><a href="#状态state" class="headerlink" title="状态state"></a>状态state</h3><p>agent在每个步骤中所处于的状态集合。</p><h3 id="行为action"><a href="#行为action" class="headerlink" title="行为action"></a>行为action</h3><p>agent在每个步骤中所能执行的动作集合。</p><h3 id="转移概率transition"><a href="#转移概率transition" class="headerlink" title="转移概率transition"></a>转移概率transition</h3><p>agent处于状态s下，执行动作a后，会转移到状态s’的概率。</p><h3 id="奖励reward"><a href="#奖励reward" class="headerlink" title="奖励reward"></a>奖励reward</h3><p>agent处于状态s下，执行动作a后，转移到状态s’后获得的立即奖励值。</p><h3 id="策略Policy"><a href="#策略Policy" class="headerlink" title="策略Policy"></a>策略Policy</h3><p>策略$\pi$是概率的集合或分布，其元素$\pi(a|s)$为对过程中的<strong>某一状态s采取可能的行为a的概率</strong>。</p><p>agent处于状态s下，应执行动作a的概率。</p><p>一个策略定义了个体在各个状态下的各种可能的行为方式以及其概率的大小。</p><h3 id="回报Return"><a href="#回报Return" class="headerlink" title="回报Return"></a>回报Return</h3><p>回报$G_t$为在一个马尔可夫奖励链上<strong>从t时刻开始往后所有的奖励的有衰减的总和</strong>。</p><h3 id="价值函数Value-Function"><a href="#价值函数Value-Function" class="headerlink" title="价值函数Value Function"></a>价值函数Value Function</h3><p>价值函数给出了某一状态或某一行为的长期价值。</p><p>某一状态的价值函数为从该状态开始的马尔可夫链收获的期望。</p><p><strong>Bellman Optimality Equation</strong></p><p>针对V<em>，一个状态的最优价值等于从该状态出发采取的所有行为产生的行为价值中<em>*最大的</em></em>那个行为价值：</p><script type="math/tex; mode=display">V_*(s)=\max_aq_*(s,a)</script><h2 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h2><h3 id="状态值函数State-Value-Function"><a href="#状态值函数State-Value-Function" class="headerlink" title="状态值函数State Value Function"></a>状态值函数State Value Function</h3><p>$V^\pi(s)$为状态值函数，表示从状态s开始，执行策略$\pi$得到的期望总回报：</p><script type="math/tex; mode=display">V^\pi(s)=E_{r\sim p(r)}[\sum^{T-1}_{t=0}\gamma^t·r_{t+1}|\tau_{s_0}=s]</script><p>其中$\tau_{s_0}$表示轨迹$\gamma$的起始状态。</p><script type="math/tex; mode=display">V^\pi(s)=E_{a\sim\pi}(a|s)E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma V^\pi(s')]\\\downarrow</script><p>Bellman equation，表示当前状态的值函数可以通过下个状态的值函数来计算。</p><h3 id="状态——动作值函数"><a href="#状态——动作值函数" class="headerlink" title="状态——动作值函数"></a>状态——动作值函数</h3><p>也叫Q函数，Q-function。指初始状态为s并进行动作a，然后执行策略$\pi$得到的期望总回报，即state-action value function。</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma·V^\pi(s')]</script><p>也可以写成：</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma·E_{a'\sim\pi(a'|s')}[Q^\pi(s',a')]]\\\uparrow\\Q函数的Bellman方程</script><hr><p><strong>基于值函数的策略学习方法</strong></p><p>主要分为<strong>动态规划</strong>和<strong>蒙特卡罗</strong>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划又分为<strong>策略迭代（policy iteration）</strong>算法和<strong>值迭代（value iteration）</strong>算法。</p><h3 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h3><ol><li><p>策略评估 policy evaluation</p><p>计算当前策略下，每个状态的值函数。可以通过Bellman方程进行迭代计算$V^\pi(s)$。</p></li><li><p>策略改进 policy improvement</p><p>根据值函数更新策略。</p></li></ol><h3 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h3><p>将策略评估与策略改进合并，来直接计算出最优策略。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/oYOnGDUXLir8awP.png" alt="策略迭代 VS 值迭代"></p><h2 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h2><p>Q函数。$Q^\pi(s,a)$为初始状态为s，并执行动作a后所能得到的期望总回报。</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{r\sim p(r)}[G(\tau_{s_0}=s,a_0=a)]</script><p>$\tau_{s_0}=s，a_0=a$表示轨迹$\tau$的起始状态和动作为s，a。</p><h3 id="蒙特卡罗方法"><a href="#蒙特卡罗方法" class="headerlink" title="蒙特卡罗方法"></a>蒙特卡罗方法</h3><p>Q函数通过<strong>采样</strong>进行计算。</p><p>对于一个策略$\pi$，agent从状态s，执行动作a开始，然后通过随机游走的方法探索环境，并计算其总回报。</p><p>在得到Q函数$Q^\pi(s,a)$之后，进行策略改进，在新策略下采样估计Q函数，不断重复。</p><h3 id="epsilon-贪心法"><a href="#epsilon-贪心法" class="headerlink" title="$\epsilon$-贪心法"></a>$\epsilon$-贪心法</h3><script type="math/tex; mode=display">\pi^\epsilon=\begin{cases}\pi(s),按概率1-\epsilon\\随机选择\mathcal{A}中的动作，按概率\epsilon\end{cases}</script><p>将一个仅利用的策略转为带探索的策略，每次选择动作$\pi(s)$的概率为$1-\epsilon+\frac{1}{|\mathcal{A}|}$，其它动作的概率为$\frac{1}{\mathcal{A}}$。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/ZQzg2apVPY5ArCn.png" alt="同策略与异策略"></p><h2 id="时序差分学习方法"><a href="#时序差分学习方法" class="headerlink" title="时序差分学习方法"></a>时序差分学习方法</h2><p>蒙特卡罗采样方法一般需要拿到完整的轨迹，才能对策略进行评估并更新模型，因此效率较低。</p><p><strong>时序差分学习（temporal-difference learning）</strong>结合了动态规划和蒙特卡罗方法：模拟一段轨迹，每行动一步（或几步）就利用Bellman方程来评估行动前状态的值。（当每次更新动作数为最大数时，就等价于蒙特卡罗方法）。</p><h3 id="SARSA算法"><a href="#SARSA算法" class="headerlink" title="SARSA算法"></a>SARSA算法</h3><p><strong>State Action Reward State Action</strong></p><p>只需要知道当前状态s和动作a，奖励r(s,a,s’)，下一步的状态s’和动作a’，其采样和优化的策略都是$\pi^\epsilon$，因此是同策略。</p><script type="math/tex; mode=display">Q^\pi(s,a)\longleftarrow Q^\pi(s,a)+\alpha(r(s,a,s')+rQ^\pi(s',a')-Q^\pi(s,a))</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kKlwCsz3dY85T9g.png" alt="SARSA算法"></p><h3 id="Q学习算法"><a href="#Q学习算法" class="headerlink" title="Q学习算法"></a>Q学习算法</h3><p><strong>Q-learning</strong></p><script type="math/tex; mode=display">Q(s,a)\longleftarrow Q(s,a)+\alpha(r+\gamma\max_{a'}Q(s',a')-Q(s,a))</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/vE2fCp69J71XB3T.png" alt="Q-learning算法"></p><p>与SARSA不同，Q-learning不通过$\pi^\epsilon$来选下一步的动作a’，而是<strong>直接选最优的Q函数</strong>。更新后的Q函数是关于策略$\pi$的，而不是策略$\pi^\epsilon$的。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马尔可夫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图与完美匹配</title>
      <link href="/2019/11/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/11/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="二分图定义"><a href="#二分图定义" class="headerlink" title="二分图定义"></a>二分图定义</h2><p>可以把图中的点分成两部分，使得每部分内部两两点之间没有连边。</p><h2 id="判定是否是二分图"><a href="#判定是否是二分图" class="headerlink" title="判定是否是二分图"></a>判定是否是二分图</h2><p>没有奇数环的图，或者能够黑白染色（染色问题）的图。</p><h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个图的最大匹配中的每个点都是匹配点</p><h3 id="Hall定理"><a href="#Hall定理" class="headerlink" title="Hall定理"></a>Hall定理</h3><p>设G是具有二划分（X, Y）的二部图，则G有饱和X的匹配当且仅当对 ∀S ⊆ X ， N ( S ) ≥ |S|，其中 N (S ) 表示 S 的所有邻点之集。</p><a id="more"></a><p>通俗的说，即<strong>选择任意的左部点S个，把所有这S个点关联的K个右部点取出来，一定有|S|&lt;=|K|</strong>。如果满足这个条件，则是二分图。</p><h3 id="Tutte定理"><a href="#Tutte定理" class="headerlink" title="Tutte定理"></a>Tutte定理</h3><blockquote><p>A graph, <em>G</em> = (<em>V</em>, <em>E</em>), has a <a href="https://en.wikipedia.org/wiki/Perfect_matching" target="_blank" rel="noopener">perfect matching</a> <a href="https://en.wikipedia.org/wiki/If_and_only_if" target="_blank" rel="noopener">if and only if</a> for every subset <em>U</em> of <em>V</em>, the <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Subgraphs" target="_blank" rel="noopener">subgraph</a> induced by <em>V</em> − <em>U</em> has at most |<em>U</em>| <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory" target="_blank" rel="noopener">connected components</a>) with an odd number of <a href="https://en.wikipedia.org/wiki/Vertex_(graph_theory" target="_blank" rel="noopener">vertices</a>).</p></blockquote><p>图G有完美匹配的充分必要条件是<strong>对∀S ⊂ V (G ) ， O (G \ S ) ≤| S |</strong>。</p><p>即图G有完美匹配等价于，对于图G去掉任意一个点集之后，图的奇分支的个数小于等于点集的个数（奇分支：有奇数个点的分支）。</p><p>例如，对于下图，证明其是否有完美匹配。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Xr2d6KgsbxOk8nP.png" alt=""></p><p>可以在图中挑出一些点，使得点与点之间分隔后的部分有<strong>奇数</strong>个顶点，然后比较挑出的点的数量，与分隔后的部分的数量的大小。如果分隔后部分的数量小于等于挑出点的数量，则有完美匹配。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/pLsJGEZud2i6Njh.png" alt=""></p><p>如上图所示，挑出12个红点，这12个红点将图分成了14个部分（每个部分必须含有奇数个顶点）。因为12&lt;14，不满足Tutte定理，所以这个图没有完美匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
            <tag> 完美匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy官方快速热门教程（译）</title>
      <link href="/2019/11/02/Numpy%E5%AE%98%E6%96%B9%E5%BF%AB%E9%80%9F%E7%83%AD%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/"/>
      <url>/2019/11/02/Numpy%E5%AE%98%E6%96%B9%E5%BF%AB%E9%80%9F%E7%83%AD%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>Numpy是一个开源的Python科学计算库，它是Python科学计算库的基础库。</p><h3 id="Numpy常用统计函数"><a href="#Numpy常用统计函数" class="headerlink" title="Numpy常用统计函数"></a>Numpy常用统计函数</h3><p><strong>函数在使用时需要指定axis轴的方向</strong>，若不指定，则默认是整个数组</p><ul><li><code>np.num()</code>：返回求和</li><li><code>np.mean()</code>：返回均值</li><li><code>np.max()</code>：返回最大值</li><li><code>np.min()</code>：返回最小值</li><li><code>np.ptp()</code>：数组沿指定轴返回最大值减去最小值，即（max-min）</li><li><code>np.std()</code>：返回标准偏差（standard deviation）</li><li><code>np.var()</code>：返回方差</li><li><code>np.cumsum()</code>：返回累加值</li><li><code>np.cunprod()</code>：返回累乘积值</li></ul><a id="more"></a><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p>Numpy的主要操作对象是同类型的多维数组。它是一个由正整数元组索引，元素类型相同的表（通常元素为数字）。在Numpy维度被成为<code>axes</code>，<code>axes</code>的数量称为<code>rank</code>。</p><p>例如，在3D空间的一个点[1,2,1]是一个<code>rank=1</code>的数组，因为它只有一个<code>axes</code>。而这个<code>axes</code>的长度为3。同样的，下面这个例子则是，数组<code>rank=2</code>（2维，2层嵌套的中括号），第一维的长度为2，第二维长度为3。（第1维即中括号最外面的部分，内部又包含2个中括号（相当于2个元素），所以长度为2；第2维即内部的中括号内含有3个元素）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>Numpy的数组类是<code>ndarray</code>，也可称作<code>array</code>。值得注意的是，<code>numpy.array</code>和标准Python库中的<code>array.array</code>是不一样的，它只能处理一维数组，提供更少的功能。</p><h4 id="ndarray对象的一些重要属性"><a href="#ndarray对象的一些重要属性" class="headerlink" title="ndarray对象的一些重要属性"></a><code>ndarray</code>对象的一些重要属性</h4><ul><li><p><code>ndarray.ndim</code></p><blockquote><p>数组的<code>axes</code>（维数）数值的大小，即<code>rank</code>，几维</p></blockquote></li><li><p><code>ndarray.shape</code></p><blockquote><p>数组的维数，这是由每个维度的大小组成的一个元组。对于一个<strong>n行m列</strong>的矩阵，<code>shape</code>是<code>(n,m)</code>。由<code>shape</code>元组的长度得出<code>rank</code>或者维数<code>ndim</code>。</p></blockquote></li><li><p><code>ndarray.size</code></p><blockquote><p>数组元素的个数总和，这等于<code>shape</code>元组数字的乘积。</p></blockquote></li><li><p><code>ndarray.dtype</code></p><blockquote><p>在数组中描述元素类型的一个对象。</p></blockquote></li><li><p><code>ndarray.itemsize</code></p><blockquote><p>数组中每个元素所占字节数。</p></blockquote></li><li><p><code>ndarray.data</code></p><blockquote><p>数据实际元素的缓存区。</p></blockquote></li></ul><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>首先导入Numpy库，以<code>np</code>为缩写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="基于list或者tuple"><a href="#基于list或者tuple" class="headerlink" title="基于list或者tuple"></a>基于list或者tuple</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组 # 基于list</span></span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>]])</span><br><span class="line">arr2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于tuple</span></span><br><span class="line">arr_tuple = np.array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(arr_tuple)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="基于np-arange"><a href="#基于np-arange" class="headerlink" title="基于np.arange"></a>基于np.arange</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr2 = np.array([np.arange(<span class="number">3</span>), np.arange(<span class="number">3</span>)])</span><br><span class="line">arr2</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h4 id="基于arange以及reshape创建多维数组"><a href="#基于arange以及reshape创建多维数组" class="headerlink" title="基于arange以及reshape创建多维数组"></a>基于arange以及reshape创建多维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建三维数组</span></span><br><span class="line">arr = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br></pre></td></tr></table></figure><p>注意，arange的长度必须与ndarray的维度的乘积要相当，即24 = 2x3x4</p><h3 id="ndarray数组的切片和索引"><a href="#ndarray数组的切片和索引" class="headerlink" title="ndarray数组的切片和索引"></a>ndarray数组的切片和索引</h3><p>一维数组的切片和索引与python的list索引类似。</p><p>二维数组的切片和索引如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/NwlfObo1QXUHmIA.png" alt="二维数组的切片和索引"></p><h3 id="处理数组形状"><a href="#处理数组形状" class="headerlink" title="处理数组形状"></a>处理数组形状</h3><h4 id="堆叠数组"><a href="#堆叠数组" class="headerlink" title="堆叠数组"></a>堆叠数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">c = b*<span class="number">2</span></span><br><span class="line">c</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><ul><li><p>水平叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hstack()</span><br><span class="line">np.hstack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>column_stack()函数以列的方式对数组进行叠加，功能类似hstack()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">column_stack()</span><br><span class="line">np.column_stack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p>垂直叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vstack()</span><br><span class="line">np.vstack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>row_stack()函数以行的方式对数组进行叠加，功能类似vstack()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row_stack()</span><br><span class="line">np.row_stack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p>concatenate()方法，通过设置axis的值来设置叠加方向</p><p>axis=1时，沿水平方向叠加</p><p>axis=0时，沿垂直方向叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">np.concatenate((b,c),axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br><span class="line">np.concatenate((b,c),axis=<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li></ul><p>用示意图来表示如下：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/NMeRC6jgBDISpU4.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Gu3YO2cjyAQ9CdR.png" alt=""></p><ul><li><p>深度叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr_dstack = np.dstack((b,c))</span><br><span class="line">print(arr_dstack.shape)</span><br><span class="line">arr_dstack</span><br><span class="line">(<span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">40</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">22</span>]]])</span><br></pre></td></tr></table></figure><p>叠加前，b和c均是shape为(2,6)的二维数组，叠加后，arr_dstack是shape为(2,6,2)的三维数组。</p></li></ul><h4 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h4><p>数组的拆分可以分为横向拆分、纵向拆分和深度拆分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><ul><li><p>横向拆分（axis=1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(b, <span class="number">2</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]]), array([[ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br><span class="line">np.split(b,<span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]]), array([[ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br></pre></td></tr></table></figure></li><li><p>纵向拆分（axis=0）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.vsplit(b, <span class="number">2</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]]), array([[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br><span class="line">np.split(b,<span class="number">2</span>,axis=<span class="number">0</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]]), array([[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br></pre></td></tr></table></figure></li><li><p>深度拆分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">arr_dstack</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">40</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">22</span>]]])</span><br><span class="line">np.dsplit(arr_dstack,<span class="number">2</span>)</span><br><span class="line">[array([[[ <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">1</span>],</span><br><span class="line">         [<span class="number">20</span>],</span><br><span class="line">         [ <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>],</span><br><span class="line">         [<span class="number">11</span>]]]), array([[[ <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">2</span>],</span><br><span class="line">         [<span class="number">40</span>],</span><br><span class="line">         [ <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">8</span>],</span><br><span class="line">         [<span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">12</span>],</span><br><span class="line">         [<span class="number">14</span>],</span><br><span class="line">         [<span class="number">16</span>],</span><br><span class="line">         [<span class="number">18</span>],</span><br><span class="line">         [<span class="number">20</span>],</span><br><span class="line">         [<span class="number">22</span>]]])]</span><br></pre></td></tr></table></figure><p>拆分的结果就是把原来的三维数组拆分成两个二维数组。</p></li></ul><h4 id="数组类型转换"><a href="#数组类型转换" class="headerlink" title="数组类型转换"></a>数组类型转换</h4><ul><li><p>数组转换成list，使用tolist()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.tolist()</span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]</span><br></pre></td></tr></table></figure></li><li><p>转换成指定类型，使用astype()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.astype(float)</span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,  <span class="number">20.</span>,   <span class="number">3.</span>,   <span class="number">4.</span>,   <span class="number">5.</span>],</span><br><span class="line">       [  <span class="number">6.</span>,   <span class="number">7.</span>,   <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure></li></ul><h4 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h4><ul><li><p>reshape()和resize()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">b.reshape(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.resize(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>resize()与reshape()的作用相似，但是resize()会改变所作用的数组</p></li><li><p>ravel()和flatten()，可以将多维数组转换成一维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b.ravel()</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line">b.flatten()</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line">b</span><br><span class="line">array([[ 0,  1,  2],</span><br><span class="line">       [ 3,  4,  5],</span><br><span class="line">       [ 6,  7,  8],</span><br><span class="line">       [ 9, 10, 11]])</span><br></pre></td></tr></table></figure><p>两者的区别在于返回拷贝还是返回视图。即flatten()是返回一份拷贝，需要分配新的内存空间，会影原始矩阵；但ravel()返回的是视图，会影响原始矩阵。</p></li><li><p>用tuple指定数组的形状，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.shape=(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li><li><p>转置</p><p>通过transpose()函数来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b.transpose()</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">20</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li></ul><h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h3><h4 id="np-reshape函数参数-1的意思"><a href="#np-reshape函数参数-1的意思" class="headerlink" title="np.reshape函数参数-1的意思"></a>np.reshape函数参数-1的意思</h4><p>-1表示暂时不知道需要什么数字，但可以通过其他推导出来。即其实可以忽略-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.reshape(a, (<span class="number">3</span>,<span class="number">-1</span>))  <span class="comment"># the unspecified value is inferred to be 2</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>这里的-1即可以忽略，只通过a和3即可推导出-1的实际应为2。</p><p>即把原数组合并在一起成为一个数组，然后分成3行，这样每行就有2列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是两张2*3大小的照片(不知道有几张照片用-1代替)，如何把所有二维照片给摊平成一维</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.reshape((<span class="number">-1</span>, <span class="number">6</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>reshape后分成6列，则12/6=2行。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IrisFlowers训练集</title>
      <link href="/2019/11/01/IrisFlowers%E8%AE%AD%E7%BB%83%E9%9B%86/"/>
      <url>/2019/11/01/IrisFlowers%E8%AE%AD%E7%BB%83%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/XR892ceDVO5h1fZ.png" alt="约翰·卡马克"></p><blockquote><p>“现今程序员的情况好多了，只要有一台便宜的二手电脑，一张Linux光盘和一个互联网帐户，你就已经拥有了把自己提升到任何级别的编程水平所需的全部工具。”<br>“在信息时代，进入编程领域的壁垒完全不存在了。即使有也是自我强加的。如果你想着手去开发一些全新的东西，你不需要数百万美元的资本。你只需要足够的比萨和健怡可乐存在你的冰箱里，有一台便宜的PC用于工作，以及让你坚持下来的奉献精神。<strong>我们睡在地板上。我们跋山涉水</strong>。”<br>－约翰·卡马克</p></blockquote><p>约翰·卡马克的最后一句话，通俗易懂。又不禁让我想起了那段台词：</p><blockquote><p>这是最好的时代，这是最坏的时代。我们一无所有，我们巍然矗立。</p></blockquote><p>We will build and use a neural network for the Iris classification task. We will use “keras” as a high-level library for managing neural networks.</p><a id="more"></a><h2 id="Analysis-Code"><a href="#Analysis-Code" class="headerlink" title="Analysis Code"></a>Analysis Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  <span class="comment"># import load_iris function from datasets module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential, Input, Model</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Load Iris dataset using sklearn (save "bunch" object containing iris dataset and its attributes) -- ##</span></span><br><span class="line"><span class="comment"># 导入Iris数据集</span></span><br><span class="line"><span class="comment"># Iris数据集是sklearn中自带的</span></span><br><span class="line"><span class="comment"># Iris数据集有3个种类，4个属性，每个属性有50个样例</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="comment"># x代表iris数据集的数据</span></span><br><span class="line">X = iris.data</span><br><span class="line"><span class="comment"># y代表着着iris的目标属性，即花的类型</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Change the labels from categorical to one-hot encoding -- ##</span></span><br><span class="line"><span class="comment"># The output neurons of the NN will be trained to match the one_hot encoded array</span></span><br><span class="line"><span class="comment"># Example: category label 0 out of 3 labels becomes [1 0 0];</span></span><br><span class="line"><span class="comment"># Example: category label 1 out of 3 labels becomes [0 1 0];</span></span><br><span class="line"><span class="comment"># HINT: use: "to_categorical" to redifine the one hot encoded target y_one_hot using the original y.</span></span><br><span class="line"><span class="comment"># for i in range(len(y)):</span></span><br><span class="line"><span class="comment">#     if y[i] == 0:</span></span><br><span class="line"><span class="comment">#         y[i] = 1</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         y[i] = 0</span></span><br><span class="line">y_one_hot = to_categorical(y)</span><br><span class="line">print(X.shape)</span><br><span class="line">print(y_one_hot.shape)</span><br><span class="line"><span class="comment"># y_one_hot = np.reshape(y, (-1, 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Split the dataset for training, validation, and test -- ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x是被划分的样本特征集</span></span><br><span class="line"><span class="comment"># y_one_hot是被划分的样本标签</span></span><br><span class="line"><span class="comment"># 如果是浮点数，就在0~1之间，表示样本所占比例；如果是整数，就是样本的数量</span></span><br><span class="line">train_and_valid_X, test_X, train_and_valid_y, test_y = train_test_split(X, y_one_hot, test_size=<span class="number">0.1</span>)</span><br><span class="line">train_X, valid_X, train_y, valid_y = train_test_split(train_and_valid_X, train_and_valid_y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the neural network</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseline_model</span><span class="params">()</span>:</span></span><br><span class="line">    nb_nurons = <span class="number">8</span></span><br><span class="line">    <span class="comment"># nb_Classes = 1  # HINT:  &lt;---- look here</span></span><br><span class="line">    nb_Classes = <span class="number">3</span></span><br><span class="line">    input_dimensions = <span class="number">4</span></span><br><span class="line">    learning_rate = <span class="number">0.002</span></span><br><span class="line">    <span class="comment"># create model</span></span><br><span class="line">    <span class="comment"># keras.models.Sequential是神经网络模型的封装容器。它会提供常见的函数</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    <span class="comment"># 第一层级 - 添加有 input_dimensions = 4个节点的输入层</span></span><br><span class="line">    <span class="comment"># 激活函数使用ReLU运算</span></span><br><span class="line">    model.add(Dense(nb_nurons, input_dim=input_dimensions, activation=<span class="string">'relu'</span>))</span><br><span class="line">    <span class="comment"># HINT: a 'softmax' activation will output a probability distribution over the output dimensions</span></span><br><span class="line">    <span class="comment"># 激活函数使用softmax函数</span></span><br><span class="line">    model.add(Dense(nb_Classes,</span><br><span class="line">                    activation=<span class="string">'softmax'</span>))</span><br><span class="line">    <span class="comment"># Compile model</span></span><br><span class="line">    <span class="comment"># 实例化一个优化器对象，这里采用RMSprop优化器</span></span><br><span class="line">    opt = optimizers.RMSprop(lr=learning_rate)</span><br><span class="line">    <span class="comment"># HINT: a 'binary_crossentropy' is only useful for at most 2 labels, look for another suitable loss function in Keras</span></span><br><span class="line">    <span class="comment"># compile用于配置训练模型，loss是字符串或目标函数名，optimizer是优化器名或优化器实例，metrics是在训练和测试期间的模型评估标准</span></span><br><span class="line">    <span class="comment"># binary_crossentropy是交叉熵损失函数，一般用于二分类</span></span><br><span class="line">    <span class="comment"># 因为这里要实现3中分类即多分类，所以使用categorical_crossentropy</span></span><br><span class="line">    model.compile(loss=<span class="string">'categorical_crossentropy'</span>, optimizer=opt, metrics=[</span><br><span class="line">        <span class="string">'accuracy'</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_correct_and_incorrect_labels</span><span class="params">(model, test_X, test_y)</span>:</span></span><br><span class="line">    <span class="comment"># Computes for every input in the test dataset a probability distribution over the categories</span></span><br><span class="line">    <span class="comment"># predict是为输入样本生成输出预测，计算是分批进行的</span></span><br><span class="line">    predicted_classes = model.predict(test_X)</span><br><span class="line">    <span class="comment"># argmax是找到样本以最大概率所属的类别作为样本的预测标签</span></span><br><span class="line">    <span class="comment"># HINT: choose the prediction with the highest probability, np.argmax( ..... , axis=1 )</span></span><br><span class="line">    <span class="comment"># np.round是取返回四舍五入后的值，可指定精度，与np.around等效</span></span><br><span class="line">    predicted_classes = np.argmax(predicted_classes, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># np.where(conditions)满足conditions的条件即输出数组的下标</span></span><br><span class="line">    correctIndex = np.where(predicted_classes == np.argmax(test_y))[<span class="number">0</span>]  <span class="comment"># HINT: replace test_y by np.argmax(test_y,axis=1)</span></span><br><span class="line">    incorrectIndex = np.where(predicted_classes != np.argmax(test_y))[<span class="number">0</span>]  <span class="comment"># HINT: replace test_y by np.argmax(test_y,axis=1)</span></span><br><span class="line">    print(<span class="string">"Found %d correct labels using the model"</span> % len(correctIndex))</span><br><span class="line">    print(<span class="string">"Found %d incorrect labels using the model"</span> % len(incorrectIndex))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_train_performance</span><span class="params">(trained_model)</span>:</span></span><br><span class="line">  <span class="comment"># history函数会每轮训练收集损失和准确率，如果有测试集也会收集测试集的数据</span></span><br><span class="line">    print(trained_model.history.keys())</span><br><span class="line">    accuracy = trained_model.history[<span class="string">'accuracy'</span>]</span><br><span class="line">    val_accuracy = trained_model.history[<span class="string">'val_accuracy'</span>]</span><br><span class="line">    loss = trained_model.history[<span class="string">'loss'</span>]</span><br><span class="line">    val_loss = trained_model.history[<span class="string">'val_loss'</span>]</span><br><span class="line">    <span class="comment"># epoch表示完成了1遍训练集中的所有样本</span></span><br><span class="line">    epochs = range(len(accuracy))</span><br><span class="line">    <span class="comment"># 创建一个画板，1为画板的编号，可以不填</span></span><br><span class="line">    f1 = plt.figure(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 一个figure对象包含了多个子图，可以使用subplot()函数来绘制子图</span></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># axis设置坐标轴</span></span><br><span class="line">    plt.axis((<span class="number">0</span>, len(epochs), <span class="number">0</span>, <span class="number">1.2</span>))</span><br><span class="line">    plt.plot(epochs, accuracy, <span class="string">'bo'</span>, label=<span class="string">'Training accuracy'</span>)</span><br><span class="line">    plt.plot(epochs, val_accuracy, <span class="string">'b'</span>, label=<span class="string">'valid accuracy'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and valid accuracy'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.axis((<span class="number">0</span>, len(epochs), <span class="number">0</span>, <span class="number">1.2</span>))</span><br><span class="line">    plt.plot(epochs, loss, <span class="string">'bo'</span>, label=<span class="string">'Training loss'</span>)</span><br><span class="line">    plt.plot(epochs, val_loss, <span class="string">'b'</span>, label=<span class="string">'valid loss'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and valid loss'</span>)</span><br><span class="line">    <span class="comment"># 展示出每个数据对应的图像名称，更好辨认</span></span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Initialize model -- ##</span></span><br><span class="line">model = baseline_model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Test the performmance of the untrained model over the test dataset -- ##</span></span><br><span class="line">find_correct_and_incorrect_labels(model, test_X, test_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Train the model -- ##</span></span><br><span class="line">print(<span class="string">'\nTraining started ...'</span>)</span><br><span class="line">trained_model = model.fit(train_X, train_y, batch_size=<span class="number">10</span>, epochs=<span class="number">150</span>, verbose=<span class="number">0</span>, validation_data=(valid_X, valid_y))</span><br><span class="line">print(<span class="string">'Training finished. \n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Test the performmance of the trained model over the test dataset -- ##</span></span><br><span class="line">find_correct_and_incorrect_labels(model, test_X, test_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Plot performance over training episodes -- ##</span></span><br><span class="line">plot_train_performance(trained_model)</span><br></pre></td></tr></table></figure><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/2flu4zmsqdJ1FLR.png" alt="结果"></p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>在按照提示修改代码后，会一直提示以下这个错误，即实际输出的数组形状为与预期数据的形状不同。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/hU1xrcYJOWkyIV3.png" alt="错误"></p><p>最终通过Stack Overflow上的<a href="https://stackoverflow.com/questions/51456613/valueerror-error-when-checking-target-expected-dense-3-to-have-shape-1-but" target="_blank" rel="noopener">一篇帖子</a>找到了问题所在。</p><p>the following line is wrong</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb_Classes = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>change it to</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb_Classes = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Because final layer is of 3 dimension. Beacuse I used <code>categorical_crossentropy</code> and also the terminal shows that actually there are three layers.</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="categorical-crossentropy-函数"><a href="#categorical-crossentropy-函数" class="headerlink" title="categorical_crossentropy()函数"></a>categorical_crossentropy()函数</h3><p>即<strong>分类交叉熵</strong>函数。它用于衡量两个概率分布之间的举例。</p><h3 id="train-test-split"><a href="#train-test-split" class="headerlink" title="train_test_split"></a>train_test_split</h3><p><code>train_test_split</code>是交叉验证中常用的函数，功能是从样本中随机的按比例选取train_data和test_data，形式为：</p><p><code>X_train, X_test, y_train, y_test = cross_validation.train_test_split(train_data, train_target, test_size=0.4, randow_state=0)</code></p><p><code>cross_validation</code>为交叉验证</p><p><strong>参数解释：</strong></p><ul><li>train_data：所划分的样本特征集</li><li>train_target：所要划分的样本结果</li><li>test_size：样本占比，如果是整数的话就是样本的数量</li><li>random_size：随机数的种子</li></ul><p><strong>随机数种子：</strong></p><p>该组随机数的编号，可以在需要重复试验的时候，保证得到一组同样的随机数。比如，如果每次都设置随机数为1，那么得到的随机数组是一样的。如果设置为0或者不填，每次都会不一样。</p><p>随机数的产生取决于种子，随机数和种子之间关系：种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><h3 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/YBISCceVP8aWohu.png" alt=""></p><p>ReLU函数是分段线性函数，可以简单表示为<code>ReLU(x) = max(x, 0)</code>，在神经元中输出为：$\max(0, w^Tx+b)$</p><blockquote><p><strong>线性整流函数</strong>（Rectified Linear Unit, <strong>ReLU</strong>），又称修正线性单元，是一种<a href="https://baike.baidu.com/item/人工神经网络" target="_blank" rel="noopener">人工神经网络</a>中常用的激活函数（activation function），通常指代以<a href="https://baike.baidu.com/item/斜坡函数" target="_blank" rel="noopener">斜坡函数</a>及其变种为代表的非线性函数。</p></blockquote><p><strong>优点：</strong></p><ul><li>梯度不饱和。因为梯度计算公式为：1{x&gt;0}，所以在反向传播的过程中，减轻了梯度弥散的问题，神经网络前几层的参数也可以很快更新。</li><li>计算速度快。ReLU函数仅仅需要设置阈值，加快了正向传播的速度。</li></ul><h3 id="RMSprop优化器"><a href="#RMSprop优化器" class="headerlink" title="RMSprop优化器"></a>RMSprop优化器</h3><p>For example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.optimizers.RMSprop(lr=<span class="number">0.001</span>, rho=<span class="number">0.9</span>, epsilon=<span class="literal">None</span>, decay=<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure><p>建议使用优化器的默认参数（除了学习率lr，它可以被自由调节）。</p><p>RMSprop优化器通常是训练循环神经网络RNN的不错选择。</p><p><strong>参数：</strong></p><ul><li><strong>lr</strong>: float &gt;= 0，学习率</li><li><strong>rho</strong>: float &gt;= 0，RMSProp梯度平方的移动均值的衰减率</li><li><strong>epsilon</strong>: float &gt;= 0，模糊因子。若为None，默认为<code>K.epsilon()</code></li><li><strong>decay</strong>: float &gt;= 0，每次参数更新后学习率衰减值</li></ul><h3 id="Model类类型方法"><a href="#Model类类型方法" class="headerlink" title="Model类类型方法"></a>Model类类型方法</h3><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(optimizer, loss=<span class="literal">None</span>,  metrics=<span class="literal">None</span>, loss_weights=<span class="literal">None</span>, sample_weight_mode=<span class="literal">None</span>, weighted_metrics=<span class="literal">None</span>, target_tensors=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>optimizer</strong>：字符串（优化器名）或者优化器实例</li><li><strong>loss</strong>：字符串（目标函数名）或目标函数。如果模型具有多个输出，则可以通过传递损失函数的字典或列表，在每个输出上使用不同的损失。 模型将最小化的损失值将是所有单个损失的总和。</li><li><strong>metrics</strong>：在训练和测试期间的模型评估标准。</li><li><strong>loss_weights</strong>：可选的指定标量系数（Python 浮点数）的列表或字典， 用以衡量损失函数对不同的模型输出的贡献。 模型将最小化的误差值是由 <code>loss_weights</code> 系数加权的<em>加权总和</em>误差。 如果是列表，那么它应该是与模型输出相对应的 1:1 映射。 如果是张量，那么应该把输出的名称（字符串）映到标量系数。</li><li><strong>sample_weight_mode</strong>：如果你需要执行按时间步采样权重（2D 权重），请将其设置为 <code>temporal</code>。 默认为 <code>None</code>，为采样权重（1D）。 如果模型有多个输出，则可以通过传递 mode 的字典或列表，以在每个输出上使用不同的 <code>sample_weight_mode</code>。</li><li><strong>weighted_metrics</strong>：在训练和测试期间，由<code>sample_weight</code>或<code>class_weight</code>评估和加权的度量标准列表。</li><li><strong>target_tensors</strong>：默认情况下，Keras 将为模型的目标创建一个占位符，在训练过程中将使用目标数据。 相反，如果你想使用自己的目标张量（反过来说，Keras 在训练期间不会载入这些目标张量的外部 Numpy 数据）， 您可以通过 <code>target_tensors</code> 参数指定它们。 它可以是单个张量（单输出模型），张量列表，或一个映射输出名称到目标张量的字典。</li><li><strong>kwargs</strong>： 当使用 Theano/CNTK 后端时，这些参数被传入 <code>K.function</code>。 当使用 TensorFlow 后端时，这些参数被传递到 <code>tf.Session.run</code>。</li></ul><h4 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit(x=<span class="literal">None</span>, y=<span class="literal">None</span>, batch_size=<span class="literal">None</span>, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, callbacks=<span class="literal">None</span>, validation_split=<span class="number">0.0</span>, validation_data=<span class="literal">None</span>, shuffle=<span class="literal">True</span>, class_weight=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, initial_epoch=<span class="number">0</span>, steps_per_epoch=<span class="literal">None</span>, validation_steps=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>编译（compile）后的模型就可以开始训练（fit）了，fit的过程可以简单的理解为通过测试数据来确定神经元间连接权重（weight）的过程。</p><p><strong>参数：</strong></p><ul><li><strong>x</strong>：训练数据的Numpy数组（一个输入）或者Numpy数组的列表（如果模型有多个输入）。None是默认。</li><li><strong>y</strong>：目标（标签）数据的Numpy数组（一个输出）或者Numpy数组的列表（如果模型有多个输出）。None是默认。</li><li><strong>batch_size</strong>：整数或者None。每次梯度更新的样本数。如果未指定，则默认为32。</li><li><strong>epochs</strong>：整数。训练模型迭代的最终轮次。</li><li><strong>verbose</strong>：0，1或2。是日志显示模式。0是安静模式，1是进度条，2是每轮一行。</li><li><strong>callbacks</strong>：一系列的<code>keras.callbacks.Callback</code>实例。一系列可以在训练时使用的回调函数。</li><li><strong>validation_split</strong>：0和1之间的浮点数，用于验证集的训练数据的比例。模型将分出一部分不会被训练的验证数据，并将在每一轮结束时评估这些验证数据的误差和任何其他模型指标。</li><li><strong>validatoin_data</strong>：元组 <code>(x_val，y_val)</code> 或元组 <code>(x_val，y_val，val_sample_weights)</code>， 用来评估损失，以及在每轮结束时的任何模型度量指标。 </li><li><strong>shuffle</strong>：布尔值在每轮迭代之前混洗数据）或者字符串（batch）。</li><li><strong>class_weight</strong>：可选的字典，用来映射类索引（整数）到权重（浮点）值，用于加权损失函数（仅在训练期间）。</li><li><strong>sample_weight</strong>：训练样本的可选Numpy权重数组，用于对损失函数进行加权。</li><li><strong>initial_epoch</strong>：整数。开始训练的轮次。</li><li><strong>steps_per_epoch</strong>：整数或None。在声明一个轮次完成并开始下一个轮次之前的总步数。</li><li><strong>validation_steps</strong>：只有在指定了<code>steps_per_epoch</code>时才有用。停止前要验证的总步数。</li></ul><h3 id="np-where-方法"><a href="#np-where-方法" class="headerlink" title="np.where()方法"></a>np.where()方法</h3><ol><li><p><code>np.where(condition, x, y)</code></p><p>当满足条件condition时，输出x，否则输出y。</p></li><li><p><code>np.where(condition)</code></p><p>只有条件condition，没有x和y，则输出满足条件元素的坐标（以tuple的形式给出）。</p></li><li><p>给<code>np.where()</code>函数传递一个条件数组和两个值或者数组，对于条件数组中等价于True的位置，从第一个值或数组中取值进行替换，否则从第二个值或数组中取值进行替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">y = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>]])</span><br><span class="line">print(np.where(x%<span class="number">2</span> == <span class="number">1</span>, x, -x))</span><br><span class="line">print(np.where(y%<span class="number">2</span> == <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">print(np.where(y, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], [<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>]))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后一组是当等于0时为false,不为0时为true</span></span><br><span class="line"><span class="comment"># 所以y取1时为true，最后一个取第一组的30；y取0时为false，最后一个取第二组的70</span></span><br><span class="line">[ <span class="number">1</span> <span class="number">-2</span>  <span class="number">3</span> <span class="number">-4</span>  <span class="number">5</span> <span class="number">-6</span>]</span><br><span class="line">[[ <span class="number">1</span> <span class="number">-1</span>  <span class="number">1</span>]</span><br><span class="line"> [<span class="number">-1</span>  <span class="number">1</span> <span class="number">-1</span>]]</span><br><span class="line">[[<span class="number">30</span> <span class="number">70</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">30</span> <span class="number">40</span> <span class="number">80</span>]]</span><br></pre></td></tr></table></figure></li></ol><p>np.where()[0]表示行的索引，np.where()[1]表示列的索引</p><h3 id="Epoch、Batchsize、Iteration"><a href="#Epoch、Batchsize、Iteration" class="headerlink" title="Epoch、Batchsize、Iteration"></a>Epoch、Batchsize、Iteration</h3><h4 id="Epoch"><a href="#Epoch" class="headerlink" title="Epoch"></a>Epoch</h4><p>训练时，所有训练数据集都被训练过一次。</p><h4 id="Batchsize"><a href="#Batchsize" class="headerlink" title="Batchsize"></a>Batchsize</h4><p>在训练集中选择一组样本（训练集中的部分样本）用来更新权值。1个batch包含的样本的数目，通常是2的n次幂。常用的包括64，128，256。网络较小时选择256，较大时选择64。</p><h4 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h4><p>训练时，1个batch训练图像通过网络训练一次（一次前向传播 + 一次后向传播），每迭代一次权重更新一次；测试时，1个batch测试图像通过网络一次（一次前向传播）。iteration即完成一个epoch所需要的batch个数。</p><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot()"></a>subplot()</h3><p><code>subplot()</code>是用来绘制子图的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成两行两列，编号为1</span></span><br><span class="line"><span class="comment"># plt.subplot('行', '列', '编号')</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>Tips:</strong></p><p>行号优先，行优先开始数。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未来面前，你我都是孩子</title>
      <link href="/2019/10/14/%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%EF%BC%8C%E4%BD%A0%E6%88%91%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90/"/>
      <url>/2019/10/14/%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%EF%BC%8C%E4%BD%A0%E6%88%91%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>70<strong>后或者</strong>60<strong>后的尾巴基本算是造成如今社会阶级分层的一代。他们或通过刚刚恢复的高考成为当时的天之骄子大学生，或头脑活络下海经商赚得第一桶金，总之他们为后辈们所打下的基础是如今这代人仅凭学习或者工作都无法轻易实现的。但是他们也很苦，因为他们小时候正逢国家最苦难的那个时代。</strong></p><a id="more"></a><p>80<strong>后，如今也许都成家立业。他们也不容易，他们赶上了</strong>08<strong>年金融危机，赶上了</strong>09<strong>年一线城市开始高涨的房价，但他们也许还可以在二线城市也就是如今的新一线城市站住脚跟。</strong></p><p><strong>而</strong>90<strong>后，他们既享受着与生俱来的福利，也面临着当今社会的生存挑战。他们自小就至少温饱不愁，衣食无忧，甚至部分已经可以享受拼爹的福利，但也有更多的人，在当他们走出学校这个象牙塔，迈入社会之时，他们可能才发现这座繁华的城市很欢迎你来，却也很难让你一直驻足下去。</strong>16<strong>年二线城市的房价飞涨，让没有提早上车又没有家庭经济基础的部分这代人，生存变得很艰难。并且伴随着国家政策的调控，连三四线城市的房价都一路攀升，或许有一天你会发现连购买你家乡的房子都捉襟见肘。</strong></p><p><strong>当今在大城市的主要职业里，有两个风口，一个是互联网IT，一个是金融。放大一点的话，房地产和教育也很不错。这些都是薪水十分可观的职业。但一些其他的职业，则仅凭薪水可能很难满足。</strong></p><p><strong>尽管生活很艰辛，阶级固化严重，尽管在仅凭十年二十年甚至一代人，就在经济实力和社会地位上跨越一个阶级并不是很轻松的事情，但是如果有方法的努力，前途仍然光明。承认并清醒地认识到自身的缺陷和不足，眼光长远，在适合自己，适合社会的领域深耕，保持自省的状态，未来可期。</strong></p><p><strong>命运如浮萍，飞砂风中转。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配Android7.0以上调取相机拍照并返回照片</title>
      <link href="/2019/04/17/%E9%80%82%E9%85%8DAndroid7.0%E4%BB%A5%E4%B8%8A%E8%B0%83%E5%8F%96%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%85%A7%E7%89%87/"/>
      <url>/2019/04/17/%E9%80%82%E9%85%8DAndroid7.0%E4%BB%A5%E4%B8%8A%E8%B0%83%E5%8F%96%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%85%A7%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>Android调取系统相机拍照获取到拍摄照片或从相册中直接选取照片后展示上传是Android开发中很常见的一个功能，实现的思路主要是：</p><ul><li>自Android 6.0以后对某些涉及用户隐私权限的获取需要动态获取，所以首先是检查权限，如没有权限则动态申请权限，这里我们需要用到的权限是WRITE_EXTERNAL_STORAGE和CAMERA</li><li><p>自Android 7.0后系统禁止应用向外部公开file://URI ，因此需要FileProvider来向外界传递URI</p></li><li><p>获取到拍照后的照片，按照现在的手机拍照文件大小来说不做处理直接展示很容易发生OOM，因此这一步需要对图片做压缩处理</p></li></ul><h3 id="一、动态申请权限"><a href="#一、动态申请权限" class="headerlink" title="一、动态申请权限"></a>一、动态申请权限</h3><p>首先在Mainfest.xml文件中声明权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为拍照需要写入文件 所以需要申请读取内存的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>点击Button模拟拍照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">mBtn.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="comment">// 如果版本大于Android 6.0</span></span><br><span class="line">        <span class="keyword">if</span> (! checkPermission()) &#123;</span><br><span class="line">          <span class="comment">// 如果没有全部权限，则请求权限</span></span><br><span class="line">          requestPermissions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        takePhoto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否有权限</span></span><br><span class="line">  <span class="keyword">boolean</span> haveCameraPermission = ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">  <span class="keyword">boolean</span> haveWritePermission = ContextCompat.checkSelfPermission(mContext, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">  <span class="keyword">return</span> haveCameraPermission &amp;&amp; haveWritePermission;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.M)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  requestPermissions(<span class="keyword">new</span> String[]&#123;Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_PERMISSION_CODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull  String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">  <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_PERMISSION_CODE:</span><br><span class="line">        <span class="keyword">boolean</span> allowAllPermission = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grantResults.length; i++) &#123;</span><br><span class="line">              <span class="comment">// 被拒绝授权</span></span><br><span class="line">              <span class="keyword">if</span> (grantResults[<span class="number">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                  allowAllPermission = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              allowAllPermission = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allowAllPermission) &#123;</span><br><span class="line">              takePhotoOrPickPhoto();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Toast.makeText(mContext, <span class="string">"该功能需要授权方可使用"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点击拍照按钮后，调用 <code>ContextCompat.checkSelfPermission( )</code>方法检查是否有权限，方法返回值为0说明已经授权。没授权的情况下，调用<code>requestPermissions( )</code>方法，该方法的第一个参数为一个数组，数组中的值为你要申请的一个或多个权限的值，第二个参数为请求码。</p><p>调用<code>requestPermission( )</code>方法后我们需要在Activity中重写<code>onRequestPermissionsResult()</code>方法，在该方法中会得到回调结果，方法中第一个参数是请求码，第二个参数是我们申请的权限数组，第三个参数数组中每一个值对应申请的每一个权限的返回值，值为0或-1，0代表授权，-1代表拒绝授权。</p><h3 id="二、FileProvider"><a href="#二、FileProvider" class="headerlink" title="二、FileProvider"></a>二、FileProvider</h3><p>在获取所有所需的权限后，我们调取系统相机拍照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 步骤一：创建存储照片的文件</span></span><br><span class="line">  String path = getFilesDir() + File.separator + <span class="string">"images"</span> + File.separator;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path, <span class="string">"test.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.getParentFile().exists())</span><br><span class="line">        file.getParentFile().mkdirs();</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    <span class="comment">// 步骤二：Android 7.0及以上获取文件 Uri </span></span><br><span class="line">      mUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.example.admin.custmerviewapplication"</span>, file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 步骤三：获取文件Uri</span></span><br><span class="line">     mUri = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 步骤四：调取系统拍照</span></span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, mUri);</span><br><span class="line">    startActivityForResult(intent, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android 7.0之前我们只需要步骤一、三、四即可调取系统相机拍照，在此之后的话直接这么调取会报<code>android.os.FileUriExposedException</code>异常。所以我们需要对Android 7.0及以后的机型适配，采用FileProvider方式。</p><h4 id="1-FileProvider是什么"><a href="#1-FileProvider是什么" class="headerlink" title="1. FileProvider是什么"></a>1. FileProvider是什么</h4><p>FileProvider是ContentProvider的一个子类，用于应用程序之间私有文件的传递。自Android 7.0后系统禁止应用向外部公开file://URI ，因此需要FileProvider来向外界传递URI，传递的形式是content : //Uri，使用时需要在清单文件中注册。</p><h4 id="2-注册清单文件"><a href="#2-注册清单文件" class="headerlink" title="2. 注册清单文件"></a>2. 注册清单文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.example.admin.custmerviewapplication"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释上面provider标签的意思：</p><p><strong>name</strong> 因为我们使用的是V4包下的FileProvider ，所以name的值就是V4包下FileProvider的相对路径值。当然我们也可以自定义类继承于FileProvider，这时候name的值就是我们自定义类的相对路径了</p><p><strong>authorities</strong> 可以理解为标识符，是我们自己自定义的。我们代码中调用getUriForFile方法获取Uri时第二个参数就是这里我们定义的值</p><p><strong>exported</strong> 代表是否可以输出被外部程序使用，填false就行</p><p><strong>android:grantUriPermissions</strong> 是否允许为文件授予临时权限，必须为true</p><p><strong><meta-data></strong> 标签里配置的内容是用来指定那个文件夹下的文件是可被共享的</p><p><strong>name</strong> 为固定的值android.support.FILE_PROVIDER_PATHS</p><p><strong>path</strong> 是对应的xml文件路径，@xml/file_paths代表在xml文件下的file_paths文件</p><h4 id="3-指定可共享的文件路径"><a href="#3-指定可共享的文件路径" class="headerlink" title="3. 指定可共享的文件路径"></a>3. <strong>指定可共享的文件路径</strong></h4><p>在res目录下新建一个xml文件夹，在文件夹下创建一个名为file_paths的xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--files-path  相当于 getFilesDir（）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--cache-path  相当于 getCacheDir（）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"lalala"</span> <span class="attr">path</span>=<span class="string">"cache_image"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--external-path  相当于 Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attr">external-path</span>  <span class="attr">name</span>=<span class="string">"hahaha"</span> <span class="attr">path</span>=<span class="string">"comeOn"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--external-files-path  相当于 getExternalFilesDir("") --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"paly"</span> <span class="attr">path</span>=<span class="string">"freeSoft"</span>/&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--external-cache-path  相当于 getExternalCacheDir（） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span>  <span class="attr">name</span>=<span class="string">"lei"</span> <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>files-path所代表的路径等于getFilesDir()，打印getFileDir( )它的路径是 /data/user/0/包名/files。什么意思呢，<code>&lt;files-path name=&quot;my_images&quot; path=&quot;images&quot;/&gt;</code>的意思就是<code>/data/user/0/包名/files + &quot;/files-path标签中path的值/&quot;</code>路径下的文件是可共享的，在生成Uri时name的值my_images会替代上面的路径<code>/data/user/0/包名/files / images /</code>向外暴露。最终的Uri会是<code>content : //com.example.admin.custmerviewapplication / my_images / test.jpg</code></p><h3 id="三、图片获取并压缩"><a href="#三、图片获取并压缩" class="headerlink" title="三、图片获取并压缩"></a>三、图片获取并压缩</h3><p>我们调用<code>startActivityForResult(intent, 101);</code>进行拍照，拍照结束后会回调onActivityResult( )方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_TAKE_PHOTO_CODE) &#123;</span><br><span class="line">      <span class="comment">// 获取系统照片上传</span></span><br><span class="line">        Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bm = getBitmapFormUri(mUri);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        mImageView.setImageBitmap(bm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Uri直接获取图片加载到内存然后显示在ImageView很容易发生OOM，所以还需做进一步的图片压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFormUri</span><span class="params">(Uri uri)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">  InputStream input = getContentResolver().openInputStream(uri);</span><br><span class="line">    <span class="comment">// 这一段代码是不加载文件到内存中也得到bitmap的真是宽高，主要是设置inJustDecodeBounds为true</span></span><br><span class="line">    BitmapFactory.Options onlyBoundsOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    onlyBoundsOptions.inJustDecodeBounds = <span class="keyword">true</span>;<span class="comment">//不加载到内存</span></span><br><span class="line">    onlyBoundsOptions.inDither = <span class="keyword">true</span>;<span class="comment">//optional</span></span><br><span class="line">    onlyBoundsOptions.inPreferredConfig = Bitmap.Config.RGB_565;<span class="comment">//optional</span></span><br><span class="line">    BitmapFactory.decodeStream(input, <span class="keyword">null</span>, onlyBoundsOptions);</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">int</span> originalWidth = onlyBoundsOptions.outWidth;</span><br><span class="line">    <span class="keyword">int</span> originalHeight = onlyBoundsOptions.outHeight;</span><br><span class="line">    <span class="keyword">if</span> ((originalWidth == -<span class="number">1</span>) || (originalHeight == -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 图片分辨率以480x800为标准</span></span><br><span class="line">    <span class="keyword">float</span> hh = <span class="number">800f</span>;<span class="comment">// 这里设置高度为800f</span></span><br><span class="line">    <span class="keyword">float</span> ww = <span class="number">480f</span>;<span class="comment">// 这里设置宽度为480f</span></span><br><span class="line">    <span class="comment">// 缩放比，由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可</span></span><br><span class="line">    <span class="keyword">int</span> be = <span class="number">1</span>;<span class="comment">// be=1表示不缩放</span></span><br><span class="line">    <span class="keyword">if</span> (originalWidth &gt; originalHeight &amp;&amp; originalWidth &gt; ww) &#123;</span><br><span class="line">      <span class="comment">// 如果宽度大的话根据宽度固定大小缩放</span></span><br><span class="line">        be = (<span class="keyword">int</span>) (originalWidth / ww);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originalWidth &lt; originalHeight &amp;&amp; originalHeight &gt; hh) &#123;</span><br><span class="line">      <span class="comment">// 如果高度高的话根据宽度固定大小缩放</span></span><br><span class="line">      be = (<span class="keyword">int</span>) (originalHeight / hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (be &lt;= <span class="number">0</span>)</span><br><span class="line">      be = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 比例压缩</span></span><br><span class="line">    BitmapFactory.Options bitmapOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    bitmapOptions.inSampleSize = be;</span><br><span class="line">  <span class="comment">// 设置缩放比例</span></span><br><span class="line">    bitmapOptions.inDither = <span class="keyword">true</span>;</span><br><span class="line">    bitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">    input = getContentResolver().openInputStream(uri);</span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeStream(input, <span class="keyword">null</span>, bitmapOptions);</span><br><span class="line">    input.close();</span><br><span class="line">truetrue<span class="keyword">return</span> compressImage(bitmap);<span class="comment">// 再进行质量压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">compressImage</span><span class="params">(Bitmap image)</span> </span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    image.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, baos);</span><br><span class="line">    <span class="comment">// 质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中</span></span><br><span class="line">    <span class="keyword">int</span> options = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (baos.toByteArray().length / <span class="number">1024</span> &gt; <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// 循环判断如果压缩后图片是否大于100kb,大于继续压缩</span></span><br><span class="line">        baos.reset();<span class="comment">// 重置baos即清空baos</span></span><br><span class="line">        <span class="comment">// 第一个参数 ：图片格式 ，第二个参数： 图片质量，100为最高，0为最差  ，第三个参数：保存压缩后的数据的流</span></span><br><span class="line">        image.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">      <span class="comment">// 这里压缩options，把压缩后的数据存放到baos中</span></span><br><span class="line">        options -= <span class="number">10</span>;<span class="comment">//每次都减少10</span></span><br><span class="line">        <span class="keyword">if</span> (options &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ByteArrayInputStream isBm = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">  <span class="comment">// 把压缩后的数据baos存放到ByteArrayInputStream中</span></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeStream(isBm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 把ByteArrayInputStream数据生成图片</span></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩的步骤分为两步，第一步是先得到bitmap的真实宽高计算压缩比例，得到压缩比例后进行初步压缩。第二步将初步压缩的bitmap进行质量压缩得到最终的图片。</p><p>从相册中选取图片步骤和调取相机拍照的步骤一致，只是创建的intent和在onActivtyResult回调时获取的Uri不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用相册</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_UR）;</span><br><span class="line">startActivityForResult(intent, PICK_IMAGE_CODE);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">  <span class="comment">//获取图片路径</span></span><br><span class="line">  <span class="keyword">if</span> (requestCode == <span class="number">102</span> &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; data != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//通过getData获取到Uri</span></span><br><span class="line">      mUri = data.getData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多媒体技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android1.5到Android10.0经历的新特性</title>
      <link href="/2019/02/28/Android1.5%E5%88%B0Android10.0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/02/28/Android1.5%E5%88%B0Android10.0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="Android-1-5-Cupcake-纸杯蛋糕"><a href="#Android-1-5-Cupcake-纸杯蛋糕" class="headerlink" title="Android 1.5(Cupcake 纸杯蛋糕)"></a>Android 1.5(Cupcake 纸杯蛋糕)</h3><ul><li>智能虚拟键盘；<strong>使用widgets实现桌面个性化</strong>；在线文件夹(Live Folder)快速浏览在线数据；视频录制和分享；图片上传；</li><li>更快的标准兼容浏览器；Voice search 语音搜索；立体声蓝牙和免提电话</li></ul><a id="more"></a><h3 id="Android-1-6-Donut-甜甜圈"><a href="#Android-1-6-Donut-甜甜圈" class="headerlink" title="Android 1.6(Donut 甜甜圈)"></a>Android 1.6(Donut 甜甜圈)</h3><ul><li>完全重新设计的Android Market，可以显示更多的屏幕截图；手势支持，可以让开发者生成针对某个应用程序的手势库</li><li>支持CDMA网络</li><li>TXT-2-Speech，支持了更多语言的发音，包括英语、法语、德语、意大利语等</li><li><strong>快速搜索框，可直接搜索括联系人，音乐，浏览历史，书签等手机内容</strong></li><li>全新的拍照界面：新版相机程序启动速度快了39%，拍照间的延迟减少了28%</li><li><strong>应用程序耗电查看</strong></li><li>新增面向视觉或听觉困难人群的易用性插件</li><li>Linux内核升级到2.6.29</li><li>支持更多的屏幕分辨率</li></ul><h3 id="Android-2-0-2-0-2-1-Eclair-松饼（闪电泡芙）"><a href="#Android-2-0-2-0-2-1-Eclair-松饼（闪电泡芙）" class="headerlink" title="Android 2.0(2.0~2.1 Eclair 松饼（闪电泡芙）)"></a>Android 2.0(2.0~2.1 Eclair 松饼（闪电泡芙）)</h3><ul><li>加强了网络社交功能，比如Facebook好友整合至联系人功能</li><li>自带的Chrome Lite浏览器现在加入了对双击屏幕进行缩放的支持</li><li>由于文件结构的改动优化，使得整个操作流畅性得到了很大的提升</li><li>强化了语音识别的搜索控制。整个系统多处都支持语音控制，并拥有独立的控制面板</li><li>谷歌地图服务更新，加入了全新的导航系统</li><li>加入了原生微软Exchange邮件服务支持</li><li>提供了多个不同帐户，统一的邮件收件箱</li><li>优化了驾车时的体验，新的“Car Home”应用程序为各功能提供了易于操作的快捷链接，还能方便地使用语音控制功能，便于用户驾车时使用</li></ul><h3 id="Android-2-1"><a href="#Android-2-1" class="headerlink" title="Android 2.1"></a>Android 2.1</h3><ul><li>可以同时绑定多个Google账号</li><li>无线控件里有了VPN设置</li><li>增加了连接到PC设置</li><li>增强了语言和声音的转换功能，并加入了文字到语音转换</li><li>全新的拨号界面，按键更大，更易于操作</li><li>更多桌面Widget</li><li>新的Google地图可以使用谷歌地图导航功能</li><li>新的浏览器版本，加强了稳定性和网页渲染能力</li><li>全局搜索功能加强</li><li>全新的Market程序，搜索更快布局更合理</li></ul><h3 id="Android-2-2-Froyo-冻酸奶"><a href="#Android-2-2-Froyo-冻酸奶" class="headerlink" title="Android 2.2(Froyo 冻酸奶)"></a>Android 2.2(Froyo 冻酸奶)</h3><ul><li>全面支持Flash 10.1</li><li><strong>应用程序自动升级</strong>，让升级更加人性化</li><li><strong>支持应用程序安装在外置内存上</strong></li><li>对系统性能进一步优化，让手机有更多的运行内存</li><li>增加了轨迹球LED指示灯变色这个新功能</li><li>增加了对3D性能的优化，3D性能更加强大</li><li>FM功能也将在新系统中得到全面支持</li></ul><h3 id="Android-2-3-Gingerbread-姜饼"><a href="#Android-2-3-Gingerbread-姜饼" class="headerlink" title="Android 2.3(Gingerbread 姜饼)"></a>Android 2.3(Gingerbread 姜饼)</h3><ul><li><strong>原生支持前置摄像头</strong></li><li>全新虚拟键盘</li><li>全局下载管理</li><li>NFC近场通信</li><li>改善电源管理</li><li>增加官方进程管理</li><li>提升多媒体能力</li><li>提升游戏体验</li><li>用户界面更美观</li></ul><h3 id="Android-3-0到3-1-3-0-Honeycomb-蜂巢"><a href="#Android-3-0到3-1-3-0-Honeycomb-蜂巢" class="headerlink" title="Android 3.0到3.1(3.0 Honeycomb 蜂巢)"></a>Android 3.0到3.1(3.0 Honeycomb 蜂巢)</h3><p>安卓3.0系统主要用于安卓的平板产品</p><h3 id="Android-4-0-Ice-CreamSandwich"><a href="#Android-4-0-Ice-CreamSandwich" class="headerlink" title="Android 4.0(Ice CreamSandwich)"></a>Android 4.0(Ice CreamSandwich)</h3><ul><li><strong>一流的新UI</strong></li><li>开源</li></ul><h3 id="Android-5-0-Lollipop-棒棒糖"><a href="#Android-5-0-Lollipop-棒棒糖" class="headerlink" title="Android 5.0(Lollipop 棒棒糖)"></a>Android 5.0(Lollipop 棒棒糖)</h3><ul><li>通过Android Market购买音乐</li><li>多核处理器优化</li><li><strong>支持现有的智能手机</strong></li><li>为OEM提供了官方的主题引擎</li></ul><h3 id="Android-6-0-Marshmallow-棉花糖"><a href="#Android-6-0-Marshmallow-棉花糖" class="headerlink" title="Android 6.0(Marshmallow 棉花糖)"></a>Android 6.0(Marshmallow 棉花糖)</h3><ul><li>锁屏下语音搜索</li><li><strong>原生指纹识别</strong></li><li><strong>更完整的应用权限管理</strong></li><li>Doze电量管理</li><li>Now on Tap功能</li><li><strong>App Links</strong></li><li><strong>Android Pay</strong></li></ul><h3 id="Android-7-0-Nougat-牛轧糖"><a href="#Android-7-0-Nougat-牛轧糖" class="headerlink" title="Android 7.0(Nougat 牛轧糖)"></a>Android 7.0(Nougat 牛轧糖)</h3><ul><li><strong>分屏多任务</strong></li><li>全新下拉快捷开关页</li><li><strong>通知消息快捷回复</strong></li><li><strong>通知消息归拢</strong></li><li><strong>夜间模式</strong></li><li>流量保护模式</li><li>全新设置样式</li><li>改进的Doze休眠机制</li><li>系统级电话黑名单功能</li><li><strong>双击菜单键快速应用切换</strong></li></ul><h3 id="Android-8-0-Oreo-奥利奥"><a href="#Android-8-0-Oreo-奥利奥" class="headerlink" title="Android 8.0(Oreo 奥利奥)"></a>Android 8.0(Oreo 奥利奥)</h3><ul><li>通知中心</li><li>设置菜单</li><li><strong>PinnedShortcuts</strong>，类似iOS中的3D Touch</li><li><strong>图标形状</strong></li><li>后台限制</li><li>安装限制</li><li><strong>TensorFlowLite</strong></li><li>NotificationDots</li><li>分屏</li><li>SmartTextSelection</li><li><strong>自动保存密码</strong></li><li>GooglePlayProtect，主要用于Google Play中，下载的应用和游戏将会经过它的排查，来看看是否是有害甚至携带病毒的应用</li><li>应用加速</li><li>字体优化</li><li>表情符号</li></ul><h3 id="Android-9-0-Pie-派"><a href="#Android-9-0-Pie-派" class="headerlink" title="Android 9.0(Pie 派)"></a>Android 9.0(Pie 派)</h3><ul><li><strong>全面屏的全面支持</strong></li><li>通知栏的多种通知</li><li>多摄像头的更多画面</li><li>GPS定位之外的WiFi定位</li><li>神经网络</li><li><strong>Material Design 2.0</strong></li><li>全局黑夜模式</li></ul><h3 id="Android-10-0"><a href="#Android-10-0" class="headerlink" title="Android 10.0"></a>Android 10.0</h3><ul><li><strong>暗黑模式</strong>，在 Android Q 中，暗黑模式适用于任何地方，如果应用不支持暗黑模式，那么系统将自动设置一个暗黑模式</li><li>隐私增强</li><li>运营商锁定</li><li>多显示器支持</li><li><strong>原生面部识别</strong></li><li><strong>桌面模式</strong></li><li><strong>原生屏幕录制</strong></li><li><strong>更安全Smart Lock</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬家前一周</title>
      <link href="/2018/11/22/%E6%90%AC%E5%AE%B6%E5%89%8D%E4%B8%80%E5%91%A8/"/>
      <url>/2018/11/22/%E6%90%AC%E5%AE%B6%E5%89%8D%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>因为各种原因，我过完这周就要搬离这个我生活了两个多月的小家了。毕竟，在这里也呆了两个多月，也结识了很nice的室友，交通也还算便利，但是，终究要离开了。</p><a id="more"></a><p>并不是说有多么的不舍，因为我还有更重要的事情需要去完成。况且，离开的结局也不是很好，毕竟是自己租期未满就提前走的，押金也无法拿回来，可以勉强算是被房东赶走的，所以并不是多么一个开心的过程。</p><p>我住在13楼。窗外就是大上海，虽然我面对的并不是繁华的市中心，但是毕竟还身处中环以内，那川流不息的车辆还是让我感觉到大城市所独特的气息。</p><p>上班时，坐地铁也就20多分钟，有时挤，有时不挤。相比某些深处外环，每天通勤时间长达三小时以上的工薪族来说，我还勉强算的上幸福。</p><p>工作的压力当然是有的。本以为实习也不会做什么艰巨的任务，主要是以培养为主。但显然这只适用于那么规模较大的公司。对于我所加入的这家创业7年，有过巅峰时期，而现在处于低谷的小公司而言，人手尚且不足，那么实习生也要求能够迅速地上手完成公司的项目。</p><p>这样有好处，当然也有坏处的。好处就是让你迅速上手完成公司项目的话，对人的阅读源码的能力要求比较高，也就是锻炼了实际写代码的能力。但是坏处也是创业公司的通病，因为需要立刻上线产品，所以在很多方面就不是那么的规范。对于有多年经验的老手来说倒是无所谓，但是对于实习生而言，还是尽量加入一家大公司，有着更完善的制度，代码也更加规范，对于今后的成长更加有帮助。</p><p>还是非常感谢这家公司能够让我加入团队。毕竟自己经历过实习，也意识到自己有太多的不足了。很多方面，我都是浅尝辄止，而没有深挖内在的原理。也正是这段实习经历，让我感到在学校里学到的很多基础学科其实大有帮助，只有将基础打牢，才能够更进一步。</p><p>作为一个还处于大四、尚未完全走出象牙塔的学生，我在某些方面仍然非常的稚嫩，包括心理的调整。毕竟身处中国最大的城市，又从事着程序员这种辛苦的职业，再加上自己现在的能力不足，很容易信心不足，产生动摇。但好在我终于挺过来了。</p><p>我觉得我从来不缺对于局势的判断能力，但我缺少的是对于某件事情攻无不克的决心。</p><p>希望今后的自己也能够更加出色吧。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android属性动画详解（转载）</title>
      <link href="/2018/11/05/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2018/11/05/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、属性动画出现的原因"><a href="#一、属性动画出现的原因" class="headerlink" title="一、属性动画出现的原因"></a>一、属性动画出现的原因</h2><p>属性动画（Property Animation）是Android3.0（API11）之后的版本中才提供的一种全新的动画模式</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>实现动画效果在Android开发中非常常见，所以Android系统提供了两种实现动画的方式：</p><ul><li>逐帧动画（Frame Animation）</li><li>补间动画（Tweened Animation）</li></ul><a id="more"></a><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>补间动画只能够作用在视图View上，即只可以对一个Button、TextView或者LinearLayout或者其它继承自View的组件进行动画操作，但无法对非View的对象进行动画操作</li><li>没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，但不会真正改变View的属性。比如通过补间动画将屏幕左上角的按钮移动到右上角，但是点击屏幕右上角仍然是没有反应的，因为实际上按钮仍然在左上角，补间动画只是将其绘制到了屏幕右上角，改变了视觉效果而已</li><li>动画效果单一。补间动画只能实现平移、旋转、缩放和透明度等简单的动画需求，对于复杂的动画效果，补间动画无法实现</li></ul><h2 id="二、属性动画简介"><a href="#二、属性动画简介" class="headerlink" title="二、属性动画简介"></a>二、属性动画简介</h2><ul><li>作用对象：任意Java对象，不再局限于视图View对象</li><li>实现的动画效果：可以自定义各种动画效果，不再局限于4种基本变换</li></ul><h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><ul><li>在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果</li><li>具体的工作原理逻辑如下：</li><li>从上述工作原理中可以看出属性动画有两个非常重要的类：ValueAnimator类和ObjectAnimator类</li></ul><h2 id="四、使用方法"><a href="#四、使用方法" class="headerlink" title="四、使用方法"></a>四、使用方法</h2><h3 id="ValueAnimator类"><a href="#ValueAnimator类" class="headerlink" title="ValueAnimator类"></a>ValueAnimator类</h3><ul><li>定义：属性动画机制中，最核心的一个类</li><li>实现动画的原理：通过不断控制值的变化，再不断手动赋给对象的属性，从而实现动画效果</li><li>ValueAnimator类中有3个主要方法：<ul><li><code>ValueAnimator.ofInt(int values)</code></li><li><code>ValueAnimator.ofFloat(float values)</code></li><li><code>ValueAnimator.ofObject(int values)</code></li></ul></li></ul><h3 id="1-valueAnimator-ofInt-int-values"><a href="#1-valueAnimator-ofInt-int-values" class="headerlink" title="1.valueAnimator.ofInt(int values)"></a>1.valueAnimator.ofInt(int values)</h3><p>Java代码设置：<br>在实际开发中，建议使用Java代码实现属性动画，因为大多数情况下，属性的起始值是无法提前确定的（无法使用XML设置）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：设置动画属性的初始值和结束值</span></span><br><span class="line">ValueAnimator anim = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// ofInt()的作用有两个</span></span><br><span class="line"><span class="comment">// 1.创建动画实例</span></span><br><span class="line"><span class="comment">// 2.将传入的多个Int参数进行平滑过渡：此处传入0和3，表示将值从0平滑过渡到3</span></span><br><span class="line"><span class="comment">// 如果传入了3个参数a、b、c，则是先从a平滑过渡到b，再从b平滑过渡到c，以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：设置动画的各种播放属性</span></span><br><span class="line"><span class="comment">// 设置动画运行的时长</span></span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 设置动画延迟播放时间</span></span><br><span class="line">anim.setStartDelay(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 设置动画重复播放次数 = 重放次数 + 1</span></span><br><span class="line"><span class="comment">// 动画播放次数 = infinite时，动画无限重复</span></span><br><span class="line">anim.setRepeatCount(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置重复播放动画模式</span></span><br><span class="line"><span class="comment">// RESTART（默认）：正序播放</span></span><br><span class="line">anim.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line"><span class="comment">// REVERSE：倒序回放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：将改变的值手动赋值给对象的属性值：</span></span><br><span class="line"><span class="comment">// 通过动画的更新监听器，设置值的更新监听器</span></span><br><span class="line"><span class="comment">// 即值每次改变、变化一次，该方法就会调用一次</span></span><br><span class="line">anim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得改变后的值</span></span><br><span class="line">    <span class="keyword">int</span> currentValue = (Integer) animation.getAnimatedValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：将改变后的值赋给对象的属性值</span></span><br><span class="line">    View.setProperty(currentValue);</span><br><span class="line">    <span class="comment">// 步骤5：刷新视图，即重新绘制，从而实现动画效果</span></span><br><span class="line">    View.requestLaytout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p><p>XML布局文件设置：</p><ul><li>步骤1：在路径res/animator文件夹中创建相对应的动画.xml文件</li><li>步骤2：设置动画参数<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animator</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueFrom</span>=<span class="string">"0"</span>         // 初始值</span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueTo</span>=<span class="string">"100"</span>         // 结束值</span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueType</span>=<span class="string">"intType"</span>   // 变化值类型：<span class="attr">floatType</span> &amp; <span class="attr">intType</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">android:duration</span>=<span class="string">"3000"</span>       // 动画持续时间（<span class="attr">ms</span>），必须设置，动画才有效果</span></span><br><span class="line"><span class="tag">  <span class="attr">android:startOffset</span>=<span class="string">"1000"</span>    // 动画延迟开始时间（<span class="attr">ms</span>）</span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillBefore</span>=<span class="string">"true"</span>     // 动画播放完后，视图是否会停留在动画开始的状态，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillAfter</span>=<span class="string">"false"</span>     // 动画播放完后，视图是否会停留在动画结束的状态，优先于<span class="attr">fillBefore</span>值，默认为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillEnabled</span>=<span class="string">"true"</span>    // 是否使用<span class="attr">fillBefore</span>值，对<span class="attr">fillAfter</span>值无影响，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:repeatMode</span>=<span class="string">"restart"</span>  // 选择重复播放动画模式，<span class="attr">restart</span>代表正序播放，<span class="attr">reverse</span>代表倒序回放，默认为<span class="attr">restart</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:repeatCount</span>=<span class="string">"0"</span>       // 重复次数（动画的播放次数=<span class="string">重复次数+1），为infinite时无限重复</span></span></span><br><span class="line"><span class="tag">  //插值器，影响动画的播放速度</span></span><br><span class="line"><span class="tag">  <span class="attr">android:interpolator</span>=<span class="string">@[package:]anim/interpolator_resource</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>步骤3：在Java代码中启动动画<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入XML动画</span></span><br><span class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.animation);</span><br><span class="line"><span class="comment">// 设置动画对象</span></span><br><span class="line">animator.setTarget(view);</span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-valueAnimator-ofInt-float-values"><a href="#2-valueAnimator-ofInt-float-values" class="headerlink" title="2.valueAnimator.ofInt(float values)"></a>2.valueAnimator.ofInt(float values)</h3><p>在使用上与ValueAnimator.ofInt(int values)完全没有区别</p><h3 id="3-valueAnimator-ofObject"><a href="#3-valueAnimator-ofObject" class="headerlink" title="3.valueAnimator.ofObject()"></a>3.valueAnimator.ofObject()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建初始动画时对象 &amp; 结束动画时的对象</span></span><br><span class="line">Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动画对象 &amp; 设置参数</span></span><br><span class="line"><span class="comment">// 参数说明</span></span><br><span class="line"><span class="comment">// 参数1：自定义的估值器对象（TypeEvaluator类型参数）</span></span><br><span class="line"><span class="comment">// 参数2：初始动画的对象</span></span><br><span class="line"><span class="comment">// 参数3：结束动画的对象</span></span><br><span class="line">ValueAnimator anim = ValueAnimator.ofObject(<span class="keyword">new</span> objectEvaluator(), object1, object2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置动画属性</span></span><br><span class="line">anim.setDuration(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><h3 id="ObjectAnimator类"><a href="#ObjectAnimator类" class="headerlink" title="ObjectAnimator类"></a>ObjectAnimator类</h3><h4 id="实现动画的原理"><a href="#实现动画的原理" class="headerlink" title="实现动画的原理"></a>实现动画的原理</h4><p>直接对对象的属性值进行改变操作，从而实现动画效果</p><h4 id="ValueAnimator类与ObjectAnimator类的区别"><a href="#ValueAnimator类与ObjectAnimator类的区别" class="headerlink" title="ValueAnimator类与ObjectAnimator类的区别"></a>ValueAnimator类与ObjectAnimator类的区别</h4><ul><li>ValueAnimator类是先改变值，然后手动赋值给对象的属性从而实现动画；是间接对对象属性进行操作</li><li>ObjectAnimator类是先改变值，然后自动赋值给对象的属性从而实现动画；是直接对对象属性进行操作</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Java设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(Object object, String property, <span class="keyword">float</span> ...values);</span><br><span class="line">anim.setDuration(<span class="number">500</span>);</span><br><span class="line">anim.setStartDelay(<span class="number">500</span>);</span><br><span class="line">anim.setRepeatCount(<span class="number">0</span>);</span><br><span class="line">anim.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>XML设置与ValueAnimator一样</p><p>a.透明度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">// 动作作用的对象是mButton</span></span><br><span class="line"><span class="comment">// 动画作者的对象的属性是透明度alpha</span></span><br><span class="line"><span class="comment">// 动画效果是：常规 - 全透明 - 常规</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>b.旋转：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">// 动作作用的对象是mButton</span></span><br><span class="line"><span class="comment">// 动画作者的对象的属性是旋转rotation</span></span><br><span class="line"><span class="comment">// 动画效果是：0 - 360</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>c.平移：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">// 获得当前控件的位置</span></span><br><span class="line"><span class="keyword">float</span> curTranslationX = mButton.getTranslationX();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画作用的对象的属性是X轴平移，translationX</span></span><br><span class="line"><span class="comment">// 在Y轴上平移同理，采用属性translationY</span></span><br><span class="line"><span class="comment">// 动画效果：从当前位置平移到x=300，再平移到初始位置</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"translationX"</span>, curTranslationX, <span class="number">300</span>, curTranslationX);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>d.缩放：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画作用的对象的属性是X轴缩放，sacleX</span></span><br><span class="line"><span class="comment">// 在Y轴上缩放同理，采用属性scaleY</span></span><br><span class="line"><span class="comment">// 动画效果：放大到3倍，再缩小到原始大小</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"scaleX"</span>, <span class="number">1f</span>, <span class="number">3f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th><th style="text-align:center">数值类型</th></tr></thead><tbody><tr><td style="text-align:center">Alpha</td><td style="text-align:center">控制View的透明度</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">TranslationX</td><td style="text-align:center">控制X方向的位移</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">TranslationY</td><td style="text-align:center">控制Y方向的位移</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">ScaleX</td><td style="text-align:center">控制X方向的缩放倍数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">ScaleY</td><td style="text-align:center">控制Y方向的缩放倍数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">Rotation</td><td style="text-align:center">控制以屏幕方向为轴的旋转度数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">RotationX</td><td style="text-align:center">控制以X轴为轴的旋转度数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">RotationY</td><td style="text-align:center">控制以Y轴为轴的旋转度数</td><td style="text-align:center">float</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫长旅途</title>
      <link href="/2018/01/15/%E6%BC%AB%E9%95%BF%E6%97%85%E9%80%94/"/>
      <url>/2018/01/15/%E6%BC%AB%E9%95%BF%E6%97%85%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p>象征着父母的鲸鱼在童年陪我们嬉戏，虽然曾一度消失，但在我们被障碍物挡住的时候再度出现，帮助我们度过困难，其实父母一直在我们身后，就如同我们和爱人跟在自己的孩子身后一样。</p><p>当爱人永远留在了草丛中无法唤醒之后，人生的旅途变得孤单漫长寂寞，最后孩子的挽留也无法阻挡我们逝去的脚步。</p><p>当一生走到尽头的时候，正如作家毕淑敏所说的，人行将就木的时候，一生的轨迹会像微缩电影一样迅速放过，温馨的糖果盒里的童年，生如夏花般美好的青春，独自闯荡的不羁无畏，爱情的火花，得子的喜悦与责任……都如同精心剪裁的电影片段匆匆走过。</p><p>是的，每个人的一生都是短暂的，来时什么都是没有，走时什么也不带走，但当自己一生的电影一放而过时，弥留之际的最后留下的幸福是满足，那此生足矣。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独者的任务是加倍孤独</title>
      <link href="/2018/01/13/%E5%AD%A4%E7%8B%AC%E8%80%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%8A%A0%E5%80%8D%E5%AD%A4%E7%8B%AC/"/>
      <url>/2018/01/13/%E5%AD%A4%E7%8B%AC%E8%80%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%8A%A0%E5%80%8D%E5%AD%A4%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<p>天色稍有嫌疑，就要带上雨伞。</p><p>停电了，打开手机，打开电脑，出于本能的赶走黑暗。</p><p>是的，一直没有变，只是心里清楚，独居的时候，没有谁会来照顾自己。</p><p>需要沦落到赞美孤独的地步吗？</p><p>绝不。</p><p>赞美人性中的孤独，</p><p>等于什么也没有赞美。</p><p>但还可以继续努力吗？ </p><p>可以的。 </p><p>即使独自生活，也要努力照顾好自己。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月长明——记北齐咸阳王斛律光</title>
      <link href="/2018/01/07/%E6%9C%88%E9%95%BF%E6%98%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%8C%97%E9%BD%90%E5%92%B8%E9%98%B3%E7%8E%8B%E6%96%9B%E5%BE%8B%E5%85%89/"/>
      <url>/2018/01/07/%E6%9C%88%E9%95%BF%E6%98%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%8C%97%E9%BD%90%E5%92%B8%E9%98%B3%E7%8E%8B%E6%96%9B%E5%BE%8B%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>与诸多良将一样，他亦是年少成名。当年在洹桥的那一箭划破苍穹时，便注定了他必不平凡的命运。</p><p>几番浴血疆场，出生入死，为的就是他心中至死不曾相负的国家。</p><p>从涡河之岸逞强失利的懵懂少年到所过之处闻风丧胆的北齐战神，他一直都是他。</p><p>以自身耀眼的明月光守护着一个国家，无论国之兴衰，无论是成是败。</p><p>可是到了最后，他辅佐的最后一位君主，这个国家的倒数第二位主人，竟同朝堂奸佞一道谋害、背弃他。</p><p>生命的最后一刻，他方才明白，这个国家现在的君主最忌惮的便是他。</p><p>可这又如何呢，在他的心里，对这个国家所做的一切永远都是值得的，无论国家对他如何、对他的家人如何。</p><p>当御用刽子手刘桃枝将弓弦紧累上他脖子的那一刻，这位不可一世的咸阳王竟无半点反抗。只是轻蔑地向身后数人瞟了一眼，拼尽最后一丝力气说出此生的最后一句话：“<strong>我不负国家</strong>”。</p><p>“不负国家”是对他一生最恰当的结语。凭这四个字，便足以将他摆在我最敬重之人的首位。如今千年光景已逝，为他留下的唯有一块难辨伪真的冰冷碑坟，和苍穹之上的清冷凉月。</p><p>他是北齐书中最耀眼的明月光，千载之后，洗尽铅华，唯余最初守望家国的明亮。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
