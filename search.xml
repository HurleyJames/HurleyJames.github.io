<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>JS有三宝——var、let、const</title>
      <link href="/2021/01/11/JS%E4%B8%89%E5%AE%9D--var%20let%20const/"/>
      <url>/2021/01/11/JS%E4%B8%89%E5%AE%9D--var%20let%20const/</url>
      
        <content type="html"><![CDATA[<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><p>最早，JavaScript是使用<code>var</code>来声明变量的，但是由于设计得并不合理，后来在ES6推出了<code>let</code>和<code>const</code>。</p><p>var的作用域是<strong>全局</strong>和<strong>函数</strong>作用域，而作用域指的是变量能够作用的范围。所以，全局作用域指的就是变量伴随了整个程序的生命周期；而函数作用域指的是在函数体内定义，可以在该函数内的任意地方使用。</p><p>什么是全局作用域？在App开发中，一个App就是一个进程，那么全局作用域就是在这个应用内部都可以访问到该变量，并且它一直在执行环境中，不会被释放。而浏览器中，就得把一个页面看做是一个全局，所以，全局变量的生命周期和这个页面的生命周期是一样的。</p><p>可是，使用<code>var</code>声明变量有很大的弊端。「它会使变量提升」，即「在代码执行之前，JavaScript引擎把变量和函数的声明部分提升到对应作用域的开始位置」。如果变量提升后，<code>var</code>声明的变量的初始值就是<code>undefined</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">call();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// name被提升</span></span><br><span class="line">    <span class="built_in">console</span>.log(name);</span><br><span class="line">    <span class="keyword">var</span> name = <span class="string">'三宝'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="let"><a href="#let" class="headerlink" title="let"></a>let</h2><p>为此，在ES6中，提出了<code>let</code>这个声明变量的方式，使用<code>let</code>声明的变量是<strong>块级作用域</strong>。即用<code>let</code>声明的变量只能在这个块内部使用，而同一变量是不可以重复声明的。不过，如果是在不同的作用域中，即跳出了这个块，那么是可以重复定义的。</p><p>什么是块呢？只要有两个大括号就属于一个域。块就是两个大括号包起来的内容。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">2</span>; i++) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">call</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="comment">// 代码块</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于使用<code>let</code>声明的变量，如果在未声明时就使用，那么会报错<code>Cannot access</code>XXX<code>before initialization</code>。</p><h3 id="const"><a href="#const" class="headerlink" title="const"></a>const</h3><p>但是有时候我们声明一个变量之后，一旦赋值了就不需要再更改了，那么我们就可以用<code>const</code>，即声明常量最常用的手段。所以，在日常开发中，能要用<code>const</code>就要用<code>const</code>，它能够保证程序的状态更加稳定。在别的方面，<code>const</code>都与<code>let</code>类似，不同之处就在于它的不变性，且使用<code>const</code>声明的变量在声明时，就一定要设定初始值。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ol><li><code>var</code>声明的变量的作用域是全局或者函数级别的，而<code>let</code>和<code>const</code>声明的变量是块级的，一个<code>{}</code>表示一个代码块。</li><li><code>var</code>声明的变量可以更新，可以重新声明；<code>let</code>声明的变量可以更新，但是不能重新声明；<code>const</code>声明的变量既不能重新更新也不能重新声明；</li><li><code>var</code>和<code>let</code>声明的变量可以不初始化，但是<code>const</code>声明的变量必须初始化；</li><li>其实，<code>var</code>、<code>let</code>、<code>const</code>声明的变量都会发生变量提升（即先使用后定义），<code>var</code>如果这样会被初始化为<code>undefined</code>，而<code>let</code>和<code>const</code>声明的变量则不会被初始化，会直接报错。</li></ol><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><ul><li><a href="https://mp.weixin.qq.com/s/uZOj5HzJmH_fNeUEPipqwA" target="_blank" rel="noopener">var 很傻、let 很亲切 、const 更坚定</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> JavaScript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务框架(二)——Spring Cloud</title>
      <link href="/2021/01/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%BA%8C)%E2%80%94%E2%80%94Spring%20Cloud/"/>
      <url>/2021/01/02/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%BA%8C)%E2%80%94%E2%80%94Spring%20Cloud/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Spring Cloud provides tools for developers to quickly build some of the common patterns in distributed systems (e.g. configuration management, service discovery, circuit breakers, intelligent routing, micro-proxy, control bus, one-time tokens, global locks, leadership election, distributed sessions, cluster state). Coordination of distributed systems leads to boiler plate patterns, and using Spring Cloud developers can quickly stand up services and applications that implement those patterns. They will work well in any distributed environment, including the developer’s own laptop, bare metal data centres, and managed platforms such as Cloud Foundry.</p></blockquote><p>Spring Cloud是一系列框架的有序集合，它利用SpringBoot的开发便利性，巧妙地简化了分布式系统的基础设施的开发，如服务发现注册、配置中心、消息总线、负载均衡、断路器、数据监控等，都可以做到一键启动和部署。</p><p><strong>选用Spring Cloud的好处包括</strong>：</p><ul><li>基于HTTP协议，使用RESTFUL风格，接口简单方便，高效透明（Dubbo是使用RPC协议，性能稍优于HTTP协议，但是耦合度更高）</li></ul><h2 id="核心成员"><a href="#核心成员" class="headerlink" title="核心成员"></a>核心成员</h2><ul><li>服务注册中心：Spring Cloud Netflix Eureka</li><li>服务调用方式：RESTFUL API</li><li>服务监控：SpringBoot Admin</li><li>断路器：Spring Cloud Netflix Hystrix</li><li>服务网关：Spring Cloud Netflix Zuul</li><li>分布式配置：Spring Cloud Config</li><li>服务跟踪：Spring Cloud Sleuth</li><li>消息总线：Spring Cloud Bus</li><li>数据流：Spring Cloud Stream</li><li>批量任务：Spring Cloud Task</li></ul><h3 id="Spring-Cloud-Eureka"><a href="#Spring-Cloud-Eureka" class="headerlink" title="Spring Cloud Eureka"></a>Spring Cloud Eureka</h3><p>Eureka是Netflix开发的服务发现组件，本身是一个基于REST的服务，主要用于定位运行在AWS域中的中间层服务，以达到负载均衡和中间层服务故障转移的目的。Spring Cloud将其集成在其子项目spring-cloud-netflix上，以实现Spring Cloud的服务发现功能。</p><p>我们可以将自定义的API接口注册到Spring Cloud Eureka上，Eureka负责服务的注册与发现，它的角色与ZooKeeper差不多，都是服务的注册与发现。所以，构成Eureka体系的包括：服务注册中心、服务提供者、服务消费者，主要包含两个组件：Eureka Server和Eureka Client。</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seo74I.png" alt="High Level Architecture"></p><blockquote><p>The architecture above depicts how Eureka is deployed at Netflix and this is how you would typically run it. There is <strong>one</strong> eureka cluster per <strong>region</strong> which knows only about instances in its region. There is at the least <strong>one</strong> eureka server per zone to handle <strong>zone</strong> failures.</p><p>Services <strong>register</strong> with Eureka and then send <strong>heartbeats</strong> to renew their leases every 30 seconds. If the client cannot renew the lease for a few times, it is taken out of the server registry in about 90 seconds. The registration information and the renewals are replicated to all the eureka nodes in the cluster. The clients from any zone can look up the <strong>registry</strong> information (happens every 30 seconds) to locate their services (which could be in any zone) and make remote calls.</p></blockquote><p>Eureka Server提供服务注册功能，提供者节点启动后，会在Eureka Server中进行注册，所以Eureka Server的服务注册表中将会存储所有可用服务节点的信息。各个提供者会向Euraka Server发送心跳，以告知Eureka Server自己的健康状况，默认周期为30秒。如果在多个心跳周期内都没有接收到某个提供者节点的心跳，那么Eureka Server就会认为其已经无法提供服务，就会将该节点从服务注册表中移除。Eureka Server之间是通过复制的方式完成数据的同步。</p><p>Eureka Client是一个Java客户端，是用于简化消费者与Eureka Server的交互。同时，Eureka Client内置有负载均衡器，为消费者从Eureka Server的服务注册表中选择合适的提供者。</p><p>Eureka提供了客户端缓存机制，即使所有的Eureka Server都宕机，客户端仍然能够利用缓存的信息为消费者提供服务发现功能。但此时就不再接受服务注册。</p><p>综上，Eureka通过心跳检查、客户端缓存等机制，确保了系统的高可用性、灵活性和可伸缩性。</p><h3 id="Spring-Cloud-Hystrix"><a href="#Spring-Cloud-Hystrix" class="headerlink" title="Spring Cloud Hystrix"></a>Spring Cloud Hystrix</h3><p>Hystrix的意思是豪猪，所以，它表明了框架的主要功能：<strong>自我保护功能</strong>。Hystrix是一个用于处理分布式系统的延迟和容错的开源库。Hystrix具有服务降级，熔断，线程池隔离，信号量隔离，缓存等功能。它能够保证在一个依赖出现问题的情况下，不会倒置整体服务失败，避免级联故障，提高分布式系统的弹性。</p><p>「断路器」本身是一种开关装置，当某个服务单元发生故障之后，通过断路器的故障监控（类似保险熔断），向调用方法返回一个符合预期的，可处理的被选相应（FallBack降级操作），而不是长时间的等待或者抛出无法处理的异常。这样保证了服务调用方法的线程不会长时间，不必要地占用，从而避免了故障在分布式系统中的蔓延，从而导致雪崩效应。</p><p>如下图所示，断路器有对应的三个阶段：</p><ul><li>第一阶段：正常</li><li>第二阶段：发现超时或者失败后，标识失败</li><li>第三阶段：达到阈值之后，触发了熔断器策略，标识服务不可用，熔断器就自动断开。如果此时B对C有访问，熔断器会给B立刻返回失败，不再调用C。同时进行间断性尝试，判断服务是否恢复</li></ul><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seooEd.png" alt="Hystrix的三种情况"></p><p>Hystrix存在三种模式：</p><ul><li><strong>断路器模式</strong>：设置超时或者失败等熔断策略</li><li><strong>后备策略模式</strong>：在第二阶段或者第三阶段失败时，如果存在后备策略，都会去执行后备策略</li><li><strong>舱壁模式</strong>：保证一个服务独享一个线程池</li></ul><p>所以，Hystrix的功能执行如下：</p><ul><li>熔断触发前，超时或者失败发生时：<ul><li>如果存在后备策略，执行后备策略</li><li>如果不存在后备策略，抛出异常处理</li></ul></li><li>在熔断触发之前后，立即返回失败，保护下游失败<ul><li>存在后备策略，则执行</li><li>不存在，则抛出异常</li></ul></li><li>在熔断器触发了之后，还可以定期检查服务是否正常，将服务恢复正常</li></ul><h3 id="Spring-Cloud-Zuul"><a href="#Spring-Cloud-Zuul" class="headerlink" title="Spring Cloud Zuul"></a>Spring Cloud Zuul</h3><p>Spring Cloud Zuul是Spring Cloud Netflix子项目的核心组件之一，可以作为微服务架构中的API网关使用，支持动态请求路由、负载均衡、效验过滤、服务容错、服务聚合等功能。API网关为微服务架构中的服务提供了统一的访问入口，客户端通过API网关访问相关服务。</p><p>Zuul的核心是一系列的Filters，其作用类比于Servlet框架的Filter，或者AOP。其大部分功能都是通过过滤器来实现的，它们能够执行非常大范围的操作，并且可以在请求-响应生命周期的不同阶段运行，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seoTUA.png" alt="Zuul"></p><p>其定义了四种标准过滤器类型：</p><ul><li>PRE：这种过滤器在请求被路由之前调用。可以用这种过滤器实现身份验证、在集群中选择请求的微服务、记录调试信息等</li><li>ROUTING：这种过滤器是用于构建发送给微服务的请求，并使用Apache HttpClient或者Netflix Ribbon请求微服务</li><li>POST：这种过滤器在路由到微服务以后执行，可用来为响应添加标准的HTTP Header、收集统计信息和指标、将相应从微服务发回给客户端等</li><li>ERROR：在其它阶段发生错误时执行该过滤器</li></ul><p><img src= "/img/loading.gif" data-src="https://s3.ax1x.com/2021/01/07/seo5HH.png" alt="Zuul四种标准过滤器模型"></p><h3 id="Spring-Cloud-Config"><a href="#Spring-Cloud-Config" class="headerlink" title="Spring Cloud Config"></a>Spring Cloud Config</h3><p>在分布式系统中，因为服务数量很多，为了方便服务配置文件统一管理，实时更新，所以需要分布式配置中心组件。在Spring Cloud中，有分布式配置中心组件Spring Cloud Config，它支持配置服务放在配置服务的内存中（本地），也支持放在远程Git中。</p><p>在Spring Cloud Config组件中，分两个角色：</p><ul><li>Config Server：一个可横向扩展、集中式的配置服务器，它用于集中管理应用程序各个环境下的配置，为客户端提供获取配置信息、加密、解密信息等访问接口</li><li>Config Client：是Config Server的客户端，是微服务架构中的各个微服务应用或基础设施，通过指定的配置中心来管理应用资源与业务相关的配置内容，并在启动的时候从配置中心获取和加载配置信息。</li></ul><p>基于消息总线的配置中心架构需要依赖外部的MQ组件，例如RabbitMQ或者Kafka等实现远程环境变更通知，客户端实时配置变更可以基于Git Hook功能实现。</p><h3 id="Spring-Cloud-Sleuth"><a href="#Spring-Cloud-Sleuth" class="headerlink" title="Spring Cloud Sleuth"></a>Spring Cloud Sleuth</h3><p>随着微服务部署的节点增多，以及对各个微服务的拆分后，对服务本身的日志和调用链路的监控变得更加困难。Spring Cloud Sleuth就是为了解决分布式链路追踪这个问题而生的。</p><p>Spring Cloud Sleuth的实体概念主要来源于谷歌在2010年发表的一篇论文：《Dapper, a Large-Scale Distributed Systems Tracing Infrastructure》：</p><ul><li>Span：基本工作单元。发送RPC就是一个新的span，就像RPC发送响应那样。Span携带了span的唯一64位标识、另外一个Trace的64位的标识。Span还有其余的数据，例如描述、带时间戳的事件、键值annotations（标签）等。</li><li>Trace：一组span造成的树状结构；</li><li>Annotation：用于及时记录事件的存在</li></ul><p>微服务日志追踪主要包括：</p><ul><li>日志输出</li><li>日志收集</li><li>分布式链路追踪：以集成Zipkin服务为基础，准备4个微服务工程：<ul><li>eureka server：复杂服务注册</li><li>zipkin server：负责链路数据收集以及查询</li><li>zuul-gateway：服务网关，负责调用</li><li>personal-service：作为后台server，负责调用</li></ul></li></ul><h3 id="Spring-Cloud-Bus"><a href="#Spring-Cloud-Bus" class="headerlink" title="Spring Cloud Bus"></a>Spring Cloud Bus</h3><p>Spring Cloud Config的作用的帮助更新配置文件，即配置文件可以通过Config Server存储到Git地方，通过Config Client进行读取。但是配置发生变化时，又是如何进行更新的呢？</p><p>一种简单的方式是关闭服务，重新让Config Client进行获取。但是这样需要关闭服务，Spring Cloud肯定不允许这样做。那么，它需要通过「消息总线」的方式来进行通知。</p><p>这套机制是：我们使用消息代理来构建一个Topic，然后把微服务架构中的所有服务都连接到这个主题上，当我们向该主题发送消息时，所有订阅了该主题的服务都会收到消息并进行消费。目前Spring Cloud Bus支持两种主流的消息代理：RabbitMQ和Kafka。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/08/cnVklGj5eQwHoih.jpg" alt="Spring Cloud Bus的执行步骤"></p><p>从上图可以看出Spring Cloud Bus的执行步骤：</p><ul><li>提交代码给客户端A</li><li>客户端A收到了请求，从Server端更新配置，发送给Spring Cloud Bus</li><li>Spring Cloud Bus接收到消息，<strong>通知</strong>其它的客户端</li><li>其它客户端接收到通知，请求Server端，获取最新的配置</li><li>这样，全部的客户端都能获取到更新的配置</li></ul><h3 id="Spring-Cloud-Stream"><a href="#Spring-Cloud-Stream" class="headerlink" title="Spring Cloud Stream"></a>Spring Cloud Stream</h3><p>Spring Cloud Stream在Spring Cloud体系内用于构建高度可扩展的基于事件驱动的微服务。而SCS(Spring Cloud Stream)是在Spring Message和Spring Integration两个项目的基础上完成构建的。</p><p>Spring Message模块是Spring Framework的一个模块，其作用就是统一消息的编程模型。</p><p>生产者Producer发送消息到消息通道Message Channel中，消费者Consumer调用<code>receive()</code>方法从消息通道中获取到消息。</p><p>Spring Integration提供了Spring编程模型的扩展，用来支持企业集成模式（Enterprise Integration Patterns）。</p><p>Spring Integration是对Spring Messaging的扩展。它提出了不少新的概念，包括消息的路由MessageRoute、消息的分发MessageDispatcher、消息过滤Filter、消息转换Transfoer、消息聚合Aggregator、消息分隔Splitter等等。</p><hr><p>SCS则是Spring Integration的加强，同时与SpringBoot体系融合，也是Spring Cloud Bus的基础。<strong>它屏蔽了底层消息中间件的实现细节，希望以统一的一套API来进行消息的发送/消费，底层消息中间件的实现细节由各消息中间件的Binder来完成</strong>。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/08/gFcrRKha52Vzibl.png" alt="Binder细节"></p><p>Binder是提供与外部消息中间件集成的组件，会构造Binding，内部构造实现生产者和消费者。<strong>它是连接应用程序跟消息中间件的桥梁，用于消息的消费和生产</strong>。</p><p>SCS解决了开发人员无感知的使用消息中间件的问题，因为SCS对消息中间件的进一步封装，可以做到代码层面对中间件的无感知，甚至还可以动态切换中间件。这使得微服务开发的高度解耦，服务可以主要关注自己的流程。</p><h3 id="Spring-Cloud-Task"><a href="#Spring-Cloud-Task" class="headerlink" title="Spring Cloud Task"></a>Spring Cloud Task</h3><p>Spring Cloud Task允许用户使用Spring Cloud开发和运行短期微服务，并在云和本地运行，甚至还可以在Spring Cloud Data Flow上运行。</p><p>Spring Cloud Task主要是来解决<code>short lived microservices</code>的问题的。因为一般的应用服务都是长时间运转的不停止的，但是有些服务却具有以下特点：</p><ul><li>定时的服务</li><li>临时的服务</li><li>占用资源过多的服务</li></ul><p>这些服务因为重要性偏低，所以可以交个Spring Cloud Task来执行。除此之外，有些任务是串联的。一个业务会牵扯到多个业务，任务之间是通过事件触发的，这就是Spring Cloud Stream来解决的。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring Cloud </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>微服务框架(一)——Dubbo</title>
      <link href="/2021/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%B8%80)--Dubbo/"/>
      <url>/2021/01/01/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%A1%86%E6%9E%B6(%E4%B8%80)--Dubbo/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><blockquote><p>Dubbo是一个分布式服务框架，致力于提高性能和透明化的RPC远程过程调用的方案，以及SOA服务治理方案。</p></blockquote><p>其核心部分包括了：</p><ul><li><strong>远程通讯</strong>：提供对多种基于长连接的NIO框架的抽象封装，包括多种线程模型，序列化，以及「请求-响应」模式的信息交换模式等。</li><li><strong>集群容错</strong>：提供基于接口方法的透明远程过程调用，包括了多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。</li><li><strong>自动发现</strong>：基于注册中心目录服务，使服务消费者能够动态地查找服务提供方，使地址透明，使服务提供方可以平滑增加或者减少机器。</li><li><strong>服务自动注册与发现</strong>：不再需要写死服务提供方的地址，注册中心基于接口名来查询服务提供者的IP地址，并且能够平滑地添加或者删除服务提供者。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/crtWdhnKvSFzYm9.png" alt="Dubbo架构"></p><p><strong>节点角色的说明</strong>：</p><ul><li><strong>Provider</strong>：暴露服务的服务提供方</li><li><strong>Consumer</strong>：调用远程服务的服务消费方</li><li><strong>Registry</strong>：服务注册与发现的注册中心</li><li><strong>Monitor</strong>：统计服务的调用次数和调用时间的监控中心</li><li><strong>Container</strong>：服务运行的容器</li></ul><p><strong>调用关系说明</strong>：</p><ul><li>服务容器负责启动，加载，运行服务提供者</li><li>服务提供者在启动时，向注册中心注册自己提供的服务</li><li>服务消费者在启动时，向注册中心订阅自己所需要的服务</li><li>注册中心会返回服务提供者地址列表给消费者，如果有变更，注册中心将基于长连接推送变更数据给消费者</li><li>服务消费者会从提供者地址列表中，基于软负载均衡的算法，选一台提供者进行调用，入股哦调用失败，再选择另一台进行调用</li><li>服务消费者和提供者，都会在内存中累计调用次数和调用时间，定时每分钟发送一个统计次数的数据到监控中心</li></ul><h3 id="注册中心"><a href="#注册中心" class="headerlink" title="注册中心"></a>注册中心</h3><p>Dubbo提供的注册中心有以下几种类型可以选择：</p><ul><li>Multicast注册中心</li><li>ZooKeeper注册中心：ZooKeeper集群由一组Server节点组成，这一组Server节点中存在一个角色作为Leader的节点，其它节点则为Follower。当客户端Client连接到ZooKeeper集群后，执行写请求时，这些请求会被发送到Leader节点上，然后Leader节点上的数据变更会同步到集群中其它的Follower节点。</li><li>Redis注册中心</li><li>Simple注册中心</li></ul><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><p>远程通信需要指定通信双方所约定的协议，在保证通信双方理解协议语义的基础上，保证高效、稳定的消息传输。Dubbo继承了目前主流的网络通信框架：</p><ul><li>Mina</li><li>Netty</li><li>Grizzly</li></ul><h3 id="远程调用协议"><a href="#远程调用协议" class="headerlink" title="远程调用协议"></a>远程调用协议</h3><p>Dubbo支持的远程调用协议：</p><ul><li>Dubbo协议</li><li>HTTP协议</li><li>RMI协议</li><li>Web Service协议</li><li>Thrift协议</li><li>Redis协议</li></ul><p>在通信过程中，不同的服务等级一般对应着不同的服务质量，所以要根据应用的创建场景来选择协议。</p><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="连通性"><a href="#连通性" class="headerlink" title="连通性"></a>连通性</h3><ul><li><p>注册中心负责服务地址的注册与查找，<strong>相当于目录服务</strong>，服务提供者和消费者只在启动的时候与注册中心交互，所以注册中心不会转发请求，压力较小。</p></li><li><p>监控中心负责统计各个服务的调用次数、调用时间等，统计先在内存汇总后每分钟一个发送到监控中心的服务器里。</p></li><li><p>服务提供者向注册中心注册其提供的服务，并汇报调用时间到监控中心，此时间内是不包括网络开销的。</p></li><li><p>服务消费者向注册中心获取服务提供者的地址列表，并根据负载算法直接调用提供者，同时汇报调用时间到监控中心，此时间是包含网络开销的。</p></li><li><p>注册中心、服务提供者、服务消费者三者之间都是<strong>长连接</strong>，监控中心除外。</p></li><li><p>注册中心通过长连接感知服务提供者的存在，如果服务提供者宕机了，注册中心会立即推送事件通知消费者；如果注册中心和监控中心都宕机了，不会影响已有的提供者和消费者，消费者在本地缓存了提供者的列表；注册中心和监控中心全部都宕机了，服务消费者可以直接连接服务提供者。</p></li></ul><h3 id="健壮性"><a href="#健壮性" class="headerlink" title="健壮性"></a>健壮性</h3><ul><li>监控中心宕机了，不影响使用，只是会缺少部分采样数据；</li><li>数据库宕机了，注册中心仍能够缓存提供服务列表进行查询，但是不能注册新的服务</li><li>注册中心对等的集群中的任意一台宕机了，将自动切换到另外一台</li><li>注册中心全部宕机了，服务提供者和服务消费者仍然能够通过本地缓存进行通讯</li><li>如果服务提供者无状态了，任意一台宕机了，也不影响使用</li><li>如果服务提供者全部宕机了，服务消费者应用将无法使用，并且无限次重连等待服务提供者恢复</li></ul><h3 id="伸缩性"><a href="#伸缩性" class="headerlink" title="伸缩性"></a>伸缩性</h3><p>注册中心对等集群，可以动态增加机器部署实例，所有客户端将自动发现新的注册中心；如果服务提供者无状态了，也可以动态增加机器部署实例，并且注册中心将推送新的服务提供者信息给消费者</p><h3 id="升级性"><a href="#升级性" class="headerlink" title="升级性"></a>升级性</h3><p>当服务集群规模进一步扩大，带动IT结构进一步升级，需要实现动态部署，进行流动计算，现有的分布式服务架构不会带来阻力。</p>]]></content>
      
      
      <categories>
          
          <category> 微服务 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>重入锁ReentrantLock以及公平性问题</title>
      <link href="/2020/12/09/%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7%E9%97%AE%E9%A2%98/"/>
      <url>/2020/12/09/%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E4%BB%A5%E5%8F%8A%E5%85%AC%E5%B9%B3%E6%80%A7%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>重入锁ReentrantLock，是指支持重进入的锁，表示锁可以支持一个线程对资源的重复加锁，即「任意线程在获取到这个锁之后，如果再次获取该锁，不会被锁阻塞」。重入锁还支持锁时的<strong>公平</strong>和<strong>非公平性</strong>（默认）的选择。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><p>实现重入的机制，需要解决以下两个问题：</p><ul><li>线程需要再次获取锁：锁一定要能够识别获取锁的线程是否是当前占据锁的线程，如果符合，就能够获取成功</li><li>锁需要得到最终的释放：线程重复了n次获取了锁之后，就需要在第n次释放锁后，其它的线程才能获取到该锁。主要是通过<strong>计数器</strong>来实现。锁每获取一次，计数器就要自增1；每释放一次，计数器就要自减1，一直减到0为止，表示当前线程已经成功释放了该锁，其它线程可以来获取该锁。</li></ul><h3 id="重入性和公平性"><a href="#重入性和公平性" class="headerlink" title="重入性和公平性"></a>重入性和公平性</h3><p>ReentrantLock不支持隐式的重入锁，但是可以在调用<code>lock()</code>方法时，已经获取到锁的线程，能够再次调用<code>lock()</code>方法获取锁且不被阻塞。ReentrantLock的公平与否，是通过构造方法来决定的，内部类<code>Sync</code>继承了<code>AQS</code>，分为公平锁<strong>FairSync</strong>和非公平锁<strong>NonfairSync</strong>。</p><h3 id="公平锁和非公平锁"><a href="#公平锁和非公平锁" class="headerlink" title="公平锁和非公平锁"></a>公平锁和非公平锁</h3><blockquote><p>先对锁进行获取的请求肯定是优先执行的，锁获取的顺序也符合请求的绝对时间顺序，类似于FIFO，那么就是公平锁。反之，就是非公平锁。</p></blockquote><p>以下是公平锁与非公平锁的测试输出结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 公平锁的结果</span></span><br><span class="line">FAIR lock by [<span class="number">9</span>], waiting by []</span><br><span class="line">FAIR lock by [<span class="number">10</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">9</span>]</span><br><span class="line">FAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">9</span>, <span class="number">13</span>, <span class="number">10</span>]</span><br><span class="line">FAIR lock by [<span class="number">12</span>], waiting by [<span class="number">9</span>, <span class="number">13</span>, <span class="number">10</span>, <span class="number">11</span>]</span><br><span class="line">FAIR lock by [<span class="number">9</span>], waiting by [<span class="number">13</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">FAIR lock by [<span class="number">13</span>], waiting by [<span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>]</span><br><span class="line">FAIR lock by [<span class="number">10</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">FAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">FAIR lock by [<span class="number">12</span>], waiting by [<span class="number">13</span>]</span><br><span class="line">FAIR lock by [<span class="number">13</span>], waiting by []</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非公平锁的结果</span></span><br><span class="line">UNFAIR lock by [<span class="number">10</span>], waiting by [<span class="number">9</span>, <span class="number">11</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">10</span>], waiting by [<span class="number">9</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">9</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">9</span>], waiting by [<span class="number">11</span>, <span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">11</span>], waiting by [<span class="number">12</span>, <span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">12</span>], waiting by [<span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">12</span>], waiting by [<span class="number">13</span>]</span><br><span class="line">UNFAIR lock by [<span class="number">13</span>], waiting by []</span><br><span class="line">UNFAIR lock by [<span class="number">13</span>], waiting by []</span><br></pre></td></tr></table></figure><p>从结果中我们可以看出，公平锁每次都是从同步队列中的第一个节点获取锁，而非公平锁则是会连续两次获取锁。</p><p>从开销上来看，<strong>公平锁的开销会更大一些</strong>，因为它每次都要切换到另一个线程，而对于非公平锁，会出现连续获取锁的对象，切换次数要少一些，所以<strong>非公平锁的开销会更小一些</strong>。所以，公平锁保证了锁的获取按照顺序进行，保证了公平性，解决了<strong>饥饿问题</strong>，但是增加了大量的线程切换。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>RabbitMQ入门</title>
      <link href="/2020/11/22/RabbitMQ%E5%85%A5%E9%97%A8/"/>
      <url>/2020/11/22/RabbitMQ%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><p>消息队列，即Message Queue(MQ)，是一种应用程序对应用程序的通信方法，。应用程序通过读写出入队列的消息来通信，而无须专用连接来连接它们。</p><p>消息队列是是典型的生产者、消费者模型。生产者不断生成消息添加到队列中，消费者不断地从队列中获取消息。因为消息的生产和消费都是异步的，并且消息队列只关注消息的发送与接收，并没有业务逻辑的侵入，这样就实现了生产者和消费者之间的解耦。</p><p>消息传递是指程序之间通过在消息中发送数据进行通信，而不是通过直接调用彼此来通信。</p><p>使用消息队列的好处就是将一些无需即时返回且耗时的操作提取出来，进行了异步处理，大大节省了服务器的请求响应时间，从而提高了系统的吞吐量。</p><h3 id="为什么使用消息队列"><a href="#为什么使用消息队列" class="headerlink" title="为什么使用消息队列"></a>为什么使用消息队列</h3><p>主要在三个方面：<strong>异步</strong>、<strong>解耦</strong>、<strong>削峰</strong></p><h4 id="异步处理"><a href="#异步处理" class="headerlink" title="异步处理"></a>异步处理</h4><p>例如，用户注册模块，需要发送注册邮件和注册短信，那么传统的方式有：</p><ol><li>串行的方式：将注册信息直接写入数据库后，然后先发送注册邮件，再发送注册短信，以上三个任务都完成了，才返回给客户端；这种方式会让用户一直等待，假如每个阶段要消耗50ms，那么用户就需要等待150ms；</li><li>并行的方式：将注册的信息写入数据库后，同时发送邮件和短信，这样就让邮件和短信的阶段并行操作，节省了时间，用户只需要等待100ms；</li></ol><p>然而，如果使用消息队列，就更能够高效地处理。引入消息队列后，可以把发送邮件、短信等操作当作不是必须的业务逻辑来异步处理。假设，写入消息队列的时间是5ms，那么用户总共只需要等待写入数据库的时间加上写入消息队列的时间，总共是55ms。</p><h4 id="应用解耦"><a href="#应用解耦" class="headerlink" title="应用解耦"></a>应用解耦</h4><p>例如，对于一个购物系统而言，用户下单后，订单系统需要通知库存系统，那么最普通的做法就是「订单系统直接调用库存系统的接口去通知并更改」。</p><p>这种做法的缺点就是：</p><ul><li>当库存系统出现故障时，那么订单会失败</li><li>订单系统和库存系统直接联系过于紧密，高度耦合</li></ul><p>那么，如果引入消息队列呢？</p><p>用户下单后，订单系统完成持久化处理后，将消息写入消息队列中，直接返回用户订单下单成功；库存系统通过订阅订单系统的信息，获取下单消息，进行库存管理的操作。</p><p>这样，即使库存系统出现了故障，消息队列里存储的消息至少保证了消息的可靠传递，不会导致消息丢失。</p><h4 id="流量削峰"><a href="#流量削峰" class="headerlink" title="流量削峰"></a>流量削峰</h4><p>例如，一个系统每天大部分时间的请求只有每秒50个，但是高峰期期间却会突增到每秒10000个请求，而系统最高只能处理1000个请求。所以，这样直接访问肯定会导致系统崩溃的。即<strong>低峰期无压力，高峰期扛不住</strong>。那么，如果使用了消息队列，把所有的请求都先写入消息队列，系统再从消息队列里慢慢拉取请求，只要拉取并处理的速度不超过系统自己能够处理的最大能力即可。</p><h3 id="消息队列的缺点"><a href="#消息队列的缺点" class="headerlink" title="消息队列的缺点"></a>消息队列的缺点</h3><ul><li>系统的可用性降低了，因为引入的外部依赖越过，系统就越复杂</li><li>使用消息队列，需要保证消息不能重复消费，消息不能丢失，已经消息传递的顺序等等问题</li><li>当生产者生产消息并添加到消息队列中就会直接返回请求成功，但是必须要确保已添加到消息队列的消息不会堆积，处理也不会出现问题，不然数据的一致性就会出现问题</li></ul><h2 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h2><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准<strong>高级消息队列协议</strong>，是为面向消息的中间件设计的。基于此协议的客户端与消息中间件可传递消息，并不受不同产品或者不同编程语言等条件的限制。</p><blockquote><p>AMQP的主要特征是面向消息、队列、路由（包括点对点和发布/订阅）、可靠性、安全等。</p></blockquote><h3 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h3><p>JMS（Java Message Service）是Sun公司最早提出的消息标准，是为了Java应用提供统一的消息操作，它与AMQP有以下的不同：</p><ul><li>JSM定义了同一个接口；AMQP是通过规定协议来统一数据交互的格式；</li><li>JMS只能在Java语言中使用；而AMQP只是协议，是跨语言的；</li><li>JMS规定了两种消息模型；而AMQP的消息模型则更加丰富；</li></ul><h3 id="常见的AMQP"><a href="#常见的AMQP" class="headerlink" title="常见的AMQP"></a>常见的AMQP</h3><ul><li>ActiveMQ：基于JMS</li><li>RabbitMQ：基于AMQP协议，稳定性好</li><li>RocketMQ：基于JMS，是阿里开发的，由Apache维护</li><li>Kafka：分布式的消息系统，高吞吐量</li></ul><h2 id="消息队列的应用场景"><a href="#消息队列的应用场景" class="headerlink" title="消息队列的应用场景"></a>消息队列的应用场景</h2><p>一个大型的软件系统，会有很多的组件或者模块或者子系统，如果将这些模块进行通信呢？传统的IPC是很多都在单一系统上，模块耦合性很大，不适合拓展；如果使用Socket进行通信，那么又需要考虑到以下一些问题：</p><ul><li>信息的发送者和接收者如何维持这个连接，如果一方连接中断，丢失的数据怎么办</li><li>如何降低发送者和接收者的耦合度</li><li>如何让Priority高的接收者更先接受到数据</li><li>如果做到负载均衡？</li><li>如何做到可拓展，甚至可以将该通信模块发送到集群cluster上？</li><li>如何保证接收者接受到了完整、正确的数据</li></ul><p>AMQP协议就解决了以上问题，而RabbitMQ就是基于AMQP实现的。</p><h2 id="RabbitMQ简介"><a href="#RabbitMQ简介" class="headerlink" title="RabbitMQ简介"></a>RabbitMQ简介</h2><blockquote><p>RabbitMQ is the most widely deployed open source message broker.</p></blockquote><p>RabbitMQ就是在AMQP的基础上实现的，可复用的企业消息系统。它可以用于大型软件系统各个模块之间的高效通信，支持<strong>高并发</strong>，支持可拓展。</p><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ul><li>启动rabbitmq：<code>rabbitmq-service start</code></li><li>关闭rabbitmq：<code>rabbitmq-service stop</code></li><li>启动监控管理器：<code>rabbitmq-plugins enable rabbitmq_management</code></li><li>关闭监控管理器：<code>rabbitmq-plugins disable rabbitmq_management</code></li><li>关闭应用：<code>rabbitmqctl stop_app</code></li><li>启动应用：<code>rabbitmqctl start_app</code></li></ul><h3 id="概念介绍"><a href="#概念介绍" class="headerlink" title="概念介绍"></a>概念介绍</h3><ul><li>Broker：消息队列服务器实体</li><li>Exchange：消息交换机，指定消息按什么原则，路由由哪个队列（用于转发消息，但是不会被存储）</li><li>Queue：消息队列载体，每个消息都会被投入到一个或者多个队列中</li><li>Binding：将exchange和queue按照路由的规则绑定起来</li><li>Rounting Key：路由的关键字，exchange就是根据这个关键字进行消息投递</li><li>vhost：虚拟主机，一个broker里可以开启多个vhost，用作不同用户的权限分离</li><li>producer：消息生产者，就是投递消息的程序</li><li>consumer：消息消费者，就是接受消息的程序</li><li>channel：消息通道，在客户端的每个连接里，可以建立多个channel，每个channel代表一个任务</li></ul><h3 id="四种交换机Exchange"><a href="#四种交换机Exchange" class="headerlink" title="四种交换机Exchange"></a>四种交换机Exchange</h3><h4 id="Direct-Exchange"><a href="#Direct-Exchange" class="headerlink" title="Direct Exchange"></a>Direct Exchange</h4><p>其行为是「先匹配，再投送」。绑定时会设定一个rounting key，只有消息的rounting key匹配时，才会被交换机投送到绑定的队列中去。这是RabbitMQ默认的交换机模式，也是最简单的模式，是根据key全文匹配去寻找队列。</p><h4 id="Topic-Exchange"><a href="#Topic-Exchange" class="headerlink" title="Topic Exchange"></a>Topic Exchange</h4><p>按规则转发消息主要是<strong>根据通配符</strong>。在这种交换机下，队列和交换机的绑定会定义一种路由模式。通配符需要在这种路由模式和路由键之间匹配后，交换机才能转发消息。</p><p>路由键必须是一串字符，用句号（.）隔开。</p><p>路由模式必须包含一个星号（*），主要是用于匹配路由键指定位置的一个单词，（#）表示相当于一个或者多个单词</p><h4 id="Headers-Exchange"><a href="#Headers-Exchange" class="headerlink" title="Headers Exchange"></a>Headers Exchange</h4><p>设置header attribute参数类型的交换机，headers是一个自定义匹配规则的类型。在队列与交换器绑定时，会设定一组键值对规则，消息中也包括了一组键值对属性，当有一对或者全部匹配时，消息就会被投送到对应的队列中。</p><h4 id="Fanout-Exchange"><a href="#Fanout-Exchange" class="headerlink" title="Fanout Exchange"></a>Fanout Exchange</h4><p>转发消息到所有绑定队列中，消息广播的模式，不管路由键或者是路由模式，会把消息发给绑定给它的全部队列。</p><h3 id="使用流程"><a href="#使用流程" class="headerlink" title="使用流程"></a>使用流程</h3><blockquote><p>消息在Producer中产生，发送到消息队列的Exchange上，Exchange根据配置的路由方式Rounting Key，发送到并绑定Queue。Queue将消息通过push或者pull的方式传递给Consumer。</p></blockquote><ol><li>客户端连接到消息队列的服务器，开启一个channel</li><li>客户端声明一个exchange，并设置相关属性</li><li>客户端声明一个queue，并设置相关属性</li><li>客户端使用rounting key，在exchange和queue之间建立好绑定关系</li><li>客户端投递信息到exchange</li><li>exchange收到信息后，根据rounting key和binding关系，将消息传递到queue中</li></ol>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Software Engineering)</title>
      <link href="/2020/11/19/Interview-Review(Software%20Engineering)/"/>
      <url>/2020/11/19/Interview-Review(Software%20Engineering)/</url>
      
        <content type="html"><![CDATA[<h2 id="软件工程"><a href="#软件工程" class="headerlink" title="软件工程"></a>软件工程</h2><blockquote><p>软件工程就是用科学的知识和技术原理来定义、开发、维护软件的一门学科。</p></blockquote><p>软件工程的三要素：<strong>工具</strong>、<strong>方法</strong>、<strong>过程</strong></p><p>软件开发中常见的软件过程模型有：</p><ul><li><strong>瀑布模型</strong></li><li><strong>快速原型模型</strong></li><li><strong>增量模型</strong></li><li><strong>螺旋模型</strong></li><li><strong>喷泉模型</strong></li><li><strong>统一软件过程</strong></li></ul><p>其中<strong>喷泉模型</strong>、<strong>统一软件过程</strong>适用于面向对象的软件开发。</p><h3 id="瀑布模型"><a href="#瀑布模型" class="headerlink" title="瀑布模型"></a>瀑布模型</h3><blockquote><p>瀑布模型（Waterfall Model）是一个项目开发架构，开发过程是通过设计一系列阶段顺序展开的，从系统需求分析开始直到产品发布和维护，每个阶段都会产生循环反馈</p></blockquote><p><strong>优点</strong>：</p><ol><li>为项目提供了按阶段划分的检查点</li><li>当前一阶段完成后，就只需要去关注后续阶段的实现</li><li>可在迭代模型中应用瀑布模型</li></ol><p><strong>缺点</strong>：</p><ol><li>在项目各个阶段之间极少有反馈</li><li>只有在项目生命周期的后期才能看到结果</li><li>需要通过过多的强制完成日期和<strong>里程碑</strong>来跟踪各个项目的阶段</li><li>不适应用户需求的变化</li></ol><h3 id="快速原型模型"><a href="#快速原型模型" class="headerlink" title="快速原型模型"></a>快速原型模型</h3><blockquote><p>快速原型是快速建立起来的，可以在计算机运行的程序，它所能完成的功能往往是最终产品所完成的功能的一部分。</p></blockquote><p>它允许在需求分析阶段对软件的需求进行初步而非完全的分析和定义，这样就可以快速设计开发出软件系统的原型。该原型向用户展示待开发软件的全部或者部分功能和性能；然后，用户对该原型进行测试评定，给出具体的改进以及丰富细节化的需求；开发人员再根据此软件进行修改和完善，直到用户满意认可之后进行软件的完整实现以及测试、维护。</p><p><strong>开发步骤</strong></p><ol><li><p>快速分析</p><p> 在分析人员与用户密切配合下，迅速确定系统的基本需求，根据原型需要体现的特征描述基本需求以满足开发原型的需要</p></li><li><p>构造原型</p><p> 在快速分析的基础上，根据基本需求说明尽快实现一个可行的系统（要求具有强有力的软件工具的支持，并暂时忽略系统在某些细节上的要求）</p></li><li><p>运行原型</p><p> 发现问题，消除误解，需要开发者与用户充分地协调</p></li><li><p>评价原型</p><p> 在运行的基础上，考核评价原型的特性，分析运行效果是否满足用户的愿望，纠正过去交互中的误解和分析中的错误，增添新的要求，并满足因环境变化或用户的新想法引起的系统要求变动，提出全面的修改意见</p></li><li><p>修改</p><p> 根据评价原型的结果进行修改</p></li></ol><h3 id="增量模型"><a href="#增量模型" class="headerlink" title="增量模型"></a>增量模型</h3><blockquote><p>使用增量模型开发软件时能把软件产品作为一系列的增量构件来设计、编码、集成和测试，每个构件由多个相互作用的模块构成，并且能够完成特定的功能。</p></blockquote><p>所以，瀑布模型或者快速模型的目标都是一次就把一个满足所有需求的产品提交给用户，而<strong>增量模型是把整个软件产品分解成多个增量构件，分批地逐步向用户提交产品</strong>。</p><p><strong>优点</strong>：</p><ol><li>能够在较短的时间内向用户提交可完成部分工作的产品</li><li>将待开发的软件系统模块化，可以分批次地提交软件产品，使用户可以及时地了解软件项目的进展</li><li>以组件为单位就可以降低软件开发的风险，一个开发周期内的错误不会影响到整个软件系统</li><li>开发顺序灵活，开发人员可以对组件的实现顺序进行优先级排序，可以选择先完成需求稳定的核心组件。当优先级发生变化时，还可以及时地对实现顺序进行调整</li></ol><p><strong>缺点</strong>：</p><ul><li>由于各个构件是逐渐并入已有的软件体系结构中的，所以加入构件很容易破坏已经构造好的系统部分，这需要软件具备开放式的体系结构</li><li>在开发的过程中，需求的变化是不可避免的，增量模型的灵活性可以适应这种变化，但是也容易退化为边做边修改模型，从而使控制失去整体性</li></ul><p><strong>缺点</strong>：</p><h3 id="螺旋模型"><a href="#螺旋模型" class="headerlink" title="螺旋模型"></a>螺旋模型</h3><blockquote><p>螺旋模型是一种演化软件开发过程的模型，它兼顾了<strong>快速原型</strong>的迭代的特征和<strong>瀑布模型</strong>的系统化与严格监控的特征。</p></blockquote><p>它最大的特点在于引入了其它模型不具备的风险分析，使软件在无法排除重大风险时就有机会停止，以减小损失。</p><p>它分为<strong>四个象限</strong>：<strong>制定计划</strong>、<strong>风险分析</strong>、<strong>实施工程</strong>、<strong>客户评估阶段</strong>。螺旋模型在每个阶段之前以及经常发生的循环之前，都必须进行风险评估。</p><p><strong>优点</strong>：</p><ol><li>设计上的灵活性，可以在项目的各个阶段进行变更；</li><li>以小的分段来构建大型系统，使得成本计算更加容易；</li><li>客户始终参与到了每个阶段的开发，保证了项目不偏离正确方向；</li></ol><p><strong>缺点</strong>：建设周期太长，而软件技术发展较快。因此会出现软件开发和当前的技术水平有了较大的差距，无法满足当前用户需求。</p><h3 id="喷泉模型"><a href="#喷泉模型" class="headerlink" title="喷泉模型"></a>喷泉模型</h3><p>喷泉模型（fountain model）是一种以用户需求为动力，以对象为驱动的模型，主要用于描述<strong>面向对象</strong>的软件开发过程。</p><p><strong>优点</strong>：</p><p>喷泉模型不像瀑布模型那样，需要一个阶段结束后才能进行下一个阶段。喷泉模型的各个阶段没有明显的界限，开发人员可以同步进行开发。优点是可以提高软件项目的开发效率，节省开发的时间。</p><p><strong>缺点</strong>：</p><p>因为喷泉模型在各个开发阶段是重叠的，所以在开发过程中需要大量的开发人员，不利于项目的管理。此外，这种模型要求严格管理文档，使得审核的难度加大。</p><h3 id="敏捷开发"><a href="#敏捷开发" class="headerlink" title="敏捷开发"></a>敏捷开发</h3><blockquote><p>敏捷开发以用户的需求进化为核心，采用迭代、循环渐进的方法进行软件开发。在敏捷开发中，软件项目在构建初期被切分成多个子项目，各个子项目的成果都经过测试。</p></blockquote><p>敏捷框架除了Scrum以外，例如看板（Kanbab），测试驱动开发（TDD）和功能驱动开发（FDD）。</p><h3 id="统一软件过程"><a href="#统一软件过程" class="headerlink" title="统一软件过程"></a>统一软件过程</h3><blockquote><p>统一软件过程，不仅仅是一个简单的软件过程，而且是一个通用的过程框架，可以用于不同类型的应用系统、各种不同的应用领域、各种不同类型的组织、各种不同功能和规模的项目。它是基于构件的，即所构造的软件系统是由软件构件通过明确的定义的接口来相互连接所建造起来的。它可以使用统一建模语言（Unified Modeling Language，UML）来制定系统的所有蓝图。</p></blockquote><p>统一软件过程的特点：用例驱动、以构架为中心、迭代和增量的软件过程框架。</p><h4 id="统一过程是用例驱动的"><a href="#统一过程是用例驱动的" class="headerlink" title="统一过程是用例驱动的"></a>统一过程是用例驱动的</h4><p><strong>用户（User）</strong>：软件系统是为了解决用户的需求的，因此对于一个系统必须首先确定它的使用者——用户。</p><p><strong>用例（User Case）</strong>：是用户对系统的业务需求，即用例是能够像用户提供有价值结果的系统中的一种功能。</p><p>所有的用户和用例组合在一起就是用例模型，它描述了系统的全部功能。</p><h4 id="统一过程是以构架为中心的"><a href="#统一过程是以构架为中心的" class="headerlink" title="统一过程是以构架为中心的"></a>统一过程是以构架为中心的</h4><p>软件系统的构架是从不同的角度描述即将构造的系统。软件构架包含了系统中最重要的静态和动态的特征。<strong>构架刻画了系统的整体设计，去掉了细节部分，突出了系统的重要特性</strong>。</p><h4 id="统一过程是迭代和增量的过程"><a href="#统一过程是迭代和增量的过程" class="headerlink" title="统一过程是迭代和增量的过程"></a>统一过程是迭代和增量的过程</h4><ul><li><strong>迭代</strong>：工作流中的步骤</li><li><strong>增量</strong>：产品中增加的部分</li></ul><p>为了获得最佳的效果，迭代过程必须是受控的，即必须按照计划好的步骤有选择地执行。那么，迭代就是以选定的构架为向导，用构件来实现设计前期已经标识并详细描述好的有关用例。</p><h4 id="统一开发过程包含哪些阶段"><a href="#统一开发过程包含哪些阶段" class="headerlink" title="统一开发过程包含哪些阶段"></a>统一开发过程包含哪些阶段</h4><p>一次典型的迭代阶段有以下四个阶段：</p><ul><li>初始阶段（inception phase）：这个阶段主要是确定项目的风险以及其优先次序，并对细化阶段进行详细规划和对整个项目进行粗略地计算。</li><li>细化阶段（elaborattion phase）：这个阶段主要是解决用例、构架和计划是否足够稳定可靠，风险释放得到了充分控制，以便能够按照规定完成整个开发任务。</li><li>构造阶段（construction phase）：将构造出整个产品。</li><li>移交阶段（transition phase）：开发人员改正用户报告产品的缺陷和不足。</li></ul><h3 id="结构化分析"><a href="#结构化分析" class="headerlink" title="结构化分析"></a>结构化分析</h3><blockquote><p>结构化分析是指面向数据流进行数据分析的方法，采用了<strong>自顶向下</strong>逐层分解的分析策略。顶层抽象地描述整个系统，底层具体地画出系统工程的每个细节。中间层则是从抽象到具体的过渡，使用了<strong>数据流图</strong>、<strong>数据字典</strong>，使用<strong>结构化语言</strong>、<strong>判定表</strong>、<strong>判定树</strong>描述加工逻辑。</p></blockquote><h3 id="软件生命周期"><a href="#软件生命周期" class="headerlink" title="软件生命周期"></a>软件生命周期</h3><blockquote><p>软件生命周期：一个软件从提出开发要求开始直到该软件废弃为止的整个时期，包括了三个大阶段、8个任务。</p></blockquote><p><strong>三大阶段</strong>：</p><ul><li>软件定义：</li><li>软件开发：</li><li>软件维护：</li></ul><p><strong>各阶段的任务</strong>：</p><ul><li>问题定义：要解决的问题是什么</li><li>可行性研究：问题是否有可行的解决办法</li><li>需求分析：目标系统必须要做什么（规格说明书）</li><li>总体设计：概况地说要怎么实现目标系统（概要设计）（确定程序由哪些模块组成以及各个模块间的关系）</li><li>详细设计：应该具体怎样实现系统（模块设计）（详细地设计每个模块，确定每个模块功能所需的算法和数据结构）</li><li>编码和单元测试：编写易理解、易维护的程序，并测试每个模块</li><li>综合测试：集成测试、验收测试、现场测试</li><li>软件维护：使系统持久地满足用户的需要</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Testing)</title>
      <link href="/2020/11/19/Interview-Review(Testing)/"/>
      <url>/2020/11/19/Interview-Review(Testing)/</url>
      
        <content type="html"><![CDATA[<h2 id="软件测试"><a href="#软件测试" class="headerlink" title="软件测试"></a>软件测试</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p><strong>按开发阶段</strong>：</p><ul><li>单元测试</li><li>集成测试</li><li>系统测试</li><li>验收测试</li></ul><p><strong>按是否运行</strong>：</p><ul><li>静态测试：不实际运行被测试的软件，而是只检查程序代码、界面或者文档中的错误</li><li>动态测试：实际运行被测试的软件，输入相应的测试数据，检查输出结果和预期结果是否符合</li></ul><p>所以，他两的区别是<strong>检测软件是否运行</strong>。</p><p><strong>按是否查看源代码</strong>：</p><ul><li>白盒测试：把被测软件当成黑盒子，只关心输入数据和输出结果，常用于软件的功能和性能</li><li>黑盒测试：把“盒子”打开，研究里面的源代码和程序结构，常用于软件的源代码<ul><li>功能<ul><li>逻辑功能测试</li><li>界面测试</li><li>易用性测试</li><li>安装测试</li><li>兼容性测试</li></ul></li><li>性能<ul><li>一般性能测试</li><li>稳定性测试</li><li>负载测试</li><li>压力测试</li></ul></li></ul></li></ul><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><p>单元测试$\rightarrow$集成测试$\rightarrow$确认测试$\rightarrow$系统测试</p><ul><li>单元测试：对源程序中每一个程序单元（最小可测试单元）进行测试，检查各个模块是否正确实现规定的功能，从而发现错误。（该阶段涉及到编码和详细设计文档）</li><li>集成测试：为了检查与设计相关的软件体系结构的有关问题，检查概要设计是否合理。</li><li>确认测试：主要是检查已实现的软件是否满足需求规格说明书中确定的各种需求。</li><li>系统测试：把已确认的软件与其它系统元素（例如硬件、数据、人工等）结合在一起进行测试，以确定软件是否可以正常使用。</li></ul><h2 id="软件维护"><a href="#软件维护" class="headerlink" title="软件维护"></a>软件维护</h2><ol><li><strong>校正性维护</strong>：在软件交付使用后，一些隐含的错误在某些特定的使用环境下出现。校正性维护就是为了识别和纠正错误，修改软件性能上的缺陷，确定和修改错误。</li><li><strong>适应性维护</strong>：为了使应用软件适应计算机硬件、软件环境以及数据环境的变化而修改软件的过程就是适应性维护。</li><li><strong>完善性维护</strong>：为了增加软件功能、增强软件性能、提高运行效率而进行的维护活动就是完善性维护。</li><li><strong>预防性维护</strong>：为了提高软件的可维护性和可靠性而对软件进行的修改是预防性维护。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>理解Spring的控制反转和依赖注入以及AOP</title>
      <link href="/2020/11/15/%E7%90%86%E8%A7%A3Spring%E7%9A%84IOC%E5%92%8CDI%E4%BB%A5%E5%8F%8AAOP/"/>
      <url>/2020/11/15/%E7%90%86%E8%A7%A3Spring%E7%9A%84IOC%E5%92%8CDI%E4%BB%A5%E5%8F%8AAOP/</url>
      
        <content type="html"><![CDATA[<h2 id="依赖倒置原则"><a href="#依赖倒置原则" class="headerlink" title="依赖倒置原则"></a>依赖倒置原则</h2><p>在了解控制反转之前，有必要了解软件设计里的一个重要思想：<strong>依赖倒置原则</strong>。</p><p>这里可以举一个汽车的例子来说明。假如我们来设计一辆汽车，先设计轮子，再根据轮子的大小去设计底盘，根据底盘去设计车身，最终根据车身来设计好整个车子。这样就会形成了一个如下的依赖关系：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/10/FKdvwgxujbYtLNR.png" alt=""></p><p>这种设计的维护性非常低。假如完工之后，需要更改轮子的设计，那么轮子上层的所有事物的设计都得修改，即整个设计都需要修改。</p><p>所以，我们需要换一种思路来实现。先设计出汽车的模型，再设计车身，根据车身设计底盘的大小，最后设计底层的轮子。那么，依赖关系就导致了。轮子的设计取决于底盘，底盘取决于车身，车身依赖车子的设计。所以，依赖关系变成了这样：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/10/MWhrfDItc6p8SV7.png" alt=""></p><p>这样，当需要修改轮子时，只要改动轮子自己的设计就可，因为没有实物是依赖于轮子的。如果是修改底盘，也只会影响到它底层的轮子，高层的事物不会被影响，就不会出现「牵一发而动全身」的情况了。</p><p>所以，原本是「高层建筑依赖底层建筑」，而现在变成了「底层建筑依赖于高层建筑」。</p><h2 id="控制反转和依赖注入"><a href="#控制反转和依赖注入" class="headerlink" title="控制反转和依赖注入"></a>控制反转和依赖注入</h2><p>Spring中经常提到的控制反转（Inversion of Control，IOC）和依赖注入（dependency injection-DI）是等同的概念，<strong>控制反转是通过通过依赖注入实现的</strong>。所谓的依赖注入指的是：</p><blockquote><p><strong>容器</strong>负责创建对象和维护对象间的依赖关系，而不是通过<strong>对象本身</strong>来负责自己的创建和解决自己的依赖。</p><p>即Spring这个容器替开发者管理着一系列的类，需要的时候，就不用自己去定义，而是直接向Spring容器去索取。</p></blockquote><p>依赖注入的主要目的是为了<strong>解耦</strong>，这是一种<strong>组合</strong>的概念。举个例子，如果一个类要具有某个功能时，如果是继承具有此功能的父类，那么该子类就与父类耦合。而如果这个类是去<strong>组合</strong>具有这个功能的其它类，那么耦合度就会大大降低。</p><p><strong>注入方式</strong>：</p><ul><li>set方式注入</li><li>构造方法注入</li><li>字段注入</li></ul><p><strong>注入类型</strong>：</p><ul><li>值类型注入</li><li>引用类型注入</li></ul><p>Spring IoC容器（ApplicationContext）是负责创建Bean，并通过容器将功能类Bean注入到自己需要的Bean中。Spring提供了多种不同的方式，如使用XML、<strong>注解</strong>、Java配置等来实现Bean的创建和注入。以上的这些配置方式都被称为是<strong>配置元数据</strong>，即<strong>描述数据的数据</strong>。Spring容器通过解析这些配置元数据就可以进行Bean的初始化、配置和管理依赖等。</p><p><strong>声明Bean的注解</strong>：</p><ul><li><code>@Component</code>组件：没有明确的角色。</li><li><code>@Service</code>：在业务逻辑层（Service层）中使用</li><li><code>@Repository</code>：在数据访问层（dao层）中使用</li><li><code>@Controller</code>：在表现层（MVC -&gt; SpringMVC）中使用</li></ul><p><strong>注入Bean的注解</strong>，一般情况下通用（下面三个注解都可以注解在<code>set</code>方法或者属性上，优点是代码少，层次清晰）：</p><p><code>@Autowired</code>：Spring提供的注解<br><code>@Inject</code>：JSR-330提供的注解<br><code>@Resource</code>：JSR-250提供的注解</p><h3 id="ApplicationContext和BeanFactory的区别"><a href="#ApplicationContext和BeanFactory的区别" class="headerlink" title="ApplicationContext和BeanFactory的区别"></a>ApplicationContext和BeanFactory的区别</h3><p><strong>ApplicationContext接口</strong></p><ol><li>每次容器启动时，就会创建容器中配置的所有对象</li><li>提供了更多的功能</li></ol><p><strong>BeanFactory接口</strong></p><ol><li>是Spring的原始接口，针对原始接口的实现类的功能较为单一</li><li>BeanFactory接口实现类的容器，特点是每次在获得对象时才会创建对象</li></ol><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP即面向切面编程。Spring的AOP是用来解耦，<strong>AOP可以让一组类共享相同的行为</strong>。</p><p>面向对象是通过继承类和接口的方式，会使代码的耦合度增加。AOP就是弥补了OOP的不足之处。它能够让那些与业务无关，<strong>但是却被业务模块共同调用的逻辑或者责任</strong>（例如事务处理、日志管理、权限控制等）封装起来，降低模块间的耦合度，有利于未来的拓展性和可维护性。</p><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>例如，银行系统里会有一个「取款」的流程和「查询余额」的流程。如果把它们两个的步骤都列举出来，会发现有一个相同的「验证流程」。那么，这个验证用户的代码是否可以提取出来，不放进主流程里呢？这里AOP就起到作用了。</p><p>在编写上述这个例子时，我们可以完全不考虑验证用户的步骤。我们可以在另外一个地方，写好验证用户的代码，然后通过，比如Spring，告知这段代码会被添加到哪些地方，Spring就会帮助我们copy过去。这样就降低了模块间的耦合度。</p><h3 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h3><ul><li><strong>横切关注点</strong>：要对哪些方法进行拦截，拦截后怎么处理，这些关注点都是<strong>横切关注点</strong>。</li><li><strong>切面（aspect）</strong>：切面是指对横切关注点的抽象</li><li><strong>连接点（joinpoint）</strong>：指被拦截到的点，即<strong>被拦截的方法</strong></li><li><strong>切入点（pointcut）</strong>：对连接点进行拦截的定义</li><li><strong>通知（advice）</strong>：拦截到连接点之间要执行的代码</li><li><strong>目标对象</strong>：代理的目标对象</li><li><strong>织入</strong>：将切面应用到目标对象并导致代理对象创建的过程</li><li><strong>引入</strong>：引入可以在运行期为类动态地添加一些方法或者字段</li></ul><h2 id="常用注解"><a href="#常用注解" class="headerlink" title="常用注解"></a>常用注解</h2><ul><li><code>@Controller</code>：表明这个类是Spring里的Controller，将其声明为Spring的一个Bean，Dispatcher Servlet会自动扫描注解了解此注解的类，并且会把Web请求映射到注解<code>@RequestMapping</code>中。</li><li><code>@RequestMapping</code>：该注解是用来映射Web请求、处理类和方法的，可注解在类，也可注解在方法上。</li><li><code>@ResponseBody</code>：允许请求的参数放在请求体中</li><li><code>@PathVariable</code>：通过path可以看出，是用来接收路径参数的。</li><li><code>@RestController</code>：这其实是一个组合注解，组合了<code>@Controller</code>和<code>@ResponseBody</code>，所以如果是编写一个与界面交互数据有关的类，那么其实可以直接使用此注解。否则，就需要加<code>@Controller</code>和<code>@ResponseBody</code>的注解。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池————建服务器应用程序的有效方法</title>
      <link href="/2020/11/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/"/>
      <url>/2020/11/09/%E7%BA%BF%E7%A8%8B%E6%B1%A0%E2%80%94%E2%80%94%E2%80%94%E2%80%94%E5%BB%BA%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%9A%84%E6%9C%89%E6%95%88%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>当需要频繁地创建多个线程进行耗时操作，每次都通过<code>new Thread</code>的方式去创建显然不是一种好的方式，因为每次<code>new Thread</code>新建和销毁对象性能较差，线程缺乏统一地管理，可能线程之间会竞争，可能会占用过多系统资源导致死锁，并且缺乏定时执行、线程中断等功能。</p><a id="more"></a><p>Java提供了<strong>4种</strong>线程池，它能够有效地管理、调度线程，避免过多的资源消耗。</p><p>它的优点如下：</p><ul><li>重用存在的线程，减少对象的创建、销毁的开销；</li><li>可有效地控制最大并发线程数，提高系统资源的使用率，同时避免过多资源竞争，避免阻塞；</li><li>可以提供定时执行、定期执行、单线程、并发数控制等功能；</li></ul><p>线程池都实现了<code>ExecutorService</code>接口，该接口定义了线程池需要实现的接口，比如<code>submit</code>、<code>execute</code>、<code>shutdown</code>等方法。它的实现有<code>ThreadPoolExecutor</code>以及<code>ScheduledThreadPoolExecutor</code>等等。JDK还提供了一个<code>Executors</code>的工厂类来简化创建线程池的流程。</p><h3 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h3><p>一个线程包括以下四个基本组成部分：</p><ul><li>线程池管理器（ThreadPool）：用于创建并管理线程池，包括<strong>创建线程池</strong>、<strong>销毁线程池</strong>、<strong>添加新任务</strong>等；</li><li>工作线程（WorkThread）：线程池中线程，在没有任务时是处于等待状态，可以循环地执行任务；</li><li>任务接口（Task）：每个任务必须实现的接口，以供工作线程调度任务的执行。它规定了任务的入口，任务执行完成后的收尾工作，任务的执行状态等等；</li><li>任务队列（TaskQueue）：用于存放没有处理的任务，提供一个缓冲机制。</li></ul><h3 id="设置线程数"><a href="#设置线程数" class="headerlink" title="设置线程数"></a>设置线程数</h3><ol><li><p>高并发、任务执行时间短的业务怎么使用线程池</p><p> <strong>线程池线程数可以设置为CPU核心数+1，减少线程上下文的切换</strong></p></li><li><p>并发不高、任务执行时间长的业务怎样使用线程池</p><ul><li>如果业务时间是集中在IO操作上，就是<strong>IO密集型的任务</strong>。因为IO操作并不占用CPU，所以不要让所有的CPU闲下来，<strong>可以适当加大线程池中的线程数目（2 * CPU核心数）</strong>，让CPU可以处理更多的业务</li><li>如果是业务时间集中在计算操作上，那么就是<strong>CPU密集型的任务</strong>。所以同样设置为<strong>CPU核心数+1</strong>，减少线程上下文的切换即可。</li></ul></li><li><p>并发高、业务执行时间长的业务怎样使用线程池</p><p> 如果既是并发程度高，又是业务执行时间长的话，解决的关键在于整体架构的设计而不是线程池。</p></li></ol><h2 id="启动指定数量的线程——ThreadPoolExecutor"><a href="#启动指定数量的线程——ThreadPoolExecutor" class="headerlink" title="启动指定数量的线程——ThreadPoolExecutor"></a>启动指定数量的线程——ThreadPoolExecutor</h2><p>ThreadPoolExecutor是线程池的主要实现之一，功能是启动指定数量的线程以及将任务添加到一个队列中，并且将任务分发给空闲的线程。<code>Executors</code>的生命周期包括3种状态：运行、空闲、终止。</p><p>ThreadPoolExecutor的构造函数如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><h3 id="workingQueue"><a href="#workingQueue" class="headerlink" title="workingQueue"></a>workingQueue</h3><p>workingQueue有下列几个常用的实现：</p><p><code>ArrayBlockingQueue</code>：基于<strong>数组</strong>结构实现的有界队列，按照FIFO原则对任务进行排序。如果队列满了还有任务进来，就调用拒绝策略。<br><code>LinkedBlockingQueue</code>：基于<strong>链表</strong>结构实现的无界队列，按照FIFO原则对任务进行排序。因为是<strong>无界</strong>，所以肯定不会满，所以采用此队列会忽略拒绝策略。<br><code>SynchronousQueue</code>：直接将任务提交给线程而不是将它加入到该队列中，所以实际上这个队列是空的。当新任务来了，但是线程池中不存在任何可以被调用的线程时，就会调用拒绝策略。<br><code>PriorityBlockingQueue</code>：具有优先级的有界队列，可以自定义优先级。</p><p>当线程池与工作队列都满了的情况，对于新添加任务也有一些默认实现的处理策略，例如拒绝策略等。</p><ul><li><code>AbortPolicy</code>：拒绝任务，会抛出异常，是线程池默认的策略</li><li><code>CallerRunsPolicy</code>：拒绝新任务进入，如果该线程池还没有被关闭，那么新任务执行在调用线程中。</li><li><code>DiscardOldestPolicy</code>：如果执行程序尚未关闭，那么工作队列头部的任务将被删除，然后重试执行程序（如果失败，继续反复重试）。这样的结果会导致最后加入的任务反而可能被执行到，而先前加入的任务都被抛弃了。</li><li><code>DiscardPolicy</code>：加不进的任务都会被抛弃，不会抛出异常。</li></ul><h2 id="可缓存线程池——CachedThreadPool"><a href="#可缓存线程池——CachedThreadPool" class="headerlink" title="可缓存线程池——CachedThreadPool"></a>可缓存线程池——CachedThreadPool</h2><blockquote><p>任务线程传入时自动分配线程，线程不够时自动创建新的线程</p></blockquote><ul><li>线程数无限制</li><li>有空闲线程就复用空闲线程，若无空闲线程则新建线程，一定程度上减少频繁创建/销毁线程，减少系统开销</li></ul><h2 id="固定长度的线程池——FixedThreadPool"><a href="#固定长度的线程池——FixedThreadPool" class="headerlink" title="固定长度的线程池——FixedThreadPool"></a>固定长度的线程池——FixedThreadPool</h2><blockquote><p>指定线程池线程的个数，任务线程传入时自动分配线程，线程不够时，剩余的任务线程排队等待线程池中的线程执行完毕</p></blockquote><ul><li>可控制线程最大的并发数（即同时执行的线程数）</li><li>超出的线程会在队列中等待</li></ul><h2 id="定时执行一些任务——ScheduledThreadPoolExecutor"><a href="#定时执行一些任务——ScheduledThreadPoolExecutor" class="headerlink" title="定时执行一些任务——ScheduledThreadPoolExecutor"></a>定时执行一些任务——ScheduledThreadPoolExecutor</h2><blockquote><p>指定线程池中线程的个数，任务线程传入时自动分配线程，可以设定任务线程第一次执行时的延时时间和之后每次执行的间隔时间。</p></blockquote><p>当需要定时地执行一些任务时，就可以通过<code>ScheduledThreadPoolExecutor</code>来实现，只需要通过<code>Executors</code>的<code>new ScheduledThreadPool</code>函数就可以创建定时执行任务的线程池。</p><ul><li>不要对那些同步等待其他任务结果的任务排队，否则可能导致死锁。在死锁中，所有线程都被一些任务所占用，而这些任务依次排队等待，又无法执行，这样所有的线程都属于忙碌状态。</li><li>理解任务————要有效地调整线程池的大小。</li><li>避免线程太少或者线程太多。</li></ul><h2 id="单线程化的线程池——SingleThreadExecutor"><a href="#单线程化的线程池——SingleThreadExecutor" class="headerlink" title="单线程化的线程池——SingleThreadExecutor"></a>单线程化的线程池——SingleThreadExecutor</h2><ul><li>有且仅有一个工作线程在执行任务</li><li>所有任务按照指定的顺序执行，即遵循队列的先入队出队的原则</li></ul><h2 id="有效的方法——BlockingQueue"><a href="#有效的方法——BlockingQueue" class="headerlink" title="有效的方法——BlockingQueue"></a>有效的方法——BlockingQueue</h2><p>阻塞队列提供了一系列有用的特性。例如，当队列满了时再调用<code>put</code>函数添加元素时，调用线程将被堵塞，直到队列不再是填满状态为止。</p><p>BlockingQueue中重要的方法有：</p><ul><li><code>add(e)</code></li><li><code>offer(e)</code></li><li><code>offer(e,time,unit)</code></li><li><code>put(e)</code></li><li><code>take()</code></li><li><code>poll(time,unit)</code></li><li><code>element()</code></li><li><code>peek()</code></li><li><code>remove()</code></li></ul><p>BlockingQueue主要有三种：</p><ul><li>基于数组的先进先出队列，有界：ArrayBlockingQueue</li><li>基于链表的先进先出队列，无界：LinkedBlockingQueue</li><li>无缓冲的等待队列，无界：SynchronousQueue</li></ul><h3 id="ArrayBlockingQueue"><a href="#ArrayBlockingQueue" class="headerlink" title="ArrayBlockingQueue"></a>ArrayBlockingQueue</h3><p>之前已经介绍了，ArrayBlockingQueue是一个基于<strong>数组</strong>结构实现的有界环形队列，按照FIFO原则对任务进行排序。如果队列满了还有任务进来，就调用拒绝策略。其原理就是利用了Lock锁的Condition通知机制进行阻塞控制。</p><p>那么，它主要使用<code>ReentrantLock</code>类中有一个<code>Condition</code>，它用于实现线程间的通信，是为了解决<code>Object.wait()</code>、<code>notify()</code>、<code>notifyAll()</code>难以使用的问题。</p><ul><li><code>await()</code>：线程等待的方法</li><li><code>await(int time, TimeUnit unit)</code>：线程等待特定的时间，超过时间则为超时</li><li><code>signal()</code>：随机唤醒某个等待线程</li><li><code>signalAll()</code>：唤醒所有等待中的线程</li></ul><p>当MyArrayBlockingQueue的元素为最大容量时，如果再往该队列中添加元素，就会调用<code>notFull.await()</code>函数使得线程阻塞，直到其它线程调用了<code>take()</code>方法从该队列中取出了元素，才不是已满状态。可以使用<code>notFull.signalAll()</code>方法唤醒所有的等待线程，使得添加元素的操作得以进行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MyArrayBlockingQueue</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据数组</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> T[] items;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 锁</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Lock lock = <span class="keyword">new</span> ReentrantLock();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队满的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition notFull = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队空的条件</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> Condition notEmpty = lock.newCondition();</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的头部索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> head;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 队列的尾部索引</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> tail;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 数据的个数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyArrayBlockingQueue&lt;Integer&gt; aQueue = <span class="keyword">new</span> MyArrayBlockingQueue&lt;&gt;();</span><br><span class="line">        aQueue.put(<span class="number">3</span>);</span><br><span class="line">        aQueue.put(<span class="number">24</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(aQueue.take());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayBlockingQueue</span><span class="params">(<span class="keyword">int</span> maxSize)</span> </span>&#123;</span><br><span class="line">        items = (T[]) <span class="keyword">new</span> Object[maxSize];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyArrayBlockingQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(T t)</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == getCapacity()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"数据已满，等待"</span>);</span><br><span class="line">                notFull.await();</span><br><span class="line">            &#125;</span><br><span class="line">            items[tail] = t;</span><br><span class="line">            <span class="keyword">if</span> (++tail == getCapacity()) &#123;</span><br><span class="line">                tail = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            ++count;</span><br><span class="line">            <span class="comment">// 唤醒等待数据的线程</span></span><br><span class="line">            notEmpty.signalAll();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> T <span class="title">take</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">                System.out.println(<span class="string">"还没有数据，请等待"</span>);</span><br><span class="line">                notEmpty.await();</span><br><span class="line">            &#125;</span><br><span class="line">            T ret = items[head];</span><br><span class="line">            items[head] = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">if</span> (++head == getCapacity()) &#123;</span><br><span class="line">                head = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            --count;</span><br><span class="line">            <span class="comment">// 唤醒添加数据的线程</span></span><br><span class="line">            notFull.signalAll();</span><br><span class="line">            <span class="keyword">return</span> ret;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getCapacity</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> items.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> count;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h4><ol><li>拿到了线程竞争lock锁，拿到了lock锁的线程就进入下一步，没有拿到lock锁的线程就自旋竞争锁；</li><li>判断阻塞队列是否已满，如果满了就调用<code>await()</code>方法阻塞这个线程，notFull（生产者）挂起，最后释放lock锁，等待被消费者线程唤醒；</li><li>如果没有满，则调用<code>enqueue()</code>方法将元素put进阻塞队列；</li><li>唤醒一个标记为<code>notEmpty()</code>（消费者）的线程。</li></ol><h4 id="take方法"><a href="#take方法" class="headerlink" title="take方法"></a>take方法</h4><ol><li>拿到了线程竞争lock锁，拿到了lock锁的线程就进入下一步，没有拿到lock锁的线程就自旋竞争锁；</li><li>判断阻塞队列是否为空，如果为空就调用<code>await()</code>方法阻塞这个线程，notEmpty（生产者）挂起，最后释放lock锁，等待被生产者线程唤醒；</li><li>如果没有空，则调用<code>dequeue()</code>方法将元素take出阻塞队列；</li><li>唤醒一个标记为<code>notFull()</code>（消费者）的线程。</li></ol><h3 id="LinkedBlockingQueue"><a href="#LinkedBlockingQueue" class="headerlink" title="LinkedBlockingQueue"></a>LinkedBlockingQueue</h3><p>LinkedBlockingQueue是基于链表的阻塞队列，其内部维持着一个数据缓冲队列（该队列由一个链表组成），当生产者往队列中放入一个数据时，队列会从生产者中获取数据，并缓存在队列内部，而生产者立即返回；只有当队列缓冲区达到最大值缓存容量时，才会阻塞生产者队列，直到消费者队列消费了数据，生产者才能继续工作。反之消费者端也是同样的。</p><p>LinkedBlockingQueue之所以能够高效处理并发数据，是因为对生产者端和消费者端都分别采用了独立的锁来控制数据同步，所以在高并发的情况下，生产者和消费者可以并行地操作队列中的数据，以此提高整个队列的并发性能。</p><h3 id="DelayQueue"><a href="#DelayQueue" class="headerlink" title="DelayQueue"></a>DelayQueue</h3><p>DelayQueue中的元素只有当自己指定的延迟时间到了，才可以从队列中获取到该元素。DelayQueue是一个没有大小限制的队列，因此往队列中插入数据是不会被阻塞的，只有获取数据会被阻塞。</p><h3 id="PriorityBlockingQueue"><a href="#PriorityBlockingQueue" class="headerlink" title="PriorityBlockingQueue"></a>PriorityBlockingQueue</h3><p>PriorityBlockingQueue是基于优先级的阻塞队列（优先级的判断是通过构造函数传入的<code>Compator</code>对象来决定的）。PriorityBlockingQueue不会阻塞生产者，只会当没有可消费的数据时，才会阻塞消费者。所以，<strong>生产者生产数据的速度绝对不能快于消费者数据的速度</strong>，否则时间长了后会耗尽所有的可用的堆内存空间（因为不会阻塞生产者）。</p><blockquote><p>实现PriorityBlockingQueue时，内部控制线程同步的锁采用的是公平锁。</p></blockquote><h3 id="SynchronousQueue"><a href="#SynchronousQueue" class="headerlink" title="SynchronousQueue"></a>SynchronousQueue</h3><p>SynchronousQueue是一种无缓冲的等待队列，类似于无中介的直接交易，生产者直接与消费者交易，少了一个中间经销商的环节（缓冲区）。</p><p>声明一个SynchronousQueue有两种不同的方式：公平模式和非公平模式。</p><p><strong>公平模式</strong>：SynchronousQueue会采用公平锁，并配合一个FIFO队列来阻塞多余的生产者和消费者，从而体系整体的公平策略。</p><p><strong>非公平模式</strong>：SynchronousQueue会采用非公平锁，同时配合一个LIFO的队列来管理多余的生产者和消费者。</p><h2 id="四种拒绝策略"><a href="#四种拒绝策略" class="headerlink" title="四种拒绝策略"></a>四种拒绝策略</h2><h3 id="AbortPolicy"><a href="#AbortPolicy" class="headerlink" title="AbortPolicy"></a>AbortPolicy</h3><blockquote><p>丢弃任务并抛出RejectedExecutionException异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> RejectedExecutionException(<span class="string">"Task"</span> + r.toString()</span><br><span class="line">        + <span class="string">" rejected from "</span> + e.toString());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DiscardPolicy"><a href="#DiscardPolicy" class="headerlink" title="DiscardPolicy"></a>DiscardPolicy</h3><blockquote><p>丢弃任务，但是并不抛出异常</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="DisCardOldSetPolicy"><a href="#DisCardOldSetPolicy" class="headerlink" title="DisCardOldSetPolicy"></a>DisCardOldSetPolicy</h3><blockquote><p>丢弃队列最前面的任务，然后提交新来的任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        e.getQueue().poll();</span><br><span class="line">        e.executor();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="CallerRunPolicy"><a href="#CallerRunPolicy" class="headerlink" title="CallerRunPolicy"></a>CallerRunPolicy</h3><blockquote><p>由调用线程（提交任务的线程，主线程）处理该任务</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!e.isShutdown()) &#123;</span><br><span class="line">        r.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(JVM)</title>
      <link href="/2020/10/29/Interview-Review(JVM)/"/>
      <url>/2020/10/29/Interview-Review(JVM)/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM内存共分为<strong>虚拟机栈</strong>、<strong>堆</strong>、<strong>方法区</strong>、<strong>程序计数器</strong>、<strong>本地方法栈</strong>五个部分。</p><p><strong>线程私有的</strong>：</p><ul><li>程序计数器 Program Counter Register</li><li>虚拟机栈 VM Stack</li><li>本地方法栈 Native Method Stack</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆 Heap</li><li>方法区 Method Area</li><li>直接内存（直接内存并不是运行时数据区域的一部分）</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块<strong>较小的内存空间</strong>，是当前线程所执行的字节码的行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都要依赖这个计数器来完成。</p><p>每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，所以这块内存区域被称为<strong>线程私有</strong>的内存。</p><p><strong>作用</strong>：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制：顺序执行、选择、循环等。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而线程被切换回来可以知道上次运行到哪。</li></ul><blockquote><p>程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></blockquote><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java内存可以分为<strong>堆内存</strong>和<strong>栈内存</strong>，这里的栈指的就是<strong>虚拟机栈</strong>。</p><p>虚拟机栈中的<strong>局部变量表</strong>主要存放了各种数据类型（八种基本数据类型）、对象引用（可能是指向对象起始地址的引用指针）等。</p><blockquote><p>Java虚拟机会出现两种错误：<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>。</p></blockquote><p>Java栈类比数据结构中的栈，保存的主要内容是栈帧，每次的函数调用都有对应的栈帧被压入Java栈，而每次函数的调用结束，都会有一个栈帧被弹出。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈的区别在于：本地方法栈是为虚拟机使用到的Native方法服务，而虚拟机栈是为执行Java（字节码）服务。「HotSpot」虚拟机中，这两个栈合二为一。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是Java虚拟机中所管理的内存最大的一块，是所有线程都共享的一块区域。这块区域的目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java堆是垃圾收集器管理的主要区域，所以也被称作<strong>GC堆</strong>。因为垃圾回收器都基本采用分代垃圾回收算法，所以Java堆还可细分为：<strong>新生代</strong>和<strong>老年代</strong>，目的是为了更好地回收内存，或者更快地分配内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也是所有线程都共享的一块区域，用于<strong>存储已被虚拟机加载的类信息、常量、静态便令、即时编译后的代码等数据</strong>。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存被频繁地使用。它避免了在Java堆和Native堆之间来回复制数据。</p><h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfFknK.png" alt="Java创建对象的过程"></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>虚拟机遇到一条new指令时，会去首先检查这个指令的参数能否在常量池定位到这个类的符号引用，并检查这个符号引用代表的类是否被加载过、解析过和初始化过。如果没有，就要执行类的加载过程。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li><strong>启动类加载器（Bootstrap ClassLoader）</strong>：这个类加载器由C++实现，是虚拟机自身的一部分；启动类加载器无法被Java程序直接引用的。</li><li><strong>扩展类加载器（Extension ClassLoader）</strong>：这个加载器由sun.misc.Launcher$ExtClassLoader实现，开发者可以直接使用该扩展类加载器。</li><li><strong>应用程序类加载器（Application ClassLoader）</strong>：这个类加载器由sun.misc.Launcher$AppClassLoader实现。它一般被称为系统类加载器，负责加载用户类路径上所指定的类库。开发者可以直接使用这个类加载器，一般就是程序中默认的类加载器。</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>类加载器之间的层次关系，被称为是类加载器的双亲委派模型。其中，除了顶层加载器之外，其余的类加载器都会有自己的父类加载器。它们之间的父子关系不是<strong>继承</strong>，而是以<strong>组合</strong>的关系来复用父类加载器的代码。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/PWeOThwsN7BSRck.png" alt="双亲委派模型"></p><p>双亲委派模型的工作过程是：</p><blockquote><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求都委派给父类加载器去完成，每一个层次的类加载器都是如此。所以所有的加载请求最终都会被传送到顶层的启动类加载器中。只有当父类加载器无法完成这个加载请求时（即它的搜索范围类没有找到这个类），子加载器才会尝试自己去完成这个加载请求。</p></blockquote><p>双亲委派模型的好处就是<strong>Java随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。比如Object类在各种类加载环境中都是同一个类，即<code>java.lang.Object</code>。</p><p>而如果没有双亲委派模型的话，如果开发者自己编写了一个同名的Object类，那么系统中会有多个Object类，那么需要加载哪个类就很混乱。</p><h4 id="破坏双亲委派模型"><a href="#破坏双亲委派模型" class="headerlink" title="破坏双亲委派模型"></a>破坏双亲委派模型</h4><p>之所以有时候要破坏双亲委派模型，是因为在某些情况下，父类加载器需要委托子类加载器去加载class文件。受到加载范围的限制，父类加载器可能会无法加载到需要的文件，这时候就需要启动类加载器来委托子类来加载实现，从而破坏了双亲委派模型（<strong>上述的只是一个例子</strong>）。</p><p>到目前为止，双亲委派模型出现过三次较大规模的「<strong>被破坏</strong>」情况：</p><ul><li>第一次其实出现在双亲委派模型之前，即JDK1.2发布之前。当时，用户必须去重写<code>loadClass</code>方法去继承<code>java.lang.ClassLoader</code>。</li><li>第二次是由于这个模型自身的缺陷导致的。双亲委派模型很好地解决了各个类加载器的基础类的统一问题，但是当基础类又要调回到用户的代码中，该怎么办？为了解决这个问题，Java设计团队引入了一个不太优雅的设计：<strong>线程上下文类加载器（Thread Context ClassLoader）</strong>。这个类加载器可以通过<code>java.lang.Thread</code>类的<code>setContextClassLoader()</code>方法进行设置。如果创建线程时还没有设置，它将会从父线程中继承一个，如果整个应用程序的全局范围内都没设置过的话，那么这个类加载器默认就是应用程序类加载器。</li><li>第三次是因为用户对于程序动态性的追求导致的。因为用户最求一些例如：代码热替换（HotSwap）、模块热部署（Hot Deployment）等，不需要重启服务器就能立即使用的情况。</li></ul><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载检查过后，就要为新生对象分配内存。分配方式有两种：</p><ul><li>指针碰撞</li><li>空闲列表</li></ul><blockquote><p>具体选择哪种方式由Java堆是否规整来决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理的功能来决定。</p></blockquote><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、对象的哈希码、对象GC分代等信息，都存储在信息头中。</p><h3 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行<code>init</code>方法</h3><p><code>new</code>指令之后会接着执行<code>init</code>方法，初始化之后对象才算完全生产出来。</p><h2 id="对象的内存布局"><a href="#对象的内存布局" class="headerlink" title="对象的内存布局"></a>对象的内存布局</h2><p>对象在内存中的布局可以分为3块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><h3 id="对象头"><a href="#对象头" class="headerlink" title="对象头"></a>对象头</h3><p>对象头包括两部分信息：</p><ul><li>第一部分：用于存储对象自身的运行时数据（哈希码、GC分代年龄、锁标志）等</li><li>第二部分：类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例</li></ul><h3 id="实例数据"><a href="#实例数据" class="headerlink" title="实例数据"></a>实例数据</h3><p>实例数据部分是<strong>对象真正存储的有效信息</strong>，也是程序中所定义的各种类型的字段内容。</p><h3 id="对齐填充"><a href="#对齐填充" class="headerlink" title="对齐填充"></a>对齐填充</h3><p>对齐填充部分不是必然存在的，也没有特别的含义，仅仅起到占位作用。</p><h2 id="对象的访问定位"><a href="#对象的访问定位" class="headerlink" title="对象的访问定位"></a>对象的访问定位</h2><p>对于对象的访问方式，主流的有<strong>使用句柄</strong>和<strong>直接指针</strong>两种。</p><h3 id="使用句柄"><a href="#使用句柄" class="headerlink" title="使用句柄"></a>使用句柄</h3><p>使用句柄的话，Java堆中会划分出一块内存来作为句柄池，<strong>引用存储的就是对象的句柄地址</strong>，句柄中包括了对象实例数据与类型数据鸽子的具体地址信息；</p><p><a href="https://imgchr.com/i/BfLnns" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfLnns.png" alt="使用句柄"></a></p><h3 id="直接指针"><a href="#直接指针" class="headerlink" title="直接指针"></a>直接指针</h3><p>如果使用直接指针，那么<strong>引用存储的就是对象的地址</strong></p><p><a href="https://imgchr.com/i/BfLuBn" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfLuBn.png" alt="直接指针"></a></p><h3 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h3><p>两种对象的访问方式各有优劣。使用句柄的好处是引用存储的是稳定的句柄地址，那么对象移动时只会改变句柄中的实例数据指针。</p><p>使用直接指针访问的最大好处是速度快，节省了一次指针定位的时间花销。</p><h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><p>垃圾回收（Garbage Collection）是一种自动的内存管理机制。当动态内存不再需要时，就应当予以释放，以让出内存，这就是<strong>垃圾回收</strong>。</p><p>垃圾回收算法的优缺点主要看以下几个方面：</p><ul><li><strong>吞吐量</strong></li><li><strong>最大暂停时间</strong></li><li><strong>堆使用效率</strong></li><li><strong>访问的局部性</strong></li></ul><h2 id="引用计数算法-Reference-Counting"><a href="#引用计数算法-Reference-Counting" class="headerlink" title="引用计数算法 Reference Counting"></a>引用计数算法 Reference Counting</h2><blockquote><p>记录每个对象被引用的次数。每次新建对象、赋值引用和删除引用的同时都要更新计数器，如果计数器的值为0就直接回收内存。</p></blockquote><p>给对象中添加一个引用计数器，每当有一个地方引用它时，计数器的值就加1；当引用失效时，计数器的值就减1。当计数器的值为0时，这个对象就是不可再被使用的。</p><p>主流Java虚拟机里并没有选择引用计数法来管理内存，主要原因是「它很难解决对象之间互相循环引用的问题」。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 因为objA.instance = objB, objB.instance = objA;</span></span><br><span class="line"><span class="comment"> * 之后令objA = null, objB = null，这两个对象就不可能再被访问了</span></span><br><span class="line"><span class="comment"> * 但因为它们互相引用着对方，导致引用计数都不为0，导致无法通知GC收集器回收它们</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testGC</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    ReferenceCountingGC objA = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    ReferenceCountingGC objB = <span class="keyword">new</span> ReferenceCountingGC();</span><br><span class="line">    objA.instance = objB;</span><br><span class="line">    objB.instance = objA;</span><br><span class="line"></span><br><span class="line">    objA = <span class="keyword">null</span>;</span><br><span class="line">    objB = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    System.gc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="可达性分析算法-Reachability-Analysis"><a href="#可达性分析算法-Reachability-Analysis" class="headerlink" title="可达性分析算法 Reachability Analysis"></a>可达性分析算法 Reachability Analysis</h2><p>这个算法的基本思路就是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径被称为<strong>引用链</strong>（Reference Chain），当一个对象到达GC Roots时都没有任何引用链与其相连时，就证明该对象是不可用的，将会被判定是可回收的对象。</p><h2 id="标记-清除算法-Mark-Sweep-GC"><a href="#标记-清除算法-Mark-Sweep-GC" class="headerlink" title="标记-清除算法 Mark-Sweep GC"></a>标记-清除算法 Mark-Sweep GC</h2><blockquote><p>首先标记出所有需要回收的对象，在标记完成后统一回收所有被标记的对象。</p></blockquote><ol><li><strong>标记阶段</strong>：从根集合出发，将所有的活动对象及其子对象打上标记</li><li><strong>清除阶段</strong>：遍历堆，将所有的非活动对象（未打上标记的对象）连接到空闲链表上</li></ol><p><strong>不足之处</strong>：</p><ul><li>效率问题：标记和清除的两个过程效率都不高</li><li>空间问题：标记清除之后会产生大量的不连续的内存碎片，空间碎片太多就会导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作。</li></ul><h2 id="标记-压缩（整理）算法-Mark-Compact-GC"><a href="#标记-压缩（整理）算法-Mark-Compact-GC" class="headerlink" title="标记-压缩（整理）算法 Mark-Compact GC"></a>标记-压缩（整理）算法 Mark-Compact GC</h2><p>后续步骤不是直接对可回收的对象进行清理，而是让所有存活的对象都向一端移动，即将所有的活动对象紧密地排在堆的一端（压缩），然后直接清理掉端边界以外的内存，消除了内存碎片，但压缩需要成本。</p><h2 id="复制算法-Copying"><a href="#复制算法-Copying" class="headerlink" title="复制算法 Copying"></a>复制算法 Copying</h2><p>将堆分为两个大小相等的From和To两块，每次只使用其中的一块。利用From空间进行分配，当From空间满了，就将其中的活动对象复制到To空间，之后将两个空间互换即完成GC。</p><blockquote><p>每次都是对整个半区进行内存回收，分配内存时也就不用考虑内存碎片等复杂情况。</p></blockquote><p>但这种算法的代价是将内存缩小到了原来的一半，因为分成了两块相等的内存空间。</p><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><blockquote><p>垃圾回收器是内存回收的具体体现。Java虚拟机中对垃圾收集器应该如何实现是没有任何固定的规定的，所有不同厂商、不同版本的虚拟机所提供的垃圾收集器都可能会有很大的差别。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/aDxytVcrLp3mb45.png" alt="HotSpot虚拟机的垃圾收集器"></p><p>如上图所示，展示了<strong>7种</strong>作用于不同分代的收集器，如果两个收集器之间存在连线，就说明可以搭配使用。处于上面区域的是<strong>新生代</strong>收集器，下面区域的是<strong>老年代</strong>收集器。</p><h2 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h2><p>Serial收集器是最基本、历史最久的收集器，曾经是JDK1.3.1版本之前的虚拟机新生代收集的唯一选择。这个收集器是一个<strong>单线程</strong>的收集器，这意味着<strong>它只会使用一个CPU或者一条收集线程去完成垃圾收集工作</strong>，同时，<strong>在它进行垃圾收集的时候，它必须暂停其它所有的工程线程，直到它收集结束</strong>。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/w3ED8n6UOHmRvz4.png" alt="Serial/Serial Old收集器运行示意图"></p><p>当然，它也是有优点的：简单而高效（与其他垃圾收集器的单线程相比），对于限定了单个CPU的环境来说，Serial收集器由于没有线程之间监护的开销，专心从事垃圾收集工作，自然就会有更高的单线程收集效率。所以，它依然是<strong>虚拟机运行在Client模式下的默认新生代收集器</strong>。</p><h2 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h2><p>ParNew收集器其实是Serial收集器的<strong>多线程版本</strong>。ParNew除了使用多线程进行垃圾收集之外，其余行为还有Serial收集器可用的所有控制参数、收集算法、对象分配规则、回收策略等。</p><p>ParNew收集器是许多运行在Server模式下的虚拟机中首选的新生代收集器，因为目前，除了Serial收集器之外，只有它可以与CMS收集器相互配合。而CMS收集器是HotSpot虚拟机中第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户工作线程同时工作，具有划时代的意义。</p><p>ParNew收集器在单CPU的环境中的运行效果不会比Serial收集器更好，但是随着使用的CPU数量的增加，它对GC的系统资源的有效利用还是有很多好处的。它默认开启的收集线程数与CPU的数量相同，如果CPU数量飞铲过，就可以使用<code>-XX:ParallelGCThreads</code>；参数来限制垃圾收集的线程数。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Ltmbg1spWojvnAX.png" alt="ParNew/Serial Old收集器运行示意图"></p><p>除此之外，我们需要理解两个概念：</p><ul><li>并行（Parallel）：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态；</li><li>并发（Concurrent）：指用户线程与垃圾收集线程同时执行（不一定是并行，也可以是交替执行），但用户程序的确是在继续执行，而垃圾收集程序运行在另一个CPU上。</li></ul><h2 id="Parallel-Scavenge收集器"><a href="#Parallel-Scavenge收集器" class="headerlink" title="Parallel Scavenge收集器"></a>Parallel Scavenge收集器</h2><blockquote><p>Parallel Scavenge收集器是一个新生代收集器，也是同样使用复制算法，也是并行多线程的收集器，但它的关注点是<strong>达到一个可控制的吞吐量（Throughput）</strong>。所以，Parallel Scavenge收集器也被称为<strong>吞吐量优先</strong>收集器。</p><p>吞吐量就是CPU用于运行用户代码的时间与CPU消耗时间的比值，即$吞吐量=\frac{运行用户代码时间}{运行用户代码时间 + 垃圾收集时间}$。</p></blockquote><p>高吞吐量可以高效率地利用CPU时间，尽快完成程序的运算任务，适合<strong>在后台运算不需要太多交互的任务</strong>。</p><h2 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h2><p>Serial收集器的老年代版本，是单线程的，使用标记-整理算法，也是主要提供给Client模式下的虚拟机使用的。</p><h2 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h2><p>Parallel收集器的老年代版本，是多线程的，采用标记-整理算法，同样是注重吞吐量。</p><h2 id="CMS收集器"><a href="#CMS收集器" class="headerlink" title="CMS收集器"></a>CMS收集器</h2><blockquote><p>CMS（Concurrent Mark Sweep）收集器是一种<strong>以获取最短回收停顿时间为目标的收集器</strong>。当一些应用十分重视服务的响应速度，希望系统停顿时间最短的话，CMS收集器就符合这类应用的需求。</p></blockquote><p>CMS收集器是基于<strong>标记——清除</strong>算法实现的，它的运作过程相比其它的收集器更发咋一些，分为<strong>4个步骤</strong>，包括：</p><ul><li><strong>初始标记（CMS inital mark）</strong></li><li><strong>并发标记（CMS concurrent mark）</strong></li><li><strong>重新标记（CMS remark）</strong></li><li><strong>并发清除（CMS concurrent sweep）</strong></li></ul><h2 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h2><p>即Garbage First收集器，是一个里程碑的收集器，开创了面向局部收集的思路和基于Region的内存布局形式。在延迟可控的情况下，可以获得尽可能高的吞吐量。</p><p>G1收集器可以将连续的Java堆划分为多个大小相等的独立区域，每一个Region都可以根据需要扮演新生代的Eden空间，Survivor空间或者老年空间。</p><p>收集过程也是4个步骤：</p><ul><li><strong>初始标记</strong>：标记GC Roots能够直接关联到的对象</li><li><strong>并发标记</strong>：并发进行可达性分析</li><li><strong>最终标记</strong>：短暂停顿，处理并发标记结束时遗留的少量对象</li><li><strong>筛选回收</strong>：更新Region统计数据，根据价值和回收成本机型排序，并依据用户期望的停顿时间来制定回收计划。</li></ul><p>所以，<strong>Java8以前是Parallel GC，Java9以后改为G1 GC</strong>。</p><p>G1收集器具有以下特点：</p><ul><li><strong>并行与并发</strong>：G1能够充分利用多CPU、多核环境下的硬件优势，使用多个CPU来缩短Stop-The-World停顿的时间。</li><li><strong>分代收集</strong>：与其他收集器一样，分代概念在G1中依然得以保留。</li><li><strong>空间整合</strong>：与CMS的「标记-清理」算法不同，G1从<strong>整体</strong>来看是基于「标记-整理」算法实现的收集器，从<strong>局部</strong>来看，则是基于「复制」算法来实现的。</li><li><strong>可预测的停顿</strong>：这个G1相对于CMS的另外一个优势，G1除了能够降低停顿时间之外，还可以建立可预测的停顿时间模型，能够让使用者明确指定在一个长度为M毫秒的时间片段内。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Git)</title>
      <link href="/2020/09/23/Interview-Review(Git)/"/>
      <url>/2020/09/23/Interview-Review(Git)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的Git部分。</p><h2 id="Git回滚以前的某个版本"><a href="#Git回滚以前的某个版本" class="headerlink" title="Git回滚以前的某个版本"></a>Git回滚以前的某个版本</h2><ol><li><p>查找历史版本</p><p> 使用<code>git log</code>命令查看所有的历史版本，获取该仓库git的某个历史版本的id。例如，假设id是fae6966548e3ae76cfa7f38a461c438cf75ba965。</p></li><li><p>恢复到历史版本</p><p> <code>$ git reset --hard fae6966548e3ae76cfa7f38a461c438cf75ba965</code></p></li><li><p>把修改推送到远程的服务器</p><p> <code>git push -f -u origin master</code></p></li></ol><h2 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h2><p><code>git merge</code>和<code>git rebase</code>都是用于合并分支的，不同之处在于对于commit记录的处理上是不同的。</p><p>例如，原始分支如下所示，一个是master(origin)分支，一个是dev(mywork)分支：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/uQjfncJy7GVTKLC.png" alt=""></p><p>当使用<code>git merge</code>的话，会新建一个新的commit对象，然后两个分支以前的commit记录都会指向这个新建的commit记录。这个方式可以保留之前的每一个分支中的commit的历史，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/nobMpWH8wT4YCuk.png" alt=""></p><p>当使用<code>git rebase</code>命令时，可以让两个分支合并后呈线性记录，和没有合并一样。<code>git rebase</code>会先找到两个分支的第一个<strong>共同的</strong>commit的祖先记录，然后提取这个祖先记录之后的所有的commit记录，将这个commit记录添加到目标分支的最新提交的后面。「它会指向新的提交，而那些老的提交会被丢弃」。经过这个合并之后，两个分支合并后的commit记录会变成线性记录了。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/YGS2bc3PkCEMtog.png" alt=""></p><h2 id="git-pull和git-fetch的区别"><a href="#git-pull和git-fetch的区别" class="headerlink" title="git pull和git fetch的区别"></a>git pull和git fetch的区别</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查之后再决定是否合并到工作主机的分支中。</p><p><code>git pull</code>是将远程主机的最新内容拉下来之后就直接合并了，所以可以理解为：<code>git pull</code>=<code>git fetch</code>+<code>git merge</code>。因为直接合并是可能会产生冲突的，所以需要手动解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的String为什么是不可变的</title>
      <link href="/2020/09/22/Java%E4%B8%AD%E7%9A%84String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/"/>
      <url>/2020/09/22/Java%E4%B8%AD%E7%9A%84String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>在Java中，String类是不可变的，即String中的对象是不可变的。</p><h3 id="区别对象和对象的引用"><a href="#区别对象和对象的引用" class="headerlink" title="区别对象和对象的引用"></a>区别对象和对象的引用</h3><p>对于Java初学者， 对于String是不可变对象总是存有疑惑。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p>打印出的结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure></p><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。从打印结果可以看出，s的值确实改变了，那么为什么说String对象是不可变的呢？其实这里存在一个误区：<strong>s只是一个String对象的引用，并不是对象本身</strong>。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当<code>s=“123456”;</code>这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个心的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/OL8ekRVIM6mwpsP.png" alt="String真实的内存结构"></p><h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><blockquote><p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。即不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能再指向其它的对象，引用类型指向的对象的状态也不能改变。</p></blockquote><p>《Effective Java》中第 15 条<strong>使可变性最小化</strong>中对<strong>不可变类</strong>的解释：</p><blockquote><p>不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并且在对象的整个生命周期内固定不变。为了使类不可变，要遵循下面五条规则：</p><ol><li>不要提供任何会修改对象状态的方法。</li><li>保证类不会被扩展。一般的做法是让这个类称为<code>final</code>的，防止子类化，破坏该类的不可变行为。</li><li>使所有的域都是<code>final</code>的。</li><li>使所有的域都成为私有的。防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。</li><li>确保对于任何可变性组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。</li></ol></blockquote><p>在 Java 平台类库中，包含许多不可变类，例如<code>String</code>, 基本类型的包装类，<code>BigInteger</code>, <code>BigDecimal</code>等等。综上所述，不可变类具有一些显著的通用特征：类本身是<code>final</code>修饰的；所有的域几乎都是私有<code>final</code>的；不会对外暴露可以修改对象属性的方法。通过查阅String的源码，可以清晰的看到这些特征。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>通过查看Java中String的源码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，String类是通过<code>final</code>修饰的，满足了第二条的：类不能被拓展。</p><p>其次，在类中，最重要的一条<code>private final byte[] value;</code>中，我们可以看到Java是使用<strong>字节数组</strong>（Java9，之前的版本是采用字符char数组实现）来实现字符串的，并且使用了<code>final</code>修饰，这就是String为什么不可变的原因。</p><p>因为它使用了<code>private final</code>，导致正常情况下外界没有办法去修改它的值。这满足了第三条：使所有的域都是<code>final</code>的，和第四条：使所有的域都是私有的。然而仅仅这样也仍然不是万无一失的。</p><p>第一条原则是：不要提供任何会修改对象状态的方法。String类在这点中做得很好。在String类中许多会对字符串进行操作的方法中，例如<code>replaceAll()</code>或者<code>substring()</code>等，其中的每一步实现都不会对<code>value</code>产生任何影响。即String类中并没有提供任何可以改变其值的方法，这比<code>final</code>更能确保其是不变的。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>《Effective Java》一书中总结了不可变类的特点：</p><ul><li>不可变类比较简单。</li><li>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享。</li><li>不仅可以共享不可变对象，甚至可以共享它们的内部信息。</li><li>不可变对象为其他对象提供了大量的构建。</li><li>不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。</li></ul><h3 id="String真的不可变吗"><a href="#String真的不可变吗" class="headerlink" title="String真的不可变吗"></a>String真的不可变吗</h3><p>其实可以通过<strong>反射机制</strong>来破坏String的不可变性。可以反射出String对象中的value属性，进而改变通过获得的value引用改变数组的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);<span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">// 变成Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack组件</title>
      <link href="/2020/09/22/Android%20Jetpack%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/22/Android%20Jetpack%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h1><p>Jetpack是Google推出的一个框架，主要是可以对代码的逻辑和UI界面实现深层的解耦，打造数据驱动型的UI界面。Android Architecture组件是Android Jetpack的一部分，包含以下组件等：</p><ul><li><strong>Lifecycle</strong>：能够处理Activity和Fragment的生命周期，在AndroidX中，Fragment和Activity已经对Lifecycle提供了默认的支持。</li><li><strong>ViewModel</strong>：当做MVVM的ViewModel层，并具有生命周期意识的处理和UI相关的数据。</li><li><strong>LiveData</strong>：和RxJava的作用是一样的，对数据进行监听，优点是无需处理生命周期、无内存泄漏等。</li><li><strong>Paging</strong>：是一个易于使用的数据分页库，支持RecyclerView。</li><li><strong>Room</strong>：强大的ORM数据库框架。</li><li><strong>Navigation</strong>：一个用于管理Fragment切换的工具类，可视化、可绑定控件、支持动画等优点。</li><li><strong>WorkManager</strong>：灵活、简单、延迟和保证执行的后台任务处理库。</li><li><strong>DataBinding</strong>：加速MVVM的创建。</li></ul><p>使用Android Jetpack组件具有以下优势：</p><ul><li>轻松管理应用程序的生命周期</li><li>构建可观察的数据对象，以便在基础数据库更改时通知视图</li><li>存储在应用程序轮换中未销毁的UI相关数据，在界面重建后恢复数据</li><li>轻松地实现SQLite数据库</li><li>系统自动调度后台任务的执行，优化使用性能</li><li>支持RxJava：由于RxJava强大的生态环境，几乎和数据相关的组件都对RxJava提供了支持。</li><li>减少代码量：以Data Binding + ViewModel + LiveData或者RxJava构建的MVVM模式能够显著地减少代码量，比平时用的MVP模式也会更加方便，无需主动更新UI。</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/cSOh1EUeYDV3K68.png" alt="Android JetPack组件"></p><p>上述组件的架构功能如下：</p><ul><li>Activity和Fragment负责产品与用户的交互</li><li>ViewModel作为数据的存储和驱动</li><li>Resposity负责调度数据的获取</li><li>Room储存本地序列化的数据</li><li>Retrofit获取远程数据的数据</li></ul><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycler是一个生命周期的感知组件，执行操作以响应另一个组件（例如Activity和Fragment）的生命周期状态的更改，可以监听Activity组件生命周期的变化，在每个生命周期执行相应的方法。</p><p>不同于以往会在生命周期中执行相应的方法时，需要设置接口，然后在生命周期中回调接口，这样会造成代码的耦合，也会引发生命周期的问题。Lifecycle的<strong>优点</strong>是实现了执行的逻辑和活动的分离，代码解耦并且增加了代码的可读性。Lifecycle在活动结束时会自定义移除监听。</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>一个应用肯定要进行数据的更新。当用户执行某种操作或者服务器端的数据发生改变后，都需要重新获取数据，再次刷新界面的UI。那么，每改变一次就需要重复一次，如何使用一个方式可以监听数据状态，在数据变化时就自动更新UI呢？LiveData就是用来实现此功能的，它解决了数据展示和刷新的问题：只需要创建LiveData实例后，为可观察的数据添加观察者，在数据改变时会自动回调观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>用户在使用应用的过程中，可能随时会被中断或者界面发生了重建，如果重新进入后数据丢失了就会造成不好的用户体验。我们可以使用<code>onSaveInstanceState()</code>方法来保存数据，然后在界面重建后使用<code>onRestoreInstanceState()</code>方法来恢复数据。这种方式虽然可以解决问题，但是如果过于频繁，在每个界面都要编写重建和恢复的代码，就会造成十分繁琐，且数据量过大时会影响执行性能。ViewModel就是来解决这个问题的。</p><p>ViewModel会在活动重建时仍然保存数据，在活动创建完成后从中获取数据。</p><p>ViewModel的优点：</p><ul><li>数据和界面的分离，使数据驱动界面</li><li>解决了运行中断和界面重建时的数据保存问题</li><li>配合LiveData实时地获取最新的数据</li><li>实现了Activity和Fragment之间的数据交互</li></ul><p>ViewModel的<strong>原理</strong>：将数据保存到ViewModel中，然后为活动中添加一个HolderFragment，HolderFragment中保存了ViewStore的实例，ViewStore中使用Map保存了ViewModel，从而在活动重新创建时获取到原来的ViewModel。</p><hr><blockquote><p>一般ViewModel会和LiveData组合，保存可观察的数据</p></blockquote><p>在研究生毕业设计的项目中，我在安卓端的代码中就使用到了LiveData搭配ViewModel的组合。</p><p>在<code>ContractViewModel</code>类中的代码如下。这里主要是使用到了一个<code>MutableLiveData</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContractViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData contractModel = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData callContractResult = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData proofPlace = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;ContractModel&gt; <span class="title">getContractModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contractModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;Boolean&gt; <span class="title">getCallContractResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callContractResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getProofPlace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proofPlace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在Fragment中这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ContractViewModel mViewModel;</span><br><span class="line"></span><br><span class="line">mViewModel = ViewModelProviders.of(fragmentActivity).get(ContractViewModel.class);</span><br><span class="line"></span><br><span class="line">mViewModel = mViewModel.getContractModel().observe(<span class="keyword">this</span>, o -&gt; &#123;</span><br><span class="line">    CertificateModel certificateModel = (CertificateModel) o;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mViewModel.getCallContractResult().postValue(XXX);</span><br><span class="line">mViewModel.getProofPlace().postValue(XXX);</span><br></pre></td></tr></table></figure><p>从上面可以看出，<code>mViewModel</code>可以通过<code>ViewModelProviders</code>与<code>fragmentActivity</code>，再与<code>ContractViewModel</code>绑定。<code>mViewModel.getContractModel().observe()</code>的方式。除此之外，可以使用<code>postValue()</code>的方式去传递值。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别是最残忍的告白</title>
      <link href="/2020/08/21/%E5%91%8A%E5%88%AB%E6%98%AF%E6%9C%80%E6%AE%8B%E5%BF%8D%E7%9A%84%E5%91%8A%E7%99%BD/"/>
      <url>/2020/08/21/%E5%91%8A%E5%88%AB%E6%98%AF%E6%9C%80%E6%AE%8B%E5%BF%8D%E7%9A%84%E5%91%8A%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>穿过树丛田野</p><p>风景向身后凛冽</p><p>铁轨伸长了双臂</p><p>向黎明驶去</p><p>窗外的世界</p><p>是从没见过的新奇</p><p>淡蓝色的月亮</p><p>城市在黎明处张望</p><p>铁轨扑向更远更长</p><p>车灯照着未知的彷徨</p><p>汽笛遮掩的话语</p><p>琐碎在肩上的行李</p><p>霓虹向后飞越</p><p>向昨晚的梦告别</p><p>淡淡的晨光</p><p>匍匐在身后的家乡</p><p>忽明忽暗的远方</p><p>在行驶的路上</p><p>珍藏的记忆都装进背包</p><p>挥手告别旧时光的美好</p><p>拥抱迎面的翻山越岭</p><p>好好告别就不会有遗憾吗</p><hr><p>那茶杯还留着酣畅的清香</p><p>而回忆却是说忘就忘</p><p>在黑色的夜晚摇月亮</p><p>我该去哪里走一走逛一逛</p><p>哪里的集市丰盛有眼光</p><p>哪里的酒好喝到能一醉方休</p><p>哪里的人不问来路与归途</p><p>我该去哪里看一看 想一想</p><p>哪里的前程值得被信仰</p><p>哪里的水清的 仿佛能看到希望</p><p>哪里的风拂晓坦荡愿与你戏攘</p><p>自在的不觉得虚妄</p><p>时间无谓无果无需隐藏</p><p>一无所有所得所期所想</p><p>尘嚣倾吐残余的伤</p><p>黄昏后回归故乡</p><p>愿你有故乡</p><hr><p>👋再见啦，🇬🇧UK</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(BlockChain)</title>
      <link href="/2020/06/07/Interview-Review(BlockChain)/"/>
      <url>/2020/06/07/Interview-Review(BlockChain)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的区块链部分。</p><a id="more"></a><ol><li><p><strong>什么是区块链</strong></p><p> 区块链是不间断的经济交易数字分类账本，可以进行编程，以记录不仅是金融交易，还可以记录几乎所有有价值的东西。它是<strong>一个不可变记录的分散式、分布式数据库</strong>，该数据库由计算机集群管理，但不属于任何单个实体。</p></li><li><p><strong>区块链是如何工作的</strong></p><p> 区块链由不可变的数据记录（称为<strong>数据块</strong>）组成，这些数据使用<strong>密码学</strong>进行链接。密码学不过是在读取私人消息时对第三方进行加密和保护数据通信的过程。在区块链中，<strong>一旦记录了数据，就不会更改</strong>。区块链就像带有<strong>时间戳</strong>的数学公证人一样工作，以避免篡改信息。</p></li><li><p><strong>为什么区块链是一种值得信赖的方法</strong></p><ul><li>它具有开源特性，与其它业务应用程序相互兼容</li><li>透明度和安全性</li><li>提高效率和速度</li><li>无需依赖任何中央权威</li></ul></li><li><p><strong>什么是区块链中的区块，如何识别</strong></p><p> 区块链中的<strong>区块用于存储数据并永久锁定</strong>。添加在块上的数据是<strong>不可变的</strong>，即<strong>不能更改或删除数据</strong>。可以通过块的<strong>高度</strong>和<strong>块头哈希</strong>来识别块。块中的数据通过称为哈希函数的计算机算法进行检测。它不仅锁定了区块链参与者可以看到的数据，而且使数据不可变。<strong>每个块都有哈希函数</strong>。</p></li><li><p><strong>块的主要元素是什么</strong></p><p> 以下是块的主要元素：</p><ul><li><strong>指向上一个块的哈希指针</strong></li><li><strong>时间戳</strong> Timestamp</li><li><strong>交易</strong> Transaction</li></ul></li><li><p><strong>是否可以从区块链的网络中删除一个或多个块</strong></p><p> 可以的，因为有时只需要考虑在线分类账本的特定部分。通过使用默认过滤器和选项，可以删除这些块。</p></li><li><p><strong>将数据写入块后是否可以更改数据</strong></p><p> 不可以。</p></li><li><p><strong>区块链数据库中可用的记录类型是什么</strong></p><p> 区块链数据库中有两种类型的记录。他们是：</p><ul><li>交易记录</li><li>阻止记录</li></ul></li><li><p><strong>有哪些不同类型的区块链</strong></p><ul><li>公有区块链（公有链）：没有人负责，任何人都可以读写/审核区块链。</li><li>私有区块链（私有链）：它是个人或者组织的私有财产。</li><li>联合区块链（联盟链）：选定的成员可以读取/写入/审核区块链。</li></ul></li><li><p><strong>什么是分类账本，并命名区块链中用户考虑的常见分类账类型</strong></p><p>分类账是一个不断增长的文件，它存储了在区块链网络上两方之间的所有交易的永久记录。</p><p>用户考虑的常见分类帐类型：</p><ul><li><strong>集中式分类账</strong></li><li><strong>分散的分类帐</strong></li><li><strong>分布式分类账</strong></li></ul></li><li><p><strong>公钥和私钥有什么区别</strong></p><p>在区块链中，需要使用<strong>公钥进行标识</strong>，而使用<strong>私钥进行加密和身份验证</strong>。发送方可以使用接收方的公钥发送消息，而接收方可以使用私钥对消息或交易进行解密。通过同时使用两个密钥，可以确保通信或交易的安全和防篡改。</p></li><li><p><strong>区块链以什么顺序连接</strong></p><p>区块链中的所有区块都以反向顺序连接，或者每个区块都与其前一个区块连接。</p></li><li><p><strong>区块链分类账和普通分类账有何不同</strong></p><p>区块链是一种数字账本，可以很容易地分散，与原始账本相比，区块链账本中的错误机会要少得多。区块链自动执行其所有任务，而在普通分类账本中，每项任务都是手动或者人工完成的。</p></li><li><p><strong>什么是共识算法</strong></p><p>共识算法是一种方法，通过该方法，区块链网络的所有对等方都可以达成分布式账本当前状态的标准协议。它可实现高可靠性，并在分布式计算环境中的未知对等方之间建立信任。</p></li><li><p><strong>共识算法有哪些</strong></p><ul><li>工作量证明PoW</li><li>容量证明PoC</li><li>活动证明PoA</li><li>委托权益证明DPoS</li><li>股权证明PoS</li><li>权威证明</li><li>燃烧证明</li><li>唯一节点列表</li><li>重量证明</li><li>拜占庭容错PBFT</li></ul></li><li><p><strong>什么是加密货币</strong></p><p>加密货币是一种数字资产，可以用作使用加密功能进行金融交易的交换媒介。加密货币利用区块链技术获得透明度，去中心化和不变性。加密货币可以使用公钥和私钥在两方之间直接发送，而手续费极低。</p></li><li><p><strong>区块链架构的核心组件是什么</strong></p><ul><li><strong>节点</strong>：区块链结构中的用户/计算机</li><li><strong>交易</strong>：区块链系统的最小组成部分</li><li><strong>块</strong>：用于维护一组分配给网络中所有节点的事务</li><li><strong>链</strong>：块顺序</li><li><strong>矿工</strong>：在添加到区块链结构之前执行块验证过程的特定节点</li><li><strong>共识协议</strong>：进行区块链操作的规则集</li></ul></li><li><p><strong>区块链的一个区块永远不能有多个父区块吗</strong></p><p><strong>区块链永远不会有父区块</strong>，每个区块在区块链中都会独立的。</p></li><li><p><strong>什么是51%攻击</strong></p><p>51%攻击或者双花攻击是指区块链上的单个或者一组矿工，他们试图控制超过50%的网络挖掘哈希率或计算能力。这些攻击者试图阻止新交易获得确认，并使他们停止某些或所有用户之间的付款。它们还能够撤销在控制网络时完成的交易。这意味着他们可以双倍花费硬币。</p></li><li><p><strong>什么是RAS算法</strong></p><p>RSA算法也被称为非对称密码算法，它对两个不同的密钥（即公共密钥和私有密钥）起作用。公共密钥可以与任何人共享，并且私有密钥必须保密。公有密钥可以与任何人共享，而私有密钥必须保密。</p><p>该算法是用于签名数据和加密的第一个算法。它最广泛运用于保护敏感数据。</p></li><li><p><strong>RSA会受到攻击吗</strong></p><p>RAS可能会遭到攻击。通常，有两种攻击RSA的方法：</p><ul><li>蛮力：包括所有潜在的秘密密钥。</li><li>数学攻击：在这种情况下，需要使用不同的技术来近似地计算两个素数的乘积。</li></ul></li><li><p><strong>什么是双重支出</strong></p><p>双倍支出被认为是数字现金计划的潜在缺陷，因为多次使用相同的数字令牌。令牌通常由可以轻松克隆的数字文件组成。比特币用户通过在区块链上付款时等待确认来保护自己免受双重支出欺诈；随着确认的增加，交易变得不可逆转。</p></li><li><p><strong>什么是盲目签名</strong></p><p>盲目签名是密码术中数字签名的一种形式，其中消息的内容在签名或者考虑之前是不可见的。它主要用于作者和签名方不同的隐私相关协议中，这是一种经过验证的方法。</p></li><li><p><strong>区块链中有助于消除安全威胁的关键原则是什么</strong></p><ul><li>连续性计划</li><li>稽核</li><li>确保测试和类似方法</li><li>数据库安全</li><li>保护应用程序</li><li>数字化劳动力培训</li></ul></li><li><p><strong>权益证明和工作量证明有什么区别</strong></p><ul><li><strong>工作量证明</strong>是区块链中的原始共识算法。它用于确认交易并为链产生新的区块。矿工相互竞争以完成网络上的交易并获得奖励。</li><li><strong>股权证明</strong>使共识机制完全虚拟。在这种情况下，一组节点决定放样其交易验证的加密货币。</li></ul></li><li><p><strong>什么是默克尔树，它在区块链中的重要性是什么</strong></p><p>Merkle树也称为哈希树，主要由以太坊和比特币使用。区块链中的Merkle树的重要性在于，<strong>如果有人想验证某个区块中的特定交易，他们可以下载区块头链，而不必下载每个交易和每个区块</strong>。</p><p>默克尔树在区块链技术中起着重要作用。它描述了由各种数据块组成的数据结构。它还通过提供整个交易集的数字指纹来汇总一个块中的所有交易。它可以对大量数据进行有效且安全的内容验证。</p></li><li><p><strong>什么是秘密共享</strong></p><p>秘密共享是用于在区块链中提供数据安全性的主要方法之一。这种方法将个人信息或机密信息分为不同的单元，然后将其发送给网络上的用户。原始信息共享给分配了秘密共享的参与者。</p></li><li><p><strong>什么是安全策略</strong></p><p>安全策略是一个正式且简短的计划，其中包含组织的目标，目的和信息安全程序。简而言之，它定义了确切地需要保护免受威胁的条件以及在威胁发生时如何处理情况。</p></li><li><p><strong>为什么区块链需要硬币或者代币</strong></p><p>令牌/代币被视为是交换媒介。它们是内置的数字资产，可在区块链内执行特定的功能。某人进行交易时，状态会发生变化，coin会从一个地址转移到另外一个地址。</p></li><li><p><strong>什么是采矿</strong></p><p>挖掘是通过向网络提供工作证明来向大型分布式公共分类账添加交易的过程，即生成的区块是有效的。它还将新硬币添加到生成的块中。</p></li><li><p><strong>脱链交易和链上交易有什么不同</strong></p><p><strong>链上交易</strong>：这些交易在区块链上可用，并且对区块链网络上的所有节点都是可见的。包括由一定数量的参与者对交易进行身份验证和确认；<br><strong>链下交易</strong>：这些交易处理区块链外部的值，可以使用多种方法进行。</p></li><li><p><strong>集中式网络，分散式网络和分布式分类账之间有什么区别</strong></p><p><strong>集中式网络</strong>：具有中央机构以方便其操作；<br><strong>分散网络</strong>：分散网络中的连接节点不依赖于单个服务器点，并且每个节点都拥有网络配置的整个副本；<br><strong>分布式分类账</strong>：这是共享分类帐，不受任何中央机构的控制。本质是分散的，并充当金融、法律或电子资产的数据库。</p></li><li><p><strong>区块链生态系统的主要元素是什么</strong></p><ul><li><strong>共享账本</strong>：本质上是分散的，是区块链的核心组成部分；</li><li><strong>节点应用程序</strong>：一种软件，可以让计算机与区块链连接；</li><li><strong>虚拟应用程序</strong>：处理区块链承担的所有任务；</li><li><strong>共识算法</strong>：用于管理区块链规则，通过该规则每个节点都可以得出结论。</li></ul></li><li><p><strong>在保护交易记录时，如何进行风险管理</strong></p><p>基于数据的价值。</p><ul><li>第一种，确定与组织的财务记录相关的威胁和漏洞，并相应地采取正确的对策。</li><li>第二种，注意备份计划。</li><li>第三种，购买新的风险管理软件。</li></ul></li><li><p><strong>在组织中采用区块链技术是否有特定于网络的条件</strong></p><p>使用区块链没有特定的网络条件。但是，该网络必须是特定协议下的对等网络。</p></li><li><p><strong>区块链有哪些框架</strong></p><ul><li>Hyperledger Fabric：是区块链技术的一种实现，旨在作为开发区块链应用程序或解决方案的基础。</li><li>Hyperledger Iroha：是一个分布式分类帐项目，旨在简化并易于整合到需要分布式分类帐技术的基础设施项目中。</li><li>Chain：Chain Core 的基础设施使企业能够在许可网络上发布和转移金融资产，仅允许授权和识别的实体成为区块链网络的一部分。</li><li>IOTA：IOTA的分类帐非常适合需要小额支付和连接设备的场景。</li><li>以太坊：是一个运行智能合约的去中心化平台：完全按照设定程序运行的应用程序，不涉及任何停机、审查、欺诈或第三方干扰。</li><li>Libra：Facebook推出的区块链框架。</li></ul></li><li><p><strong>如何在保证所有人都可以访问的情况下防止篡改</strong></p><p>区块链主要是依靠加密技术来保障数据的安全，主要使用到了加密哈希函数。</p><p>哈希算法是无论输入的大小如何，输出始终是相同的字节。但如果输入发生变化，输出将完全不相同。只要输入不变，则不管运行多少次哈希函数，输出的哈希值都是始终相同的。</p><p>在区块链中，输出值（即哈希）是数据块的唯一标识符。每个区块的哈希是相对于前一个区块的哈希生成的。区块的哈希值是由其所包含的哈希函数决定的，任何数据的改变都会更改哈希值。所以，该区块的哈希值是由所包含的数据和前一区块的哈希值决定的。这就确保了区块链的安全性和不可篡改性。</p></li><li><p><strong>描述一下从交易发出到交易上链，以及如何实现共识</strong></p><p>区块“链”的链，包含“<strong>数据链</strong>”和“<strong>节点链</strong>”。“数据链”指用链式结构组织区块数据，构成数据校验和追溯的链条；“节点链”指多个节点通过网络连接在一起，互相共享信息，其中的共识节点则联合执行共识算法，产生并确认区块。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/2uz8cQTtSWNUqRx.png" alt=""></p><p>交易“上链”的简要过程如下：</p><ol><li><p>记账者们收录交易，按链式数据结构打包成“区块”。</p></li><li><p>共识算法驱动大家验证新区块里的交易，确保计算出一致的结果。</p></li><li><p>数据被广播到所有节点，稳妥存储下来，每个节点都会存储一个完整的数据副本。</p></li></ol><p>交易一旦“上链”，则意味着得到完整执行，达成了“分布式事务性”，即永久可见且无法更改。</p><p>“上链”意味着“<strong>共识</strong>”和“<strong>存储</strong>”，两者缺一不可。交易不经过共识，则不能保证一致性和正确性，无法被链上所有参与者接受；共识后的数据不被多方存储，意味着数据有可能丢失或被单方篡改，更谈不上冗余可用。</p><p>除此之外，如果仅仅是调用接口查询一下，没有改变任何链上数据，也不需要进行共识确认，则不算“上链”。</p><hr><p>区块链是通过共识算法来让不同的节点之间达成共识。例如PoW、PoS等。</p></li><li><p><strong>区块链有哪些应用场景</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Algorithm)</title>
      <link href="/2020/06/06/Interview-Review(Algorithm)/"/>
      <url>/2020/06/06/Interview-Review(Algorithm)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的算法部分。</p><a id="more"></a><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><h3 id="模型评估方法"><a href="#模型评估方法" class="headerlink" title="模型评估方法"></a>模型评估方法</h3><ol><li><p>Accuracy作为指标有哪些局限性</p><p> 准确率的定义是：分类正确的样本占总样本个数的比例，$Accuracy = \frac{n_{correct}}{n_{total}}$。但是此指标存在以下缺陷：</p><p> 当正负样本非常不均衡时，占比大的类别就成为了影响准确率的主要因素，比如负样本占90%时，即使把所有样本都预测为负样本，也可以轻松获得90%的准确率，而这样的准确率是没有意义的，不足以说明分类器的好坏。</p></li><li><p>ROC曲线和PR曲线各是什么</p></li><li><p>编程实现AUC的计算，复杂度是多少</p></li><li>AUC指标有什么特点？放缩结果对AUC是否有影响</li><li>余弦距离与欧氏距离有什么特点</li></ol><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol><li><p>如何划分训练集？如何选择验证集？</p><p> 有以下几种不同的方法划分训练集与验证集：</p><ul><li><p>留出法：</p><ol><li>把数据集划分成互不相交的两部分，一部分作为训练集，一部分作为测试集；</li><li>保持数据的分布大致一致，类似分层抽样；</li><li>训练集数据所占比例应该为2/3或4/5左右</li><li>为了保证随机性，将数据集多次随机划分为训练集和测试集，然后再对多次划分的结果去平均</li></ol></li><li><p>k折交叉验证法：</p><ol><li>将数据集随机分为互斥的k个子集，为保证随机性，使用p次随机划分取平均；</li><li>将k个子集随机分为k-1个组，剩下一个为另一组，有k种分法；</li><li>在每一种方法的分组结果中，那个k-1个子集的组都作为训练集，剩下的一个组作为测试集，这样就产生了k次预测，并对其取平均；</li><li>这种方法称为p次k折交叉验证，一般k取10</li></ol></li><li><p>自助法：</p><ol><li>当样本量足够时，使用自助法不如使用留出法和交叉验证法，因为无法满足数据分布一致。而如果样本量较小，无法划分，就可以使用自助法；</li><li>每次随机从数据集中抽取一个样本，然后再放回（可能会被重复抽出），m次之后会得到有m个样本的数据集，将其作为训练集；</li><li>始终没有抽到的样本的比例按概率算约是36.8%，这也保证了训练集占比大概在2/3左右</li></ol></li></ul></li><li><p>什么是偏差和方差？</p></li><li><p>什么是过拟合？在深度学习中，解决过拟合的方法有哪些？</p><p> 过拟合（overfitting）是指在模型参数拟合过程中的问题。由于训练数据包含了抽样误差，而训练时，复杂的模型将抽样的误差也考虑在内。</p><p> 过拟合具体的表现就是最终模型在<strong>训练集</strong>上效果很好，但<strong>测试集</strong>上效果很差。模型的泛化能力弱。</p><p> 产生过拟合的原因有：</p><ul><li>样本方面的原因。样本数量太少或者抽出的样本数据不能有效地代表场景；</li><li>样本里的噪声数据干扰过大，使得模型过分地记住了噪声特征，反而忽略了真实的输入输出间的关系；</li><li><p>参数太多以及模型复杂度高；</p><p>降低过拟合的方法有：</p></li><li><p>正则化：可以使用L0正则化、L1正则化或L2正则化，机器学习中一般采用L2正则化；</p></li><li>dropout：可以随机地，以一定的概率让一部分神经元失活或者丢弃；</li><li>batch normalization：BN在训练某层时，会对每一个batch数据都进行标准化或者叫归一化（normalization）处理，使得输出的规范呈正态分布；</li><li>early stopping：当随着模型的能力提升，训练集的误差会先减小后增大，所以可以提前终止算法缓解过拟合的现象（例如决策树的预剪枝方法）；</li><li>重新清洗数据：有可能是因为数据不纯导致的，所以需要重新清洗数据；</li><li>Data expending：增大数据的训练量。过拟合有可能是因为训练集的数据量太小导致的，或者训练数据占总数据的比例太小导致的；</li></ul></li><li><p>深度模型参数调整的一般方法论</p></li></ol><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li><p>简述了解的优化器</p><ol><li><p>SGD(Stochastic Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J\left(\theta ; x^{(i)} ; y^{(i)}\right)$</p><p> SGD随机梯度下降参数的更新原则是<strong>一条数据都可以对参数进行一次更新</strong>。其它的优化器都是在这个优化器的基础上改善得来的。</p><p> 优点：参数的更新速度快；</p><p> 缺点：由于每次参数更新时采用的数据量小，造成梯度更新时的震荡幅度较大，但是大多数情况是向着梯度较小的方向；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> data:</span><br><span class="line">        params_grad = eval_gradient(loss_function, example, params)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p> <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/25/tpQUgK.png" alt=""></p><p> 从上图可以看出，SGD的噪音较多，不是每次迭代都向着整体最优化方向。所以虽然训练速度快，但是准确率下降，并不是<strong>全局最优</strong>。</p></li><li><p>BGD(Batch Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J(\theta)$</p><p> BGD批量梯度下降的参数更新原则是：<strong>所有数据</strong>都参与梯度的每一次更新。</p><p> 优点：因为每次参数更新时采用的数据量都非常大，所以梯度更新时比较平滑；</p><p> 缺点：由于参数更新时需要的数据量大，所以更新的速度非常慢；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    params_grad = eval_gradient(loss_function, example, params)</span><br><span class="line">    params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure></li><li><p>MBGD(Mini-Batch Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J\left(\theta ; x^{(i: i+n)} ; y^{(i: i+n)}\right)$</p><p> MBGD是每一次利用一小批样本，即<strong>n个样本</strong>进行计算，这样就可以<strong>降低参数更新时的方差，收敛更稳定</strong>。</p><p> 优点：相比SGD，由于参与梯度更新的数据量大，所以梯度更新时较为平滑；相比BGD，参与梯度更新的数据量小，参数更新速度会更快一些。</p><p> 缺点：</p><ol><li>如果数据是稀疏的，希望对出现频率低的特征进行更大的更，learning_rate会随着更新的次数逐渐变小；</li><li><p>不能保证很好的收敛性，learning_rate如果选择得太小，收敛速度会很慢，如果太大，loss_function就会在极小值处不停地震荡甚至偏离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> get_batches(data, batch_size=n):</span><br><span class="line">        params_grad = eval_gradient(loss_function, batch, patams)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p>这里的<code>batch_size=n</code>的n一般取值在50~256之间。</p></li></ol></li><li><p>Momentum</p><p> $v_{n+1}=\gamma v_{n}+\eta \theta J(\theta)$</p><p> $\theta^{n+1}=\theta^{n}-v_{n+1}$</p><p> Momenntum通过引入$\gamma v_{n}$，加速SGD，并且抑制震荡。$\gamma$一般取值为0.9左右，</p><p> 优点：因为当我们将一个小球从山上滚下来时，没有阻力的话，它的动量就会越来越大，但是如果遇到了阻力，速度就会变小。所以加入了动量，**可以使得梯度方向不变的维度速度变快，梯度方向有所改变的维度上的更新速度变慢，这样就可以加快收敛并且减小震荡。</p><p> 缺点：当梯度方向改变时，梯度更新速度不能及时减小导致适应性差。</p></li><li><p>Adagrad(Adaptive gradient algorithm)</p><p> Adagrad解决了不能根据参数重要性而对不同参数进行不同程度更新的问题。它的参数更新原则是：对低频的参数做较大的更新，对高频的参数做较小的更新。一般超参数$\eta$取值0.01。</p><p> $\theta_{t+1, i}=\theta_{t, i}-\frac{\eta}{\sqrt{G_{t, i i}+\epsilon}} \cdot g_{t, i}$</p><p> 其中g是t时刻时参数$\theta_i$的梯度。</p><p> $g_{t, i}=\nabla_{\theta} J\left(\theta_{i}\right)$</p><p> 优点：对于稀疏的数据它的表现很好，很好地提高了SGD的鲁棒性。</p><p> 缺点：它的缺点是分母会不断的积累，这样学习率就会收缩最终会变得非常小。</p></li><li><p>Adadelta</p><p> Adadelta解决的就是Adagrad的缺点，即分母不断积累，导致学习率收缩变得非常小的问题。</p><p> Adadelta的参数更新原则就是和Adagrad相比，将分母的$G_{t, i i}$换成了过去的梯度平方的衰减平均值，指数衰减平均值。</p><p> $\Delta \theta_{t}=-\frac{\eta}{\sqrt{E\left[g^{2}\right]_{t}}+\epsilon} g_{t}$</p></li><li><p>RMSprop</p><p> 同样是为了解决Adagrad的学习率急剧下降的问题。参数更新原则同样是使用指数加权平均。</p><p> $E\left[g^{2}\right]_{t}=0.9 E\left[g^{2}\right]_{t-1}+0.1 g_{t}^{2}$</p><p> $\theta_{t+1}=\theta_{t}-\frac{\eta}{\sqrt{E\left[g_{t}^{2}\right]+\epsilon}} g_{t}$</p><p> 超参数$\gamma$为0.9，学习率$\eta$为0.001。</p></li><li><p>Adam(Adaptive Moment Estimation)</p><p> Adam相当于RMSprop+Momentum。</p></li></ol></li><li><p>常用的损失函数有哪些，分别适用于场景</p><p> 损失函数是用来<strong>估量模型的预测值$f(x)$与真实值Y的不一致程度</strong>。它是一个非负实值函数，通常使用$L(Y, f(x))$来表示。<strong>损失函数越小，模型的鲁棒性就越好</strong>。</p><ul><li><p>LogLoss对数损失函数</p><p>  可以适用于<strong>逻辑回归，交叉熵损失</strong>等。$\log$损失函数的标准形式是：</p><p>  $L(Y, P(Y | X))=-\log P(Y | X)$</p><p>  softmax使用的是<strong>交叉熵损失函数</strong>，binary_crossentropy使用的是<strong>二分类交叉熵损失函数</strong>，categorical_crossentropy使用的是<strong>多分类交叉熵损失函数</strong>。</p></li><li><p>平方损失函数</p><p>  可以适用于<strong>最小二乘法</strong>等。平方损失函数的标准形式如下：</p><p>  $L(Y, f(X))=(Y-f(X))^{2}$</p><p>  在实际应用中，通常使用均方差MSE作为一项衡量指标，公式如下：</p><p>  $M S E=\frac{1}{n} \sum_{i=1}^{n}\left(\tilde{Y}_{i}-Y_{i}\right)^{2}$</p></li><li><p>指数损失函数</p><p>  可以使用于Adaboost算法。</p></li><li><p>Hinge损失函数</p><p>  在机器学习算法中，hinge损失函数与SVM是息息相关的。其标准形式是：</p><p>  $L(y)=\max (0,1-y \tilde{y}), y=\pm 1$</p></li><li><p>其它损失函数</p><p>  0-1损失函数：$L(Y, f(X))=\left\{\begin{array}{ll}</p><pre><code>          1, &amp; Y \neq f(X) \\          0, &amp; y=f(X)          \end{array}\right.$</code></pre><p>  绝对值损失函数：$L(Y, f(X))=|Y-f(X)|$</p></li><li><p>Keras/Tensorflow中常用的cost function：</p><ul><li>mean_squared_error或者MSE</li><li>mean_absolute_error或者MAE</li><li>mean_absolute_percentage_error或者MAPE</li><li>mean_squared_logarithmic_error或者MSLE</li><li>squared_hinge</li><li>hinge</li><li>categorical_hinge</li><li>binary_crossentropy</li><li>logcosh</li><li>categorical_crossentropy</li></ul></li></ul></li><li><p>梯度下降与牛顿法、拟牛顿法的异同</p></li><li><p>L1和L2正则分别有什么特点？为什么L1更稀疏</p></li><li><p>如何提高小型网络的精度</p></li></ol><h3 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h3><ol><li>用一层隐藏层的神经网络，以ReLU作为激活函数，MSE作为损失函数推导反向传播</li><li>NN的权重参数能否初始化为0</li><li>什么是梯度消失和梯度爆炸，梯度爆炸的解决方法</li><li>常用的激活函数和导数</li><li>ReLU的优点和局限性，改进方法是什么</li><li>sigmoid和tanh为什么会导致梯度消失</li><li>相比sigmoid激活函数，ReLU激活函数有什么优势</li><li>一个隐藏层需要多少个节点能实现包含n元输入的任意布尔函数</li><li>多个隐藏层实现包含n元输入的任意布尔函数，需要多少个节点和网络层</li><li>Dropout为什么能够防止过拟合</li><li>Dropout和BN在前向传播和反向传播阶段的区别</li><li>解释批量归一化的原理</li><li>什么是反卷积，有哪些用途</li></ol><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><ol><li>给定卷积核的尺寸，特征图大小的计算方法</li><li>网络容量的计算方法</li><li>共享参数有什么优点</li><li>常用的池化操作有哪些，有什么特点，池化层有什么作用</li><li>CNN如何用于文本分类</li><li>ResNet提出的背景和核心理论是什么</li><li>空洞卷积是什么？有什么应用场景，作用是什么</li></ol><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><ol><li>简述RNN，LSTM，GRU的区别和联系</li><li>画出LSTM的结构图，写出公式</li><li>RNN的梯度消失问题，如何解决</li><li>LSTM中是否可以用ReLU作为激活函数</li><li>LSTM各个门分别使用什么作为激活函数</li><li>简述seq2seq模型</li><li>seq2seq在解码的时候有哪些方法</li><li>注意力机制是什么</li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>样本不均衡如何处理（如何解决不平衡数据集的分类问题）</p><p> 样本不均衡是指不同类别样本的比例相差悬殊，就会对算法的学习过程造成重大的干扰。例如，有1000个样本，只有5个正样本，995个负样本，那么算法把所有的样本都预测为负样本，精度也能达到99.5%。虽然精度很高，但是没有任何意义。</p><p> 解决方法有：</p><ul><li><p>欠采样，减少数量较多的那一类的样本的数量，使得正负样本的比例均衡。</p><p>  欠采样又分为随机欠采样、EasyEnsemble和BalanceCascade以及基于KNN欠采样。</p><ul><li>随机欠采样是指随机从多数类样本中抽取一部分数据进行删除。缺点就是未考虑到样本的分布情况，而采样过程又具有很大的随机性，可能会误删多数类样本中的一些重要信息。</li><li>EasyEnsemble是通过从多数的那一类样本中<strong>有放回</strong>的随机抽取一部分样本生成多个子数据集，将每个子集与少数类数据联合起来进行训练生成多个模型，然后综合多个模型的结果进行判断。方法和随机森林的原理很相似。</li><li>BalanceCascade是通过一次随机欠采样产生训练集，训练一个分类器，对于那些分类正确的多数类的样本不放回，然后剩下的多数类样本再次进行欠采样产生第二个训练器，训练第二个分类器，同样进行操作，以此类推，直到满足某个停止条件。最终的模型也是多个分类器的组合。</li><li>基于KNN欠采样：有四种KNN欠采样的方法。<ul><li>NearMiss-1：选择到最近的三个少数类样本平均距离最小的那些多数类样本</li><li>NearMiss-2：选择到最远的三个少数类样本平均距离最小的那些多数类样本</li><li>NearMiss-3：为每个少数类样本选择给定数目的最近多数类样本，目的是保证每个少数类样本都被一些多数类样本包围</li><li>最远距离：选择到最近的三个少数类样本平均距离最大的那些多数类样本</li></ul></li></ul></li><li><p>过采样，增加数量较少的那一类的样本的数量，使得正负样本的比例均衡。</p><p>  过采样又分为随机过采样、SMOTE算法和Borderline-SMOTE算法以及基于K-means过采样。</p><ul><li>随机过采样是指多次随机从少数类样本中有放回的抽取数据，采取数量大于原有的少数类样本的数量。其中的有一部分数据会出现重复，而重复数据的出现会增大方差造成模型的过拟合。</li><li>SMOTE的全称是Synthetic Minority Oversampling Technique，即合成少数类过采样技术。它是基于随机过采样算法的一种改机方案。SMOTE算法的基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中。</li><li>Borderline-SMOTE算法较SMOTE算法提升的地方是只为那些K近邻中有一半以上多数类样本的少数类样本生成新样本，因为这些样本容易被错分，而在这些少数类样本附近生存人工合成样本，有助于少数类样本的分类正确。而如果少数类样本周围全是多数类样本，这种情况下，这个样本会被认定为噪声样本。</li><li>基于K-means聚类过采样方法是首先分别对正负例进行K-means聚类，聚类之后，对其中较小的蔟进行上面的过采样方法扩充样本数量。然后再进行正负类样本的均衡扩充。</li></ul></li><li><p>不处理样本，样本分类阈值移动。</p></li></ul></li><li><p>什么是生成模型什么是判别模型</p></li><li><p>什么是鞍点问题</p></li><li><p>集成学习的分类？有什么代表性的模型和方法</p></li><li><p>常用的特征筛选方法有哪些</p></li><li><p>文本如何构造特征</p></li><li><p>类别变量如何构造特征</p></li><li><p>连续值变量如何构造特征</p></li><li><p>哪些模型需要对特征进行归一化</p></li><li><p>什么是组合特征？如何处理高维组合特征</p></li></ol><h3 id="处理分类问题常用算法"><a href="#处理分类问题常用算法" class="headerlink" title="处理分类问题常用算法"></a>处理分类问题常用算法</h3><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><ol><li><p>逻辑回归怎么实现多分类</p><p> 我们知道，普通的逻辑回归只能解决二分类问题。要想实现多分类，就要改进逻辑回归。</p><ol><li>第一种方式是One-Vs-All（或者叫One-Vs-Rest）。直接根据每个类别，都建立一个二分类器。带有这个类别的样本标记为1，带有其它样本的标记为0。如果有k个类别，那么最终就得到了k个针对不同标记的普通的逻辑分类器。</li><li>第二种方式是One-Vs-One。让不同类别的数据两两组合训练分类器。</li><li>第三种方式是修改逻辑回归的损失函数，让其适应多分类问题。即softmax回归。</li></ol></li><li><p>交叉熵公式</p></li><li><p>LR公式，LR的推导和损失函数</p></li><li><p>LR与SVM的区别和联系</p><p> 相同点有：</p><ul><li>都是<strong>监督</strong>的分类算法</li><li>都会线性分类算法</li><li><p>都会判别模型</p><p>不同点有：</p></li><li><p>损失函数不同。LR的损失函数是cross entropy：，SVM的损失函数是最大化间隔距离：</p></li><li>SVM不能产生概率，LR可以产生概率</li><li>SVM依赖于数据的测度，而LR不受影响</li><li>SVM自带结构风险最小化，LR是经验风险最小化</li><li>SVM会用核函数而LR一般不用核函数的原因</li></ul></li><li><p>LR和线性回归的区别</p></li><li><p>为什么正则化可以防止过拟合（为什么L1和L2正则化可以降低过拟合）</p></li><li><p>L1正则和L2正则有什么区别</p></li><li><p>L1正则化不可导，怎么求解</p></li><li><p>逻辑回归为什么一般性能差</p></li><li><p>如何使用LR解决非线性问题</p></li></ol><h4 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h4><ol><li>SVM什么时候使用线性核，什么时候使用高斯核</li><li>SVM的作用和基本实现原理</li><li>SVM的硬间隔和软间隔表达式</li><li>SVM使用对偶计算的目的是什么，如何推导出来的，手写推导</li><li>SVM为什么要求解决对偶问题？为什么对偶问题与原问题等价</li><li>SVM的物理意义是什么</li><li>SVM的核函数的选择</li><li>SVM的核函数的作用</li><li>SVM的核函数的原理</li><li>SVM为什么采用间隔最大化（与感知机的区别）</li><li>为什么SVM对缺失数据敏感</li><li>SVM的优缺点</li><li>SVM如何调节惩罚因子C</li><li>如何处理SVM中样本不平衡的问题</li><li>SVM如何处理多分类问题</li><li>SVM对噪声敏感的原因</li><li>如何使用SMO最优化方法求解SVM模型</li><li>SMO算法优化的终止条件是什么</li><li>是否一定存在参数使得SVM的训练误差到0</li></ol><h4 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h4><ol><li>随机森林与SVM的区别</li><li>随机森林不会发生过拟合的原因</li><li>随机森林与梯度提升树（GBDT）的区别</li><li>随机森林是怎么避免ID3算法信息增益的缺点的</li><li>为什么随机森林能降低方差</li></ol><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><ol><li>朴素贝叶斯的要求（前提假设）是？</li><li>朴素贝叶斯算法原理和工作流程</li><li>什么是先验概率和后验概率</li><li>什么是条件概率</li><li>朴素贝叶斯为什么“朴素”</li><li>朴素贝叶斯可以做多分类吗</li><li>什么是朴素贝叶斯中的零概率问题？如何解决</li><li>朴素贝叶斯中概率计算的下溢问题如何解决</li><li>朴素贝叶斯分类器对异常值敏感吗</li><li>朴素贝叶斯对缺失值敏感吗</li><li>朴素贝叶斯有哪几种常用的分类模型</li><li>朴素贝叶斯算法中使用拉普拉斯平滑，拉普拉斯因子的大小如何确定</li><li>为什么说是朴素贝叶斯是高偏差低方差的</li><li>朴素贝叶斯为什么是增量计算</li><li>高度相关的特征对朴素贝叶斯有什么影响</li><li>朴素贝叶斯有什么优缺点</li></ol><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><ol><li>ID3，C4.5和CART三种决策树的区别</li><li>简述决策树的原理</li><li>简述决策树的构建过程</li><li>决策树有哪些划分指标，其区别和联系</li><li>信息增益率有什么优缺点</li><li>如何对决策树进行剪枝操作，为什么要进行剪枝</li><li>树模型如何调参</li><li>树模型如何剪枝</li><li>预剪枝和后剪枝</li><li>简述一下分类树和回归树</li><li>决策树对缺失值如何处理</li><li>如果决策树属性用完了，但仍未对决策树完成划分该怎么办</li><li>如何避免决策树的过拟合</li><li>决策树需要进行归一化处理吗</li><li>与其它模型比较，决策树有哪些优点和缺点</li></ol><h3 id="处理回归问题常用算法"><a href="#处理回归问题常用算法" class="headerlink" title="处理回归问题常用算法"></a>处理回归问题常用算法</h3><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><ol><li>简单介绍一下线性回归的原理（什么是线性回归）</li><li>线性回归的求解方法有哪些</li><li>线性回归为什么用均方差</li></ol><h4 id="普通最小二乘回归"><a href="#普通最小二乘回归" class="headerlink" title="普通最小二乘回归"></a>普通最小二乘回归</h4><ol><li>最小二乘法的推导</li><li>最小二乘法和梯度下降法有哪些区别</li></ol><h4 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h4><ol><li>简述逐步回归算法</li></ol><h4 id="多元自适应回归样条"><a href="#多元自适应回归样条" class="headerlink" title="多元自适应回归样条"></a>多元自适应回归样条</h4><ol><li>简述多元自适应回归样条</li></ol><h3 id="处理聚类问题常用算法"><a href="#处理聚类问题常用算法" class="headerlink" title="处理聚类问题常用算法"></a>处理聚类问题常用算法</h3><h4 id="K均值（基于划分的聚类）"><a href="#K均值（基于划分的聚类）" class="headerlink" title="K均值（基于划分的聚类）"></a>K均值（基于划分的聚类）</h4><ol><li>简述一下K-means算法的原理和工作流程</li><li>K-means有什么缺点</li><li>K值如何确定</li><li>初始点选择方法</li><li>K-means不能处理哪种数据</li><li>K-means如何处理大数据（几十亿）</li><li>K-means与KNN有何不同</li></ol><h4 id="DBSCAN（基于密度的聚类）"><a href="#DBSCAN（基于密度的聚类）" class="headerlink" title="DBSCAN（基于密度的聚类）"></a>DBSCAN（基于密度的聚类）</h4><ol><li>DBSCAN与传统的K-means的不同</li><li>DBSCAN的聚类法原理</li></ol><h4 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h4><h3 id="推荐系统常用算法"><a href="#推荐系统常用算法" class="headerlink" title="推荐系统常用算法"></a>推荐系统常用算法</h3><h4 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h4><ol><li>itemCF与userCF的区别和适用场景</li></ol><h4 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h4><h3 id="模型融合和提升的常用算法"><a href="#模型融合和提升的常用算法" class="headerlink" title="模型融合和提升的常用算法"></a>模型融合和提升的常用算法</h3><h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><h4 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h4><h4 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h4><h4 id="GBRT"><a href="#GBRT" class="headerlink" title="GBRT"></a>GBRT</h4><h4 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h4><h4 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h4><h4 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h4><h3 id="其它重要算法"><a href="#其它重要算法" class="headerlink" title="其它重要算法"></a>其它重要算法</h3><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><ol><li>word2vec的原理</li><li>glove的原理</li><li>fasttext的原理</li><li>了解elmo和bert吗？简述与word embedding的联系与趋避</li></ol><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="搜索回溯"><a href="#搜索回溯" class="headerlink" title="搜索回溯"></a>搜索回溯</h3><ol><li>八皇后，全排列，组合</li><li>重复数字的排列，重复数字的组合</li><li>图的搜索</li><li>A star</li></ol><h3 id="概率题"><a href="#概率题" class="headerlink" title="概率题"></a>概率题</h3><ol><li>用rand7构造rand10</li><li>轮盘赌</li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>编辑距离</li><li>背包问题</li><li>LCS</li><li>备忘录方法</li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>给定字符串是否符合正则表达式</li><li>给定字符串是否是数字</li><li>KMP</li><li>超大数相加</li></ol><h3 id="海量数据"><a href="#海量数据" class="headerlink" title="海量数据"></a>海量数据</h3><ol><li>海量日志的出现最多的K个字符串</li><li>10亿个1-10的数字排序</li><li>trie树</li><li>布隆过滤器</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>算法的几个特征是什么</li><li>算法复杂性的定义，大O、θ、Ω、小o分别表示的含义</li><li>递归算法的定义、递归算法的两个要素</li><li>分治算法的思想</li><li>动态规划算法的两个要素是什么</li><li>贪心算法的思想，贪心算法的两个要素</li><li>回溯法的思想，回溯法中有哪两种典型的模型</li><li>分支限界法思想，有哪两种分支限界法</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(BigData)</title>
      <link href="/2020/06/06/Interview-Review(BigData)/"/>
      <url>/2020/06/06/Interview-Review(BigData)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的大数据部分。</p><a id="more"></a><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><ol><li><p>什么是Hadoop</p><blockquote><p>Hadoop是一个开源软件框架，用于存储大量数据，并发处理/查询在具有多个商用硬件节点的集群上的那些数据。</p></blockquote><p> HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）：HDFS允许以一种分布式和冗余的方式存储大量数据。例如，1024MB可以拆分为16*128MB文件，并存储在Hadoop集群中的8个不同的节点上。每个分裂可以复制3次，以实现容错，以便如果1个节点故障的话，也有备份。</p><p> MapReduce：是一个计算框架（Google三剑客之一：GFS、BigTable、MapReduce）。它以分布式和并行的方式处理大量的数据。例如，当对所有年龄大于18的用户在上面的1024MB文件中查询时，会有8个Map函数并行运行，以在其128MB拆分文件中提取年龄大于18的用户，然后Reduce函数将运行以将所有单独的输出组合成单个最终结果。Map就是拆解，Reduce就是组装，本治就是分治法。</p></li><li><p>正常工作的Hadoop集群中都需要启动哪些进程，作用分别是什么</p><ul><li>NameNode：是HDFS的守护进程，负责记录文件是如何分割成数据块，以及这些数据块分别被存储到哪些数据节点上，它的主要功能是对内存以及IO进行集中管理；</li><li>Secondary NameNode：辅助后台程序，与NameNode进行通信，以便定期保存HDFS元数据的快照；</li><li>DataNode：负责把HDFS数据块读写到本地的文件系统；</li><li>JobTracker：负责分配task，并监控所有运行的task；</li><li>TaskTracker：负责执行具体的task，并与JobTracker进行交互；</li></ul></li><li><p>列举出流行的Hadoop调度器，并简要说明其工作方法</p><p> Hadoop调度器的基本作用就是根据节点资源使用情况和作业的要求，将任务调度到各个节点上执行；</p><p> <strong>调度器需要考虑的因素有三种</strong>：</p><ul><li>作业优先级：作业优先级越高，能够获取到的资源也越多。Hadoop提供了5种作业优先级，分别是<code>VERY_HIGH</code>、<code>HIGH</code>、<code>NORMAL</code>、<code>LOW</code>、<code>VERY_LOW</code>、<code>VERY_LOW</code>，通过<code>mapreduce.job.priority</code>属性来设置。</li><li>作业提交时间：作业提交的时间越早，就越先执行；</li><li><p>作业所在队列的资源限制：调度器可以分为多个队列，不同的产品线放到不同的队列里运行。<strong>不同的队列会设置一个边缘限制</strong>，这样不同的队列就会有自己独立的资源，不会出现抢占和滥用资源的情况。</p><p><strong>自带调度器有三种</strong>：</p></li><li><p>先进先出调度器（FIFO）：</p><p>  FIFO是Hadoop中默认的调度器，也是一种<strong>批处理调度器</strong>。它先按照作业的优先级高低，再按照到达时间的先后选择被执行的作业。</p></li><li><p>容量调度器（Capacity Scheduler）：</p><p>  支持多个队列，每个队列可以配置一定的资源量，每个队列采用FIFO调度策略，<strong>为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定</strong>；</p></li><li><p>公平调度器（Fair Scheduler）：</p><p>  支持多队列多用户，每个队列中的资源量可以配置，<strong>同一队列中的作业公平共享队列中的所有资源</strong>。</p></li></ul></li><li><p><strong>简要说一下Hadoop的MapReduce编程模型</strong></p><p> 首先Map task会从本地文件系统读取数据，转换成key-value形式的键值对集合。使用的是Hadoop内置的数据类型，比如longwritable、text等。然后将键值对集合输入mapper进行业务处理过程，将其转换成需要的key-value再输出。</p><p> 之后会进行一个partition的分区操作，默认使用的是hashpartitioner，可以通过重写hashpartitioner的getpartition方法来自定义分区的规则；</p><p> 之后会对key进行sort排序，grouping分组操作将相同key的value合并分组输出；</p><p> 之后进行combiner归约操作，即一个本地段的reduce预处理，以减小后面shuffle和reducer的工作量；</p><p> reduce task通过网络将各个数据收集进行reduce处理，最后将数据保存或者显示，结束整个job。</p></li><li><p>MapReduce的大致过程：</p><p> MapReduce大致可以分为<strong>input</strong>、<strong>split</strong>、<strong>map</strong>、<strong>shuffle</strong>、<strong>reduce</strong>、<strong>output</strong>六个步骤。</p><ul><li>输入input：输入数据，一般是HDFS上的文件或目录</li><li>拆分split：切割文件，例如将字符串分割成每个单词</li><li>映射map：将拆分的内容转换成key-value形式</li><li>派发shuffle：将key相同的放到一起value是一个序列，这步涉及到数据移动，会将key相同的数据移动到一台机器上</li><li>缩减recude：将同样key的value序列进行计算</li><li>输入output：输出结果</li></ul></li><li><p>为什么要用flume导入HDFS，HDFS的架构是怎么样的</p><p> flume是可以实时地导入数据到hdfs中，当hdfs上的文件达到一个指定大小的时候，就会形成一个文件，超过指定时间的话，也会形成一个文件。</p><p> 文件是存储在DataNode上，NameNode记录着DataNode的元数据信息，而NameNode的元数据信息是存在内存中的。所以，当文件切片很小或者很多的时候，就会卡死。</p></li><li><p>MapReduce程序运行的时候会有什么比较常见的问题</p><p> 比如键值对对任务分配不均匀造成的<strong>数据倾斜</strong>问题。解决的办法是在分区的时候，重新定义分区规则，对于value数据很多的key可以进行拆分、均匀打散等处理，或者是在map端的Combiner中进行数据预处理的操作。</p></li><li><p>Hadoop的性能调优</p><ol><li>从应用角度进行优化：<ol><li>避免不必要的reduce任务</li><li>为job添加一个Combiner</li><li>根据处理数据特征使用最适合和最简洁的Writable类型</li><li>重用Writable类型</li><li>使用StringBuffer而不是String</li></ol></li><li>对Hadoop参数进行调优：<ol><li>关闭不必要的linux服务</li><li>关闭ipv6</li><li>调整文件最大打开数</li><li>修改linux内核参数</li></ol></li><li>从系统实现角度进行调优：从Hadoop实现机制的角度，发现当前Hadoop设计和实现上的缺点，然后进行源码级的修改。</li></ol></li><li><p>HDFS的特点</p><ul><li>处理超大文件</li><li>高容错性，运行在廉价机器上</li><li>横向扩展</li><li>流式数据处理，而不是随机读写（流式数据读取指的是一个文件只能写一次，后面一直追加，所以每次读取只需要从头开始一直往后读即可）</li><li>不支持文件修改，只能追加写入</li><li>对大量的小文件性能不好</li></ul><ol><li>主从架构，有两种角色namenode和datanode。namenode负责管理存储元数据，处理客户端读写请求；datanode存储真正的数据，执行读写操作；</li><li>读流程：客户端访问namenode，验证权限，返回数据具体的datanode的地址，客户端访问datanode读取数据；</li><li>写流程：客户端访问namenode，验证权限并确定文件是否存在，然后先记录到editLog返回输出流对象，客户端最近的一个datanode写数据，每写一个数据块，其余的datanode自己同步</li></ol></li><li><p>YARN的工作原理，简述其工作方法</p><p>YARN全称yet another resource negotiator，即另一种资源调度器。</p><p><strong>ResourceManager</strong>：</p><p>ResourceManager有为所有应用程序仲裁资源的权限的功能，用来代替JobTracker，主要由schedule和ApplicationManager组成。</p><p>schedule通过container来分配资源，封装了磁盘、内存、CPU等资源。</p><p>ApplicationManager负责接收作业的提交，并申请第一个container来执行作业的ApplicationMaster，并提供失败时重启ApplicationManager的container，而作业的ApplicationMaster向schedule申请资源。</p><p><strong>NodeManager</strong>：</p><p>NodeManager是YARN在每台机器上的代理，负责启动并管理节点上的container，container执行具体的由ApplicationMaster划分的任务。</p><p><strong>整体流程</strong>：</p><ol><li>客户端向ResourceManager的ApplicationManager提交程序；</li><li>ResourceManager的ApplicationManager在NodeManager启动第一个container执行ApplicationManager</li><li>ApplicationManager拆分程序，划分成一个个的task，这些task可以在container上运行，然后向ResourceManager申请资源执行task，并向ResourceManager发送心跳；</li><li>申请到container后，ApplicationMaster会和NodeManager通信，并将task发送到对应的container执行，task会向ApplicationMaster发送心跳；</li><li>程序执行完成，ApplicationMaster会向ResourceManager注销并释放资源；</li></ol></li></ol><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ol><li><p>Spark有几种部署模式，每种模式的特点</p><ul><li>local模式（本地模式）：运行在一台机器上，常用于本地开发测试，本地模式还分为local单线程和local-cluster多线程；</li><li>standalone模式（集群模式）：典型的Master/Slave模式，起初Master是有单点故障的；</li><li>yarn模式（集群模式）：运行在yarn资源管理器框架之上，由yarn负责资源管理，Spark负责任务调度和计算；</li><li>mesos模式（集群模式）：运行在mesos资源管理器框架之上，由mesos负责资源管理，Spark负责任务调度和计算；</li></ul></li><li><p>Spark为什么比MapReduce快（Run workloads 100x faster）</p><ul><li><p>Spark是基于内存计算的，减少了低效的磁盘交互；而MapReduce是基于磁盘的迭代。</p><ul><li>MapReduce的设计：中间结果保存在文件中，提高了可靠性，减少了内存占用，但是牺牲了性能；</li><li>Spark的设计：数据在内存中进行交换，要更快一些，所以性能要比MapReduce好，但是内存的可靠性不如磁盘；</li></ul></li><li><p>高效的调度算法，基于DAG；</p></li><li>容错机制Linage；</li></ul></li><li><p>Spark有哪些组件</p><ul><li><code>master</code>：管理集群和节点，不参与计算</li><li><code>worker</code>：计算节点，进程本身不参与计算</li><li><code>driver</code>：运行程序的Main方法，创建spark context对象</li><li><code>spark context</code>：控制整个application的生命周期，包括dag sheduler和task scheduler等组件</li><li><code>client</code>：用户提交程序的入口</li></ul></li><li><p>Hadoop和Spark的shuffle相同和差异</p><ul><li>高层面：两者并没有太大的差别，都是将<code>mapper</code>的输出进行<code>partition</code>，不同的是<code>partition</code>是送到不同的<code>reducer</code>里。</li><li>低层面：Hadoop是<code>sort-based</code>，在进入<code>combine()</code>和<code>reduce()</code>之后，<strong>必须先排序</strong>；Spark默认是<code>hash-based</code>，通常使用HashMap来对shuffle来的数据进行汇总，<strong>不需要提前排序</strong>；</li><li>实现角度：Hadoop MapReduce需要将处理流程划分成明显的几个部分：<code>map</code>、<code>split</code>、<code>merge</code>、<code>shuffle</code>、<code>sort</code>、<code>recude</code>，而Spark没有这样功能明确的阶段；</li></ul></li><li><p>RDD宽依赖和窄依赖</p><ul><li>窄依赖：每一个parent RDD的Partition最多被子RDD的一个Partition使用（即<strong>一父一子</strong>）</li><li>宽依赖：多个子RDD的Partition会依赖同一个parent RDD的Partition（<strong>一父多子</strong>）</li></ul></li><li><p>cache和pesist的区别</p><p> cache和persist都是用于缓存RDD，避免重复计算，<code>.cache()==.persist(MEMORY_ONLY)</code></p></li><li><p>RDD有哪些缺陷</p><ul><li>不支持细粒度的写和更新操作：Spark写数据是粗粒度的，就是批量写入数据，但是读数据可以细粒度</li><li>不支持增量迭代计算（Flink）支持</li></ul></li><li><p>RDD有哪几种操作类型</p></li><li><p>Spark的工作机制</p></li><li><p>Spark的优化怎么做</p></li><li><p>Spark中数据的位置是被谁管理的</p></li><li><p>Spark的数据本地性有哪几种</p></li><li><p>Spark的常用算子区别</p></li><li><p>Transformation和action是什么，有什么区别，举出一些常用方法</p></li><li><p>Spark on Yarn模式有哪些优点</p></li><li><p>描述Yarn执行一个任务的过程</p></li></ol><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ol><li>Storm的工作原理是什么</li><li>流的模式是什么？默认是什么？</li><li>Storm Group分类</li><li>Storm的特点和特性是什么<ul><li>编程简单：开发人员只需要关注应用逻辑，而且跟Hadoop类似，Storm提供的编程语言也很简单</li><li>高性能，低延迟：可以应用于广告搜索引擎等要求实时响应的场景</li><li>分布式：可以轻松应对数据量大，单机搞不定的场景</li><li>可拓展：随着业务的发展，数据量和计算量越来越大，系统可水平扩展</li><li>容错：单个节点挂了是不影响应用的</li><li>消息不丢失：保证了消息处理</li></ul></li><li>Storm组件有哪些</li></ol><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><blockquote><p>Kafka是一种高吞吐量的分布式发布订阅消息系统，它可以处理消费者规模的网站中的所有动作流数据。</p></blockquote><ol><li><p>Kafka的设计是怎么样的</p><p> <img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/n6oUKCm4tZrGTv3.png" alt="Kafka的设计结构"></p><ol><li>Kafka是可以配合zookeeper集群进行工作的</li><li>Kafka集群中有若干个Broker，<strong>其中一个是leader，其它的是follower</strong></li><li>Consumer外面还包裹了一层Consumer Group</li></ol></li><li><p>数据传输的事物定义有哪三种</p></li><li>Kafka判断一个节点是否还活着的两个条件</li><li>Kafka与传统消息系统之间的三个关键区别</li><li>Kafka高消息文件存储设计的特点</li><li><p>Kafka有哪几个组件</p><ul><li>Broker：Kafka集群包含一个或者多个服务器，这种服务器被称为broker</li><li>Topic：每条发布到Kafka集群的消息都有一个类别，类别就被称为是topic（物理上topic是分开存储的）</li><li>Partition：是一个物理上的概念，每个Topic包含一个或者多个Partition</li><li>Producer：负责发布消息到Kafka broker上</li><li>Consumer：消息消费者，向Kafka broker读取消息的客户端</li><li>Consumer Group：每个Consumer都属于一个特性的Consumer Group</li></ul></li><li><p>Kafka的特性</p><ul><li>以时间复杂度为$O(1)$的方式提供消息持久化能力，即使TB以上的数据也能保证常数的时间复杂度的访问性能</li><li>高吞吐率：即使在廉价的机器上也能支持高吞吐率的传输</li><li>支持Kafka Server间的消息分区以及分布式消费，同时保证每个Partition内的消息<strong>顺序传输</strong></li><li>Scale out：支持在线水平扩展</li></ul></li><li><p>Kafka的应用场景</p><ul><li>构建可在系统或者应用程序之间可靠获取数据的<strong>实时流</strong>数据管道</li><li>构建实时流应用程序，可以转换或者响应数据流</li></ul></li><li><p>Kafka四个核心api</p><ul><li>Producer：使用Producer API发布消息到1个或者多个topic中</li><li>Consumer：应用程序使用Consumer API订阅一个或者多个topic，并处理产生的消息</li><li>Streams：使用Streams API充当一个流处理器，从1个或多个topic消息输入流，产生一个输出流到1个或者多个topic，有效地<strong>将输入流转化为输出流</strong></li><li>Connector：允许构建或者运行可重复使用的生产者或者消费者，将topic连接到现有的应用程序或者数据系统</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/OltHomjCFWpG2Sk.png" alt="Kafka的四个核心API"></p></li><li><p>Kafka分区的概念</p><p>大多数消息系统，在同一个topic下的消息，都会存储在一个队列中。而分区的概念就是**把这个队列划分为若干个小的队列，每一个小的队列就是一个分区。</p><p>创建分区的好处就是可以让多个消费者同时消费，这样速度就大大提升。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/hvbTipcM2yne87j.png" alt="Kafka分区的概念"></p><p>分区有以下几个特征：</p><ul><li>一个partition只能被同组的一个consumer对象消费</li><li>同一个组里的consumer可以消费多个partition</li><li>消费效率最高的情况是partition和consumer的数量相等，这样可以保证每个consumer都专职负责一个partition</li><li>consumer数量是不能大于partition的数量的，不然就会有consumer闲置</li><li>consumer group是一个订阅者的集群，其中的每个consumer负责自己消费的分区</li></ul><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/N7KpFanochzJBM5.png" alt="Kafka分区的特征"></p></li></ol><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><blockquote><p>ZooKeeper是一个经典的分布式数据一致性解决方案，致力于为分布式应用提供一个高性能、高可用，且具有严格顺序访问控制能力的分布式协调服务。<br>分布式应用程序可以基于ZooKeeper实现数据发布与订阅、负责均衡、命名服务、分布式协调与通知、集群管理、Leader选举、分布式锁、分布式队列等功能。</p></blockquote><ol><li><p>ZooKeeper都要哪些功能</p><ol><li><p>统一命名服务（naming）</p><p> 分布式应用中，通常需要一套完整的命名规则，既能够产生唯一的命名便于记住，又不需要将名称关联到特定的资源上，类似数据库中产生的唯一的主键。</p></li><li><p>配置管理</p><p> 配置信息可以交个Zookeeper来管理，将配置信息保存在Zookeeper中的某个目录节点中，然后将所有需要修改的应用监控配置信息的状态。一旦配置信息发生变化，每台应用就会收到Zookeeper的通知，获取新的配置信息应用到系统中。</p></li><li><p>集群管理</p><p> Zookeeper不仅能够帮助维护当前的集群中机器的服务状态，而且能够帮助选出一个Master来管理集群。</p></li><li><p>对列管理</p><ul><li>当一个队列的成员都聚齐时，这个队列才可用，否则就需要一直等待，这就是<strong>同步队列</strong>。</li><li>队列按照FIFO方式进行出队和入队操作，例如实现生产者和消费者模型。</li></ul></li></ol></li><li><p>ZooKeeper怎么保证主从节点的状态同步</p></li><li>ZooKeeper有几种部署模式<ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群上运行；</li><li>伪集群部署：一台集群启动多个ZooKeeper实例运行</li></ul></li><li>ZooKeeper的通知机制</li><li>集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗</li><li>两阶段提交和三阶段提交的过程</li><li>ZooKeeper宕机如何处理</li><li>获得分布式锁的流程</li><li>ZooKeeper队列管理</li><li>ZooKeeper下Server的工作状态</li><li>ZooKeeper是如何保证事务的顺序一致性的</li><li>ZooKeeper负载均衡和nginx负载均衡区别</li></ol><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><ol><li><p>Hive中存放的是什么</p><p> Hive中存放的是<strong>表</strong>，存的是和hdfs的映射关系，hive是逻辑上的数据仓库，实际操作的是HDFS上的文件，HQL是用sql语法编写的MapReduce程序。</p></li><li><p>Hive与关系型数据库的关系</p><p> 没有任何关系，hive是数据仓库弥，不能和数据库一样进行实时的CRUD操作，是一次写入多次读取的操作。</p></li><li><p>Hive表关联查询，如何解决数据倾斜的问题</p><p> <strong>倾斜原因</strong>：map输出数据，按照key的Hash值分配到reduce中。由于key分布不均匀、业务数据本身的特性、建表时考虑不周等等原因造成的reduce上的数据量差异过大。</p><ul><li>key分布不均匀</li><li>业务数据本身的特性</li><li>建表时考虑不周</li><li><p>某些SQL语句本身就会有数据倾斜</p><p><strong>解决方案</strong>：</p></li><li><p>参数调节：有数据倾斜的时候进行负载均衡</p></li><li>SQL语句调节：<ul><li>选择<code>join key</code>分布最均匀的表作为驱动表，做好裁剪、filter等操作，以达到两表做<code>join</code>的时候，数据量相对变小的效果</li><li>大表<code>join</code>小表：把空值的key变成一个字符串加上随机数，把倾斜的数据分到不同的reduce上</li><li><code>count distinct</code>大量相同的特殊值</li><li>大小表<code>join</code>：使用<code>map join</code>让小的维度表先进内存，在map端完成reduce。</li></ul></li></ul></li><li><p>Hive的HSQL转换为<code>MapReduce</code>的过程</p><ol><li><strong>SQL Parser</strong>：（<strong>将HQL转换成抽象语法树</strong>）定义SQL的语法规则，完成SQL语法，语法解析，将SQL转化为抽象语法树AST Tree</li><li><strong>Semantic Analyzer</strong>：（<strong>将抽象语法树转换成查询块</strong>）遍历AST Tree，抽象出查询的基本组成单元QueryBlock</li><li><strong>Logical Plan</strong>：（<strong>将查询块转换成逻辑查询计划</strong>）遍历QueryBlock，翻译为执行操作树OperatorTree</li><li><strong>Logical Plan Optimizer</strong>：（<strong>重写逻辑查询计划</strong>）逻辑层优化器进行OperatorTree变换，合并不必要的ReduceSinkOperator，减少shuffle数据量；</li><li><strong>Physical Plan</strong>：（<strong>将逻辑计划转成物理计划</strong>）遍历OperatorTree，也就是翻译为MapReduce任务；</li><li><strong>Logical Plan Optimizer</strong>：物理层优化器进行MapReduce任务的变换，生成最终的执行计划；</li></ol></li><li><p>Hive特点</p><p> Hive是基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张数据库表，并提供完整的sql查询功能，可以将sql语句转换为MapReduce任务进行运行。优点是学习成本低，可以通过类SQL语句快速实现简单的MapReduce统计，无需专门开发MapReduce应用，但是<strong>不支持实时查询</strong>。</p></li><li><p>Hive内部表和外部表的区别</p><ul><li><strong>创建表时</strong>：创建内部表，会将数据移动到数据仓库指向的路径；若创建外部表，仅记录数据所在的路径，不对数据的位置做出任何改变；</li><li><strong>删除表时</strong>：内部表的元数据会和数据一起删除，外部表只是删除数据元数据，不删除数据。</li></ul></li><li><p>Hive底层与数据库的交互原理</p><p> 由于Hive的元数据可能要面临不断地更新、修改和读取操作，所以它显然不适合使用Hadoop文件系统进行存储。所以，目前Hive是将元数据存储在RDBMS中，比如存储在MySQL中。元数据的信息包括：存在的表、表的列、权限和更多信息。</p></li></ol><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><h3 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h3><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><h3 id="Kylin"><a href="#Kylin" class="headerlink" title="Kylin"></a>Kylin</h3><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3><p>布隆过滤器（Bloom Filter）是一个节省空间的概率数据结构，用来测试一个元素是否在一个集合里。它实际上是一个很长的<strong>二进制向量</strong>和<strong>一系列随机映射函数</strong>。相比于传统的List、Set、Map等数据结构，它更高效、占用空间更少，但是缺点是<strong>返回的结果是概率性的，不是确定的</strong>。</p><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/S4tU26X9d7Evpbw.png" alt=""></p><ol><li><p><strong>插入</strong></p><p> 当一个元素要被加入到集合中时，需要通过K个Hash函数将这个元素映射成一个位数组中的K个点，把它们置为1</p></li><li><p><strong>查找</strong></p><p> 当需要查找某个元素时，首先需要判断其是否存在，只要看这些点是不是都是1就可知道集合中是否含有它。如果这些点有任何一个0，都说明被查找的元素不存在；如果都是1，则被检的元素很可能存在。</p></li></ol><h3 id="运用场景"><a href="#运用场景" class="headerlink" title="运用场景"></a>运用场景</h3><ul><li>解决了redis等其它缓存穿透的问题</li><li>判断是否存在该行或者列，以减少对磁盘的访问，提高数据库的访问性能</li><li>分布式数据库BigTable使用了布隆过滤器来查找不存在的行或者列，可以减少磁盘查找的IO次数</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p><strong>优点</strong>：</p><ul><li>节省存储空间</li><li>查找速度快</li></ul><p><strong>缺点</strong>：</p><ul><li>存在误判：因为可能hash之后得到的k个位置都是1，但是要查到的元素并没有在容器中</li><li>删除困难：一个放入的容器中的元素映射到bit数组的k个位置上都是1，所以删除的时候并不能简单地直接设置为0，因为这样会影响其它元素的判断</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(CloudComputing)</title>
      <link href="/2020/06/06/Interview-Review(CloudComputing)/"/>
      <url>/2020/06/06/Interview-Review(CloudComputing)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的云计算部分。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>云计算中弹性与可拓展性的区别是什么<br>可拓展性通过增加资源容量的比例来处理不断增加的工作量。通过使用可拓展性，如果流量引发需求，则体系结构提供随需应变的资源。</p><p>弹性是一种特征，它提供动态调试和退役大量资源容量的概念。它通过资源的需求速度和资源的使用来衡量。</p></li><li>使用云计算的优点<ul><li>数据备份和数据存储</li><li>强大的服务器功能</li><li>提高生产力</li><li>非常划算且节省时间</li></ul></li><li>哪些平台可用于大规模云计算<ul><li>Apache Hadoop</li><li>MapReduce</li></ul></li><li>云计算部署的不同模型<ul><li>私有云</li><li>公共云</li><li>混合云</li><li>社区云</li></ul></li><li>云计算与移动计算有何区别<br>移动计算和云计算在概念上略有相同。移动计算使用云计算的概念。云计算为用户提供他们在移动计算中所需的数据，在远程服务器上运行的应用程序以及为用户提供存储和管理的访问权限。</li><li>用户如何得益于公益计算（Utility Computing）<br>公用计算让用户可以只需要为使用的资源付费。它是由决定从云端部署哪种类型的服务的企业组织管理的一种插件。</li><li>云在安全方面的措施有哪些<ul><li>身份管理：授权应用程序服务</li><li>访问控制：将权限授予用户，用户就可以控制进入到云环境的另一个用户的访问</li><li>验证和授权：只允许通过授权和验证的用户访问数据和应用程序</li></ul></li><li>虚拟化平台在实施云中的主要用途（有何要求）<ul><li>它用于管理服务级别策略</li><li>云操作系统</li><li>虚拟化平台有助于保持后端级别和用户级别概念彼此不同</li></ul></li><li>在使用云计算平台前，用户需要考虑哪些必要的方面<ul><li>合规</li><li>数据丢失</li><li>数据存储</li><li>业务连续性</li><li>正常运行时间</li><li>云计算的数据完整性</li></ul></li><li>开源的云计算平台数据库有哪些<ul><li>MongoDB</li><li>CouchDB</li></ul></li><li>解释软件即服务（SaaS）的不同模式<ul><li>简单的多租户模式：在该模式中，每个用户有独立的资源，与其它用户分开来，是一种高效的模式；</li><li>细粒度的多租户模式：在该模式中，资源由许多租户共享，功能仍然一样；</li></ul></li><li>API在云服务中有何用途<br>API用于云平台，它提供了一种替代方法，无需编写完全成熟的应用程序，它可以在一个或者多个应用程序之间进行通信。</li><li>为云计算部署了哪些不同的数据中心<ul><li>集装箱式数据中心</li><li>低密度数据中心</li></ul></li><li>云计算中有哪些不同的层<ul><li>SaaS：软件即服务，它让用户可以直接访问云应用程序，不必在系统上安装任何东西</li><li>IaaS：基础设施即服务，它从硬件等层面提供了基础设施</li><li>PaaS：平台即服务，它为开发人员提供了云应用程序平台</li></ul></li><li>云服务是什么<br>云服务用来通过互联网，使用网络中的服务器来构建应用程序，它提供了这种便利：不必将云应用程序安装到计算机上，即可直接使用。它还减少了维护和支持使用云服务开发的应用程序的工作。</li><li>云架构具有的好处<ul><li>无需基础设施投入</li><li>适时的基础设施</li><li>更高效地利用资源</li></ul></li><li>云架构有别于传统架构的特点<ul><li>按照需求，云架构满足硬件要求</li><li>云架构能够按需增减资源</li><li>云架构能够管理和处理动态工作负载，顺畅无阻</li></ul></li><li>在云架构中，必须的不同部分有哪些<ul><li>云入站</li><li>处理器速度</li><li>云存储服务</li><li>云提供商服务</li><li>云间通信</li></ul></li><li>在云架构中，经历的不同阶段有哪些<ul><li>启动阶段</li><li>监测阶段</li><li>关闭阶段</li><li>清理阶段</li></ul></li></ol><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><ol><li>Kubernetes与Docker Swarm的区别如何</li><li>Kubernetes与Docker有什么关系</li><li>在主机和容器上部署应用程序有什么区别</li><li>什么是Container Orchestration</li><li>Container Orchestration需要什么</li><li>Kubernetes Architecture的不同组件有哪些</li><li>Kubernetes包含几个组件，各个组件的功能是什么，组件之间是如何交互的</li><li>k8s中的pod内几个容器之间的关系是什么</li><li>一个经典pod的完整生命周期</li><li>容器编排的价值和好处是什么</li><li>如何在 Kubernetes 中实现负载均衡</li></ol><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ol><li>OpenStack及其主要组件</li><li>什么服务通常在控制节点上运行</li><li>什么服务通常在计算节点上运行</li><li>计算节点上虚拟机的默认地址是什么</li></ol><h3 id="OpenNebula"><a href="#OpenNebula" class="headerlink" title="OpenNebula"></a>OpenNebula</h3><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to PyTorch</title>
      <link href="/2020/02/20/Introduction-to-PyTorch/"/>
      <url>/2020/02/20/Introduction-to-PyTorch/</url>
      
        <content type="html"><![CDATA[<p>This notebook covers:</p><ul><li>Tensors</li><li>Gradients</li><li>Datasets</li><li>Neural networks</li><li>Training(+ training on a GPU)</li><li>Calculating</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>代码见<a href="https://github.com/HurleyJames/GoogleColabExercise/blob/master/Intro_to_PyTorch.ipynb" target="_blank" rel="noopener">Intro_to_Pytorch</a>。</p><a id="more"></a><h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p>Tensor is a basic building block.</p><p>它和Numpy的<code>ndarrays</code>相似，但是相比后者，它可以在GPU上使用。</p><p><code>torch.Tensor</code>是一种包含单一数据类型元素的多维矩阵。</p><h3 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h3><p>相比Numpy，PyTorch在传播梯度方面更加强大。它可以前向传播也可以反向传播。</p><p>Both the gradient, and forward and backward pass functions are attached to PyTorch’s Tensor object.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>如果设置<code>requires_grad=True</code>，那么将会追踪对于该张量的操作。当完成计算后，通过调用<code>.backward()</code>，自动计算所有梯度，而这个张量的所有梯度将会自动积累到<code>.grad</code>属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.grad_fn</span><br></pre></td></tr></table></figure><p><code>Tensor</code>和<code>Function</code>是互联的并且构成了一个无环计算图，以此来实现对完整计算历程的编码。每个Tensor都有一个<code>.grad_fn</code>属性指向一个<code>Function</code>，正是这个<code>Function</code>创建了那个Tensor。</p><hr><p>然后通过Numpy和Tensor分别创建了两个相同的数组，Numpy通过<code>grad_w = v * w</code>得到的结果与Tensor通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = w * x</span><br><span class="line">y.backward(v)</span><br><span class="line">w.grad</span><br></pre></td></tr></table></figure><p>得到的结果是相同的。</p><p>可以看到，PyTorch中的<code>backward</code>函数是一个反向求导的函数，通过反向传播的方式，使用链式法则求导。</p><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p><strong>Transforms</strong> are common image transformations which can be chained together using Compose().</p><p><code>torchvision.transforms</code>是PyTorch中的图像预处理包，包含了很多种对图像数据进行变换的函数。而<code>Compose</code>方法则是把多种变换组合在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>,), (<span class="number">0.5</span>,))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>.ToTensor()</code>的变换操作是将PILImage转变为<code>torch.FloatTensor</code>的数据形式。然后的<code>.Normalize</code>方法是用给定的均值和标准差分别对每个通道的数据进行正则化，即使用如下公式进行归一化：</p><p><code>channel = (channel - mean) / std</code></p><p><code>DataLoader</code>是PyTorch中的一种数据类型，主要包含以下几个参数：</p><ol><li><p><code>dataset</code>：数据类型<code>dataset</code></p><p> 输入数据类型。例如<strong>数据集</strong>。</p></li><li><p><code>batch_size</code>：数据类型<code>int</code></p><p> 每次输入数据的行数，默认为1。即定义每次喂给神经网络多少行数据，如果是1，那么就是一行一行的进行（效率太低）。</p></li><li><p><code>shuffle</code>：数据类型<code>bool</code></p><p> 洗牌。默认设置为<code>False</code>。如果设置为<code>True</code>，那么系统在返回之前会将张量数据Tensors复制到CUDA内存中。</p></li><li><p><code>batch_sampler</code>：数据类型<code>Sampler</code></p><p> 批量采样，默认设置为<code>None</code>。每次返回的是一批数据的索引。<strong>和<code>batch_size</code>和<code>sampler</code>和<code>drop_last</code>不兼容</strong>。</p></li><li><p><code>sampler</code>：数据类型<code>Sampler</code></p><p> 采样，默认设置为<code>None</code>。根据定义的策略从数据集中采样输入。如果定义了采样规则，则洗牌设置必须为<code>False</code>。</p></li><li><p><code>num_workers</code>：数据类型<code>int</code></p><p> 工作者数量，默认为0。即<strong>使用多少个子进程来导入数据</strong>。如果设置为0，就是使用主进程来导入数据（这个数字必须大于0）。</p></li></ol><p>例如，如果想</p><ul><li>打乱数据的顺序，可以设置<strong>shuffle</strong>为<code>True</code></li><li>改变数据输入的数量，可以设置<strong>batch_size</strong>的数目</li><li>想多线程输入，可以设置<strong>num_workers</strong>的数目</li><li>想随机抽取的模式输入，可以设置<strong>sampler</strong>或者<strong>batch_sampler</strong>。</li></ul><p>然后<code>classes = np.arange(0, 10)</code>的方法就是创建一个数组，默认步长为1，所以这个数组就是<code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code>。这个的作用主要是后面的绘制混淆矩阵要用到。</p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>这里主要有两个步骤：</p><ul><li>构建网络</li><li>构建损失函数和优化器</li></ul><p>所有的网络都继承至<code>nn.Module</code>，然后总是需要用到以下两个函数：</p><ul><li><strong>init</strong>, which will be called the moment you instantiate the class.</li><li><strong>forward()</strong> function which will be called during training.</li></ul><h4 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearClassifier</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes=<span class="number">10</span>)</span>:</span></span><br><span class="line">        <span class="comment"># Calls __init__() on the parent class, which is nn.Module</span></span><br><span class="line">        super(LinearClassifier, self).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define each layer of the network as a class variable</span></span><br><span class="line">        <span class="comment"># fc1 stands for first fully-connected layer</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span> * <span class="number">28</span>, num_classes)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = x.reshape(x.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="comment"># TODO what does this do? Why do we need it?</span></span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>这部分代码没有加上卷积层、池化层等操作，而是只有一个简单的全连接层。</p><p>而后面又问了一个问题：<code>out = x.reshape(x.size(0), -1)</code>这句代码的作用是什么？为什么要这样写？</p><p>如果数据集最后一个batch样本数量小于定义的batch_batch大小，会出现mismatch问题。可以自己修改下，如只传入后面的shape，然后通过x.szie(0)，来输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这行的代码是因为在神经网络中，参数默认是进行随机初始化的。而不同的初始化参数往往会导致不同的结果，而在得到好的结果时我们都希望这个结果是能够<strong>复现</strong>的。因为通过设置<strong>随机数种子</strong>可以达到这个目的。</p><h4 id="损失函数和优化器部分"><a href="#损失函数和优化器部分" class="headerlink" title="损失函数和优化器部分"></a>损失函数和优化器部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stochastic gradient descent</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p>这里用到的损失函数是<code>CrossEntropyLoss()</code>，然后优化器是用<code>SGD</code>，学习率为0,001，动量为0.9。</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p><code>optimizer.zero_grad</code>是将梯度重置为0，其余部分主要就是设置epoch次数，然后打印出每轮的损失率。最后通过计算<code>accuracy = correct / total</code>来得到准确率。</p><p>然后可以通过<code>matplotlib.pyplot</code>来生出具体的特征图，例如混淆矩阵。</p><h3 id="Calculating"><a href="#Calculating" class="headerlink" title="Calculating"></a>Calculating</h3><h4 id="卷积操作输出的计算公式"><a href="#卷积操作输出的计算公式" class="headerlink" title="卷积操作输出的计算公式"></a>卷积操作输出的计算公式</h4><p>首先，定义一下参数的概念。</p><p><code>width</code>、<code>height</code>、<code>depth</code>、<code>filter</code>、<code>stride</code>、<code>padding</code></p><p>W：图像的宽；H：图像的高；D：图像的深度（通道数）</p><p>F：卷积核的宽和高；N：卷积核（过滤器）的个数</p><p>S：步长；P：用零填充的个数</p><p>因此，卷积输出的公式为：</p><!-- more --><p><code>output_shape = (input_shape - filter_size + 2 * padding) / stride + 1</code></p><p>即<code>卷积输出大小=(输入大小 - 卷积核大小 + 2 * padding) / 步长 + 1</code></p><h4 id="池化操作输出的计算公式"><a href="#池化操作输出的计算公式" class="headerlink" title="池化操作输出的计算公式"></a>池化操作输出的计算公式</h4><p>同样，W：图像宽；H：图像高；D：图像深度（通道数）</p><p>F：<code>MaxPooling</code>中的卷积核的宽高；S：步长</p><p>因此，池化后输出大小为：</p><p><code>(input_shape - filter_size) / stride + 1</code></p><p>值得注意的是，这里的filter_size不是<code>Conv2d</code>中的卷积核大小，而是池化层中的卷积核大小。例如<code>MaxPool2d(2, 2)</code>这里的卷积核大小就是<code>2x2</code>。</p><h4 id="nn-Conv2d简单说明"><a href="#nn-Conv2d简单说明" class="headerlink" title="nn.Conv2d简单说明"></a>nn.Conv2d简单说明</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li><code>in_channels(int)</code></li><li><code>out_channels(int)</code></li><li><code>kernel_size(int or tuple)</code></li><li><code>stride(int or tuple, optional)</code></li><li><code>padding(int or tuple, optional)</code></li><li><code>groups(int, optional)</code></li><li><code>bias(bool, optional)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weka中实现J48决策树算法</title>
      <link href="/2020/02/04/Weka%E4%B8%AD%E5%AE%9E%E7%8E%B0J48%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/04/Weka%E4%B8%AD%E5%AE%9E%E7%8E%B0J48%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="WEKA"><a href="#WEKA" class="headerlink" title="WEKA"></a>WEKA</h2><p>WEKA（Waikato Environment for Knowledge Analysis）诞生于University of Waikato（新西兰），并在1997年首次以现代的格式实现。</p><p>为了将数据加载到WEKA，我们必须将数据放入一个我们能够理解的格式。WEKA建议加载的数据格式是Attribute Relation File Format（ARFF）。其中含有三个重要的注解：</p><ul><li>@RELATION</li><li>@ATTRIBUTE</li><li>@DATA</li></ul><a id="more"></a><h2 id="J48决策树算法"><a href="#J48决策树算法" class="headerlink" title="J48决策树算法"></a>J48决策树算法</h2><p>J48的全名是<code>weka.classifiers.trees.J48</code>。J48算法是著名的C4.5算法的改进，Weka对于这个算法赋予了默认的参数：-C 0.25 -M 2。该命令给出了分类器的默认参数配置，一般很少需要为提高性能而修改参数配置。前者是用于剪枝的置信因子，后者指定了每个叶结点最小的实例数。</p><p>通过运行weather.nominal.arff文件，在分类器面板的Test options部分选择Use training set，然后点击Start按钮创建分类器并进行评估。</p><p>运行完成后，可以在右侧的Classifier output中查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">=== Run information ===</span><br><span class="line"></span><br><span class="line">Scheme:       weka.classifiers.trees.J48 -C 0.25 -M 2</span><br><span class="line">Relation:     weather.symbolic</span><br><span class="line">Instances:    14</span><br><span class="line">Attributes:   5</span><br><span class="line">              outlook</span><br><span class="line">              temperature</span><br><span class="line">              humidity</span><br><span class="line">              windy</span><br><span class="line">              play</span><br><span class="line">Test mode:    evaluate on training data</span><br><span class="line"></span><br><span class="line">=== Classifier model (full training set) ===</span><br><span class="line"></span><br><span class="line">J48 pruned tree</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">outlook = sunny</span><br><span class="line">|   humidity = high: no (3.0)</span><br><span class="line">|   humidity = normal: yes (2.0)</span><br><span class="line">outlook = overcast: yes (4.0)</span><br><span class="line">outlook = rainy</span><br><span class="line">|   windy = TRUE: no (2.0)</span><br><span class="line">|   windy = FALSE: yes (3.0)</span><br><span class="line"></span><br><span class="line">Number of Leaves  : 5</span><br><span class="line"></span><br><span class="line">Size of the tree : 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time taken to build model: 0.01 seconds</span><br><span class="line"></span><br><span class="line">=== Evaluation on training set ===</span><br><span class="line"></span><br><span class="line">Time taken to test model on training data: 0 seconds</span><br><span class="line"></span><br><span class="line">=== Summary ===</span><br><span class="line"></span><br><span class="line">Correctly Classified Instances          14              100      %</span><br><span class="line">Incorrectly Classified Instances         0                0      %</span><br><span class="line">Kappa statistic                          1     </span><br><span class="line">Mean absolute error                      0     </span><br><span class="line">Root mean squared error                  0     </span><br><span class="line">Relative absolute error                  0      %</span><br><span class="line">Root relative squared error              0      %</span><br><span class="line">Total Number of Instances               14     </span><br><span class="line"></span><br><span class="line">=== Detailed Accuracy By Class ===</span><br><span class="line"></span><br><span class="line">                 TP Rate  FP Rate  Precision  Recall   F-Measure  MCC      ROC Area  PRC Area  Class</span><br><span class="line">                 1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     yes</span><br><span class="line">                 1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     no</span><br><span class="line">Weighted Avg.    1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     </span><br><span class="line"></span><br><span class="line">=== Confusion Matrix ===</span><br><span class="line"></span><br><span class="line"> a b   &lt;-- classified as</span><br><span class="line"> 9 0 | a = yes</span><br><span class="line"> 0 5 | b = no</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="Instances"><a href="#Instances" class="headerlink" title="Instances"></a>Instances</h4><p>代表输入的数据量</p><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>代表数据中有哪些数据分类，即属性</p><h4 id="Number-of-Leaves"><a href="#Number-of-Leaves" class="headerlink" title="Number of Leaves"></a>Number of Leaves</h4><p>叶子树</p><h4 id="Size-of-the-tree"><a href="#Size-of-the-tree" class="headerlink" title="Size of the tree"></a>Size of the tree</h4><p>决策树大小</p><h4 id="Kappa-statistic"><a href="#Kappa-statistic" class="headerlink" title="Kappa statistic"></a>Kappa statistic</h4><p>这个参数是把分类器与随机分类器作比较得出的一个对分类器的评价值。</p><h4 id="Mean-absolute-error和Root-mean-squared-error"><a href="#Mean-absolute-error和Root-mean-squared-error" class="headerlink" title="Mean absolute error和Root mean squared error"></a>Mean absolute error和Root mean squared error</h4><p>平均绝对误差，用来衡量分类器预测值和实际结果的差异，越小越好。</p><h4 id="Relative-absolute-error和Root-relative-squared-error"><a href="#Relative-absolute-error和Root-relative-squared-error" class="headerlink" title="Relative absolute error和Root relative squared error"></a>Relative absolute error和Root relative squared error</h4><p>有时候绝对误差不能体现误差的真实大小，而<strong>相对误差</strong>通过体现误差占真值的比重来反映误差大小的效果会更好。</p><h4 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h4><p>混淆矩阵。这个矩阵上对角线的数字越大，说明预测得越好。</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudSim NetworkExample1</title>
      <link href="/2020/02/02/CloudSim-NetworkExample1/"/>
      <url>/2020/02/02/CloudSim-NetworkExample1/</url>
      
        <content type="html"><![CDATA[<p>CloudSim中的Network包同样含有很多个Example。在NetworkExample1.java文件中，与Example1.java的不同，主要在于模拟之前，需要初始化网络拓扑。即有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load the network topology file</span></span><br><span class="line"><span class="comment">// 直接运行有可能会运行失败，报错找不到toplogy.brite文件</span></span><br><span class="line"><span class="comment">// 方法一：buildNetworkTopology()中的参数改为topology.brite的绝对路径</span></span><br><span class="line"><span class="comment">// 方法二：把topology.brite拷贝到项目的根目录下</span></span><br><span class="line">NetworkTopology.buildNetworkTopology(<span class="string">"topology.brite"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// maps CloudSim entities to BRITE entities</span></span><br><span class="line"><span class="comment">// PowerDatacenter will correspond to BRITE node 0</span></span><br><span class="line"><span class="keyword">int</span> briteNode=<span class="number">0</span>;</span><br><span class="line">NetworkTopology.mapNode(datacenter0.getId(),briteNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broker will correspond to BRITE node 3</span></span><br><span class="line">briteNode=<span class="number">3</span>;</span><br><span class="line">NetworkTopology.mapNode(broker.getId(),briteNode);</span><br></pre></td></tr></table></figure><a id="more"></a><p>那么，NetworkTopology这个类的作用是什么呢？</p><p>它的实现主要是根据一个brite文件建立一个网络拓扑模型，topology.brite文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Topology: ( 5 Nodes, 8 Edges ) </span><br><span class="line">Model (1 - RTWaxman): 5 5 5 1 2 0.15000000596046448 0.20000000298023224 1 1 </span><br><span class="line">10.0 1024.0 </span><br><span class="line"></span><br><span class="line">Nodes: ( 5 ) </span><br><span class="line">0 1 3 3 3 -1 RT_NODE </span><br><span class="line">1 0 3 3 3 -1 RT_NODE </span><br><span class="line">2 4 3 3 3 -1 RT_NODE </span><br><span class="line">3 3 1 3 3 -1 RT_NODE </span><br><span class="line">4 3 3 4 4 -1 RT_NODE </span><br><span class="line"></span><br><span class="line">Edges: ( 8 ) </span><br><span class="line">0 2 0 3.0 1.1 10.0 -1 -1 E_RT U </span><br><span class="line">1 2 1 4.0 2.1 10.0 -1 -1 E_RT U </span><br><span class="line">2 3 0 2.8284271247461903 3.9 10.0 -1 -1 E_RT U </span><br><span class="line">3 3 1 3.605551275463989 4.1 10.0 -1 -1 E_RT U </span><br><span class="line">4 4 3 2.0 5.0 10.0 -1 -1 E_RT U </span><br><span class="line">5 4 2 1.0 4.0 10.0 -1 -1 E_RT U </span><br><span class="line">6 0 4 2.0 3.0 10.0 -1 -1 E_RT U </span><br><span class="line">7 1 4 3.0 4.1 10.0 -1 -1 E_RT U</span><br></pre></td></tr></table></figure><p>程序运行后会寻找标记<code>Nodes</code>和<code>Edges</code>，<code>Nodes</code>是节点信息，其中第一列是节点序号，第二列是节点的横坐标，第三列是节点的纵坐标；<code>Edges</code>是边信息，第一列是边序号，第二列是始节点序号，第三列是终节点序号，第四列是边长度，第五列是边时延，第六列是边带宽。</p><p>这里有一个关键类<code>ToplogicalGraph</code>，描绘了图的拓扑的数据结构。这里面包含两个链表，分别用来存储节点<code>ToplogicalNode</code>和边<code>ToplogicalLink</code>。</p><p>在<code>ToplogicalGraph</code>中通过<code>readGraphFile</code>方法，将文件中的描述，转化为网络拓扑模型。接着用得到的网络拓扑，通过<code>generateMatrices()</code>和<code>createBwMatrix()</code>生成一个是实体间的时延矩阵和带宽矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudSim Example1</title>
      <link href="/2020/02/01/CloudSim-Example1/"/>
      <url>/2020/02/01/CloudSim-Example1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CloudSim是一个云计算基础架构和服务的建模和仿真框架，由Java语言编写，提供给研究人员做仿真实验。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li>支持大型云计算数据中心的建模和仿真</li><li>支持对虚拟服务器主机进行建模和仿真，并具有可自定义的策略，用于向虚拟机提供主机资源</li><li>支持对应用程序容器进行建模和仿真</li><li>支持能源感知计算资源的建模和仿真</li><li>支持对数据中心网络拓扑和消息传递应用程序进行建模和仿真</li><li>支持动态插入模拟元素，停止和继续模拟</li><li>支持用于将主机分配给虚拟机的用户定义策略以及用于将主机资源分配给虚拟机的资源</li></ul><a id="more"></a><h2 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h2><p>Inspect <strong>ClouldSimExample1.java</strong>. Study the code and try to get an overall feel for what it is doing (or supposed to do). You should focus on the following aspects: </p><ul><li>Virtual Machine creation </li><li>Virtual Machine description</li><li>Broker</li><li>Cloudlet</li><li>Data centre</li><li>Simulation parameter setting</li><li>Simulation output</li></ul><p><code>CloudSimExample1.java</code>主要创建了一个含有一个云主机的数据中心，并在其上运行一个云任务。以下是部分代码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudSimExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 云用户数量</span></span><br><span class="line">            <span class="keyword">int</span> num_user = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 用当前日期和时间初始化字段的日历</span></span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            <span class="comment">// 事件追踪</span></span><br><span class="line">            <span class="keyword">boolean</span> trace_flag = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 初始化 CloudSim 工具包</span></span><br><span class="line">            CloudSim.init(num_user, calendar, trace_flag);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建数据中心</span></span><br><span class="line">            Datacenter datacenter0 = createDatacenter(<span class="string">"Datacenter 0"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建 Broker 代理</span></span><br><span class="line">            DatacenterBroker broker = createBroker();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个虚拟机列表</span></span><br><span class="line">            vmlist = <span class="keyword">new</span> ArrayList&lt;Vm&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个虚拟机</span></span><br><span class="line">            Vm vm = <span class="keyword">new</span> Vm(vmid, brokerId, mips, pesNumber, ram, bw, size, vmm, <span class="keyword">new</span> CloudletSchedulerTimeShared());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将虚拟机添加到虚拟机列表中</span></span><br><span class="line">            vmlist.add(vm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将虚拟机列表提交到数据中心代理</span></span><br><span class="line">            broker.submitVmList(vmlist);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建云任务列表</span></span><br><span class="line">            cloudletList = <span class="keyword">new</span> ArrayList&lt;Cloudlet&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建云任务</span></span><br><span class="line">            Cloudlet cloudlet = <span class="keyword">new</span> Cloudlet(id, length, pesNumber, fileSize, outputSize, utilizationModel, utilizationModel, utilizationModel);</span><br><span class="line">truetruetruecloudlet.setUserId(brokerId);</span><br><span class="line">truetruetruecloudlet.setVmId(vmid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将云任务添加到列表中</span></span><br><span class="line">            cloudletList.add(cloudlet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将云任务列表提交到数据中心代理</span></span><br><span class="line">            broker.submitCloudletList(cloudletList);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 开始模拟</span></span><br><span class="line">            CloudSim.startSimulation();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 结束模拟</span></span><br><span class="line">            CloudSim.stopSimulation();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            List&lt;Cloudlet&gt; newList = broker.getCloudletReceivedList();</span><br><span class="line">            printCloudletList(newList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建数据中心</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Datacenter <span class="title">createDatacenter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建列表用于储存机器，简称主机列表</span></span><br><span class="line">        List&lt;Host&gt; hostList = <span class="keyword">new</span> ArrayList&lt;Host&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建处理器，并添加到Pe列表中</span></span><br><span class="line">        peList.add(<span class="keyword">new</span> Pe(<span class="number">0</span>, <span class="keyword">new</span> PeProvisionerSimple(mips)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建处理器，并将其添加到主机列表中</span></span><br><span class="line">        <span class="keyword">int</span> hostId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ram = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">long</span> storage = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">int</span> bw = <span class="number">10000</span>;</span><br><span class="line">        </span><br><span class="line">        hostList.add(<span class="keyword">new</span> Host(hostId, <span class="keyword">new</span> RamProvisionerSimple(ram), <span class="keyword">new</span> BwProvisionerSimple(bw), storage, peList, <span class="keyword">new</span> VmSchedulerTimeShared(peList)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建数据中心特征，它表示了数据中心的静态属性：体系架构、操作系统、主机列表、分配策略、时间或空间共享、时区、价格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Power数据中心</span></span><br><span class="line">        Datacenter datacenter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datacenter = <span class="keyword">new</span> Datacenter(name, characteristics, <span class="keyword">new</span> VmAllocationPolicySimple(hostList), storageList, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> datacenter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建代理，可以根据特定需求发展自己的代理协议来提交虚拟机和云任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DatacenterBroker <span class="title">createBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCloudletList</span><span class="params">(List&lt;Cloudlet&gt; list)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>墨染霜——曹植</title>
      <link href="/2020/01/22/%E5%A2%A8%E6%9F%93%E9%9C%9C%E2%80%94%E2%80%94%E6%9B%B9%E6%A4%8D/"/>
      <url>/2020/01/22/%E5%A2%A8%E6%9F%93%E9%9C%9C%E2%80%94%E2%80%94%E6%9B%B9%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>昔年风骨皆建安</p><p>点墨琳琅耀星汉</p><p>拂袖长歌醉青衫</p><p>夜听闲棋敲纹盘</p><p>微婉雅韵自悠然</p><a id="more"></a><p>天地初入胸臆缓登台</p><p>援笔千言尽华彩</p><p>青眼景慕庙堂寒</p><p>犹映余晖自烛堪</p><p>深恭敛退情义难</p><p>雨打江山</p><p>半纸盛藻 半枕黄粱 聚散俱无端</p><p>半生锦繁 半世离乱 杯中尽余欢</p><p>今古粲溢流年</p><p>卓尔怎居偏安</p><p>何如飘摇随长风</p><p>百载相传</p><p>为君不易 为臣独难 忠信事不显</p><p>悲歌长吟 悲风弦断 泪下冠缨沾</p><p>忆昔踌躇临轩</p><p>而今凌云志短</p><p>旦暮间参商相槛</p><p>千秋一叹</p><p>昔年征伐非沙场</p><p>俯仰沉浮尽炎凉</p><p>一朝青鸾平步升</p><p>明夕同袍隔阋墙</p><p>九重宫阙降离殃</p><p>迷津漫漫一苇独难航</p><p>若枕相思入他乡</p><p>城头不复汉时月</p><p>金銮青冥两茫茫</p><p>不如怀佩归苍黄</p><p>洛川雪扬</p><p>一步一怅 一字一憾 墨染殿前霜</p><p>一言一人 一生一心 道斯人未忘</p><p>长门火映微光</p><p>冷寂漠然空响</p><p>物是人非事亦休</p><p>七步成殇</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础（二）</title>
      <link href="/2020/01/13/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/13/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="可空和非可空类型"><a href="#可空和非可空类型" class="headerlink" title="可空和非可空类型"></a>可空和非可空类型</h2><p>在Kotlin中，对于<code>null</code>安全类型是一种消除代码中空引用风险的过程。如果Kotlin编译器发现任何<code>null</code>参数而仍然执行<code>null</code>引用相关语句，则会立即抛出<code>NullPointerException</code>。</p><p>Kotlin类型系统区分可以保持<code>null</code>（可空引用）和不能保持<code>null</code>（非<code>null</code>引用）的引用。通常，<code>String</code>类型是不可为<code>null</code>的。要创建保存<code>null</code>值的字符串，必须要放置一个<code>?</code>来明确定义。例如，<code>String?</code></p><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>通过放置一个<code>?</code>来声明可空类型<code>?</code>在String后面</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1: String? = <span class="string">"hello"</span></span><br><span class="line">str1 = <span class="literal">null</span><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>这时候<code>str1</code>可以等于<code>null</code>。</p><h3 id="非可空类型"><a href="#非可空类型" class="headerlink" title="非可空类型"></a>非可空类型</h3><p>非可空类型是普通字符串，它们声明为<code>String</code>类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: String = <span class="literal">null</span><span class="comment">// compile error</span></span><br><span class="line">str = <span class="string">"hello"</span><span class="comment">// compile error Val cannot be reassign</span></span><br><span class="line"><span class="keyword">var</span> str2: String = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="literal">null</span><span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>第一行的错误是没有将<code>str</code>定义为可空类型就令它为<code>null</code>。第二行的错误是使用<code>val</code>定义<code>str</code>，那么之后<code>str</code>的值是不可更改的。第三、四行虽然用<code>var</code>定义<code>str2</code>，但是同样没有定义为可空类型，所以不可令<code>str2 = null</code>。</p><h2 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h2><p>在没有安全转换的情况下访问可空类型的<code>String</code>时，它将生成编译错误。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string: String? = <span class="string">"Hello"</span></span><br><span class="line">print(string.length)<span class="comment">//compile error</span></span><br></pre></td></tr></table></figure><p>如上代码会报错，因为没有判断字符串是否为空。</p><p>而使用安全转换为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> string: String? = <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">if</span> (string != <span class="literal">null</span>) &#123;</span><br><span class="line">    print(string.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断string不为空后，就可以正常执行。</p><h3 id="使用is或-is来智能转换"><a href="#使用is或-is来智能转换" class="headerlink" title="使用is或!is来智能转换"></a>使用is或!is来智能转换</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> obj: Any = <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    println(<span class="string">"字符串长度：<span class="subst">$&#123;obj.length&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不安全和安全类型转换"><a href="#不安全和安全类型转换" class="headerlink" title="不安全和安全类型转换"></a>不安全和安全类型转换</h2><h3 id="不安全转换操作符：as"><a href="#不安全转换操作符：as" class="headerlink" title="不安全转换操作符：as"></a>不安全转换操作符：as</h3><p>有时无法转换变量并抛出异常，这称为不安全转换。例如，可以为空的字符串<code>String?</code>不能转换成非null字符串<code>String</code>，这会造成异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> obj: Any? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">val</span> str: String = obj <span class="keyword">as</span> String</span><br><span class="line">  println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码把<code>Any</code>类型转换为字符串类型会造成<code>ClassCastException</code>异常。</p><h3 id="安全转换操作符：as"><a href="#安全转换操作符：as" class="headerlink" title="安全转换操作符：as?"></a>安全转换操作符：as?</h3><p>Kotlin提供一种安全转换操作符：<code>as?</code>。如果无法进行转换，则返回<code>null</code>，而不是抛出异常。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> location: Any = <span class="string">"Kotlin"</span></span><br><span class="line">  <span class="keyword">val</span> safeString: String? = location <span class="keyword">as</span>? String</span><br><span class="line">  <span class="keyword">val</span> safeInt: <span class="built_in">Int</span>? = location <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">  println(safeString)</span><br><span class="line">  println(safeInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码得到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kotlin</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>因为<code>Any</code>类型的<code>Kotlin</code>可以转换成<code>String</code>类型但是不能转换成<code>Int</code>类型，所以第二个输入为<code>null</code>。</p><h2 id="Elvis运算符"><a href="#Elvis运算符" class="headerlink" title="Elvis运算符"></a>Elvis运算符</h2><p>Elvis运算符用来返回非<code>null</code>值，即使条件表达式为<code>null</code>。可以用来<strong>检查值的空安全性</strong>。</p><p>假设一个包含空引用的变量<code>str</code>，在程序中使用<code>str</code>之前要检查它的可空性。如果发现变量<code>str</code>不为<code>null</code>，则其属性可以使用，否则就得返回其它非空值。<strong>（总之不能返回<code>null</code>）</strong>。</p><p>Kotlin还提供称为Elvis运算符(<code>?:</code>)的高级运算符，即使条件表达式为空，也返回非空值。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> str2: String? = <span class="string">"nullable string"</span></span><br><span class="line"><span class="keyword">var</span> len1: <span class="built_in">Int</span> = str?.length ?: -<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> len2: <span class="built_in">Int</span> = str2?.length ?: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过Elvis运算符就相当于使用传统的<code>if...else</code>语句执行此安全检查。</p><p>上述代码通过判断<code>str</code>是否为空，如果为空，就返回正常的<code>str.length</code>，否则返回<code>?:</code>后的值-1。</p><p>除此之外，Elvis运算符后还可以使用<code>throw</code>和<code>return</code>表达式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text1 = text1 ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> text2 = text2 ?: IllegalArgumentException(<span class="string">"text exception"</span>)</span><br></pre></td></tr></table></figure><h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><p>Kotlin类不支持静态方法和成员，但是Kotlin支持全局函数和变量，所以可以直接使用全局函数和变量来代替类中静态方法和静态成员变量。</p><p>Kotlin中有一个有趣的语法糖：<code>Objects</code>。它可以解决由于没有<code>static</code>而造成的麻烦。</p><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>指类中所有的方法都为静态方法的情况，例如工具类一般是静态类。</p><p><strong>把类名<code>class</code>改成<code>object</code>即可</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DateUtil &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>这里又要引入Kotlin另一个语法糖：<code>Companion Objects</code>。在类的内部可以用<code>companion object{}</code>包裹所需的静态方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">"LoginActivity"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>companion object</code>中定义的成员变量就可以通过类名直接访问。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础（一）</title>
      <link href="/2020/01/12/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/12/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fun main(args: Array&lt;String&gt;)</code>也可以直接写成<code>fun main()</code>。</p><a id="more"></a><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在Kotlin中，使用关键字<code>var</code>和<code>val</code>声明变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language = <span class="string">"Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> salary = <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>Kotlin中不需要明确指定变量的类型。Kotlin编译器通过<code>initilizer</code>表达式自动识别推断变量的类型。当然，在声明变量时也可以明确指定变量的类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language: String = <span class="string">"Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> salary: <span class="built_in">Int</span> = <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="关键字var和val的区别"><a href="#关键字var和val的区别" class="headerlink" title="关键字var和val的区别"></a>关键字var和val的区别</h3><ul><li>val用来定义常量，即恒定不变的量。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constant = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>var定义变量，即可变动的量。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable = <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="如何分清"><a href="#如何分清" class="headerlink" title="如何分清"></a>如何分清</h4><p>如果不清楚什么时候使用常量什么时候使用变量时，可以优先使用常量val，如果IDE提示错误则改为var。</p><p>当使用val定义为常量时，常量是不能变动的，只能为其赋值一次。所以如果要改变它的值，需要使用var改成变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = &quot;abc&quot; =&gt; public String str = &quot;abc&quot;</span><br><span class="line">val str: String = &quot;abc&quot; =&gt; public final String str = &quot;abc&quot;</span><br></pre></td></tr></table></figure><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>实际上，val表示的是<strong>只读（read-only）</strong>，即不能再将值写入val，并不意味着其是不可变的。</p><p>在Kotlin的类中，val和var用于表示属性是否有getter/setter：</p><ul><li>var：同时有getter和setter</li><li>val：只有getter</li></ul><h3 id="lateinit和lazy"><a href="#lateinit和lazy" class="headerlink" title="lateinit和lazy"></a>lateinit和lazy</h3><p>如果不想在一开始就对一个属性进行初始化，那么可以使用以下两个关键字。</p><ul><li>lateinit</li><li>lazy</li></ul><h4 id="lateint"><a href="#lateint" class="headerlink" title="lateint"></a>lateint</h4><p>通常情况下，声明为非null类型的属性必须初始化，可以使用<code>lateinit</code>修饰符修饰属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user: User</span><br></pre></td></tr></table></figure><ul><li><code>lateinit</code>只能用于<code>var</code>声明的类变量，并且属性没有自定义<code>getter</code>和<code>setter</code>方法</li><li>属性的类型必须是非空的，并且不能是原始类型</li></ul><h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p><code>lazy()</code>是一个函数，它接收一个<code>lambda</code>并返回一个<code>lazy</code>实例，它可以作为一个实现<code>lazy</code>属性的委托。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String <span class="keyword">by</span> lazy &#123;<span class="string">"Android Developer"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><code>lazy</code>只能用于<code>val</code>属性，而<code>lateinit</code>只能用于<code>var</code>属性</li><li><code>lateinit var</code>可以从任何能看到对象的地方进行初始化。如果想要属性在外部被初始化，可以使用<code>lateinit</code></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数字类型</li><li>字符类型</li><li>布尔类型</li><li>数组类型</li><li>字符串类型</li></ul><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>分为整数和浮点数。</p><ul><li>Byte</li><li>Short</li><li>Int</li><li>Long</li><li>Float</li><li>Double</li></ul><h3 id="字符类型-Char"><a href="#字符类型-Char" class="headerlink" title="字符类型(Char)"></a>字符类型(Char)</h3><p>使用关键字<code>char</code>表示，使用单引号<code>&#39;&#39;</code>声明。</p><h3 id="布尔数据类型-Boolean"><a href="#布尔数据类型-Boolean" class="headerlink" title="布尔数据类型(Boolean)"></a>布尔数据类型(Boolean)</h3><p>使用关键字<code>Boolean</code>表示，包含<code>true</code>和<code>false</code>。</p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>Kotlin中的数组用<code>Array</code>表示。使用库函数<code>arrayOf()</code>和<code>Array()</code>构造函数创建数组。<code>Array</code>中有<code>get()</code>、<code>set()</code>函数，<code>size</code>属性等。</p><h4 id="使用arrayOf创建数组"><a href="#使用arrayOf创建数组" class="headerlink" title="使用arrayOf创建数组"></a>使用<code>arrayOf</code>创建数组</h4><p>例如<code>arrayOf(1,2,3)</code>，它创建一个数组<code>[1,2,3]</code>。通过索引值<code>array[index]</code>访问数组的元素，索引从0开始。</p><h4 id="使用Array-创建数组"><a href="#使用Array-创建数组" class="headerlink" title="使用Array()创建数组"></a>使用<code>Array()</code>创建数组</h4><p>使用<code>Array()</code>构造函数创建数组时，需要在<code>Array()</code>构造函数中使用两个参数：</p><ul><li>第一个参数作为数组的大小</li><li>第二个参数作为函数，用于初始化并返回给定索引的数组元素的值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123;i -&gt; i * <span class="number">2</span>&#125;) <span class="comment">// asc[0,2,4,6,8]</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>使用<code>String</code>表示。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><code>toByte()</code></li><li><code>toShort()</code></li><li><code>toInt()</code></li><li><code>toLong()</code></li><li><code>toFloat()</code></li><li><code>toDouble()</code></li><li><code>toChar()</code></li></ul><h2 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h2><p>Kotlin中的<code>when</code>表达式相当于<code>switch</code>语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> numberProvided = <span class="keyword">when</span>(number) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">"One"</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">"Two"</span></span><br><span class="line">    <span class="number">3</span> -&gt; <span class="string">"Three"</span></span><br><span class="line">    <span class="number">4</span> -&gt; <span class="string">"Four"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"invalid number"</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"You provide <span class="variable">$numberProvided</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">5</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP完全性证明</title>
      <link href="/2019/12/24/NP%E5%AE%8C%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/"/>
      <url>/2019/12/24/NP%E5%AE%8C%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="NP完全性的证明"><a href="#NP完全性的证明" class="headerlink" title="NP完全性的证明"></a>NP完全性的证明</h2><p><strong>引理</strong>：如果语言L是一种满足对任意$L’\in NPC$都有$L’\le_{p}L$的语言，则L是NP-hardness。此外，如果$L\in NP$，则$L\in NPC$。</p><p><strong>证明</strong>：</p><p>$\because L’\in NPC\\<br>\therefore 对于所有L’’\in NP，都有L’’\le _{p}L’\\<br>根据假设，L’\le _{p}L\\<br>\therefore 根据传递性，L’’\in _{p}L\\<br>\therefore L是NP-hardness\\<br>那么，如果L\in NP，且L是NP-hardness\\<br>\therefore L\in NPC$</p><a id="more"></a><h3 id="证明某种语言L是NP完全问题的方法"><a href="#证明某种语言L是NP完全问题的方法" class="headerlink" title="证明某种语言L是NP完全问题的方法"></a>证明某种语言L是NP完全问题的方法</h3><ol><li>证明$L\in NP$</li><li>选取一种已知的NP完全语言L’</li><li>描述一种可计算函数f(x)的算法，其中f可将L’中每一个实例$x\in \left\{0,1\right\}^*$映射为L中的实例$f(x)$</li><li>证明函数f满足$x\in L’$当前仅当对于所有的$x\in \left\{0,1\right\}^*$都有$f(x)\in L$</li><li>证明计算函数$f(x)$的算法具有多项式运行时间</li></ol><p>第2步~第5步是为了证明L是NP-hardness，然后结合第一步的L是NP问题，就可以得出$L\in NPC$。</p><h2 id="典型NPC问题"><a href="#典型NPC问题" class="headerlink" title="典型NPC问题"></a>典型NPC问题</h2><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/wkGF648EsRtgl3B.png" alt="一些典型的NPC问题"></p><ul><li><strong>SAT</strong>：布尔公式的可满足性问题</li><li><strong>3-CNF-SAT</strong>：3合取范式的布尔公式的可满足性问题</li><li><strong>团问题CLIQUE</strong>：寻找无向图中的最大团</li><li><strong>顶点覆盖问题VERTEX COVER</strong>：在无向图中找出最小规模的顶点覆盖</li><li><strong>哈密顿回路问题HAM-CYCLE</strong>：无向图中是否存在哈密顿回路，即通过每个顶点的简单回路</li><li><strong>旅行商问题TSP</strong>：寻找通过无向图每个顶点一次的最小回路</li><li><strong>子集和问题SUBSET-SUM</strong>：给定正整数集合和正整数t，判断是否存在一个子集的元素和为t</li></ul><h2 id="布尔组合电路"><a href="#布尔组合电路" class="headerlink" title="布尔组合电路"></a>布尔组合电路</h2><p>布尔组合电路由一个或多个布尔组合元素通过线路连接而成，布尔组合电路是不包括回路的。</p><p>一个布尔组合电路的<strong>真值赋值</strong>是指一组布尔输入值。如果一个单输出布尔组合电路具有可满足性赋值，则称该布尔组合电路是可满足的。</p><p>布尔值取自集合$\left\{0,1\right\}$，0代表false，1代表true。</p><p>布尔组合元素称为逻辑门：$\begin{cases}与门\quad AND\\或门\quad OR\\非门\quad NOT\end{cases}$</p><p>For example：</p><ol><li>对此电路的输入赋值$<x_1=1, x_2=1, x_3=0>$，使得电路的输出为1，那么电路是可满足的。</li><li>如果对此电路输入的任何一种赋值都不能使得输出为1，则电路不满足。</li></ol><h3 id="NP完全性证明"><a href="#NP完全性证明" class="headerlink" title="NP完全性证明"></a>NP完全性证明</h3><p>给定一个电路C，通过检查输入的所有可能赋值来确定它是否来自可满足性电路。</p><p>那么，如果有k个输入，就有检查$2^k$种可能，因为$\begin{cases}1\\0\end{cases}$</p><p>所以当电路C的规模为k的多项式时，对每个电路的检查要花费$\Omega(2^k)$的时间，呈多项式关系。</p><p>$\therefore$ 该问题是NP完全的</p><h2 id="布尔可满足性问题SAT"><a href="#布尔可满足性问题SAT" class="headerlink" title="布尔可满足性问题SAT"></a>布尔可满足性问题SAT</h2><p><strong>定理</strong>：布尔公式的可满足性问题是NP完全的。</p><p><strong>证明</strong>：</p><ol><li>证明$SAT\in NP$，即证明对于输入公式$\phi$，由它的一个可满足性赋值所组成的证书可以在多项式时间内得到验证</li><li>证明$CIRCUIT-SAT\le _{p}SAT$从而得出SAT是NP-hard</li><li>根据语言$L\in NP$且$L\in NP-hard$能推出$L\in NPC$，得证</li></ol><h2 id="3-CNF可满足性"><a href="#3-CNF可满足性" class="headerlink" title="3-CNF可满足性"></a>3-CNF可满足性</h2><p>即布尔公式中的一个文字（literal）是指一个变量或非“$\neg$”。</p><h3 id="合取范式"><a href="#合取范式" class="headerlink" title="合取范式"></a>合取范式</h3><p>如果一个布尔公式可以表示为所有子句的“与”，并且每个字句都是一个或多个文字的“或”，则称该布尔公式为合取范式。</p><p>如果每个字句恰好有三个不同的<strong>“文字”</strong>，则该布尔公式为3合取范式，即3-CNF。</p><p>For example：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kZuHzcObLqvSj9h.png" alt="合取范式"></p><p><strong>定理</strong>：3合取范式形式的布尔公式的可满足性是NP完全的。</p><p><strong>证明</strong>：要证明$3-CNF-SAT\le NP$，仅需证明$SAT\le _{p}3-CNF-SAT$。</p><h2 id="团问题CLIQUE"><a href="#团问题CLIQUE" class="headerlink" title="团问题CLIQUE"></a>团问题CLIQUE</h2><p>无向图G=(V,E)的团(clique)是一个顶点子集$V’\subseteq V$，其中每一对顶点之间都由E中的一条边来连接。</p><p>一个团是G中的一个完全子图，<strong>图的规模是指它所包含的顶点数</strong>。</p><p>团问题就是关于寻找图中规模最大的团的优化问题。</p><p>事实上，团问题的有效算法是不大可能存在的。因为要确定一个具有$|V|$个顶点的无向图G=(V,E)是否包含一个规模为k的团，有一种朴素算法：</p><p>列出V的所有规模为k的子集，对其中的每一个进行检查，看它是否是一个团。这个算法的运行时间是与k有关。如果k是常数，那么该算法的运行时间是多项式时间的。然而，在一般情况下，k可能接近于$|V|/2$。这样的话，运行时间就是超多项式时间。所以，团问题的有效算法是不大可能存在的。</p><h3 id="形式语言定义"><a href="#形式语言定义" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$CLIQUE=\left\{<G,k>:G是一个包含规模为k的团的图\right\}$</p><p><strong>定理</strong>：$CLIQUE\subseteq NP-Complete$</p><p><strong>证明</strong>：首先，证明$CLIQUE\in NP$。然后，证明$CLIQUE\in NP-hard$</p><ol><li>对于一个给定的图G=(V,E)，用图中顶点集$V’\subseteq V$作为G的一个证书。对于任意一对顶点$\mu,\nu\in V’$，通过检查边$(\mu,\nu)$是否属于E，就可以在多项式时间内确定V’是否是团。</li><li>通过证明$3-CNF-SAT\le _{p}CLIQUE$来说明$CLIQUE\in NP-hard$。</li></ol><h2 id="顶点覆盖问题Vertex-Cover"><a href="#顶点覆盖问题Vertex-Cover" class="headerlink" title="顶点覆盖问题Vertex Cover"></a>顶点覆盖问题Vertex Cover</h2><p>无向图G=(V,E)的顶点覆盖是一个子集$V’\subseteq V$，满足如果有$(\mu,\nu)\in E$，则$\mu\in V’$或$\nu\in V’$（或两者同时成立）。</p><p>顶点覆盖的规模是指它所包含的顶点数。顶点覆盖问题就是在一个给定的图中，找出具有最小规模的顶点覆盖。</p><h3 id="形式语言定义-1"><a href="#形式语言定义-1" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$VERTEX-COVER=\left\{<G,k>:图G有一个规模为k的顶点覆盖\right\}$</p><p><strong>定理</strong>：$VC\subseteq NP-Complete$</p><p><strong>证明</strong>：首先，证明$VC\in NP$。然后证明$CLIQUE\le _{p}VC$从而得到$VC\in NP-hard$</p><h2 id="哈密顿回路问题HAM-CYCLE"><a href="#哈密顿回路问题HAM-CYCLE" class="headerlink" title="哈密顿回路问题HAM-CYCLE"></a>哈密顿回路问题HAM-CYCLE</h2><p><strong>定理</strong>：哈密顿回路问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$HAM-CYCLE\in NP$。然后通过证明$VC\le _{p}HAM-CYCLE$从而得到$HAM-CYCLE\in NP-hard$</p><h2 id="旅行商问题TSP"><a href="#旅行商问题TSP" class="headerlink" title="旅行商问题TSP"></a>旅行商问题TSP</h2><h3 id="形式语言定义-2"><a href="#形式语言定义-2" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$TSP=\left\{<G,c,k>:G=(V,E)是一个完全图，c是V*V\rightarrow Z上的一个函数，k\in Z，G中包含一个最大花费为k的旅行回路。\right\}$</p><p><strong>定理</strong>：旅行商问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$TSP\in NP$。然后通过证明$HAM-CYCLE\le _{p}TSP$从而得到$TSP\in NP-hard$</p><h2 id="子集和问题SUBSET-SUM-problem"><a href="#子集和问题SUBSET-SUM-problem" class="headerlink" title="子集和问题SUBSET-SUM problem"></a>子集和问题SUBSET-SUM problem</h2><p>给定一个正整数有限集S和一个整数目标t&gt;0，问是否存在一个子集$S’\subseteq S$，其元素和为t。</p><h3 id="形式语言定义-3"><a href="#形式语言定义-3" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$SUBSET-SUM=\left\{<S,t>:存在一个子集S’\subseteq S，使得t= \sum\limits_{S\in S’}S\right\}$</p><p><strong>定理</strong>：子集和问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$SUBSET-SUM\in NP$。然后，通过证明$3-CNF-SAT\le _{p}SUBSET-SUM$从而得到$SUBSET-SUM\in NP-hard$</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fault Tolerance</title>
      <link href="/2019/12/23/Fault%20Tolerance/"/>
      <url>/2019/12/23/Fault%20Tolerance/</url>
      
        <content type="html"><![CDATA[<h2 id="容错性描述"><a href="#容错性描述" class="headerlink" title="容错性描述"></a>容错性描述</h2><p>容错与可靠性（dependability）紧密相关。</p><ul><li><strong>可用性</strong>(availability)说明系统已准备好，马上就可以使用</li><li><strong>可靠性</strong>(reliability)指系统可以无故障地持续运行</li><li><strong>安全性</strong>(safety)指在系统偶然出现故障的情况下，仍然能够正确的操作而不会造成任何灾难</li><li><strong>可维护性</strong>(maintainability)是指发生故障的系统被恢复的难易程度</li></ul><a id="more"></a><h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><ul><li><strong>Fail</strong>：当一个系统不能兑现它的承诺时就被认为是失败了</li><li><strong>Error</strong>：是系统状态的一部分，它可能会导致失败</li><li><strong>Fault</strong>：是造成Error的原因</li></ul><h3 id="Handling-Faults"><a href="#Handling-Faults" class="headerlink" title="Handling Faults"></a>Handling Faults</h3><ul><li>Fault prevention：Prevent the occurrence of a fault</li><li>Fault tolerance：Build a component such that it can mask the occurrence of a fault</li><li>Fault removal：Reduce thte presence, number, or seriousness of a fault</li><li>Fault forecasting：Estimate current presence, future incidence, and consequences of faults</li></ul><h3 id="Failure-Models"><a href="#Failure-Models" class="headerlink" title="Failure Models"></a>Failure Models</h3><ul><li><p>崩溃性故障 Crash failure</p><p>服务器停机，但是在停机之前工作正常</p></li><li><p>遗漏性故障 Omission failure</p><p>服务器不能响应到来的请求</p><ul><li><p>接收故障 Receive omission</p><p>服务器不能接受到来的请求</p></li><li><p>发送故障 Send omission</p><p>服务器不能发送消息</p></li></ul></li><li><p>定时故障 Timing failure</p><p>服务器的响应在指定的时间间隔之外</p></li><li><p>响应故障 Response failure</p><p>服务器的响应不正确</p><ul><li><p>值故障 Value failure</p><p>响应的值错误</p></li><li><p>状态转换故障 State-transition failure</p><p>服务器偏离了正确的控制流</p></li></ul></li><li><p>随意性故障 Arbitrary (or Byzantine) failure</p><p>服务器可能在随意的时间产生随意的响应</p></li></ul><h3 id="冗余掩盖故障-Failure-Masking-by-Redundancy"><a href="#冗余掩盖故障-Failure-Masking-by-Redundancy" class="headerlink" title="冗余掩盖故障 Failure Masking by Redundancy"></a>冗余掩盖故障 Failure Masking by Redundancy</h3><ul><li>信息冗余 Information redundancy</li><li>时间冗余 Time redundancy</li><li>物理冗余 Physical redundancy</li></ul><h2 id="进程恢复-Process-Resilience"><a href="#进程恢复-Process-Resilience" class="headerlink" title="进程恢复 Process Resilience"></a>进程恢复 Process Resilience</h2><h3 id="平等组与等级组"><a href="#平等组与等级组" class="headerlink" title="平等组与等级组"></a>平等组与等级组</h3><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/2MepDj9v3S5wrO7.png" alt=""></p><p><strong>平等组</strong>是对称的，没有单独的失败点。如果一个进程崩溃，组只是简单地变得更小，但是还可以继续。它的缺点是做出决定比较复杂，比如需要进行表决，会导致一些延迟和开销。</p><p><strong>等级组</strong>则相反。某个成员的故障会使整个组崩溃，但是只要它保持运行，就可以独自做出决定，不需要其他进程参加。</p><h3 id="故障掩盖和复制"><a href="#故障掩盖和复制" class="headerlink" title="故障掩盖和复制"></a>故障掩盖和复制</h3><p>如果系统能够经受k个组件的故障并且还能满足规范的要求，那么就被称为<strong>k容错</strong>（k fault tolerant）。</p><p>如果这些进程失败了，那么k+1个组件就能提供k容错。</p><p>另一方面，如果进程发生<strong>拜占庭失败</strong>，继续错误运行并发送出错误或随机的应答，最少需要2k+1个进程才能获得k容错。</p><h2 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h2><p>全称是<strong>拜占庭将军问题</strong>（Byzantine Generals Problem），是由莱斯利·兰波特提出的分布式对等网络通信容错问题。在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同的结论，从而破坏系统一致性。拜占庭问题被认为是容错性问题中最难的问题类型之一。</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>系统的问题在于，将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。<strong>假如那些忠诚（没有出错）的将军仍然能通过多数决定来决定他们的策略</strong>，那么就达到了<strong>拜占庭容错</strong>。</p><p>上述故事映射到计算机系统里，将军就是计算机，信差就是通信系统。在分布式对等网络中需要按照共同一致策略协作的<strong>成员计算机</strong>即为问题中的<strong>将军</strong>，而各成员赖以进行通讯的<strong>网络链路</strong>即为<strong>信使</strong>。拜占庭将军描述的就是某些成员计算机或网络链路出现错误、甚至被蓄意破坏者控制的情况。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>如何让忠诚者（非叛徒）达成一致。</p><p>假设节点总数为N，叛徒数为F，则当<strong>N&gt;=3F+1</strong>时，问题才有解，即<strong>Byzantine Fault Tolerant(BTF)</strong>算法。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>N=3, F=1, 不满足N&gt;=3F+1</p><ol><li>当提出方案的人<strong>不是叛徒</strong>时，提案人提出一个方案，叛徒就提出相反的方案，剩下一个人收到两个相反的意见，就无法判断谁是叛徒，也无法给出一致的意见。所以如果提案人提出方案，系统中就有N-F份确定的信息和F份不确定的信息，只有$N-F \ge F \Rightarrow N&gt;F$的情况下达成一致。</li><li>当提出方案的人是<strong>叛徒</strong>时，提案人提出方案，发送给另外两人。另外两人收到两份相反的消息，无法判断谁才是叛徒，系统也无法达成一致。因为提出方案的叛徒会尽量发送相反的消息给N-F个忠诚者，那么$\begin{cases}\frac{N-F}{2}个信息1\\ \frac{N-F}{2}个信息0\end{cases}$</li></ol><p>Leslie Lamport证明，当叛徒数不超过<strong>1/3</strong>时，存在有效的算法让忠诚者总能达成一致。然而，如果叛徒数过多，就无法保证能够达成一致。</p><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>如果叛徒数超过1/3时，有无解决方案？</p><p>设有f个叛徒和g个忠诚者，叛徒可以故意使坏，可以给出错误的结果也可以不响应请求。</p><ol><li>当f个叛徒不响应，则g个忠诚者占多数，仍然能够得到正确结果</li><li>当f个叛徒，每个叛徒都给出一个恶意提案，并且当g个忠诚者中有f个处于离线状态时，则剩下g-f个忠诚者想要占据多数保持正确结果，则必须有$g-f&gt;f \Rightarrow g&gt;2f$，而系统的整体规模：$g+f &gt; 2f+f=3f \Rightarrow g+f&gt;3f$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timing and Synchronisation</title>
      <link href="/2019/12/23/Timing%20and%20Synchronisation/"/>
      <url>/2019/12/23/Timing%20and%20Synchronisation/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Eight-Fallacies-of-Distributed-Computing"><a href="#The-Eight-Fallacies-of-Distributed-Computing" class="headerlink" title="The Eight Fallacies of Distributed Computing"></a>The Eight Fallacies of Distributed Computing</h2><ul><li>The network is reliable</li><li>Latency is zero</li><li>Bandwidth is infinite</li><li>The network is secure</li><li>Topology doesn’t change</li><li>There is one administrator</li><li>Transport cost is zero</li><li>The network is homogeneous</li><li><font color=red>All blocks are synchronized</font></li></ul><p>第9大悖论即<strong>所有时钟是同步的</strong>。</p><a id="more"></a><h2 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h2><p>In a DS, there is <font color=red>no global agreement on time.</font></p><h3 id="物理时钟"><a href="#物理时钟" class="headerlink" title="物理时钟"></a>物理时钟</h3><p>几乎所有的计算机都有一个计时电路。但它们不是通常意义上的时钟，称为<strong>计时器（timer）</strong>更为掐当。这里还有几个概念：</p><ul><li>有两个计数器与每个石英晶体相关联，一个是<strong>计数器（counter）</strong>，另一个是<strong>保持寄存器（holding register）</strong></li><li>每次的中断称为一个时钟滴答（When counter reaches zero, a <font color=red>timer interrupt</font> or <font color=red>clock tick</font> is generated and counter is reloaded from a holding register）</li><li>时钟偏移：In a DS with <em>n</em> machines, all <em>n</em> crystals will run at slightly different rates, resulting in <font color=red>clock skew</font>.</li></ul><h3 id="时钟同步算法"><a href="#时钟同步算法" class="headerlink" title="时钟同步算法"></a>时钟同步算法</h3><h4 id="Cristian’s-Algorithm"><a href="#Cristian’s-Algorithm" class="headerlink" title="Cristian’s Algorithm"></a>Cristian’s Algorithm</h4><p>Cristian提出让客户与<strong>时间服务器</strong>（time server）联系。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/KW4FhDvZsi2jcqz.png" alt=""></p><p>如图所示，best estimate of one-way propagation time is <strong><em>(T1-T0-I)/2</em></strong>.</p><p><strong>例题：</strong><br>The client’s clock reads 5:26:08. The server’s clock reads 5:16:44 when they synchronize using Cristian’s algorithm. Assume RTT is 2 seconds. What is the time at the client after synchronization? Note: the time format is HH:MM:SS.</p><p><strong>解答：</strong></p><p>Cristian’s algorithm assumes that the server has an accurate clock. The client requests the time and sets its clock to the server’s time $+\frac{1}{2}(RTT)$. In this case, the RTT is 2 seconds, so the client set time after synchronization: $5:16:44 + \frac{1}{2}*2seconds = 5:16:45$</p><h4 id="Berkeley-Algorithm"><a href="#Berkeley-Algorithm" class="headerlink" title="Berkeley Algorithm"></a>Berkeley Algorithm</h4><p>Berkeley UNIX系统中的时间服务器（实际上是时间守护程序）是主动的，它定期地询问每台机器的时间。基于这些回答，它计算出一个平均时间，并告诉所有其他机器将它们的时钟快拨到一个新的时间，或者拨慢时间。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/7wdnyTFM4ZmKPWq.png" alt=""></p><p><strong>例题1：</strong></p><p>The client’s clock reads 5:26:00. The server’s clock reads 5:14:00 when they synchronize using the Berkeley algorithm. Assume message delays are negligible. What is the time at the client after synchronisation? Note: the time format is HH:MM:SS.</p><p><strong>解答：</strong></p><p>The Berkeley algorithm averages clocks among the entire group. In this case, the group has two members: the client and the server. The average of the two clocks is $(5:26:00+5:14:00)/2=5:20:00$. Both the client and server will be set at $5:20:00$.</p><p><strong>例题2：</strong></p><p>Consider a network consisting of 5 computers, A (coordinator), B, C, D, and E. At 08:45 the coordinator decides to synchronise the clock of all computers in the network. The time format is HH:MM. At that moment, the clock of the computers in the network shows the following: B(08:43), C(08:49), D(08:42), E(08:46). Apply the Berkeley clock synchronisation algorithm to this situation, show the stages of computation, and explain the outcome of the synchronisation. You may assume that the time needed for computation and for network communication is negligible.</p><p><strong>解答：</strong></p><p>由上图给出的例子作为解释，这里的同步是指由coordinator服务器发起的。coordinator服务器发送请求到所有slave服务器，接收到所有的slave服务器时间后，计算时间的平均值，然后将这个值回填至所有的服务器。其中也包括coordinator服务器。A服务器即coordinator请求时的时间是08:45，B、C、D、E的服务器时间分别是08：43、08：49、08：42、08：46。所以这4台服务器收到请求后分别返回与coordinator的时间差-2、+4、-3、+1。coordinator接收到这两个值后进行计算$(-2+4-3+1)/3=0$。说明时钟走过的时间为0，可忽略。然后$0-(-2)=2，0-4=-4，0-(-3)=3，0-1=-1$。分别将这四个值回填给另外四台服务器。</p><h4 id="Bully-Algorithm"><a href="#Bully-Algorithm" class="headerlink" title="Bully Algorithm"></a>Bully Algorithm</h4><p>当任何一个进程发现协作者不再响应请求时，它就发起一次选举。进程P按如下过程主持一次选举：</p><ol><li>P向所有编号比它大的进程发送一个Election消息；</li><li>如果无人响应，P获胜并称为协作者;</li><li>如果有编号比它大的进程响应，则由响应者接管选举工作。P的工作完成。</li></ol><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/zOZ2jvY3sU9kKET.png" alt=""></p><h4 id="网络时间协议"><a href="#网络时间协议" class="headerlink" title="网络时间协议"></a>网络时间协议</h4><p>网络时间协议（network time protocol, NTP）在服务器之间创建了两条连接。换句话说，B也可以探查A的当前时间。</p><p>原则上，对称地应用NTP也可以让B参照A来调整它的时钟。但是，如果已知B的时钟更精确，那么这种调整就不应该了。所以，NTP把服务器分成多个层。含有<strong>参考时钟</strong>（reference clock）的服务器称为<strong>1层服务器</strong>（stratum-1 server）（时钟本身为0层）。</p><p>当A与B联系时，如果它的层比B的层要高，那么它就只调整自己的时间。经过同步化后，A将比B高一层。如果B是k层服务器，且A的初始层已经大于k，那么，经过时间调整后，A就变成（k+1）层服务器。由于NTP的对称性，如果A的层数比B的低，那么B将按照A来调整自己。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔可夫决策过程</title>
      <link href="/2019/12/20/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/12/20/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h2><p>某一状态信息包含了相关的历史，只要当前状态可知，所有的历史信息都不再需要，当前状态就可以决定未来，则认为该状态具有马尔可夫性（Markov Property）。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/fk6g5r3bL2QnpHZ.png" alt="马尔可夫性"></p><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><p>又叫马尔可夫链（Markov Chain）。它是一个无记忆的随机过程，可以用一个元组<S, P>表示，其中S是有限数量的状态集，P是状态转移概率矩阵。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kjVv3wCQdELxm8p.png" alt="马尔可夫过程"></p><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p>马尔可夫奖励过程（Markov Reward Process）在马尔可夫过程的基础上增加了奖励R和衰减系数V：<S, P, R, V>。R是一个奖励函数。S状态下的奖励是某一时刻（t）处所在状态s下在下一个时刻（t+1）能获得的奖励期望：</p><script type="math/tex; mode=display">R_s = E[R_{t+1}|S_t=s]</script><p>衰减系数（Discount Factor）：$\gamma\in[0, 1]$，避免无限循环。</p><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p>Markov Decision Process，MDP</p><p>多了一个行为集合A，元组<S, A, P, R, V>。</p><script type="math/tex; mode=display">P^a_{ss'} = P[S_{t+1}=s'|S_t=s, A_t=a]\\R^a_s=E[R_{t+1}|S_t=s, A=a]</script><p>当给定一个MDP： $<S, R, P,R, \gamma>$和一个策略$\pi$，那么状态序列$S_1，S_2$，是一个马尔可夫过程$<S, P^\pi>$。</p><p>下一个时刻的状态$S_{t+1}$和<strong>当前时刻的状态$S_t$以及动作$a_t$有关</strong>。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><script type="math/tex; mode=display">初始化状态agent所处状态s_0\\\Downarrow\\根据policy\quad\pi(a|s)采取动作a_0，a_0\sim\pi(a|s_0)\\\Downarrow\\根据转移概率p(s'|s,a)采取新状态s_1，s_1\sim p(s'|s,a)\\\Downarrow\\得到单步奖励r_1=R^{a_0}_{s_0s_1}\\\Downarrow\\持续，得到终止状态S_T，得到轨迹\gamma=(s_0,a_0,s_1,a_1,\dots,s_T)\\\Downarrow\\轨迹的联合概率：\\p(r)=p(S_0)·\prod^\pi_{t=1}p(a_{t-1}|S_{t-1})·p(S_t|S_{t-1},a_{t-1})\\\Downarrow对于每一条轨迹，累计奖励函数是关于单步奖励的函数\\R=f(r_0,r_1\dots r_{T-1})\\\downarrow\\可以是T步累计奖励函数R=\sum^{T-1}_{t=0}r_t，\\也可以是\gamma折扣奖励函数，R=\sum^{T-1}_{t=0}\gamma^t·r_t\\\Downarrow期望累计奖励是E_R=E_p(r)[\sum^{T-1}_{t=0}\gamma^t·r_t^T]\\\therefore agent的目标策略就是使得期望累计奖励最大的策略\\\pi=\max\limits_{\pi}E_{p(r)}^\pi[\sum^{T-1}_{t=0}\gamma^t·r_t]</script><h3 id="状态state"><a href="#状态state" class="headerlink" title="状态state"></a>状态state</h3><p>agent在每个步骤中所处于的状态集合。</p><h3 id="行为action"><a href="#行为action" class="headerlink" title="行为action"></a>行为action</h3><p>agent在每个步骤中所能执行的动作集合。</p><h3 id="转移概率transition"><a href="#转移概率transition" class="headerlink" title="转移概率transition"></a>转移概率transition</h3><p>agent处于状态s下，执行动作a后，会转移到状态s’的概率。</p><h3 id="奖励reward"><a href="#奖励reward" class="headerlink" title="奖励reward"></a>奖励reward</h3><p>agent处于状态s下，执行动作a后，转移到状态s’后获得的立即奖励值。</p><h3 id="策略Policy"><a href="#策略Policy" class="headerlink" title="策略Policy"></a>策略Policy</h3><p>策略$\pi$是概率的集合或分布，其元素$\pi(a|s)$为对过程中的<strong>某一状态s采取可能的行为a的概率</strong>。</p><p>agent处于状态s下，应执行动作a的概率。</p><p>一个策略定义了个体在各个状态下的各种可能的行为方式以及其概率的大小。</p><h3 id="回报Return"><a href="#回报Return" class="headerlink" title="回报Return"></a>回报Return</h3><p>回报$G_t$为在一个马尔可夫奖励链上<strong>从t时刻开始往后所有的奖励的有衰减的总和</strong>。</p><h3 id="价值函数Value-Function"><a href="#价值函数Value-Function" class="headerlink" title="价值函数Value Function"></a>价值函数Value Function</h3><p>价值函数给出了某一状态或某一行为的长期价值。</p><p>某一状态的价值函数为从该状态开始的马尔可夫链收获的期望。</p><p><strong>Bellman Optimality Equation</strong></p><p>针对V<em>，一个状态的最优价值等于从该状态出发采取的所有行为产生的行为价值中<em>*最大的</em></em>那个行为价值：</p><script type="math/tex; mode=display">V_*(s)=\max_aq_*(s,a)</script><h2 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h2><h3 id="状态值函数State-Value-Function"><a href="#状态值函数State-Value-Function" class="headerlink" title="状态值函数State Value Function"></a>状态值函数State Value Function</h3><p>$V^\pi(s)$为状态值函数，表示从状态s开始，执行策略$\pi$得到的期望总回报：</p><script type="math/tex; mode=display">V^\pi(s)=E_{r\sim p(r)}[\sum^{T-1}_{t=0}\gamma^t·r_{t+1}|\tau_{s_0}=s]</script><p>其中$\tau_{s_0}$表示轨迹$\gamma$的起始状态。</p><script type="math/tex; mode=display">V^\pi(s)=E_{a\sim\pi}(a|s)E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma V^\pi(s')]\\\downarrow</script><p>Bellman equation，表示当前状态的值函数可以通过下个状态的值函数来计算。</p><h3 id="状态——动作值函数"><a href="#状态——动作值函数" class="headerlink" title="状态——动作值函数"></a>状态——动作值函数</h3><p>也叫Q函数，Q-function。指初始状态为s并进行动作a，然后执行策略$\pi$得到的期望总回报，即state-action value function。</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma·V^\pi(s')]</script><p>也可以写成：</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma·E_{a'\sim\pi(a'|s')}[Q^\pi(s',a')]]\\\uparrow\\Q函数的Bellman方程</script><hr><p><strong>基于值函数的策略学习方法</strong></p><p>主要分为<strong>动态规划</strong>和<strong>蒙特卡罗</strong>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划又分为<strong>策略迭代（policy iteration）</strong>算法和<strong>值迭代（value iteration）</strong>算法。</p><h3 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h3><ol><li><p>策略评估 policy evaluation</p><p>计算当前策略下，每个状态的值函数。可以通过Bellman方程进行迭代计算$V^\pi(s)$。</p></li><li><p>策略改进 policy improvement</p><p>根据值函数更新策略。</p></li></ol><h3 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h3><p>将策略评估与策略改进合并，来直接计算出最优策略。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/oYOnGDUXLir8awP.png" alt="策略迭代 VS 值迭代"></p><h2 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h2><p>Q函数。$Q^\pi(s,a)$为初始状态为s，并执行动作a后所能得到的期望总回报。</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{r\sim p(r)}[G(\tau_{s_0}=s,a_0=a)]</script><p>$\tau_{s_0}=s，a_0=a$表示轨迹$\tau$的起始状态和动作为s，a。</p><h3 id="蒙特卡罗方法"><a href="#蒙特卡罗方法" class="headerlink" title="蒙特卡罗方法"></a>蒙特卡罗方法</h3><p>Q函数通过<strong>采样</strong>进行计算。</p><p>对于一个策略$\pi$，agent从状态s，执行动作a开始，然后通过随机游走的方法探索环境，并计算其总回报。</p><p>在得到Q函数$Q^\pi(s,a)$之后，进行策略改进，在新策略下采样估计Q函数，不断重复。</p><h3 id="epsilon-贪心法"><a href="#epsilon-贪心法" class="headerlink" title="$\epsilon$-贪心法"></a>$\epsilon$-贪心法</h3><script type="math/tex; mode=display">\pi^\epsilon=\begin{cases}\pi(s),按概率1-\epsilon\\随机选择\mathcal{A}中的动作，按概率\epsilon\end{cases}</script><p>将一个仅利用的策略转为带探索的策略，每次选择动作$\pi(s)$的概率为$1-\epsilon+\frac{1}{|\mathcal{A}|}$，其它动作的概率为$\frac{1}{\mathcal{A}}$。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/ZQzg2apVPY5ArCn.png" alt="同策略与异策略"></p><h2 id="时序差分学习方法"><a href="#时序差分学习方法" class="headerlink" title="时序差分学习方法"></a>时序差分学习方法</h2><p>蒙特卡罗采样方法一般需要拿到完整的轨迹，才能对策略进行评估并更新模型，因此效率较低。</p><p><strong>时序差分学习（temporal-difference learning）</strong>结合了动态规划和蒙特卡罗方法：模拟一段轨迹，每行动一步（或几步）就利用Bellman方程来评估行动前状态的值。（当每次更新动作数为最大数时，就等价于蒙特卡罗方法）。</p><h3 id="SARSA算法"><a href="#SARSA算法" class="headerlink" title="SARSA算法"></a>SARSA算法</h3><p><strong>State Action Reward State Action</strong></p><p>只需要知道当前状态s和动作a，奖励r(s,a,s’)，下一步的状态s’和动作a’，其采样和优化的策略都是$\pi^\epsilon$，因此是同策略。</p><script type="math/tex; mode=display">Q^\pi(s,a)\longleftarrow Q^\pi(s,a)+\alpha(r(s,a,s')+rQ^\pi(s',a')-Q^\pi(s,a))</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/kKlwCsz3dY85T9g.png" alt="SARSA算法"></p><h3 id="Q学习算法"><a href="#Q学习算法" class="headerlink" title="Q学习算法"></a>Q学习算法</h3><p><strong>Q-learning</strong></p><script type="math/tex; mode=display">Q(s,a)\longleftarrow Q(s,a)+\alpha(r+\gamma\max_{a'}Q(s',a')-Q(s,a))</script><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/vE2fCp69J71XB3T.png" alt="Q-learning算法"></p><p>与SARSA不同，Q-learning不通过$\pi^\epsilon$来选下一步的动作a’，而是<strong>直接选最优的Q函数</strong>。更新后的Q函数是关于策略$\pi$的，而不是策略$\pi^\epsilon$的。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马尔可夫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图与完美匹配</title>
      <link href="/2019/11/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/11/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="二分图定义"><a href="#二分图定义" class="headerlink" title="二分图定义"></a>二分图定义</h2><p>可以把图中的点分成两部分，使得每部分内部两两点之间没有连边。</p><h2 id="判定是否是二分图"><a href="#判定是否是二分图" class="headerlink" title="判定是否是二分图"></a>判定是否是二分图</h2><p>没有奇数环的图，或者能够黑白染色（染色问题）的图。</p><h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个图的最大匹配中的每个点都是匹配点</p><h3 id="Hall定理"><a href="#Hall定理" class="headerlink" title="Hall定理"></a>Hall定理</h3><p>设G是具有二划分（X, Y）的二部图，则G有饱和X的匹配当且仅当对 ∀S ⊆ X ， N ( S ) ≥ |S|，其中 N (S ) 表示 S 的所有邻点之集。</p><a id="more"></a><p>通俗的说，即<strong>选择任意的左部点S个，把所有这S个点关联的K个右部点取出来，一定有|S|&lt;=|K|</strong>。如果满足这个条件，则是二分图。</p><h3 id="Tutte定理"><a href="#Tutte定理" class="headerlink" title="Tutte定理"></a>Tutte定理</h3><blockquote><p>A graph, <em>G</em> = (<em>V</em>, <em>E</em>), has a <a href="https://en.wikipedia.org/wiki/Perfect_matching" target="_blank" rel="noopener">perfect matching</a> <a href="https://en.wikipedia.org/wiki/If_and_only_if" target="_blank" rel="noopener">if and only if</a> for every subset <em>U</em> of <em>V</em>, the <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Subgraphs" target="_blank" rel="noopener">subgraph</a> induced by <em>V</em> − <em>U</em> has at most |<em>U</em>| <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory" target="_blank" rel="noopener">connected components</a>) with an odd number of <a href="https://en.wikipedia.org/wiki/Vertex_(graph_theory" target="_blank" rel="noopener">vertices</a>).</p></blockquote><p>图G有完美匹配的充分必要条件是<strong>对∀S ⊂ V (G ) ， O (G \ S ) ≤| S |</strong>。</p><p>即图G有完美匹配等价于，对于图G去掉任意一个点集之后，图的奇分支的个数小于等于点集的个数（奇分支：有奇数个点的分支）。</p><p>例如，对于下图，证明其是否有完美匹配。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Xr2d6KgsbxOk8nP.png" alt=""></p><p>可以在图中挑出一些点，使得点与点之间分隔后的部分有<strong>奇数</strong>个顶点，然后比较挑出的点的数量，与分隔后的部分的数量的大小。如果分隔后部分的数量小于等于挑出点的数量，则有完美匹配。</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/pLsJGEZud2i6Njh.png" alt=""></p><p>如上图所示，挑出12个红点，这12个红点将图分成了14个部分（每个部分必须含有奇数个顶点）。因为12&lt;14，不满足Tutte定理，所以这个图没有完美匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
            <tag> 完美匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy官方快速热门教程（译）</title>
      <link href="/2019/11/02/Numpy%E5%AE%98%E6%96%B9%E5%BF%AB%E9%80%9F%E7%83%AD%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/"/>
      <url>/2019/11/02/Numpy%E5%AE%98%E6%96%B9%E5%BF%AB%E9%80%9F%E7%83%AD%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>Numpy是一个开源的Python科学计算库，它是Python科学计算库的基础库。</p><h3 id="Numpy常用统计函数"><a href="#Numpy常用统计函数" class="headerlink" title="Numpy常用统计函数"></a>Numpy常用统计函数</h3><p><strong>函数在使用时需要指定axis轴的方向</strong>，若不指定，则默认是整个数组</p><ul><li><code>np.num()</code>：返回求和</li><li><code>np.mean()</code>：返回均值</li><li><code>np.max()</code>：返回最大值</li><li><code>np.min()</code>：返回最小值</li><li><code>np.ptp()</code>：数组沿指定轴返回最大值减去最小值，即（max-min）</li><li><code>np.std()</code>：返回标准偏差（standard deviation）</li><li><code>np.var()</code>：返回方差</li><li><code>np.cumsum()</code>：返回累加值</li><li><code>np.cunprod()</code>：返回累乘积值</li></ul><a id="more"></a><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p>Numpy的主要操作对象是同类型的多维数组。它是一个由正整数元组索引，元素类型相同的表（通常元素为数字）。在Numpy维度被成为<code>axes</code>，<code>axes</code>的数量称为<code>rank</code>。</p><p>例如，在3D空间的一个点[1,2,1]是一个<code>rank=1</code>的数组，因为它只有一个<code>axes</code>。而这个<code>axes</code>的长度为3。同样的，下面这个例子则是，数组<code>rank=2</code>（2维，2层嵌套的中括号），第一维的长度为2，第二维长度为3。（第1维即中括号最外面的部分，内部又包含2个中括号（相当于2个元素），所以长度为2；第2维即内部的中括号内含有3个元素）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>Numpy的数组类是<code>ndarray</code>，也可称作<code>array</code>。值得注意的是，<code>numpy.array</code>和标准Python库中的<code>array.array</code>是不一样的，它只能处理一维数组，提供更少的功能。</p><h4 id="ndarray对象的一些重要属性"><a href="#ndarray对象的一些重要属性" class="headerlink" title="ndarray对象的一些重要属性"></a><code>ndarray</code>对象的一些重要属性</h4><ul><li><p><code>ndarray.ndim</code></p><blockquote><p>数组的<code>axes</code>（维数）数值的大小，即<code>rank</code>，几维</p></blockquote></li><li><p><code>ndarray.shape</code></p><blockquote><p>数组的维数，这是由每个维度的大小组成的一个元组。对于一个<strong>n行m列</strong>的矩阵，<code>shape</code>是<code>(n,m)</code>。由<code>shape</code>元组的长度得出<code>rank</code>或者维数<code>ndim</code>。</p></blockquote></li><li><p><code>ndarray.size</code></p><blockquote><p>数组元素的个数总和，这等于<code>shape</code>元组数字的乘积。</p></blockquote></li><li><p><code>ndarray.dtype</code></p><blockquote><p>在数组中描述元素类型的一个对象。</p></blockquote></li><li><p><code>ndarray.itemsize</code></p><blockquote><p>数组中每个元素所占字节数。</p></blockquote></li><li><p><code>ndarray.data</code></p><blockquote><p>数据实际元素的缓存区。</p></blockquote></li></ul><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>首先导入Numpy库，以<code>np</code>为缩写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="基于list或者tuple"><a href="#基于list或者tuple" class="headerlink" title="基于list或者tuple"></a>基于list或者tuple</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组 # 基于list</span></span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>]])</span><br><span class="line">arr2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于tuple</span></span><br><span class="line">arr_tuple = np.array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(arr_tuple)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="基于np-arange"><a href="#基于np-arange" class="headerlink" title="基于np.arange"></a>基于np.arange</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr2 = np.array([np.arange(<span class="number">3</span>), np.arange(<span class="number">3</span>)])</span><br><span class="line">arr2</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h4 id="基于arange以及reshape创建多维数组"><a href="#基于arange以及reshape创建多维数组" class="headerlink" title="基于arange以及reshape创建多维数组"></a>基于arange以及reshape创建多维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建三维数组</span></span><br><span class="line">arr = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br></pre></td></tr></table></figure><p>注意，arange的长度必须与ndarray的维度的乘积要相当，即24 = 2x3x4</p><h3 id="ndarray数组的切片和索引"><a href="#ndarray数组的切片和索引" class="headerlink" title="ndarray数组的切片和索引"></a>ndarray数组的切片和索引</h3><p>一维数组的切片和索引与python的list索引类似。</p><p>二维数组的切片和索引如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/NwlfObo1QXUHmIA.png" alt="二维数组的切片和索引"></p><h3 id="处理数组形状"><a href="#处理数组形状" class="headerlink" title="处理数组形状"></a>处理数组形状</h3><h4 id="堆叠数组"><a href="#堆叠数组" class="headerlink" title="堆叠数组"></a>堆叠数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">c = b*<span class="number">2</span></span><br><span class="line">c</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><ul><li><p>水平叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hstack()</span><br><span class="line">np.hstack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>column_stack()函数以列的方式对数组进行叠加，功能类似hstack()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">column_stack()</span><br><span class="line">np.column_stack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p>垂直叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vstack()</span><br><span class="line">np.vstack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>row_stack()函数以行的方式对数组进行叠加，功能类似vstack()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row_stack()</span><br><span class="line">np.row_stack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p>concatenate()方法，通过设置axis的值来设置叠加方向</p><p>axis=1时，沿水平方向叠加</p><p>axis=0时，沿垂直方向叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">np.concatenate((b,c),axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br><span class="line">np.concatenate((b,c),axis=<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li></ul><p>用示意图来表示如下：</p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/NMeRC6jgBDISpU4.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://i.loli.net/2021/01/07/Gu3YO2cjyAQ9CdR.png" alt=""></p><ul><li><p>深度叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr_dstack = np.dstack((b,c))</span><br><span class="line">print(arr_dstack.shape)</span><br><span class="line">arr_dstack</span><br><span class="line">(<span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">40</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">22</span>]]])</span><br></pre></td></tr></table></figure><p>叠加前，b和c均是shape为(2,6)的二维数组，叠加后，arr_dstack是shape为(2,6,2)的三维数组。</p></li></ul><h4 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h4><p>数组的拆分可以分为横向拆分、纵向拆分和深度拆分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><ul><li><p>横向拆分（axis=1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(b, <span class="number">2</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]]), array([[ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br><span class="line">np.split(b,<span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]]), array([[ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br></pre></td></tr></table></figure></li><li><p>纵向拆分（axis=0）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.vsplit(b, <span class="number">2</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]]), array([[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br><span class="line">np.split(b,<span class="number">2</span>,axis=<span class="number">0</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]]), array([[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br></pre></td></tr></table></figure></li><li><p>深度拆分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">arr_dstack</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">40</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">22</span>]]])</span><br><span class="line">np.dsplit(arr_dstack,<span class="number">2</span>)</span><br><span class="line">[array([[[ <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">1</span>],</span><br><span class="line">         [<span class="number">20</span>],</span><br><span class="line">         [ <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>],</span><br><span class="line">         [<span class="number">11</span>]]]), array([[[ <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">2</span>],</span><br><span class="line">         [<span class="number">40</span>],</span><br><span class="line">         [ <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">8</span>],</span><br><span class="line">         [<span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">12</span>],</span><br><span class="line">         [<span class="number">14</span>],</span><br><span class="line">         [<span class="number">16</span>],</span><br><span class="line">         [<span class="number">18</span>],</span><br><span class="line">         [<span class="number">20</span>],</span><br><span class="line">         [<span class="number">22</span>]]])]</span><br></pre></td></tr></table></figure><p>拆分的结果就是把原来的三维数组拆分成两个二维数组。</p></li></ul><h4 id="数组类型转换"><a href="#数组类型转换" class="headerlink" title="数组类型转换"></a>数组类型转换</h4><ul><li><p>数组转换成list，使用tolist()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.tolist()</span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]</span><br></pre></td></tr></table></figure></li><li><p>转换成指定类型，使用astype()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.astype(float)</span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,  <span class="number">20.</span>,   <span class="number">3.</span>,   <span class="number">4.</span>,   <span class="number">5.</span>],</span><br><span class="line">       [  <span class="number">6.</span>,   <span class="number">7.</span>,   <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure></li></ul><h4 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h4><ul><li><p>reshape()和resize()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">b.reshape(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.resize(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>resize()与reshape()的作用相似，但是resize()会改变所作用的数组</p></li><li><p>ravel()和flatten()，可以将多维数组转换成一维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b.ravel()</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line">b.flatten()</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line">b</span><br><span class="line">array([[ 0,  1,  2],</span><br><span class="line">       [ 3,  4,  5],</span><br><span class="line">       [ 6,  7,  8],</span><br><span class="line">       [ 9, 10, 11]])</span><br></pre></td></tr></table></figure><p>两者的区别在于返回拷贝还是返回视图。即flatten()是返回一份拷贝，需要分配新的内存空间，会影原始矩阵；但ravel()返回的是视图，会影响原始矩阵。</p></li><li><p>用tuple指定数组的形状，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.shape=(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li><li><p>转置</p><p>通过transpose()函数来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b.transpose()</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">20</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li></ul><h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h3><h4 id="np-reshape函数参数-1的意思"><a href="#np-reshape函数参数-1的意思" class="headerlink" title="np.reshape函数参数-1的意思"></a>np.reshape函数参数-1的意思</h4><p>-1表示暂时不知道需要什么数字，但可以通过其他推导出来。即其实可以忽略-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.reshape(a, (<span class="number">3</span>,<span class="number">-1</span>))  <span class="comment"># the unspecified value is inferred to be 2</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>这里的-1即可以忽略，只通过a和3即可推导出-1的实际应为2。</p><p>即把原数组合并在一起成为一个数组，然后分成3行，这样每行就有2列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是两张2*3大小的照片(不知道有几张照片用-1代替)，如何把所有二维照片给摊平成一维</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.reshape((<span class="number">-1</span>, <span class="number">6</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>reshape后分成6列，则12/6=2行。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未来面前，你我都是孩子</title>
      <link href="/2019/10/14/%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%EF%BC%8C%E4%BD%A0%E6%88%91%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90/"/>
      <url>/2019/10/14/%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%EF%BC%8C%E4%BD%A0%E6%88%91%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>70<strong>后或者</strong>60<strong>后的尾巴基本算是造成如今社会阶级分层的一代。他们或通过刚刚恢复的高考成为当时的天之骄子大学生，或头脑活络下海经商赚得第一桶金，总之他们为后辈们所打下的基础是如今这代人仅凭学习或者工作都无法轻易实现的。但是他们也很苦，因为他们小时候正逢国家最苦难的那个时代。</strong></p><a id="more"></a><p>80<strong>后，如今也许都成家立业。他们也不容易，他们赶上了</strong>08<strong>年金融危机，赶上了</strong>09<strong>年一线城市开始高涨的房价，但他们也许还可以在二线城市也就是如今的新一线城市站住脚跟。</strong></p><p><strong>而</strong>90<strong>后，他们既享受着与生俱来的福利，也面临着当今社会的生存挑战。他们自小就至少温饱不愁，衣食无忧，甚至部分已经可以享受拼爹的福利，但也有更多的人，在当他们走出学校这个象牙塔，迈入社会之时，他们可能才发现这座繁华的城市很欢迎你来，却也很难让你一直驻足下去。</strong>16<strong>年二线城市的房价飞涨，让没有提早上车又没有家庭经济基础的部分这代人，生存变得很艰难。并且伴随着国家政策的调控，连三四线城市的房价都一路攀升，或许有一天你会发现连购买你家乡的房子都捉襟见肘。</strong></p><p><strong>当今在大城市的主要职业里，有两个风口，一个是互联网IT，一个是金融。放大一点的话，房地产和教育也很不错。这些都是薪水十分可观的职业。但一些其他的职业，则仅凭薪水可能很难满足。</strong></p><p><strong>尽管生活很艰辛，阶级固化严重，尽管在仅凭十年二十年甚至一代人，就在经济实力和社会地位上跨越一个阶级并不是很轻松的事情，但是如果有方法的努力，前途仍然光明。承认并清醒地认识到自身的缺陷和不足，眼光长远，在适合自己，适合社会的领域深耕，保持自省的状态，未来可期。</strong></p><p><strong>命运如浮萍，飞砂风中转。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配Android7.0以上调取相机拍照并返回照片</title>
      <link href="/2019/04/17/%E9%80%82%E9%85%8DAndroid7.0%E4%BB%A5%E4%B8%8A%E8%B0%83%E5%8F%96%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%85%A7%E7%89%87/"/>
      <url>/2019/04/17/%E9%80%82%E9%85%8DAndroid7.0%E4%BB%A5%E4%B8%8A%E8%B0%83%E5%8F%96%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%85%A7%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>Android调取系统相机拍照获取到拍摄照片或从相册中直接选取照片后展示上传是Android开发中很常见的一个功能，实现的思路主要是：</p><ul><li>自Android 6.0以后对某些涉及用户隐私权限的获取需要动态获取，所以首先是检查权限，如没有权限则动态申请权限，这里我们需要用到的权限是WRITE_EXTERNAL_STORAGE和CAMERA</li><li><p>自Android 7.0后系统禁止应用向外部公开file://URI ，因此需要FileProvider来向外界传递URI</p></li><li><p>获取到拍照后的照片，按照现在的手机拍照文件大小来说不做处理直接展示很容易发生OOM，因此这一步需要对图片做压缩处理</p></li></ul><h3 id="一、动态申请权限"><a href="#一、动态申请权限" class="headerlink" title="一、动态申请权限"></a>一、动态申请权限</h3><p>首先在Mainfest.xml文件中声明权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为拍照需要写入文件 所以需要申请读取内存的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>点击Button模拟拍照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">mBtn.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="comment">// 如果版本大于Android 6.0</span></span><br><span class="line">        <span class="keyword">if</span> (! checkPermission()) &#123;</span><br><span class="line">          <span class="comment">// 如果没有全部权限，则请求权限</span></span><br><span class="line">          requestPermissions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        takePhoto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 检查权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 是否有权限</span></span><br><span class="line">  <span class="keyword">boolean</span> haveCameraPermission = ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">  <span class="keyword">boolean</span> haveWritePermission = ContextCompat.checkSelfPermission(mContext, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">  <span class="keyword">return</span> haveCameraPermission &amp;&amp; haveWritePermission;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.M)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  requestPermissions(<span class="keyword">new</span> String[]&#123;Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_PERMISSION_CODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull  String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">  <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_PERMISSION_CODE:</span><br><span class="line">        <span class="keyword">boolean</span> allowAllPermission = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grantResults.length; i++) &#123;</span><br><span class="line">              <span class="comment">// 被拒绝授权</span></span><br><span class="line">              <span class="keyword">if</span> (grantResults[<span class="number">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                  allowAllPermission = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              allowAllPermission = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (allowAllPermission) &#123;</span><br><span class="line">              takePhotoOrPickPhoto();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Toast.makeText(mContext, <span class="string">"该功能需要授权方可使用"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点击拍照按钮后，调用 <code>ContextCompat.checkSelfPermission( )</code>方法检查是否有权限，方法返回值为0说明已经授权。没授权的情况下，调用<code>requestPermissions( )</code>方法，该方法的第一个参数为一个数组，数组中的值为你要申请的一个或多个权限的值，第二个参数为请求码。</p><p>调用<code>requestPermission( )</code>方法后我们需要在Activity中重写<code>onRequestPermissionsResult()</code>方法，在该方法中会得到回调结果，方法中第一个参数是请求码，第二个参数是我们申请的权限数组，第三个参数数组中每一个值对应申请的每一个权限的返回值，值为0或-1，0代表授权，-1代表拒绝授权。</p><h3 id="二、FileProvider"><a href="#二、FileProvider" class="headerlink" title="二、FileProvider"></a>二、FileProvider</h3><p>在获取所有所需的权限后，我们调取系统相机拍照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 步骤一：创建存储照片的文件</span></span><br><span class="line">  String path = getFilesDir() + File.separator + <span class="string">"images"</span> + File.separator;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path, <span class="string">"test.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.getParentFile().exists())</span><br><span class="line">        file.getParentFile().mkdirs();</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    <span class="comment">// 步骤二：Android 7.0及以上获取文件 Uri </span></span><br><span class="line">      mUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.example.admin.custmerviewapplication"</span>, file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// 步骤三：获取文件Uri</span></span><br><span class="line">     mUri = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">// 步骤四：调取系统拍照</span></span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, mUri);</span><br><span class="line">    startActivityForResult(intent, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android 7.0之前我们只需要步骤一、三、四即可调取系统相机拍照，在此之后的话直接这么调取会报<code>android.os.FileUriExposedException</code>异常。所以我们需要对Android 7.0及以后的机型适配，采用FileProvider方式。</p><h4 id="1-FileProvider是什么"><a href="#1-FileProvider是什么" class="headerlink" title="1. FileProvider是什么"></a>1. FileProvider是什么</h4><p>FileProvider是ContentProvider的一个子类，用于应用程序之间私有文件的传递。自Android 7.0后系统禁止应用向外部公开file://URI ，因此需要FileProvider来向外界传递URI，传递的形式是content : //Uri，使用时需要在清单文件中注册。</p><h4 id="2-注册清单文件"><a href="#2-注册清单文件" class="headerlink" title="2. 注册清单文件"></a>2. 注册清单文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.example.admin.custmerviewapplication"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释上面provider标签的意思：</p><p><strong>name</strong> 因为我们使用的是V4包下的FileProvider ，所以name的值就是V4包下FileProvider的相对路径值。当然我们也可以自定义类继承于FileProvider，这时候name的值就是我们自定义类的相对路径了</p><p><strong>authorities</strong> 可以理解为标识符，是我们自己自定义的。我们代码中调用getUriForFile方法获取Uri时第二个参数就是这里我们定义的值</p><p><strong>exported</strong> 代表是否可以输出被外部程序使用，填false就行</p><p><strong>android:grantUriPermissions</strong> 是否允许为文件授予临时权限，必须为true</p><p><strong><meta-data></strong> 标签里配置的内容是用来指定那个文件夹下的文件是可被共享的</p><p><strong>name</strong> 为固定的值android.support.FILE_PROVIDER_PATHS</p><p><strong>path</strong> 是对应的xml文件路径，@xml/file_paths代表在xml文件下的file_paths文件</p><h4 id="3-指定可共享的文件路径"><a href="#3-指定可共享的文件路径" class="headerlink" title="3. 指定可共享的文件路径"></a>3. <strong>指定可共享的文件路径</strong></h4><p>在res目录下新建一个xml文件夹，在文件夹下创建一个名为file_paths的xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--files-path  相当于 getFilesDir（）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--cache-path  相当于 getCacheDir（）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"lalala"</span> <span class="attr">path</span>=<span class="string">"cache_image"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--external-path  相当于 Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attr">external-path</span>  <span class="attr">name</span>=<span class="string">"hahaha"</span> <span class="attr">path</span>=<span class="string">"comeOn"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--external-files-path  相当于 getExternalFilesDir("") --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"paly"</span> <span class="attr">path</span>=<span class="string">"freeSoft"</span>/&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--external-cache-path  相当于 getExternalCacheDir（） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span>  <span class="attr">name</span>=<span class="string">"lei"</span> <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>files-path所代表的路径等于getFilesDir()，打印getFileDir( )它的路径是 /data/user/0/包名/files。什么意思呢，<code>&lt;files-path name=&quot;my_images&quot; path=&quot;images&quot;/&gt;</code>的意思就是<code>/data/user/0/包名/files + &quot;/files-path标签中path的值/&quot;</code>路径下的文件是可共享的，在生成Uri时name的值my_images会替代上面的路径<code>/data/user/0/包名/files / images /</code>向外暴露。最终的Uri会是<code>content : //com.example.admin.custmerviewapplication / my_images / test.jpg</code></p><h3 id="三、图片获取并压缩"><a href="#三、图片获取并压缩" class="headerlink" title="三、图片获取并压缩"></a>三、图片获取并压缩</h3><p>我们调用<code>startActivityForResult(intent, 101);</code>进行拍照，拍照结束后会回调onActivityResult( )方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_TAKE_PHOTO_CODE) &#123;</span><br><span class="line">      <span class="comment">// 获取系统照片上传</span></span><br><span class="line">        Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bm = getBitmapFormUri(mUri);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        mImageView.setImageBitmap(bm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Uri直接获取图片加载到内存然后显示在ImageView很容易发生OOM，所以还需做进一步的图片压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFormUri</span><span class="params">(Uri uri)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">  InputStream input = getContentResolver().openInputStream(uri);</span><br><span class="line">    <span class="comment">// 这一段代码是不加载文件到内存中也得到bitmap的真是宽高，主要是设置inJustDecodeBounds为true</span></span><br><span class="line">    BitmapFactory.Options onlyBoundsOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    onlyBoundsOptions.inJustDecodeBounds = <span class="keyword">true</span>;<span class="comment">//不加载到内存</span></span><br><span class="line">    onlyBoundsOptions.inDither = <span class="keyword">true</span>;<span class="comment">//optional</span></span><br><span class="line">    onlyBoundsOptions.inPreferredConfig = Bitmap.Config.RGB_565;<span class="comment">//optional</span></span><br><span class="line">    BitmapFactory.decodeStream(input, <span class="keyword">null</span>, onlyBoundsOptions);</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">int</span> originalWidth = onlyBoundsOptions.outWidth;</span><br><span class="line">    <span class="keyword">int</span> originalHeight = onlyBoundsOptions.outHeight;</span><br><span class="line">    <span class="keyword">if</span> ((originalWidth == -<span class="number">1</span>) || (originalHeight == -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">// 图片分辨率以480x800为标准</span></span><br><span class="line">    <span class="keyword">float</span> hh = <span class="number">800f</span>;<span class="comment">// 这里设置高度为800f</span></span><br><span class="line">    <span class="keyword">float</span> ww = <span class="number">480f</span>;<span class="comment">// 这里设置宽度为480f</span></span><br><span class="line">    <span class="comment">// 缩放比，由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可</span></span><br><span class="line">    <span class="keyword">int</span> be = <span class="number">1</span>;<span class="comment">// be=1表示不缩放</span></span><br><span class="line">    <span class="keyword">if</span> (originalWidth &gt; originalHeight &amp;&amp; originalWidth &gt; ww) &#123;</span><br><span class="line">      <span class="comment">// 如果宽度大的话根据宽度固定大小缩放</span></span><br><span class="line">        be = (<span class="keyword">int</span>) (originalWidth / ww);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originalWidth &lt; originalHeight &amp;&amp; originalHeight &gt; hh) &#123;</span><br><span class="line">      <span class="comment">// 如果高度高的话根据宽度固定大小缩放</span></span><br><span class="line">      be = (<span class="keyword">int</span>) (originalHeight / hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (be &lt;= <span class="number">0</span>)</span><br><span class="line">      be = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">// 比例压缩</span></span><br><span class="line">    BitmapFactory.Options bitmapOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    bitmapOptions.inSampleSize = be;</span><br><span class="line">  <span class="comment">// 设置缩放比例</span></span><br><span class="line">    bitmapOptions.inDither = <span class="keyword">true</span>;</span><br><span class="line">    bitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">    input = getContentResolver().openInputStream(uri);</span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeStream(input, <span class="keyword">null</span>, bitmapOptions);</span><br><span class="line">    input.close();</span><br><span class="line">truetrue<span class="keyword">return</span> compressImage(bitmap);<span class="comment">// 再进行质量压缩</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">compressImage</span><span class="params">(Bitmap image)</span> </span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    image.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, baos);</span><br><span class="line">    <span class="comment">// 质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中</span></span><br><span class="line">    <span class="keyword">int</span> options = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (baos.toByteArray().length / <span class="number">1024</span> &gt; <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">// 循环判断如果压缩后图片是否大于100kb,大于继续压缩</span></span><br><span class="line">        baos.reset();<span class="comment">// 重置baos即清空baos</span></span><br><span class="line">        <span class="comment">// 第一个参数 ：图片格式 ，第二个参数： 图片质量，100为最高，0为最差  ，第三个参数：保存压缩后的数据的流</span></span><br><span class="line">        image.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">      <span class="comment">// 这里压缩options，把压缩后的数据存放到baos中</span></span><br><span class="line">        options -= <span class="number">10</span>;<span class="comment">//每次都减少10</span></span><br><span class="line">        <span class="keyword">if</span> (options &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ByteArrayInputStream isBm = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">  <span class="comment">// 把压缩后的数据baos存放到ByteArrayInputStream中</span></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeStream(isBm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">// 把ByteArrayInputStream数据生成图片</span></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩的步骤分为两步，第一步是先得到bitmap的真实宽高计算压缩比例，得到压缩比例后进行初步压缩。第二步将初步压缩的bitmap进行质量压缩得到最终的图片。</p><p>从相册中选取图片步骤和调取相机拍照的步骤一致，只是创建的intent和在onActivtyResult回调时获取的Uri不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用相册</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_UR）;</span><br><span class="line">startActivityForResult(intent, PICK_IMAGE_CODE);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">  <span class="comment">//获取图片路径</span></span><br><span class="line">  <span class="keyword">if</span> (requestCode == <span class="number">102</span> &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; data != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//通过getData获取到Uri</span></span><br><span class="line">      mUri = data.getData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多媒体技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android1.5到Android10.0经历的新特性</title>
      <link href="/2019/02/28/Android1.5%E5%88%B0Android10.0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/02/28/Android1.5%E5%88%B0Android10.0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="Android-1-5-Cupcake-纸杯蛋糕"><a href="#Android-1-5-Cupcake-纸杯蛋糕" class="headerlink" title="Android 1.5(Cupcake 纸杯蛋糕)"></a>Android 1.5(Cupcake 纸杯蛋糕)</h3><ul><li>智能虚拟键盘；<strong>使用widgets实现桌面个性化</strong>；在线文件夹(Live Folder)快速浏览在线数据；视频录制和分享；图片上传；</li><li>更快的标准兼容浏览器；Voice search 语音搜索；立体声蓝牙和免提电话</li></ul><a id="more"></a><h3 id="Android-1-6-Donut-甜甜圈"><a href="#Android-1-6-Donut-甜甜圈" class="headerlink" title="Android 1.6(Donut 甜甜圈)"></a>Android 1.6(Donut 甜甜圈)</h3><ul><li>完全重新设计的Android Market，可以显示更多的屏幕截图；手势支持，可以让开发者生成针对某个应用程序的手势库</li><li>支持CDMA网络</li><li>TXT-2-Speech，支持了更多语言的发音，包括英语、法语、德语、意大利语等</li><li><strong>快速搜索框，可直接搜索括联系人，音乐，浏览历史，书签等手机内容</strong></li><li>全新的拍照界面：新版相机程序启动速度快了39%，拍照间的延迟减少了28%</li><li><strong>应用程序耗电查看</strong></li><li>新增面向视觉或听觉困难人群的易用性插件</li><li>Linux内核升级到2.6.29</li><li>支持更多的屏幕分辨率</li></ul><h3 id="Android-2-0-2-0-2-1-Eclair-松饼（闪电泡芙）"><a href="#Android-2-0-2-0-2-1-Eclair-松饼（闪电泡芙）" class="headerlink" title="Android 2.0(2.0~2.1 Eclair 松饼（闪电泡芙）)"></a>Android 2.0(2.0~2.1 Eclair 松饼（闪电泡芙）)</h3><ul><li>加强了网络社交功能，比如Facebook好友整合至联系人功能</li><li>自带的Chrome Lite浏览器现在加入了对双击屏幕进行缩放的支持</li><li>由于文件结构的改动优化，使得整个操作流畅性得到了很大的提升</li><li>强化了语音识别的搜索控制。整个系统多处都支持语音控制，并拥有独立的控制面板</li><li>谷歌地图服务更新，加入了全新的导航系统</li><li>加入了原生微软Exchange邮件服务支持</li><li>提供了多个不同帐户，统一的邮件收件箱</li><li>优化了驾车时的体验，新的“Car Home”应用程序为各功能提供了易于操作的快捷链接，还能方便地使用语音控制功能，便于用户驾车时使用</li></ul><h3 id="Android-2-1"><a href="#Android-2-1" class="headerlink" title="Android 2.1"></a>Android 2.1</h3><ul><li>可以同时绑定多个Google账号</li><li>无线控件里有了VPN设置</li><li>增加了连接到PC设置</li><li>增强了语言和声音的转换功能，并加入了文字到语音转换</li><li>全新的拨号界面，按键更大，更易于操作</li><li>更多桌面Widget</li><li>新的Google地图可以使用谷歌地图导航功能</li><li>新的浏览器版本，加强了稳定性和网页渲染能力</li><li>全局搜索功能加强</li><li>全新的Market程序，搜索更快布局更合理</li></ul><h3 id="Android-2-2-Froyo-冻酸奶"><a href="#Android-2-2-Froyo-冻酸奶" class="headerlink" title="Android 2.2(Froyo 冻酸奶)"></a>Android 2.2(Froyo 冻酸奶)</h3><ul><li>全面支持Flash 10.1</li><li><strong>应用程序自动升级</strong>，让升级更加人性化</li><li><strong>支持应用程序安装在外置内存上</strong></li><li>对系统性能进一步优化，让手机有更多的运行内存</li><li>增加了轨迹球LED指示灯变色这个新功能</li><li>增加了对3D性能的优化，3D性能更加强大</li><li>FM功能也将在新系统中得到全面支持</li></ul><h3 id="Android-2-3-Gingerbread-姜饼"><a href="#Android-2-3-Gingerbread-姜饼" class="headerlink" title="Android 2.3(Gingerbread 姜饼)"></a>Android 2.3(Gingerbread 姜饼)</h3><ul><li><strong>原生支持前置摄像头</strong></li><li>全新虚拟键盘</li><li>全局下载管理</li><li>NFC近场通信</li><li>改善电源管理</li><li>增加官方进程管理</li><li>提升多媒体能力</li><li>提升游戏体验</li><li>用户界面更美观</li></ul><h3 id="Android-3-0到3-1-3-0-Honeycomb-蜂巢"><a href="#Android-3-0到3-1-3-0-Honeycomb-蜂巢" class="headerlink" title="Android 3.0到3.1(3.0 Honeycomb 蜂巢)"></a>Android 3.0到3.1(3.0 Honeycomb 蜂巢)</h3><p>安卓3.0系统主要用于安卓的平板产品</p><h3 id="Android-4-0-Ice-CreamSandwich"><a href="#Android-4-0-Ice-CreamSandwich" class="headerlink" title="Android 4.0(Ice CreamSandwich)"></a>Android 4.0(Ice CreamSandwich)</h3><ul><li><strong>一流的新UI</strong></li><li>开源</li></ul><h3 id="Android-5-0-Lollipop-棒棒糖"><a href="#Android-5-0-Lollipop-棒棒糖" class="headerlink" title="Android 5.0(Lollipop 棒棒糖)"></a>Android 5.0(Lollipop 棒棒糖)</h3><ul><li>通过Android Market购买音乐</li><li>多核处理器优化</li><li><strong>支持现有的智能手机</strong></li><li>为OEM提供了官方的主题引擎</li></ul><h3 id="Android-6-0-Marshmallow-棉花糖"><a href="#Android-6-0-Marshmallow-棉花糖" class="headerlink" title="Android 6.0(Marshmallow 棉花糖)"></a>Android 6.0(Marshmallow 棉花糖)</h3><ul><li>锁屏下语音搜索</li><li><strong>原生指纹识别</strong></li><li><strong>更完整的应用权限管理</strong></li><li>Doze电量管理</li><li>Now on Tap功能</li><li><strong>App Links</strong></li><li><strong>Android Pay</strong></li></ul><h3 id="Android-7-0-Nougat-牛轧糖"><a href="#Android-7-0-Nougat-牛轧糖" class="headerlink" title="Android 7.0(Nougat 牛轧糖)"></a>Android 7.0(Nougat 牛轧糖)</h3><ul><li><strong>分屏多任务</strong></li><li>全新下拉快捷开关页</li><li><strong>通知消息快捷回复</strong></li><li><strong>通知消息归拢</strong></li><li><strong>夜间模式</strong></li><li>流量保护模式</li><li>全新设置样式</li><li>改进的Doze休眠机制</li><li>系统级电话黑名单功能</li><li><strong>双击菜单键快速应用切换</strong></li></ul><h3 id="Android-8-0-Oreo-奥利奥"><a href="#Android-8-0-Oreo-奥利奥" class="headerlink" title="Android 8.0(Oreo 奥利奥)"></a>Android 8.0(Oreo 奥利奥)</h3><ul><li>通知中心</li><li>设置菜单</li><li><strong>PinnedShortcuts</strong>，类似iOS中的3D Touch</li><li><strong>图标形状</strong></li><li>后台限制</li><li>安装限制</li><li><strong>TensorFlowLite</strong></li><li>NotificationDots</li><li>分屏</li><li>SmartTextSelection</li><li><strong>自动保存密码</strong></li><li>GooglePlayProtect，主要用于Google Play中，下载的应用和游戏将会经过它的排查，来看看是否是有害甚至携带病毒的应用</li><li>应用加速</li><li>字体优化</li><li>表情符号</li></ul><h3 id="Android-9-0-Pie-派"><a href="#Android-9-0-Pie-派" class="headerlink" title="Android 9.0(Pie 派)"></a>Android 9.0(Pie 派)</h3><ul><li><strong>全面屏的全面支持</strong></li><li>通知栏的多种通知</li><li>多摄像头的更多画面</li><li>GPS定位之外的WiFi定位</li><li>神经网络</li><li><strong>Material Design 2.0</strong></li><li>全局黑夜模式</li></ul><h3 id="Android-10-0"><a href="#Android-10-0" class="headerlink" title="Android 10.0"></a>Android 10.0</h3><ul><li><strong>暗黑模式</strong>，在 Android Q 中，暗黑模式适用于任何地方，如果应用不支持暗黑模式，那么系统将自动设置一个暗黑模式</li><li>隐私增强</li><li>运营商锁定</li><li>多显示器支持</li><li><strong>原生面部识别</strong></li><li><strong>桌面模式</strong></li><li><strong>原生屏幕录制</strong></li><li><strong>更安全Smart Lock</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬家前一周</title>
      <link href="/2018/11/22/%E6%90%AC%E5%AE%B6%E5%89%8D%E4%B8%80%E5%91%A8/"/>
      <url>/2018/11/22/%E6%90%AC%E5%AE%B6%E5%89%8D%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>因为各种原因，我过完这周就要搬离这个我生活了两个多月的小家了。毕竟，在这里也呆了两个多月，也结识了很nice的室友，交通也还算便利，但是，终究要离开了。</p><a id="more"></a><p>并不是说有多么的不舍，因为我还有更重要的事情需要去完成。况且，离开的结局也不是很好，毕竟是自己租期未满就提前走的，押金也无法拿回来，可以勉强算是被房东赶走的，所以并不是多么一个开心的过程。</p><p>我住在13楼。窗外就是大上海，虽然我面对的并不是繁华的市中心，但是毕竟还身处中环以内，那川流不息的车辆还是让我感觉到大城市所独特的气息。</p><p>上班时，坐地铁也就20多分钟，有时挤，有时不挤。相比某些深处外环，每天通勤时间长达三小时以上的工薪族来说，我还勉强算的上幸福。</p><p>工作的压力当然是有的。本以为实习也不会做什么艰巨的任务，主要是以培养为主。但显然这只适用于那么规模较大的公司。对于我所加入的这家创业7年，有过巅峰时期，而现在处于低谷的小公司而言，人手尚且不足，那么实习生也要求能够迅速地上手完成公司的项目。</p><p>这样有好处，当然也有坏处的。好处就是让你迅速上手完成公司项目的话，对人的阅读源码的能力要求比较高，也就是锻炼了实际写代码的能力。但是坏处也是创业公司的通病，因为需要立刻上线产品，所以在很多方面就不是那么的规范。对于有多年经验的老手来说倒是无所谓，但是对于实习生而言，还是尽量加入一家大公司，有着更完善的制度，代码也更加规范，对于今后的成长更加有帮助。</p><p>还是非常感谢这家公司能够让我加入团队。毕竟自己经历过实习，也意识到自己有太多的不足了。很多方面，我都是浅尝辄止，而没有深挖内在的原理。也正是这段实习经历，让我感到在学校里学到的很多基础学科其实大有帮助，只有将基础打牢，才能够更进一步。</p><p>作为一个还处于大四、尚未完全走出象牙塔的学生，我在某些方面仍然非常的稚嫩，包括心理的调整。毕竟身处中国最大的城市，又从事着程序员这种辛苦的职业，再加上自己现在的能力不足，很容易信心不足，产生动摇。但好在我终于挺过来了。</p><p>我觉得我从来不缺对于局势的判断能力，但我缺少的是对于某件事情攻无不克的决心。</p><p>希望今后的自己也能够更加出色吧。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android属性动画详解（转载）</title>
      <link href="/2018/11/05/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2018/11/05/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="一、属性动画出现的原因"><a href="#一、属性动画出现的原因" class="headerlink" title="一、属性动画出现的原因"></a>一、属性动画出现的原因</h2><p>属性动画（Property Animation）是Android3.0（API11）之后的版本中才提供的一种全新的动画模式</p><h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>实现动画效果在Android开发中非常常见，所以Android系统提供了两种实现动画的方式：</p><ul><li>逐帧动画（Frame Animation）</li><li>补间动画（Tweened Animation）</li></ul><a id="more"></a><h3 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h3><ul><li>补间动画只能够作用在视图View上，即只可以对一个Button、TextView或者LinearLayout或者其它继承自View的组件进行动画操作，但无法对非View的对象进行动画操作</li><li>没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，但不会真正改变View的属性。比如通过补间动画将屏幕左上角的按钮移动到右上角，但是点击屏幕右上角仍然是没有反应的，因为实际上按钮仍然在左上角，补间动画只是将其绘制到了屏幕右上角，改变了视觉效果而已</li><li>动画效果单一。补间动画只能实现平移、旋转、缩放和透明度等简单的动画需求，对于复杂的动画效果，补间动画无法实现</li></ul><h2 id="二、属性动画简介"><a href="#二、属性动画简介" class="headerlink" title="二、属性动画简介"></a>二、属性动画简介</h2><ul><li>作用对象：任意Java对象，不再局限于视图View对象</li><li>实现的动画效果：可以自定义各种动画效果，不再局限于4种基本变换</li></ul><h2 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h2><ul><li>在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果</li><li>具体的工作原理逻辑如下：</li><li>从上述工作原理中可以看出属性动画有两个非常重要的类：ValueAnimator类和ObjectAnimator类</li></ul><h2 id="四、使用方法"><a href="#四、使用方法" class="headerlink" title="四、使用方法"></a>四、使用方法</h2><h3 id="ValueAnimator类"><a href="#ValueAnimator类" class="headerlink" title="ValueAnimator类"></a>ValueAnimator类</h3><ul><li>定义：属性动画机制中，最核心的一个类</li><li>实现动画的原理：通过不断控制值的变化，再不断手动赋给对象的属性，从而实现动画效果</li><li>ValueAnimator类中有3个主要方法：<ul><li><code>ValueAnimator.ofInt(int values)</code></li><li><code>ValueAnimator.ofFloat(float values)</code></li><li><code>ValueAnimator.ofObject(int values)</code></li></ul></li></ul><h3 id="1-valueAnimator-ofInt-int-values"><a href="#1-valueAnimator-ofInt-int-values" class="headerlink" title="1.valueAnimator.ofInt(int values)"></a>1.valueAnimator.ofInt(int values)</h3><p>Java代码设置：<br>在实际开发中，建议使用Java代码实现属性动画，因为大多数情况下，属性的起始值是无法提前确定的（无法使用XML设置）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 步骤1：设置动画属性的初始值和结束值</span></span><br><span class="line">ValueAnimator anim = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">// ofInt()的作用有两个</span></span><br><span class="line"><span class="comment">// 1.创建动画实例</span></span><br><span class="line"><span class="comment">// 2.将传入的多个Int参数进行平滑过渡：此处传入0和3，表示将值从0平滑过渡到3</span></span><br><span class="line"><span class="comment">// 如果传入了3个参数a、b、c，则是先从a平滑过渡到b，再从b平滑过渡到c，以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤2：设置动画的各种播放属性</span></span><br><span class="line"><span class="comment">// 设置动画运行的时长</span></span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 设置动画延迟播放时间</span></span><br><span class="line">anim.setStartDelay(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">// 设置动画重复播放次数 = 重放次数 + 1</span></span><br><span class="line"><span class="comment">// 动画播放次数 = infinite时，动画无限重复</span></span><br><span class="line">anim.setRepeatCount(<span class="number">0</span>);</span><br><span class="line"><span class="comment">// 设置重复播放动画模式</span></span><br><span class="line"><span class="comment">// RESTART（默认）：正序播放</span></span><br><span class="line">anim.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line"><span class="comment">// REVERSE：倒序回放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 步骤3：将改变的值手动赋值给对象的属性值：</span></span><br><span class="line"><span class="comment">// 通过动画的更新监听器，设置值的更新监听器</span></span><br><span class="line"><span class="comment">// 即值每次改变、变化一次，该方法就会调用一次</span></span><br><span class="line">anim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 获得改变后的值</span></span><br><span class="line">    <span class="keyword">int</span> currentValue = (Integer) animation.getAnimatedValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 步骤4：将改变后的值赋给对象的属性值</span></span><br><span class="line">    View.setProperty(currentValue);</span><br><span class="line">    <span class="comment">// 步骤5：刷新视图，即重新绘制，从而实现动画效果</span></span><br><span class="line">    View.requestLaytout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p><p>XML布局文件设置：</p><ul><li>步骤1：在路径res/animator文件夹中创建相对应的动画.xml文件</li><li>步骤2：设置动画参数<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animator</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueFrom</span>=<span class="string">"0"</span>         // 初始值</span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueTo</span>=<span class="string">"100"</span>         // 结束值</span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueType</span>=<span class="string">"intType"</span>   // 变化值类型：<span class="attr">floatType</span> &amp; <span class="attr">intType</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">android:duration</span>=<span class="string">"3000"</span>       // 动画持续时间（<span class="attr">ms</span>），必须设置，动画才有效果</span></span><br><span class="line"><span class="tag">  <span class="attr">android:startOffset</span>=<span class="string">"1000"</span>    // 动画延迟开始时间（<span class="attr">ms</span>）</span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillBefore</span>=<span class="string">"true"</span>     // 动画播放完后，视图是否会停留在动画开始的状态，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillAfter</span>=<span class="string">"false"</span>     // 动画播放完后，视图是否会停留在动画结束的状态，优先于<span class="attr">fillBefore</span>值，默认为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillEnabled</span>=<span class="string">"true"</span>    // 是否使用<span class="attr">fillBefore</span>值，对<span class="attr">fillAfter</span>值无影响，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:repeatMode</span>=<span class="string">"restart"</span>  // 选择重复播放动画模式，<span class="attr">restart</span>代表正序播放，<span class="attr">reverse</span>代表倒序回放，默认为<span class="attr">restart</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:repeatCount</span>=<span class="string">"0"</span>       // 重复次数（动画的播放次数=<span class="string">重复次数+1），为infinite时无限重复</span></span></span><br><span class="line"><span class="tag">  //插值器，影响动画的播放速度</span></span><br><span class="line"><span class="tag">  <span class="attr">android:interpolator</span>=<span class="string">@[package:]anim/interpolator_resource</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure>步骤3：在Java代码中启动动画<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 载入XML动画</span></span><br><span class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.animation);</span><br><span class="line"><span class="comment">// 设置动画对象</span></span><br><span class="line">animator.setTarget(view);</span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-valueAnimator-ofInt-float-values"><a href="#2-valueAnimator-ofInt-float-values" class="headerlink" title="2.valueAnimator.ofInt(float values)"></a>2.valueAnimator.ofInt(float values)</h3><p>在使用上与ValueAnimator.ofInt(int values)完全没有区别</p><h3 id="3-valueAnimator-ofObject"><a href="#3-valueAnimator-ofObject" class="headerlink" title="3.valueAnimator.ofObject()"></a>3.valueAnimator.ofObject()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建初始动画时对象 &amp; 结束动画时的对象</span></span><br><span class="line">Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建动画对象 &amp; 设置参数</span></span><br><span class="line"><span class="comment">// 参数说明</span></span><br><span class="line"><span class="comment">// 参数1：自定义的估值器对象（TypeEvaluator类型参数）</span></span><br><span class="line"><span class="comment">// 参数2：初始动画的对象</span></span><br><span class="line"><span class="comment">// 参数3：结束动画的对象</span></span><br><span class="line">ValueAnimator anim = ValueAnimator.ofObject(<span class="keyword">new</span> objectEvaluator(), object1, object2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 设置动画属性</span></span><br><span class="line">anim.setDuration(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">// 启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><h3 id="ObjectAnimator类"><a href="#ObjectAnimator类" class="headerlink" title="ObjectAnimator类"></a>ObjectAnimator类</h3><h4 id="实现动画的原理"><a href="#实现动画的原理" class="headerlink" title="实现动画的原理"></a>实现动画的原理</h4><p>直接对对象的属性值进行改变操作，从而实现动画效果</p><h4 id="ValueAnimator类与ObjectAnimator类的区别"><a href="#ValueAnimator类与ObjectAnimator类的区别" class="headerlink" title="ValueAnimator类与ObjectAnimator类的区别"></a>ValueAnimator类与ObjectAnimator类的区别</h4><ul><li>ValueAnimator类是先改变值，然后手动赋值给对象的属性从而实现动画；是间接对对象属性进行操作</li><li>ObjectAnimator类是先改变值，然后自动赋值给对象的属性从而实现动画；是直接对对象属性进行操作</li></ul><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>Java设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(Object object, String property, <span class="keyword">float</span> ...values);</span><br><span class="line">anim.setDuration(<span class="number">500</span>);</span><br><span class="line">anim.setStartDelay(<span class="number">500</span>);</span><br><span class="line">anim.setRepeatCount(<span class="number">0</span>);</span><br><span class="line">anim.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>XML设置与ValueAnimator一样</p><p>a.透明度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">// 动作作用的对象是mButton</span></span><br><span class="line"><span class="comment">// 动画作者的对象的属性是透明度alpha</span></span><br><span class="line"><span class="comment">// 动画效果是：常规 - 全透明 - 常规</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>b.旋转：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">// 动作作用的对象是mButton</span></span><br><span class="line"><span class="comment">// 动画作者的对象的属性是旋转rotation</span></span><br><span class="line"><span class="comment">// 动画效果是：0 - 360</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>c.平移：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">// 获得当前控件的位置</span></span><br><span class="line"><span class="keyword">float</span> curTranslationX = mButton.getTranslationX();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画作用的对象的属性是X轴平移，translationX</span></span><br><span class="line"><span class="comment">// 在Y轴上平移同理，采用属性translationY</span></span><br><span class="line"><span class="comment">// 动画效果：从当前位置平移到x=300，再平移到初始位置</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"translationX"</span>, curTranslationX, <span class="number">300</span>, curTranslationX);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>d.缩放：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 动画作用的对象的属性是X轴缩放，sacleX</span></span><br><span class="line"><span class="comment">// 在Y轴上缩放同理，采用属性scaleY</span></span><br><span class="line"><span class="comment">// 动画效果：放大到3倍，再缩小到原始大小</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"scaleX"</span>, <span class="number">1f</span>, <span class="number">3f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th><th style="text-align:center">数值类型</th></tr></thead><tbody><tr><td style="text-align:center">Alpha</td><td style="text-align:center">控制View的透明度</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">TranslationX</td><td style="text-align:center">控制X方向的位移</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">TranslationY</td><td style="text-align:center">控制Y方向的位移</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">ScaleX</td><td style="text-align:center">控制X方向的缩放倍数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">ScaleY</td><td style="text-align:center">控制Y方向的缩放倍数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">Rotation</td><td style="text-align:center">控制以屏幕方向为轴的旋转度数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">RotationX</td><td style="text-align:center">控制以X轴为轴的旋转度数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">RotationY</td><td style="text-align:center">控制以Y轴为轴的旋转度数</td><td style="text-align:center">float</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫长旅途</title>
      <link href="/2018/01/15/%E6%BC%AB%E9%95%BF%E6%97%85%E9%80%94/"/>
      <url>/2018/01/15/%E6%BC%AB%E9%95%BF%E6%97%85%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p>象征着父母的鲸鱼在童年陪我们嬉戏，虽然曾一度消失，但在我们被障碍物挡住的时候再度出现，帮助我们度过困难，其实父母一直在我们身后，就如同我们和爱人跟在自己的孩子身后一样。</p><p>当爱人永远留在了草丛中无法唤醒之后，人生的旅途变得孤单漫长寂寞，最后孩子的挽留也无法阻挡我们逝去的脚步。</p><p>当一生走到尽头的时候，正如作家毕淑敏所说的，人行将就木的时候，一生的轨迹会像微缩电影一样迅速放过，温馨的糖果盒里的童年，生如夏花般美好的青春，独自闯荡的不羁无畏，爱情的火花，得子的喜悦与责任……都如同精心剪裁的电影片段匆匆走过。</p><p>是的，每个人的一生都是短暂的，来时什么都是没有，走时什么也不带走，但当自己一生的电影一放而过时，弥留之际的最后留下的幸福是满足，那此生足矣。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独者的任务是加倍孤独</title>
      <link href="/2018/01/13/%E5%AD%A4%E7%8B%AC%E8%80%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%8A%A0%E5%80%8D%E5%AD%A4%E7%8B%AC/"/>
      <url>/2018/01/13/%E5%AD%A4%E7%8B%AC%E8%80%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%8A%A0%E5%80%8D%E5%AD%A4%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<p>天色稍有嫌疑，就要带上雨伞。</p><p>停电了，打开手机，打开电脑，出于本能的赶走黑暗。</p><p>是的，一直没有变，只是心里清楚，独居的时候，没有谁会来照顾自己。</p><p>需要沦落到赞美孤独的地步吗？</p><p>绝不。</p><p>赞美人性中的孤独，</p><p>等于什么也没有赞美。</p><p>但还可以继续努力吗？ </p><p>可以的。 </p><p>即使独自生活，也要努力照顾好自己。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月长明——记北齐咸阳王斛律光</title>
      <link href="/2018/01/07/%E6%9C%88%E9%95%BF%E6%98%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%8C%97%E9%BD%90%E5%92%B8%E9%98%B3%E7%8E%8B%E6%96%9B%E5%BE%8B%E5%85%89/"/>
      <url>/2018/01/07/%E6%9C%88%E9%95%BF%E6%98%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%8C%97%E9%BD%90%E5%92%B8%E9%98%B3%E7%8E%8B%E6%96%9B%E5%BE%8B%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>与诸多良将一样，他亦是年少成名。当年在洹桥的那一箭划破苍穹时，便注定了他必不平凡的命运。</p><p>几番浴血疆场，出生入死，为的就是他心中至死不曾相负的国家。</p><p>从涡河之岸逞强失利的懵懂少年到所过之处闻风丧胆的北齐战神，他一直都是他。</p><p>以自身耀眼的明月光守护着一个国家，无论国之兴衰，无论是成是败。</p><p>可是到了最后，他辅佐的最后一位君主，这个国家的倒数第二位主人，竟同朝堂奸佞一道谋害、背弃他。</p><p>生命的最后一刻，他方才明白，这个国家现在的君主最忌惮的便是他。</p><p>可这又如何呢，在他的心里，对这个国家所做的一切永远都是值得的，无论国家对他如何、对他的家人如何。</p><p>当御用刽子手刘桃枝将弓弦紧累上他脖子的那一刻，这位不可一世的咸阳王竟无半点反抗。只是轻蔑地向身后数人瞟了一眼，拼尽最后一丝力气说出此生的最后一句话：“<strong>我不负国家</strong>”。</p><p>“不负国家”是对他一生最恰当的结语。凭这四个字，便足以将他摆在我最敬重之人的首位。如今千年光景已逝，为他留下的唯有一块难辨伪真的冰冷碑坟，和苍穹之上的清冷凉月。</p><p>他是北齐书中最耀眼的明月光，千载之后，洗尽铅华，唯余最初守望家国的明亮。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
