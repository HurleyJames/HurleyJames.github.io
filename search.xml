<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>141.Linked List Cycle</title>
      <link href="/2020/11/05/141.Linked-List-Cycle/"/>
      <url>/2020/11/05/141.Linked-List-Cycle/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个链表，判断链表中是否有环。</p></blockquote><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/LinkedListRing.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/LinkedListRing.java</a></p><p>这个题目可以衍生为三个问题。</p><ol><li>判断一个带头节点的单链表L是否有环</li><li>假如有环，找出环的入口节点</li><li>求环的长度</li></ol><p>要判断单链表是否有环，肯定要判断两个指针是否相等。可以用到「<strong>快慢指针法</strong>」。设置两个指针fast和slow，都是从头节点触发往后走，slow每次走一步，fast每次走两步，这两个指针一直往后面走，直到后面fast为空，则说明单链表没有环。如果直到fast走到与slow相等，则说明单链表有环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">hasRing</span><span class="params">(LNode l)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 都指向头节点开始</span></span><br><span class="line">    LNode p = head;</span><br><span class="line">    LNode q = head;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 快指针</span></span><br><span class="line">        q = q.next.next;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 慢指针</span></span><br><span class="line">    p = p.next;</span><br><span class="line">    <span class="keyword">while</span> (q != p) &#123;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="keyword">null</span> &amp;&amp; q.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">            q = q.next.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        p = p.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 当p=q时，说明相遇，则有环</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>寻找入口节点则是在上面的程序后添加</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (head != p) &#123;</span><br><span class="line">    p = p.next;</span><br><span class="line">    head = head.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> p;</span><br></pre></td></tr></table></figure><p>求环的长度是在找到入口节点后，再绕一圈回到入口节点时，走过的路程就是环的长度</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// p是上面的程序中找到的入口节点的指针；</span></span><br><span class="line">LNode p;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line">LNode q = p.next;</span><br><span class="line"><span class="keyword">int</span> length = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (p != q) &#123;</span><br><span class="line">    length++;</span><br><span class="line">    q = q.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 当p=q时，说明回到了入口节点</span></span><br><span class="line"><span class="keyword">return</span> length;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Longest Substring Without Repeating Characters</title>
      <link href="/2020/11/05/136.Single-Number/"/>
      <url>/2020/11/05/136.Single-Number/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。</p><p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗<br>示例 1:</p><p>输入: [2,2,1]<br>输出: 1<br>示例 2:</p><p>输入: [4,1,2,1,2]<br>输出: 4</p></blockquote><p>因为要求「不使用额外的空间」，所以使用集合、HashMap等方式都是不可取的。不然的话，思路大概有以下几种：</p><ul><li>使用<strong>集合</strong>存储数字。遍历数组中的每个数字，如果集合中没有该数字，就将其加入集合，如果已存在，就将它从集合中删除。这样最后剩下的数字就是只出现了一次的数字。</li><li>使用HashMap来存储<strong>每个数字</strong>和<strong>该数字出现的次数</strong>。遍历数组，就可以得到每个数字出现的次数，然后更新HashMap的值，最终为1的就是只出现一次的数字。</li><li>使用Set集合存储数组中出现的所有数字，并计算数组中的元素之和。由于Set集合保证元素无重复，因此计算集合中的所有元素之和的两倍，即为每个元素出现两次的情况下的元素之和。由于数组中只有一个元素出现一次，其余元素都出现两次，因此用集合中的元素之和的两倍减去数组中的元素之和，剩下的数就是数组中只出现一次的数字。</li></ul><p>上述的三种方法都需要$O(n)$的空间，所以并不满足此题的要求。</p><p>这里需要注意的是如果是List，则<code>remove()</code>方法需要是移除元素而不是索引，因为是一个整型数组，所以需要用<code>indexOf()</code>的方法获取具体的元素值，不然就默认是索引值。而如果是Set，则没有<code>get()</code>方法，需要用<code>iterator()</code>的方法去显示。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniqueAward1</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// write code here</span></span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    List&lt;Integer&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (list.contains(nums[i])) &#123;</span><br><span class="line">            list.remove(list.indexOf(nums[i]));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            list.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> list.get(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用HashSet方法</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniqueAward2</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> len = nums.length;</span><br><span class="line">    Set&lt;Integer&gt; set = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(nums[i])) &#123;</span><br><span class="line">            set.remove(nums[i]);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            set.add(nums[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Iterator&lt;Integer&gt; it = set.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        <span class="keyword">return</span> it.next();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 使用集合数组相减的方式</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> nums</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">uniqueAward3</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    Set&lt;Integer&gt; sets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">    <span class="keyword">int</span> countArray = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> countSet = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        sets.add(nums[i]);</span><br><span class="line">        countArray += nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    Iterator&lt;Integer&gt; it = sets.iterator();</span><br><span class="line">    <span class="keyword">while</span> (it.hasNext()) &#123;</span><br><span class="line">        countSet += it.next();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">2</span> * countSet - countArray;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那么，如何才能做到线性时间复杂度和常数空间复杂度呢？</p><p>答案是使用<strong>位运算</strong>。对于这道题，可使用<strong>异或运算</strong>$\oplus$。异或运算有以下三个性质。</p><ul><li>任何数和0做异或运算，结果仍然是原来的数，即 $a \oplus 0=a$。</li><li>任何数和其自身做异或运算，结果是0，即$a \oplus a=0$。</li><li>异或运算满足交换律和结合律，即$a \oplus b \oplus a=b \oplus a \oplus a=b \oplus (a \oplus a)=b \oplus0=b$。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">singleNumber</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> single = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> num : nums) &#123;</span><br><span class="line">        single ^= num;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> single;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>148.Sort List</title>
      <link href="/2020/11/05/148.Sort-List/"/>
      <url>/2020/11/05/148.Sort-List/</url>
      
        <content type="html"><![CDATA[<h2 id="单链表的排序"><a href="#单链表的排序" class="headerlink" title="单链表的排序"></a>单链表的排序</h2><blockquote><p>给你链表的头结点 head ，请将其按 升序 排列并返回 排序后的链表 。</p><p>进阶：</p><p>你可以在 O(n log n) 时间复杂度和常数级空间复杂度下，对链表进行排序吗？</p></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>具体思路是：</p><ul><li>定义一个辅助节点aux，永远指向链表头结点，即aux.next=head;</li><li>定义当前节点cur和它的上一个节点pre，如果<code>pre.next&lt;=cur.next</code>,那么pre节点和cur节点同时向后移动</li><li>如果<code>pre.next&gt;cur.next</code>，切断pre节点和cur节点的引用关系，令<code>pre.next=cur.next</code>，把cur节点插入前面恰当位置</li><li>定义节点<code>node1=aux</code>和<code>node2=aux.next</code>，同时向后移动node1和node2，当出现<code>cur.val&lt;node2.val</code>时，把cur插入node1和node2之间</li><li><code>cur节点变为pre.next</code></li></ul><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">sortLinkedList</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 头节点</span></span><br><span class="line">    Node pre = head;</span><br><span class="line">    Node cur = head.next;</span><br><span class="line">    <span class="comment">// 辅助节点</span></span><br><span class="line">    Node aux = <span class="keyword">new</span> Node(<span class="number">0</span>);</span><br><span class="line">    <span class="comment">// 辅助节点永远指向头节点</span></span><br><span class="line">    aux.next = head;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果cur节点的值比前一节点的值小</span></span><br><span class="line">        <span class="keyword">if</span> (cur.val &lt; pre.val) &#123;</span><br><span class="line">            <span class="comment">// 前一节点直接跳过cur，指向cur的后一节点</span></span><br><span class="line">            pre.next = cur.next;</span><br><span class="line">            Node node1 = aux;</span><br><span class="line">            Node node2 = aux.next;</span><br><span class="line">            <span class="comment">// 遍历，找到一个节点的值要比cur更小的节点</span></span><br><span class="line">            <span class="keyword">while</span> (cur.val &gt; node2.val) &#123;</span><br><span class="line">                node1 = node2;</span><br><span class="line">                node2 = node2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 找到后，就将这两个值排序</span></span><br><span class="line">            node1.next = cur;</span><br><span class="line">            cur.next = node2;</span><br><span class="line">            cur = pre.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 往后移动，接着查找</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> aux.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>268.Missing Number</title>
      <link href="/2020/11/05/268.Missing-Number/"/>
      <url>/2020/11/05/268.Missing-Number/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>22.Generate Parenttheses</title>
      <link href="/2020/11/05/22.Generate-Parentheses/"/>
      <url>/2020/11/05/22.Generate-Parentheses/</url>
      
        <content type="html"><![CDATA[<p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GenerateParentheses.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GenerateParentheses.java</a></p><blockquote><p>数字 n 代表生成括号的对数，请你设计一个函数，用于能够生成所有可能的并且<strong>有效的</strong>括号组合。</p></blockquote><p>假如输入n=3，结果会输出5，因为结果：”((()))”, “(())()”, “(()())”, “()(())”, “()()()”。</p><p>即输入一个数，会返回所有可能的括号组合的数量。</p><p>通过观察，会有以下规律：</p><ul><li>左括号的数量总是与右括号的数量相等</li><li>左括号总是位于右括号的左侧</li><li>必须要形成合理的包含关系</li></ul><p>这里可以使用递归帮助解决问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> List&lt;String&gt; lists = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(String str, List&lt;String&gt; lists, <span class="keyword">int</span> left, <span class="keyword">int</span> right)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (left == <span class="number">0</span> &amp;&amp; right == <span class="number">0</span>) &#123;</span><br><span class="line">        lists.add(str);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        str = str + <span class="string">"("</span>;</span><br><span class="line">        dfs(str, lists, left - <span class="number">1</span>, right);</span><br><span class="line"><span class="comment">//            str = str.substring(0, str.length() - 1);</span></span><br><span class="line">        System.out.println(<span class="string">"字符串1："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt; left) &#123;</span><br><span class="line">        str = str + <span class="string">")"</span>;</span><br><span class="line">        dfs(str, lists, left, right - <span class="number">1</span>);</span><br><span class="line"><span class="comment">//            str = str.substring(0, str.length() - 1);</span></span><br><span class="line">        System.out.println(<span class="string">"字符串2："</span> + str);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果左括号大于0，则加上一个左括号，说明左括号有的多，然后数量减1。</p><p>如果右括号数量大于左括号，则说明右括号需要跟前面的左括号相匹配，则右括号数量减1。</p><p>当<code>left == 0 &amp;&amp; right == 0</code>时，说明已经不剩下括号了，那么就将最后的字符串加入到list中。</p><p>例如，n=2，则排列出的组合有：</p><script type="math/tex; mode=display">L\qquad R</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">2\qquad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">1\qquad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">0\qquad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">1\qquad1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">0\qquad1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">0\qquad0</script>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>349.Intersection of Two Arrays</title>
      <link href="/2020/11/05/349.Intersection-of-Two-Arrays/"/>
      <url>/2020/11/05/349.Intersection-of-Two-Arrays/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>547.Find Circle Num</title>
      <link href="/2020/11/01/547.Find-Circle-Num/"/>
      <url>/2020/11/01/547.Find-Circle-Num/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>朋友圈</strong><br>班上有 N 名学生。其中有些人是朋友，有些则不是。他们的友谊具有是传递性。如果已知 A 是 B 的朋友，B 是 C 的朋友，那么我们可以认为 A 也是 C 的朋友。所谓的朋友圈，是指所有朋友的集合。</p><p>给定一个 N * N 的矩阵 M，表示班级中学生之间的朋友关系。如果M[i][j] = 1，表示已知第 i 个和 j 个学生互为朋友关系，否则为不知道。你必须输出所有学生中的已知的朋友圈总数。</p><p>示例 1：</p><p>输入：<br>[[1,1,0],<br> [1,1,0],<br> [0,0,1]]</p><p>输出：2 </p><p>解释：已知学生 0 和学生 1 互为朋友，他们在一个朋友圈。<br>第2个学生自己在一个朋友圈。所以返回 2 。</p><p>示例 2：</p><p>输入：<br>[[1,1,0],<br> [1,1,1],<br> [0,1,1]]</p><p>输出：1</p><p>解释：已知学生 0 和学生 1 互为朋友，学生 1 和学生 2 互为朋友，所以学生 0 和学生 2 也是朋友，所以他们三个在一个朋友圈，返回 1 。</p><p>提示：</p><p>1 &lt;= N &lt;= 200</p><p>M[I][I] == 1</p><p>M[I][j] == M[j][I]</p></blockquote><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><p>可以用邻接矩阵的方式将其看成是一个图，所以其实就是寻找连通顶点的个数。</p><p>通过创建一个大小等于邻接矩阵大小的visited数组，例如$M=N*N$，<code>visited[i]</code>用来存储第i个元素是否被深度优先遍历搜索过。</p><p>我们首先选择一个节点，访问任一相邻的节点。然后再访问这一节点的任一相邻节点。这样不断遍历到没有未访问的相邻节点时，回溯到之前的节点进行访问。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 创建一个长度大小为M的visited数组</span></span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            dfs(M, visited, i);</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] M, <span class="keyword">int</span>[] visited, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">        <span class="comment">// 当M[i][j]==1说明有朋友圈，并且如果visited数组元素为0时，说明未被遍历过</span></span><br><span class="line">        <span class="keyword">if</span> (M[i][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 令visited元素为1</span></span><br><span class="line">            visited[j] = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 继续深度遍历</span></span><br><span class="line">            dfs(M, visited, j);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：因为要遍历整个矩阵的每一个元素，所以是$O(n^2)$</li><li><strong>空间复杂度</strong>：创建了一个visited数组来存储元素，所以是$O(n)$</li></ul><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><p>如果把矩阵看成的图的邻接矩阵，就是计算连通块的个数。那么，可以用到图中的<strong>广度优先搜索</strong>。</p><p>在广度优先搜索中，从一个特定点开始，访问所有邻接的节点。然后对于这些邻接节点，我们依然通过访问邻接节点的方式，直到访问所有可以到达的节点。因此，我们按照一层一层的方式访问节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="keyword">int</span>[][] M)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] visited = <span class="keyword">new</span> <span class="keyword">int</span>[M.length];</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 创建一个队列</span></span><br><span class="line">    Queue&lt;Integer&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; M.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (visited[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            queue.add(i);</span><br><span class="line">            <span class="comment">// 如果队列不为空</span></span><br><span class="line">            <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">                <span class="keyword">int</span> s = queue.remove();</span><br><span class="line">                visited[s] = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; M.length; j++) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (M[s][j] == <span class="number">1</span> &amp;&amp; visited[j] == <span class="number">0</span>)</span><br><span class="line">                        queue.add(j);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(JVM)</title>
      <link href="/2020/10/29/Interview-Review(JVM)/"/>
      <url>/2020/10/29/Interview-Review(JVM)/</url>
      
        <content type="html"><![CDATA[<h1 id="运行时数据区域"><a href="#运行时数据区域" class="headerlink" title="运行时数据区域"></a>运行时数据区域</h1><p>JVM内存共分为<strong>虚拟机栈</strong>、<strong>堆</strong>、<strong>方法区</strong>、<strong>程序计数器</strong>、<strong>本地方法栈</strong>五个部分。</p><p><strong>线程私有的</strong>：</p><ul><li>程序计数器 Program Counter Register</li><li>虚拟机栈 VM Stack</li><li>本地方法栈 Native Method Stack</li></ul><p><strong>线程共享的</strong>：</p><ul><li>堆 Heap</li><li>方法区 Method Area</li><li>直接内存（直接内存并不是运行时数据区域的一部分）</li></ul><h2 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h2><p>程序计数器是一块较小的内存空间，是当前线程所执行的字节码的行号指示器。字节码解释器工作时，通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理等都要依赖这个计数器来完成。</p><p>每个线程都需要有一个独立的程序计数器，各个线程之间的计数器互不影响，独立存储，所以这块内存区域被称为<strong>线程私有</strong>的内存。</p><p><strong>作用</strong>：</p><ul><li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制：顺序执行、选择、循环等。</li><li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而线程被切换回来可以知道上次运行到哪。</li></ul><blockquote><p>程序计数器是唯一一个不会出现<code>OutOfMemoryError</code>的内存区域。生命周期随着线程的创建而创建，随着线程的结束而死亡。</p></blockquote><h2 id="虚拟机栈"><a href="#虚拟机栈" class="headerlink" title="虚拟机栈"></a>虚拟机栈</h2><p>Java内存可以分为<strong>堆内存</strong>和<strong>栈内存</strong>，这里的栈指的就是<strong>虚拟机栈</strong>。</p><p>虚拟机栈中的<strong>局部变量表</strong>主要存放了各种数据类型（八种基本数据类型）、对象引用（可能是指向对象起始地址的引用指针）等。</p><blockquote><p>Java虚拟机会出现两种错误：<code>StackOverFlowError</code>和<code>OutOfMemoryError</code>。</p></blockquote><p>Java栈类比数据结构中的栈，保存的主要内容是栈帧，每次的函数调用都有对应的栈帧被压入Java栈，而每次函数的调用结束，都会有一个栈帧被弹出。</p><h2 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h2><p>本地方法栈与虚拟机栈的区别在于：本地方法栈是为虚拟机使用到的Native方法服务，而虚拟机栈是为执行Java（字节码）服务。「HotSpot」虚拟机中，这两个栈合二为一。</p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><p>堆是Java虚拟机中所管理的内存最大的一块，是所有线程都共享的一块区域。这块区域的目的是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p><p>Java堆是垃圾收集器管理的主要区域，所以也被称作<strong>GC堆</strong>。因为垃圾回收器都基本采用分代垃圾回收算法，所以Java堆还可细分为：<strong>新生代</strong>和<strong>老年代</strong>，目的是为了更好地回收内存，或者更快地分配内存。</p><h2 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h2><p>方法区也是所有线程都共享的一块区域，用于<strong>存储已被虚拟机加载的类信息、常量、静态便令、即时编译后的代码等数据</strong>。</p><h2 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h2><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存被频繁地使用。它避免了在Java堆和Native堆之间来回复制数据。</p><h1 id="HotSpot虚拟机对象"><a href="#HotSpot虚拟机对象" class="headerlink" title="HotSpot虚拟机对象"></a>HotSpot虚拟机对象</h1><h2 id="对象的创建"><a href="#对象的创建" class="headerlink" title="对象的创建"></a>对象的创建</h2><p><a href="https://imgchr.com/i/BfFknK" target="_blank" rel="noopener"><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/11/06/BfFknK.png" alt="Java创建对象的过程"></a></p><h3 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h3><p>虚拟机遇到一条new指令时，会去首先检查这个指令的参数能否在常量池定位到这个类的符号引用，并检查这个符号引用代表的类是否被加载过、解析过和初始化过。如果没有，就要执行类的加载过程。</p><h4 id="类加载器"><a href="#类加载器" class="headerlink" title="类加载器"></a>类加载器</h4><ul><li>启动类加载器（Bootstrap ClassLoader）：这个类加载器由C++实现，是虚拟机自身的一部分；启动类加载器无法被Java程序直接引用的。</li><li>扩展类加载器（Extension ClassLoader）：这个加载器由sun.misc.Launcher$ExtClassLoader实现，开发者可以直接使用该扩展类加载器。</li><li>应用程序类加载器（Application ClassLoader）：这个类加载器由sun.misc.Launcher$AppClassLoader实现。它一般被称为系统类加载器，负责加载用户类路径上所指定的类库。开发者可以直接使用这个类加载器，一般就是程序中默认的类加载器。</li></ul><h4 id="双亲委派模型"><a href="#双亲委派模型" class="headerlink" title="双亲委派模型"></a>双亲委派模型</h4><p>类加载器之间的层次关系，被称为是类加载器的双亲委派模型。其中，除了顶层加载器之外，其余的类加载器都会有自己的父类加载器。它们之间的父子关系不是<strong>继承</strong>，而是以<strong>组合</strong>的关系来复用父类加载器的代码。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/13" alt=""></p><p>双亲委派模型的工作过程是：</p><blockquote><p>如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求都委派给父类加载器去完成，每一个层次的类加载器都是如此。所以所有的加载请求最终都会被传送到顶层的启动类加载器中。只有当父类加载器无法完成这个加载请求时（即它的搜索范围类没有找到这个类），子加载器才会尝试自己去完成这个加载请求。</p></blockquote><p>双亲委派模型的好处就是<strong>Java随着它的类加载器一起具备了一种带有优先级的层次关系</strong>。比如Object类在各种类加载环境中都是同一个类，即<code>java.lang.Object</code>。</p><p>而如果没有双亲委派模型的话，如果开发者自己编写了一个同名的Object类，那么系统中会有多个Object类，那么需要加载哪个类就很混乱。</p><h3 id="分配内存"><a href="#分配内存" class="headerlink" title="分配内存"></a>分配内存</h3><p>在类加载检查过后，就要为新生对象分配内存。分配方式有两种：</p><ul><li>指针碰撞</li><li>空闲列表</li></ul><blockquote><p>具体选择哪种方式由Java堆是否规整来决定，而Java堆是否规整又由所采用的垃圾收集器是否带有压缩整理的功能来决定。</p></blockquote><h3 id="初始化零值"><a href="#初始化零值" class="headerlink" title="初始化零值"></a>初始化零值</h3><p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），保证了对象的实例字段在Java代码中可以不赋初始值就直接使用。</p><h3 id="设置对象头"><a href="#设置对象头" class="headerlink" title="设置对象头"></a>设置对象头</h3><p>虚拟机要对对象进行必要的设置，例如对象是哪个类的实例、对象的哈希码、对象GC分代等信息，都存储在信息头中。</p><h3 id="执行init方法"><a href="#执行init方法" class="headerlink" title="执行init方法"></a>执行<code>init</code>方法</h3><p><code>new</code>指令之后会接着执行<code>init</code>方法，初始化之后对象才算完全生产出来。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>非互联网企业手撕代码题</title>
      <link href="/2020/10/03/%E9%9D%9E%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E9%A2%98/"/>
      <url>/2020/10/03/%E9%9D%9E%E4%BA%92%E8%81%94%E7%BD%91%E4%BC%81%E4%B8%9A%E6%89%8B%E6%92%95%E4%BB%A3%E7%A0%81%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>总的来说，非互联网企业，包括银行、运营商等公司的笔试编程题相对还是简单的，很多都是大一接触到的，例如斐波那契数列等类型的题。然而，由于太久未看到这些基础的提醒，在一时间也有可能会反应不过来。毕竟，时间是有限的。因此，在这里做一个简单的汇总和说明。</p><h2 id="定义一个小顶堆"><a href="#定义一个小顶堆" class="headerlink" title="定义一个小顶堆"></a>定义一个小顶堆</h2><h2 id="手写一个循环队列"><a href="#手写一个循环队列" class="headerlink" title="手写一个循环队列"></a>手写一个循环队列</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/tree/master/src/basic/LoopQueue" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/tree/master/src/basic/LoopQueue</a></p><p>一个队列是实行先进先出的原则，需要加上front和rear两个变量分别代表在数组中的位置，初值为0。</p><p>在非空队列中，front指向队首元素，rear指向队尾元素的下一个存储位置。</p><p>循环队列中会有一个问题：无法区分队空和队满的状态，因为条件都是<code>rear == front</code>。</p><p>所以这里少使用一个存储单元，即队空的条件为<code>rear == front</code>，队满的条件是<code>front == (rear + 1) % maxSize</code>。</p><p>编写队列接口，主要要实现<strong>入队</strong>、<strong>出队</strong>、<strong>长度</strong>、<strong>是否为空</strong>等方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IQueue</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isEmpty</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">length</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">peek</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">offer</span><span class="params">(Object x)</span> <span class="keyword">throws</span> Exception</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">poll</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="求两数的最大公约数和最小公倍数"><a href="#求两数的最大公约数和最小公倍数" class="headerlink" title="求两数的最大公约数和最小公倍数"></a>求两数的最大公约数和最小公倍数</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GCDAndLCM.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/GCDAndLCM.java</a></p><p>这道题实际上就是实现现实中的求最大公约数和最小公倍数。那么，有些规律需要掌握，例如最小公倍数就等于两个数相乘再除以最大公约数，所以这道题的关键就是求最大公约数。</p><p>最大公约数即是用两个数中的更大的数除以最小的数取余数，然后反复除以，直到没有余数为止。有时会因为余数已经小于除数，所以需要更换位置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">deff</span><span class="params">(<span class="keyword">int</span> x, <span class="keyword">int</span> y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    <span class="keyword">if</span> (x &lt; y) &#123;</span><br><span class="line">        <span class="comment">// 设计成x始终大于y</span></span><br><span class="line">        t = x;</span><br><span class="line">        x = y;</span><br><span class="line">        y = t;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (y != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == y) &#123;</span><br><span class="line">            <span class="keyword">return</span> x;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> k = x % y;</span><br><span class="line">            x = y;</span><br><span class="line">            y = k;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="去除特殊符号后的字符串再根据ASCII码值排序"><a href="#去除特殊符号后的字符串再根据ASCII码值排序" class="headerlink" title="去除特殊符号后的字符串再根据ASCII码值排序"></a>去除特殊符号后的字符串再根据ASCII码值排序</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ASCIISort.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ASCIISort.java</a></p><p>首先要掌握ASCII值的概念和规律。常见的ASCII值的大小顺序规律是：0～9 &lt; A~Z &lt; a~z。即数字要比字母小，大小字母要比小写字母小。</p><p>几个常见的ASCII值有：“A”：65， “a”：97，“0”：48</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">ASCIISort</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 将字符串拆分成一个个字符</span></span><br><span class="line">    <span class="keyword">char</span>[] test = <span class="keyword">new</span> <span class="keyword">char</span>[str.length()];</span><br><span class="line">    StringBuilder sb = <span class="keyword">new</span> StringBuilder();</span><br><span class="line">    <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">        String a = str;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; str.length(); i++) &#123;</span><br><span class="line">            test[i] = a.charAt(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 数组排序</span></span><br><span class="line">        Arrays.sort(test);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; test.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 添加会StringBuilder里</span></span><br><span class="line">            sb.append(test[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// trim()是用来删除字符串的首尾空白符</span></span><br><span class="line">        String trim = sb.toString().trim();</span><br><span class="line">        <span class="keyword">return</span> trim;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后定义去除特殊字符的方法，运用正则表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">replaceString</span><span class="params">(String str)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 运用正则表达式</span></span><br><span class="line">    String regEx = <span class="string">"[\\n`~!@#$%^&amp;*()+=|&#123;&#125;':;',\\\\[\\\\].&lt;&gt;/?~！@#￥%……&amp;*（）——+|&#123;&#125;【】‘；：”“’。， 、？]"</span>;</span><br><span class="line"></span><br><span class="line">    Pattern p = Pattern.compile(regEx);</span><br><span class="line">    Matcher m = p.matcher(str);</span><br><span class="line">    String string = <span class="string">""</span>;</span><br><span class="line">    string = m.replaceAll(string).trim();</span><br><span class="line">    System.out.println(string);</span><br><span class="line">    <span class="keyword">return</span> string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="递归实现字符串反转"><a href="#递归实现字符串反转" class="headerlink" title="递归实现字符串反转"></a>递归实现字符串反转</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ReverseStr.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/ReverseStr.java</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title">reverse</span><span class="params">(String originStr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (originStr == <span class="keyword">null</span> || originStr.length() &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> originStr;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//        System.out.println(originStr.substring(1));</span></span><br><span class="line"><span class="comment">//        System.out.println(originStr.charAt(0));</span></span><br><span class="line">    <span class="comment">// 递归截取第一个字符，然后递归依次相加</span></span><br><span class="line">    <span class="keyword">return</span> reverse(originStr.substring(<span class="number">1</span>)) + originStr.charAt(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设字符串为”123a6”，那么<code>substring(1)</code>的作用是截取掉第1个字符后剩下的字符串，<code>charAt(0)</code>是获得第一个字符。</p><p>所以顺序会是：</p><script type="math/tex; mode=display">23a6\quad1</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">3a6\quad2</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">a6\quad3</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">6\quad a</script><script type="math/tex; mode=display">\Downarrow</script><script type="math/tex; mode=display">\quad6</script><p>所以按照递归从后往前相加的顺序，就变成<code>6 + a + 3 + 2 + 1</code>，反转字符串后的最终结果就是<code>6a321</code>。</p><h2 id="两个有序数组的交集"><a href="#两个有序数组的交集" class="headerlink" title="两个有序数组的交集"></a>两个有序数组的交集</h2><p>代码位于：<a href="https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/Intersection.java" target="_blank" rel="noopener">https://github.com/HurleyJames/MyLeetCode/blob/master/src/basic/Intersection.java</a></p><p>对于两个有序的数组，如何寻找它们之间的公共元素呢？</p><p>很容易想到的一个方法就是双重循环，然后条件语句判断元素是否相等，但如果要求时间复杂度不能超过$O(n)$呢？</p><p>所以这时候<strong>有序</strong>就成了一个非常关键的条件。因为有序，所以当<code>a[i] &gt; b[j]</code>时，我们就可以让<code>a[i]</code>与<code>b[j + 1]</code>进行比较；反之，则是<code>a[i + 1]</code>与<code>b[j]</code>进行比较。那么，我们只需要在<strong>一个循环</strong>里完成就可以了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">intersection</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, List&lt;Integer&gt; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> len1 = a.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> len2 = b.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; len1 || j &lt; len2) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == b[j]) &#123;</span><br><span class="line">            lists.add(a[i]);</span><br><span class="line">            i++;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[i] &gt; b[j]) &#123;</span><br><span class="line">            j++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为使用的是<code>while</code>循环，所以为了防止数组越界，需要将数组的长度减1。当满足某个条件时，就把数组的index往后移一位。</p><hr><p>然而，上面这个方法适用于「两个数组长度接近的情况」，这样比较的过程就不会做很多无用功。如果两个数组之间的长度相差很大，那么可以直接遍历较短数组的元素，然后在长数组中对该元素进行查找，如果查找到，就说明是公共元素，反之则不是。这个思路就更加简单了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> List&lt;Integer&gt; <span class="title">binaryIntersection</span><span class="params">(<span class="keyword">int</span>[] a, <span class="keyword">int</span>[] b, List&lt;Integer&gt; lists)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] longArray;</span><br><span class="line">    <span class="keyword">int</span>[] shortArray;</span><br><span class="line">    <span class="keyword">if</span> (a.length &lt;= b.length) &#123;</span><br><span class="line">        shortArray = a;</span><br><span class="line">        longArray = b;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        shortArray = b;</span><br><span class="line">        longArray = a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 遍历短的数组</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; shortArray.length; i++) &#123;</span><br><span class="line">        <span class="comment">// 使用短数组中的每一个元素在长数组中进行二分查找，如果查找到了，说明有公共元素</span></span><br><span class="line">        <span class="keyword">int</span> result = Arrays.binarySearch(longArray, shortArray[i]);</span><br><span class="line">        <span class="keyword">if</span> (result &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            lists.add(longArray[result]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lists;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩"><a href="#实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩" class="headerlink" title="实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩"></a>实现一个数据结构，满足有100个学生，学号不相同，且成绩分数都不相同（1-100分之间），按照成绩由高到低的方式输出学生的所有信息：学号、姓名、成绩</h2><h2 id="猴子吃桃问题"><a href="#猴子吃桃问题" class="headerlink" title="猴子吃桃问题"></a>猴子吃桃问题</h2><blockquote><p>猴子第一天摘下N个桃子，当时就吃了一半，还不过瘾，就又吃了一个。第二天又将剩下的桃子吃掉一半，又多吃了一个。以后每天都吃前一天剩下的一半零一个。到第n天在想吃的时候就剩一个桃子了,求第一天共摘下来多少个桃子？</p></blockquote><p>通过描述可以发现，递推公式是$f(n)=(f(n+1)+1)*2$，当n等于1时，就是第一个摘下来的桃子数量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">eat</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; n) &#123;</span><br><span class="line">        x = (x + <span class="number">1</span>) * <span class="number">2</span>;</span><br><span class="line">        i++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="简单找零钱算法"><a href="#简单找零钱算法" class="headerlink" title="简单找零钱算法"></a>简单找零钱算法</h2><h2 id="青蛙跳台阶问题"><a href="#青蛙跳台阶问题" class="headerlink" title="青蛙跳台阶问题"></a>青蛙跳台阶问题</h2><blockquote><p>一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）。</p></blockquote><p><strong>解题思路</strong>：</p><blockquote><p>当n&gt;2时，第一次跳的时候就有两种不同的选择：</p><p>一是第一次只跳1级，此时跳法数目等于剩下的n-1级台阶的跳法数目，即$f(n-1)$</p><p>二是第一次跳2级，此时跳法数目等于后面剩下的n-2级台阶的跳法数目，即$f(n-2)$</p><p>因此，n级台阶的跳法总数目$f(n)=f(n-1)+f(n-2)$</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">frogJump</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span> || n &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">1</span> || n == <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 通过观察，发现其实一个 f(n)=f(n-1)+f(n-2) 的规律</span></span><br><span class="line">        <span class="keyword">return</span> frogJump(n - <span class="number">1</span>) + frogJump(n - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="男女排队问题"><a href="#男女排队问题" class="headerlink" title="男女排队问题"></a>男女排队问题</h2><blockquote><p>幼儿园有n个小朋友排为一个队伍，男生用“B”表示，女生用“G”表示。当男女同挨着时便会发生矛盾。需要对所排的队伍进行调整，每次调整只能让相邻的小朋友交换位置，现在需要尽快完成队伍调整，你需要计算出最少需要调整多少次可以让上述情况最少。例如：GGBGG-&gt;GGBGB-&gt;GGGBB这样就能使之前的两处男女相邻变为一处男女相邻，需要调整队形两次<br>程序输入：输入一个数据包括一个长度为N且只包含Ｇ和Ｂ的字符串。<br> 输入：ＧＧＢＢＧ<br>输出：２</p></blockquote><h2 id="求两个日期之间的工作日"><a href="#求两个日期之间的工作日" class="headerlink" title="求两个日期之间的工作日"></a>求两个日期之间的工作日</h2>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Git)</title>
      <link href="/2020/09/23/Interview-Review(Git)/"/>
      <url>/2020/09/23/Interview-Review(Git)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的Git部分。</p><h2 id="Git回滚以前的某个版本"><a href="#Git回滚以前的某个版本" class="headerlink" title="Git回滚以前的某个版本"></a>Git回滚以前的某个版本</h2><ol><li><p>查找历史版本</p><p> 使用<code>git log</code>命令查看所有的历史版本，获取该仓库git的某个历史版本的id。例如，假设id是fae6966548e3ae76cfa7f38a461c438cf75ba965。</p></li><li><p>恢复到历史版本</p><p> <code>$ git reset --hard fae6966548e3ae76cfa7f38a461c438cf75ba965</code></p></li><li><p>把修改推送到远程的服务器</p><p> <code>git push -f -u origin master</code></p></li></ol><h2 id="git-merge和git-rebase的区别"><a href="#git-merge和git-rebase的区别" class="headerlink" title="git merge和git rebase的区别"></a>git merge和git rebase的区别</h2><p><code>git merge</code>和<code>git rebase</code>都是用于合并分支的，不同之处在于对于commit记录的处理上是不同的。</p><p>例如，原始分支如下所示，一个是master(origin)分支，一个是dev(mywork)分支：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/1.jpg" alt=""></p><p>当使用<code>git merge</code>的话，会新建一个新的commit对象，然后两个分支以前的commit记录都会指向这个新建的commit记录。这个方式可以保留之前的每一个分支中的commit的历史，如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2.jpg" alt=""></p><p>当使用<code>git rebase</code>命令时，可以让两个分支合并后呈线性记录，和没有合并一样。<code>git rebase</code>会先找到两个分支的第一个<strong>共同的</strong>commit的祖先记录，然后提取这个祖先记录之后的所有的commit记录，将这个commit记录添加到目标分支的最新提交的后面。「它会指向新的提交，而那些老的提交会被丢弃」。经过这个合并之后，两个分支合并后的commit记录会变成线性记录了。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/4.jpg" alt=""></p><h2 id="git-pull和git-fetch的区别"><a href="#git-pull和git-fetch的区别" class="headerlink" title="git pull和git fetch的区别"></a>git pull和git fetch的区别</h2><p><code>git fetch</code>是将远程主机的最新内容拉到本地，用户在检查之后再决定是否合并到工作主机的分支中。</p><p><code>git pull</code>是将远程主机的最新内容拉下来之后就直接合并了，所以可以理解为：<code>git pull</code>=<code>git fetch</code>+<code>git merge</code>。因为直接合并是可能会产生冲突的，所以需要手动解决。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android Jetpack组件</title>
      <link href="/2020/09/22/Android%20Jetpack%E7%BB%84%E4%BB%B6/"/>
      <url>/2020/09/22/Android%20Jetpack%E7%BB%84%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="Jetpack"><a href="#Jetpack" class="headerlink" title="Jetpack"></a>Jetpack</h1><p>Jetpack是Google推出的一个框架，主要是可以对代码的逻辑和UI界面实现深层的解耦，打造数据驱动型的UI界面。Android Architecture组件是Android Jetpack的一部分，包含以下组件等：</p><ul><li><strong>Lifecycle</strong>：能够处理Activity和Fragment的生命周期，在AndroidX中，Fragment和Activity已经对Lifecycle提供了默认的支持。</li><li><strong>ViewModel</strong>：当做MVVM的ViewModel层，并具有生命周期意识的处理和UI相关的数据。</li><li><strong>LiveData</strong>：和RxJava的作用是一样的，对数据进行监听，优点是无需处理生命周期、无内存泄漏等。</li><li><strong>Paging</strong>：是一个易于使用的数据分页库，支持RecyclerView。</li><li><strong>Room</strong>：强大的ORM数据库框架。</li><li><strong>Navigation</strong>：一个用于管理Fragment切换的工具类，可视化、可绑定控件、支持动画等优点。</li><li><strong>WorkManager</strong>：灵活、简单、延迟和保证执行的后台任务处理库。</li><li><strong>DataBinding</strong>：加速MVVM的创建。</li></ul><p>使用Android Jetpack组件具有以下优势：</p><ul><li>轻松管理应用程序的生命周期</li><li>构建可观察的数据对象，以便在基础数据库更改时通知视图</li><li>存储在应用程序轮换中未销毁的UI相关数据，在界面重建后恢复数据</li><li>轻松地实现SQLite数据库</li><li>系统自动调度后台任务的执行，优化使用性能</li><li>支持RxJava：由于RxJava强大的生态环境，几乎和数据相关的组件都对RxJava提供了支持。</li><li>减少代码量：以Data Binding + ViewModel + LiveData或者RxJava构建的MVVM模式能够显著地减少代码量，比平时用的MVP模式也会更加方便，无需主动更新UI。</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/168931a7b8210bdf" alt=""></p><p>上述组件的架构功能如下：</p><ul><li>Activity和Fragment负责产品与用户的交互</li><li>ViewModel作为数据的存储和驱动</li><li>Resposity负责调度数据的获取</li><li>Room储存本地序列化的数据</li><li>Retrofit获取远程数据的数据</li></ul><h2 id="Lifecycle"><a href="#Lifecycle" class="headerlink" title="Lifecycle"></a>Lifecycle</h2><p>Lifecycler是一个生命周期的感知组件，执行操作以响应另一个组件（例如Activity和Fragment）的生命周期状态的更改，可以监听Activity组件生命周期的变化，在每个生命周期执行相应的方法。</p><p>不同于以往会在生命周期中执行相应的方法时，需要设置接口，然后在生命周期中回调接口，这样会造成代码的耦合，也会引发生命周期的问题。Lifecycle的<strong>优点</strong>是实现了执行的逻辑和活动的分离，代码解耦并且增加了代码的可读性。Lifecycle在活动结束时会自定义移除监听。</p><h2 id="LiveData"><a href="#LiveData" class="headerlink" title="LiveData"></a>LiveData</h2><p>一个应用肯定要进行数据的更新。当用户执行某种操作或者服务器端的数据发生改变后，都需要重新获取数据，再次刷新界面的UI。那么，每改变一次就需要重复一次，如何使用一个方式可以监听数据状态，在数据变化时就自动更新UI呢？LiveData就是用来实现此功能的，它解决了数据展示和刷新的问题：只需要创建LiveData实例后，为可观察的数据添加观察者，在数据改变时会自动回调观察者。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h2 id="ViewModel"><a href="#ViewModel" class="headerlink" title="ViewModel"></a>ViewModel</h2><p>用户在使用应用的过程中，可能随时会被中断或者界面发生了重建，如果重新进入后数据丢失了就会造成不好的用户体验。我们可以使用<code>onSaveInstanceState()</code>方法来保存数据，然后在界面重建后使用<code>onRestoreInstanceState()</code>方法来恢复数据。这种方式虽然可以解决问题，但是如果过于频繁，在每个界面都要编写重建和恢复的代码，就会造成十分繁琐，且数据量过大时会影响执行性能。ViewModel就是来解决这个问题的。</p><p>ViewModel会在活动重建时仍然保存数据，在活动创建完成后从中获取数据。</p><p>ViewModel的优点：</p><ul><li>数据和界面的分离，使数据驱动界面</li><li>解决了运行中断和界面重建时的数据保存问题</li><li>配合LiveData实时地获取最新的数据</li><li>实现了Activity和Fragment之间的数据交互</li></ul><p>ViewModel的<strong>原理</strong>：将数据保存到ViewModel中，然后为活动中添加一个HolderFragment，HolderFragment中保存了ViewStore的实例，ViewStore中使用Map保存了ViewModel，从而在活动重新创建时获取到原来的ViewModel。</p><hr><blockquote><p>一般ViewModel会和LiveData组合，保存可观察的数据</p></blockquote><p>在研究生毕业设计的项目中，我在安卓端的代码中就使用到了LiveData搭配ViewModel的组合。</p><p>在<code>ContractViewModel</code>类中的代码如下。这里主要是使用到了一个<code>MutableLiveData</code>的类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ContractViewModel</span> <span class="keyword">extends</span> <span class="title">ViewModel</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData contractModel = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData callContractResult = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line">    <span class="keyword">private</span> MutableLiveData proofPlace = <span class="keyword">new</span> MutableLiveData();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;ContractModel&gt; <span class="title">getContractModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> contractModel;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;Boolean&gt; <span class="title">getCallContractResult</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> callContractResult;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> MutableLiveData&lt;String&gt; <span class="title">getProofPlace</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> proofPlace;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，在Fragment中这样使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ContractViewModel mViewModel;</span><br><span class="line"></span><br><span class="line">mViewModel = ViewModelProviders.of(fragmentActivity).get(ContractViewModel.class);</span><br><span class="line"></span><br><span class="line">mViewModel = mViewModel.getContractModel().observe(<span class="keyword">this</span>, o -&gt; &#123;</span><br><span class="line">    CertificateModel certificateModel = (CertificateModel) o;</span><br><span class="line">    <span class="comment">// TODO</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">mViewModel.getCallContractResult().postValue(XXX);</span><br><span class="line">mViewModel.getProofPlace().postValue(XXX);</span><br></pre></td></tr></table></figure><p>从上面可以看出，<code>mViewModel</code>可以通过<code>ViewModelProviders</code>与<code>fragmentActivity</code>，再与<code>ContractViewModel</code>绑定。<code>mViewModel.getContractModel().observe()</code>的方式。除此之外，可以使用<code>postValue()</code>的方式去传递值。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java中的String为什么是不可变的</title>
      <link href="/2020/09/22/Java%E4%B8%AD%E7%9A%84String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/"/>
      <url>/2020/09/22/Java%E4%B8%AD%E7%9A%84String%E4%B8%BA%E4%BB%80%E4%B9%88%E6%98%AF%E4%B8%8D%E5%8F%AF%E5%8F%98%E7%9A%84/</url>
      
        <content type="html"><![CDATA[<p>在Java中，String类是不可变的，即String中的对象是不可变的。</p><h3 id="区别对象和对象的引用"><a href="#区别对象和对象的引用" class="headerlink" title="区别对象和对象的引用"></a>区别对象和对象的引用</h3><p>对于Java初学者， 对于String是不可变对象总是存有疑惑。例如如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">String s = <span class="string">"ABCabc"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br><span class="line"></span><br><span class="line">s = <span class="string">"123456"</span>;</span><br><span class="line">System.out.println(<span class="string">"s = "</span> + s);</span><br></pre></td></tr></table></figure><p>打印出的结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">s = ABCabc</span><br><span class="line">s = <span class="number">123456</span></span><br></pre></td></tr></table></figure></p><p>首先创建一个String对象s，然后让s的值为“ABCabc”， 然后又让s的值为“123456”。从打印结果可以看出，s的值确实改变了，那么为什么说String对象是不可变的呢？其实这里存在一个误区：<strong>s只是一个String对象的引用，并不是对象本身</strong>。对象在内存中是一块内存区，成员变量越多，这块内存区占的空间越大。引用只是一个4字节的数据，里面存放了它所指向的对象的地址，通过这个地址可以访问对象。</p><p>也就是说，s只是一个引用，它指向了一个具体的对象，当<code>s=“123456”;</code>这句代码执行过之后，又创建了一个新的对象“123456”， 而引用s重新指向了这个心的对象，原来的对象“ABCabc”还在内存中存在，并没有改变。内存结构如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20140115201808140.png" alt=""></p><h3 id="不可变类"><a href="#不可变类" class="headerlink" title="不可变类"></a>不可变类</h3><blockquote><p>如果一个对象，在它创建完成之后，不能再改变它的状态，那么这个对象就是不可变的。即不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能再指向其它的对象，引用类型指向的对象的状态也不能改变。</p></blockquote><p>《Effective Java》中第 15 条<strong>使可变性最小化</strong>中对<strong>不可变类</strong>的解释：</p><blockquote><p>不可变类只是其实例不能被修改的类。每个实例中包含的所有信息都必须在创建该实例的时候就提供，并且在对象的整个生命周期内固定不变。为了使类不可变，要遵循下面五条规则：</p><ol><li>不要提供任何会修改对象状态的方法。</li><li>保证类不会被扩展。一般的做法是让这个类称为<code>final</code>的，防止子类化，破坏该类的不可变行为。</li><li>使所有的域都是<code>final</code>的。</li><li>使所有的域都成为私有的。防止客户端获得访问被域引用的可变对象的权限，并防止客户端直接修改这些对象。</li><li>确保对于任何可变性组件的互斥访问。如果类具有指向可变对象的域，则必须确保该类的客户端无法获得指向这些对象的引用。</li></ol></blockquote><p>在 Java 平台类库中，包含许多不可变类，例如<code>String</code>, 基本类型的包装类，<code>BigInteger</code>, <code>BigDecimal</code>等等。综上所述，不可变类具有一些显著的通用特征：类本身是<code>final</code>修饰的；所有的域几乎都是私有<code>final</code>的；不会对外暴露可以修改对象属性的方法。通过查阅String的源码，可以清晰的看到这些特征。</p><h3 id="源码"><a href="#源码" class="headerlink" title="源码"></a>源码</h3><p>通过查看Java中String的源码，如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">String</span> <span class="keyword">implements</span> <span class="title">Serializable</span>, <span class="title">Comparable</span>&lt;<span class="title">String</span>&gt;, <span class="title">CharSequence</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Stable</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">byte</span>[] value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，String类是通过<code>final</code>修饰的，满足了第二条的：类不能被拓展。</p><p>其次，在类中，最重要的一条<code>private final byte[] value;</code>中，我们可以看到Java是使用<strong>字节数组</strong>（Java9，之前的版本是采用字符char数组实现）来实现字符串的，并且使用了<code>final</code>修饰，这就是String为什么不可变的原因。</p><p>因为它使用了<code>private final</code>，导致正常情况下外界没有办法去修改它的值。这满足了第三条：使所有的域都是<code>final</code>的，和第四条：使所有的域都是私有的。然而仅仅这样也仍然不是万无一失的。</p><p>第一条原则是：不要提供任何会修改对象状态的方法。String类在这点中做得很好。在String类中许多会对字符串进行操作的方法中，例如<code>replaceAll()</code>或者<code>substring()</code>等，其中的每一步实现都不会对<code>value</code>产生任何影响。即String类中并没有提供任何可以改变其值的方法，这比<code>final</code>更能确保其是不变的。</p><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>《Effective Java》一书中总结了不可变类的特点：</p><ul><li>不可变类比较简单。</li><li>不可变对象本质上是线程安全的，它们不要求同步。不可变对象可以被自由地共享。</li><li>不仅可以共享不可变对象，甚至可以共享它们的内部信息。</li><li>不可变对象为其他对象提供了大量的构建。</li><li>不可变类真正唯一的缺点是，对于每个不同的值都需要一个单独的对象。</li></ul><h3 id="String真的不可变吗"><a href="#String真的不可变吗" class="headerlink" title="String真的不可变吗"></a>String真的不可变吗</h3><p>其实可以通过<strong>反射机制</strong>来破坏String的不可变性。可以反射出String对象中的value属性，进而改变通过获得的value引用改变数组的结构。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">testReflection</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建字符串"Hello World"， 并赋给引用s</span></span><br><span class="line">    String s = <span class="string">"Hello World"</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);<span class="comment">// Hello World</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取String类中的value字段</span></span><br><span class="line">    Field valueFieldOfString = String.class.getDeclaredField(<span class="string">"value"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变value属性的访问权限</span></span><br><span class="line">    valueFieldOfString.setAccessible(<span class="keyword">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取s对象上的value属性的值</span></span><br><span class="line">    <span class="keyword">char</span>[] value = (<span class="keyword">char</span>[]) valueFieldOfString.get(s);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 改变value所引用的数组中的第5个字符</span></span><br><span class="line">    value[<span class="number">5</span>] = <span class="string">'_'</span>;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">"s = "</span> + s);  <span class="comment">// 变成Hello_World</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>告别是最残忍的告白</title>
      <link href="/2020/08/21/%E5%91%8A%E5%88%AB%E6%98%AF%E6%9C%80%E6%AE%8B%E5%BF%8D%E7%9A%84%E5%91%8A%E7%99%BD/"/>
      <url>/2020/08/21/%E5%91%8A%E5%88%AB%E6%98%AF%E6%9C%80%E6%AE%8B%E5%BF%8D%E7%9A%84%E5%91%8A%E7%99%BD/</url>
      
        <content type="html"><![CDATA[<p>穿过树丛田野</p><p>风景向身后凛冽</p><p>铁轨伸长了双臂</p><p>向黎明驶去</p><p>窗外的世界</p><p>是从没见过的新奇</p><p>淡蓝色的月亮</p><p>城市在黎明处张望</p><p>铁轨扑向更远更长</p><p>车灯照着未知的彷徨</p><p>汽笛遮掩的话语</p><p>琐碎在肩上的行李</p><p>霓虹向后飞越</p><p>向昨晚的梦告别</p><p>淡淡的晨光</p><p>匍匐在身后的家乡</p><p>忽明忽暗的远方</p><p>在行驶的路上</p><p>珍藏的记忆都装进背包</p><p>挥手告别旧时光的美好</p><p>拥抱迎面的翻山越岭</p><p>好好告别就不会有遗憾吗</p><hr><p>那茶杯还留着酣畅的清香</p><p>而回忆却是说忘就忘</p><p>在黑色的夜晚摇月亮</p><p>我该去哪里走一走逛一逛</p><p>哪里的集市丰盛有眼光</p><p>哪里的酒好喝到能一醉方休</p><p>哪里的人不问来路与归途</p><p>我该去哪里看一看 想一想</p><p>哪里的前程值得被信仰</p><p>哪里的水清的 仿佛能看到希望</p><p>哪里的风拂晓坦荡愿与你戏攘</p><p>自在的不觉得虚妄</p><p>时间无谓无果无需隐藏</p><p>一无所有所得所期所想</p><p>尘嚣倾吐残余的伤</p><p>黄昏后回归故乡</p><p>愿你有故乡</p><hr><p>👋再见啦，🇬🇧UK</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(BlockChain)</title>
      <link href="/2020/06/07/Interview-Review(BlockChain)/"/>
      <url>/2020/06/07/Interview-Review(BlockChain)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的区块链部分。</p><a id="more"></a><ol><li><p><strong>什么是区块链</strong></p><p> 区块链是不间断的经济交易数字分类账本，可以进行编程，以记录不仅是金融交易，还可以记录几乎所有有价值的东西。它是<strong>一个不可变记录的分散式、分布式数据库</strong>，该数据库由计算机集群管理，但不属于任何单个实体。</p></li><li><p><strong>区块链是如何工作的</strong></p><p> 区块链由不可变的数据记录（称为<strong>数据块</strong>）组成，这些数据使用<strong>密码学</strong>进行链接。密码学不过是在读取私人消息时对第三方进行加密和保护数据通信的过程。在区块链中，<strong>一旦记录了数据，就不会更改</strong>。区块链就像带有<strong>时间戳</strong>的数学公证人一样工作，以避免篡改信息。</p></li><li><p><strong>为什么区块链是一种值得信赖的方法</strong></p><ul><li>它具有开源特性，与其它业务应用程序相互兼容</li><li>透明度和安全性</li><li>提高效率和速度</li><li>无需依赖任何中央权威</li></ul></li><li><p><strong>什么是区块链中的区块，如何识别</strong></p><p> 区块链中的<strong>区块用于存储数据并永久锁定</strong>。添加在块上的数据是<strong>不可变的</strong>，即<strong>不能更改或删除数据</strong>。可以通过块的<strong>高度</strong>和<strong>块头哈希</strong>来识别块。块中的数据通过称为哈希函数的计算机算法进行检测。它不仅锁定了区块链参与者可以看到的数据，而且使数据不可变。<strong>每个块都有哈希函数</strong>。</p></li><li><p><strong>块的主要元素是什么</strong></p><p> 以下是块的主要元素：</p><ul><li><strong>指向上一个块的哈希指针</strong></li><li><strong>时间戳</strong> Timestamp</li><li><strong>交易</strong> Transaction</li></ul></li><li><p><strong>是否可以从区块链的网络中删除一个或多个块</strong></p><p> 可以的，因为有时只需要考虑在线分类账本的特定部分。通过使用默认过滤器和选项，可以删除这些块。</p></li><li><p><strong>将数据写入块后是否可以更改数据</strong></p><p> 不可以。</p></li><li><p><strong>区块链数据库中可用的记录类型是什么</strong></p><p> 区块链数据库中有两种类型的记录。他们是：</p><ul><li>交易记录</li><li>阻止记录</li></ul></li><li><p><strong>有哪些不同类型的区块链</strong></p><ul><li>公有区块链（公有链）：没有人负责，任何人都可以读写/审核区块链。</li><li>私有区块链（私有链）：它是个人或者组织的私有财产。</li><li>联合区块链（联盟链）：选定的成员可以读取/写入/审核区块链。</li></ul></li><li><p><strong>什么是分类账本，并命名区块链中用户考虑的常见分类账类型</strong></p><p>分类账是一个不断增长的文件，它存储了在区块链网络上两方之间的所有交易的永久记录。</p><p>用户考虑的常见分类帐类型：</p><ul><li><strong>集中式分类账</strong></li><li><strong>分散的分类帐</strong></li><li><strong>分布式分类账</strong></li></ul></li><li><p><strong>公钥和私钥有什么区别</strong></p><p>在区块链中，需要使用<strong>公钥进行标识</strong>，而使用<strong>私钥进行加密和身份验证</strong>。发送方可以使用接收方的公钥发送消息，而接收方可以使用私钥对消息或交易进行解密。通过同时使用两个密钥，可以确保通信或交易的安全和防篡改。</p></li><li><p><strong>区块链以什么顺序连接</strong></p><p>区块链中的所有区块都以反向顺序连接，或者每个区块都与其前一个区块连接。</p></li><li><p><strong>区块链分类账和普通分类账有何不同</strong></p><p>区块链是一种数字账本，可以很容易地分散，与原始账本相比，区块链账本中的错误机会要少得多。区块链自动执行其所有任务，而在普通分类账本中，每项任务都是手动或者人工完成的。</p></li><li><p><strong>什么是共识算法</strong></p><p>共识算法是一种方法，通过该方法，区块链网络的所有对等方都可以达成分布式账本当前状态的标准协议。它可实现高可靠性，并在分布式计算环境中的未知对等方之间建立信任。</p></li><li><p><strong>共识算法有哪些</strong></p><ul><li>工作量证明PoW</li><li>容量证明PoC</li><li>活动证明PoA</li><li>委托权益证明DPoS</li><li>股权证明PoS</li><li>权威证明</li><li>燃烧证明</li><li>唯一节点列表</li><li>重量证明</li><li>拜占庭容错PBFT</li></ul></li><li><p><strong>什么是加密货币</strong></p><p>加密货币是一种数字资产，可以用作使用加密功能进行金融交易的交换媒介。加密货币利用区块链技术获得透明度，去中心化和不变性。加密货币可以使用公钥和私钥在两方之间直接发送，而手续费极低。</p></li><li><p><strong>区块链架构的核心组件是什么</strong></p><ul><li><strong>节点</strong>：区块链结构中的用户/计算机</li><li><strong>交易</strong>：区块链系统的最小组成部分</li><li><strong>块</strong>：用于维护一组分配给网络中所有节点的事务</li><li><strong>链</strong>：块顺序</li><li><strong>矿工</strong>：在添加到区块链结构之前执行块验证过程的特定节点</li><li><strong>共识协议</strong>：进行区块链操作的规则集</li></ul></li><li><p><strong>区块链的一个区块永远不能有多个父区块吗</strong></p><p><strong>区块链永远不会有父区块</strong>，每个区块在区块链中都会独立的。</p></li><li><p><strong>什么是51%攻击</strong></p><p>51%攻击或者双花攻击是指区块链上的单个或者一组矿工，他们试图控制超过50%的网络挖掘哈希率或计算能力。这些攻击者试图阻止新交易获得确认，并使他们停止某些或所有用户之间的付款。它们还能够撤销在控制网络时完成的交易。这意味着他们可以双倍花费硬币。</p></li><li><p><strong>什么是RAS算法</strong></p><p>RSA算法也被称为非对称密码算法，它对两个不同的密钥（即公共密钥和私有密钥）起作用。公共密钥可以与任何人共享，并且私有密钥必须保密。公有密钥可以与任何人共享，而私有密钥必须保密。</p><p>该算法是用于签名数据和加密的第一个算法。它最广泛运用于保护敏感数据。</p></li><li><p><strong>RSA会受到攻击吗</strong></p><p>RAS可能会遭到攻击。通常，有两种攻击RSA的方法：</p><ul><li>蛮力：包括所有潜在的秘密密钥。</li><li>数学攻击：在这种情况下，需要使用不同的技术来近似地计算两个素数的乘积。</li></ul></li><li><p><strong>什么是双重支出</strong></p><p>双倍支出被认为是数字现金计划的潜在缺陷，因为多次使用相同的数字令牌。令牌通常由可以轻松克隆的数字文件组成。比特币用户通过在区块链上付款时等待确认来保护自己免受双重支出欺诈；随着确认的增加，交易变得不可逆转。</p></li><li><p><strong>什么是盲目签名</strong></p><p>盲目签名是密码术中数字签名的一种形式，其中消息的内容在签名或者考虑之前是不可见的。它主要用于作者和签名方不同的隐私相关协议中，这是一种经过验证的方法。</p></li><li><p><strong>区块链中有助于消除安全威胁的关键原则是什么</strong></p><ul><li>连续性计划</li><li>稽核</li><li>确保测试和类似方法</li><li>数据库安全</li><li>保护应用程序</li><li>数字化劳动力培训</li></ul></li><li><p><strong>权益证明和工作量证明有什么区别</strong></p><ul><li><strong>工作量证明</strong>是区块链中的原始共识算法。它用于确认交易并为链产生新的区块。矿工相互竞争以完成网络上的交易并获得奖励。</li><li><strong>股权证明</strong>使共识机制完全虚拟。在这种情况下，一组节点决定放样其交易验证的加密货币。</li></ul></li><li><p><strong>什么是默克尔树，它在区块链中的重要性是什么</strong></p><p>Merkle树也称为哈希树，主要由以太坊和比特币使用。区块链中的Merkle树的重要性在于，<strong>如果有人想验证某个区块中的特定交易，他们可以下载区块头链，而不必下载每个交易和每个区块</strong>。</p><p>默克尔树在区块链技术中起着重要作用。它描述了由各种数据块组成的数据结构。它还通过提供整个交易集的数字指纹来汇总一个块中的所有交易。它可以对大量数据进行有效且安全的内容验证。</p></li><li><p><strong>什么是秘密共享</strong></p><p>秘密共享是用于在区块链中提供数据安全性的主要方法之一。这种方法将个人信息或机密信息分为不同的单元，然后将其发送给网络上的用户。原始信息共享给分配了秘密共享的参与者。</p></li><li><p><strong>什么是安全策略</strong></p><p>安全策略是一个正式且简短的计划，其中包含组织的目标，目的和信息安全程序。简而言之，它定义了确切地需要保护免受威胁的条件以及在威胁发生时如何处理情况。</p></li><li><p><strong>为什么区块链需要硬币或者代币</strong></p><p>令牌/代币被视为是交换媒介。它们是内置的数字资产，可在区块链内执行特定的功能。某人进行交易时，状态会发生变化，coin会从一个地址转移到另外一个地址。</p></li><li><p><strong>什么是采矿</strong></p><p>挖掘是通过向网络提供工作证明来向大型分布式公共分类账添加交易的过程，即生成的区块是有效的。它还将新硬币添加到生成的块中。</p></li><li><p><strong>脱链交易和链上交易有什么不同</strong></p><p><strong>链上交易</strong>：这些交易在区块链上可用，并且对区块链网络上的所有节点都是可见的。包括由一定数量的参与者对交易进行身份验证和确认；<br><strong>链下交易</strong>：这些交易处理区块链外部的值，可以使用多种方法进行。</p></li><li><p><strong>集中式网络，分散式网络和分布式分类账之间有什么区别</strong></p><p><strong>集中式网络</strong>：具有中央机构以方便其操作；<br><strong>分散网络</strong>：分散网络中的连接节点不依赖于单个服务器点，并且每个节点都拥有网络配置的整个副本；<br><strong>分布式分类账</strong>：这是共享分类帐，不受任何中央机构的控制。本质是分散的，并充当金融、法律或电子资产的数据库。</p></li><li><p><strong>区块链生态系统的主要元素是什么</strong></p><ul><li><strong>共享账本</strong>：本质上是分散的，是区块链的核心组成部分；</li><li><strong>节点应用程序</strong>：一种软件，可以让计算机与区块链连接；</li><li><strong>虚拟应用程序</strong>：处理区块链承担的所有任务；</li><li><strong>共识算法</strong>：用于管理区块链规则，通过该规则每个节点都可以得出结论。</li></ul></li><li><p><strong>在保护交易记录时，如何进行风险管理</strong></p><p>基于数据的价值。</p><ul><li>第一种，确定与组织的财务记录相关的威胁和漏洞，并相应地采取正确的对策。</li><li>第二种，注意备份计划。</li><li>第三种，购买新的风险管理软件。</li></ul></li><li><p><strong>在组织中采用区块链技术是否有特定于网络的条件</strong></p><p>使用区块链没有特定的网络条件。但是，该网络必须是特定协议下的对等网络。</p></li><li><p><strong>区块链有哪些框架</strong></p><ul><li>Hyperledger Fabric：是区块链技术的一种实现，旨在作为开发区块链应用程序或解决方案的基础。</li><li>Hyperledger Iroha：是一个分布式分类帐项目，旨在简化并易于整合到需要分布式分类帐技术的基础设施项目中。</li><li>Chain：Chain Core 的基础设施使企业能够在许可网络上发布和转移金融资产，仅允许授权和识别的实体成为区块链网络的一部分。</li><li>IOTA：IOTA的分类帐非常适合需要小额支付和连接设备的场景。</li><li>以太坊：是一个运行智能合约的去中心化平台：完全按照设定程序运行的应用程序，不涉及任何停机、审查、欺诈或第三方干扰。</li><li>Libra：Facebook推出的区块链框架。</li></ul></li><li><p><strong>如何在保证所有人都可以访问的情况下防止篡改</strong></p><p>区块链主要是依靠加密技术来保障数据的安全，主要使用到了加密哈希函数。</p><p>哈希算法是无论输入的大小如何，输出始终是相同的字节。但如果输入发生变化，输出将完全不相同。只要输入不变，则不管运行多少次哈希函数，输出的哈希值都是始终相同的。</p><p>在区块链中，输出值（即哈希）是数据块的唯一标识符。每个区块的哈希是相对于前一个区块的哈希生成的。区块的哈希值是由其所包含的哈希函数决定的，任何数据的改变都会更改哈希值。所以，该区块的哈希值是由所包含的数据和前一区块的哈希值决定的。这就确保了区块链的安全性和不可篡改性。</p></li><li><p><strong>描述一下从交易发出到交易上链，以及如何实现共识</strong></p><p>区块“链”的链，包含“<strong>数据链</strong>”和“<strong>节点链</strong>”。“数据链”指用链式结构组织区块数据，构成数据校验和追溯的链条；“节点链”指多个节点通过网络连接在一起，互相共享信息，其中的共识节点则联合执行共识算法，产生并确认区块。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/11.jpeg" alt=""></p><p>交易“上链”的简要过程如下：</p><ol><li><p>记账者们收录交易，按链式数据结构打包成“区块”。</p></li><li><p>共识算法驱动大家验证新区块里的交易，确保计算出一致的结果。</p></li><li><p>数据被广播到所有节点，稳妥存储下来，每个节点都会存储一个完整的数据副本。</p></li></ol><p>交易一旦“上链”，则意味着得到完整执行，达成了“分布式事务性”，即永久可见且无法更改。</p><p>“上链”意味着“<strong>共识</strong>”和“<strong>存储</strong>”，两者缺一不可。交易不经过共识，则不能保证一致性和正确性，无法被链上所有参与者接受；共识后的数据不被多方存储，意味着数据有可能丢失或被单方篡改，更谈不上冗余可用。</p><p>除此之外，如果仅仅是调用接口查询一下，没有改变任何链上数据，也不需要进行共识确认，则不算“上链”。</p><hr><p>区块链是通过共识算法来让不同的节点之间达成共识。例如PoW、PoS等。</p></li><li><p><strong>区块链有哪些应用场景</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(CloudComputing)</title>
      <link href="/2020/06/06/Interview-Review(CloudComputing)/"/>
      <url>/2020/06/06/Interview-Review(CloudComputing)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的云计算部分。</p><a id="more"></a><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li><p>云计算中弹性与可拓展性的区别是什么<br>可拓展性通过增加资源容量的比例来处理不断增加的工作量。通过使用可拓展性，如果流量引发需求，则体系结构提供随需应变的资源。</p><p>弹性是一种特征，它提供动态调试和退役大量资源容量的概念。它通过资源的需求速度和资源的使用来衡量。</p></li><li>使用云计算的优点<ul><li>数据备份和数据存储</li><li>强大的服务器功能</li><li>提高生产力</li><li>非常划算且节省时间</li></ul></li><li>哪些平台可用于大规模云计算<ul><li>Apache Hadoop</li><li>MapReduce</li></ul></li><li>云计算部署的不同模型<ul><li>私有云</li><li>公共云</li><li>混合云</li><li>社区云</li></ul></li><li>云计算与移动计算有何区别<br>移动计算和云计算在概念上略有相同。移动计算使用云计算的概念。云计算为用户提供他们在移动计算中所需的数据，在远程服务器上运行的应用程序以及为用户提供存储和管理的访问权限。</li><li>用户如何得益于公益计算（Utility Computing）<br>公用计算让用户可以只需要为使用的资源付费。它是由决定从云端部署哪种类型的服务的企业组织管理的一种插件。</li><li>云在安全方面的措施有哪些<ul><li>身份管理：授权应用程序服务</li><li>访问控制：将权限授予用户，用户就可以控制进入到云环境的另一个用户的访问</li><li>验证和授权：只允许通过授权和验证的用户访问数据和应用程序</li></ul></li><li>虚拟化平台在实施云中的主要用途（有何要求）<ul><li>它用于管理服务级别策略</li><li>云操作系统</li><li>虚拟化平台有助于保持后端级别和用户级别概念彼此不同</li></ul></li><li>在使用云计算平台前，用户需要考虑哪些必要的方面<ul><li>合规</li><li>数据丢失</li><li>数据存储</li><li>业务连续性</li><li>正常运行时间</li><li>云计算的数据完整性</li></ul></li><li>开源的云计算平台数据库有哪些<ul><li>MongoDB</li><li>CouchDB</li></ul></li><li>解释软件即服务（SaaS）的不同模式<ul><li>简单的多租户模式：在该模式中，每个用户有独立的资源，与其它用户分开来，是一种高效的模式；</li><li>细粒度的多租户模式：在该模式中，资源由许多租户共享，功能仍然一样；</li></ul></li><li>API在云服务中有何用途<br>API用于云平台，它提供了一种替代方法，无需编写完全成熟的应用程序，它可以在一个或者多个应用程序之间进行通信。</li><li>为云计算部署了哪些不同的数据中心<ul><li>集装箱式数据中心</li><li>低密度数据中心</li></ul></li><li>云计算中有哪些不同的层<ul><li>SaaS：软件即服务，它让用户可以直接访问云应用程序，不必在系统上安装任何东西</li><li>IaaS：基础设施即服务，它从硬件等层面提供了基础设施</li><li>PaaS：平台即服务，它为开发人员提供了云应用程序平台</li></ul></li><li>云服务是什么<br>云服务用来通过互联网，使用网络中的服务器来构建应用程序，它提供了这种便利：不必将云应用程序安装到计算机上，即可直接使用。它还减少了维护和支持使用云服务开发的应用程序的工作。</li><li>云架构具有的好处<ul><li>无需基础设施投入</li><li>适时的基础设施</li><li>更高效地利用资源</li></ul></li><li>云架构有别于传统架构的特点<ul><li>按照需求，云架构满足硬件要求</li><li>云架构能够按需增减资源</li><li>云架构能够管理和处理动态工作负载，顺畅无阻</li></ul></li><li>在云架构中，必须的不同部分有哪些<ul><li>云入站</li><li>处理器速度</li><li>云存储服务</li><li>云提供商服务</li><li>云间通信</li></ul></li><li>在云架构中，经历的不同阶段有哪些<ul><li>启动阶段</li><li>监测阶段</li><li>关闭阶段</li><li>清理阶段</li></ul></li></ol><h3 id="Kubernetes"><a href="#Kubernetes" class="headerlink" title="Kubernetes"></a>Kubernetes</h3><ol><li>Kubernetes与Docker Swarm的区别如何</li><li>Kubernetes与Docker有什么关系</li><li>在主机和容器上部署应用程序有什么区别</li><li>什么是Container Orchestration</li><li>Container Orchestration需要什么</li><li>Kubernetes Architecture的不同组件有哪些</li><li>Kubernetes包含几个组件，各个组件的功能是什么，组件之间是如何交互的</li><li>k8s中的pod内几个容器之间的关系是什么</li><li>一个经典pod的完整生命周期</li><li>容器编排的价值和好处是什么</li><li>如何在 Kubernetes 中实现负载均衡</li></ol><h3 id="OpenStack"><a href="#OpenStack" class="headerlink" title="OpenStack"></a>OpenStack</h3><ol><li>OpenStack及其主要组件</li><li>什么服务通常在控制节点上运行</li><li>什么服务通常在计算节点上运行</li><li>计算节点上虚拟机的默认地址是什么</li></ol><h3 id="OpenNebula"><a href="#OpenNebula" class="headerlink" title="OpenNebula"></a>OpenNebula</h3><h3 id="Serverless"><a href="#Serverless" class="headerlink" title="Serverless"></a>Serverless</h3><h3 id="Container"><a href="#Container" class="headerlink" title="Container"></a>Container</h3><h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><h3 id="Swarm"><a href="#Swarm" class="headerlink" title="Swarm"></a>Swarm</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(BigData)</title>
      <link href="/2020/06/06/Interview-Review(BigData)/"/>
      <url>/2020/06/06/Interview-Review(BigData)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的大数据部分。</p><a id="more"></a><h3 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h3><ol><li><p>什么是Hadoop</p><blockquote><p>Hadoop是一个开源软件框架，用于存储大量数据，并发处理/查询在具有多个商用硬件节点的集群上的那些数据。</p></blockquote><p> HDFS（Hadoop Distributed File System，Hadoop分布式文件系统）：HDFS允许以一种分布式和冗余的方式存储大量数据。例如，1024MB可以拆分为16*128MB文件，并存储在Hadoop集群中的8个不同的节点上。每个分裂可以复制3次，以实现容错，以便如果1个节点故障的话，也有备份。</p><p> MapReduce：是一个计算框架（Google三剑客之一：GFS、BigTable、MapReduce）。它以分布式和并行的方式处理大量的数据。例如，当对所有年龄大于18的用户在上面的1024MB文件中查询时，会有8个Map函数并行运行，以在其128MB拆分文件中提取年龄大于18的用户，然后Reduce函数将运行以将所有单独的输出组合成单个最终结果。Map就是拆解，Reduce就是组装，本治就是分治法。</p></li><li><p>正常工作的Hadoop集群中都需要启动哪些进程，作用分别是什么</p><ul><li>NameNode：是HDFS的守护进程，负责记录文件是如何分割成数据块，以及这些数据块分别被存储到哪些数据节点上，它的主要功能是对内存以及IO进行集中管理；</li><li>Secondary NameNode：辅助后台程序，与NameNode进行通信，以便定期保存HDFS元数据的快照；</li><li>DataNode：负责把HDFS数据块读写到本地的文件系统；</li><li>JobTracker：负责分配task，并监控所有运行的task；</li><li>TaskTracker：负责执行具体的task，并与JobTracker进行交互；</li></ul></li><li><p>列举出流行的Hadoop调度器，并简要说明其工作方法</p><p> Hadoop调度器的基本作用就是根据节点资源使用情况和作业的要求，将任务调度到各个节点上执行；</p><p> <strong>调度器需要考虑的因素有三种</strong>：</p><ul><li>作业优先级：作业优先级越高，能够获取到的资源也越多。Hadoop提供了5种作业优先级，分别是<code>VERY_HIGH</code>、<code>HIGH</code>、<code>NORMAL</code>、<code>LOW</code>、<code>VERY_LOW</code>、<code>VERY_LOW</code>，通过<code>mapreduce.job.priority</code>属性来设置。</li><li>作业提交时间：作业提交的时间越早，就越先执行；</li><li><p>作业所在队列的资源限制：调度器可以分为多个队列，不同的产品线放到不同的队列里运行。<strong>不同的队列会设置一个边缘限制</strong>，这样不同的队列就会有自己独立的资源，不会出现抢占和滥用资源的情况。</p><p><strong>自带调度器有三种</strong>：</p></li><li><p>先进先出调度器（FIFO）：</p><p>  FIFO是Hadoop中默认的调度器，也是一种<strong>批处理调度器</strong>。它先按照作业的优先级高低，再按照到达时间的先后选择被执行的作业。</p></li><li><p>容量调度器（Capacity Scheduler）：</p><p>  支持多个队列，每个队列可以配置一定的资源量，每个队列采用FIFO调度策略，<strong>为了防止同一个用户的作业独占队列中的资源，该调度器会对同一用户提交的作业所占资源量进行限定</strong>；</p></li><li><p>公平调度器（Fair Scheduler）：</p><p>  支持多队列多用户，每个队列中的资源量可以配置，<strong>同一队列中的作业公平共享队列中的所有资源</strong>。</p></li></ul></li><li><p>简要说一下Hadoop的MapReduce编程模型</p><p> 首先Map task会从本地文件系统读取数据，转换成key-value形式的键值对集合。使用的是Hadoop内置的数据类型，比如longwritable、text等。然后将键值对集合输入mapper进行业务处理过程，将其转换成需要的key-value再输出。</p><p> 之后会进行一个partition的分区操作，默认使用的是hashpartitioner，可以通过重写hashpartitioner的getpartition方法来自定义分区的规则；</p><p> 之后会对key进行sort排序，grouping分组操作将相同key的value合并分组输出；</p><p> 之后进行combiner归约操作，即一个本地段的reduce预处理，以减小后面shuffle和reducer的工作量；</p><p> reduce task通过网络将各个数据收集进行reduce处理，最后将数据保存或者显示，结束整个job。</p></li><li><p>MapReduce的大致过程：</p><p> MapReduce大致可以分为<strong>input</strong>、<strong>split</strong>、<strong>map</strong>、<strong>shuffle</strong>、<strong>reduce</strong>、<strong>output</strong>六个步骤。</p><ul><li>输入input：输入数据，一般是HDFS上的文件或目录</li><li>拆分split：切割文件，例如将字符串分割成每个单词</li><li>映射map：将拆分的内容转换成key-value形式</li><li>派发shuffle：将key相同的放到一起value是一个序列，这步涉及到数据移动，会将key相同的数据移动到一台机器上</li><li>缩减recude：将同样key的value序列进行计算</li><li>输入output：输出结果</li></ul></li><li><p>为什么要用flume导入HDFS，HDFS的架构是怎么样的</p></li><li><p>MapReduce程序运行的时候会有什么比较常见的问题</p></li><li><p>Hadoop的性能调优</p></li><li><p>HDFS的特点</p><ul><li>处理超大文件</li><li>高容错性，运行在廉价机器上</li><li>横向扩展</li><li>流式数据处理，而不是随机读写（流式数据读取指的是一个文件只能写一次，后面一直追加，所以每次读取只需要从头开始一直往后读即可）</li><li>不支持文件修改，只能追加写入</li><li>对大量的小文件性能不好</li></ul><ol><li>主从架构，有两种角色namenode和datanode。namenode负责管理存储元数据，处理客户端读写请求；datanode存储真正的数据，执行读写操作；</li><li>读流程：客户端访问namenode，验证权限，返回数据具体的datanode的地址，客户端访问datanode读取数据；</li><li>写流程：客户端访问namenode，验证权限并确定文件是否存在，然后先记录到editLog返回输出流对象，客户端最近的一个datanode写数据，每写一个数据块，其余的datanode自己同步</li></ol></li><li><p>YARN的工作原理，简述其工作方法</p><p>YARN全称yet another resource negotiator，即另一种资源调度器。</p><p><strong>ResourceManager</strong>：</p><p>ResourceManager有为所有应用程序仲裁资源的权限的功能，用来代替JobTracker，主要由schedule和ApplicationManager组成。</p><p>schedule通过container来分配资源，封装了磁盘、内存、CPU等资源。</p><p>ApplicationManager负责接收作业的提交，并申请第一个container来执行作业的ApplicationMaster，并提供失败时重启ApplicationManager的container，而作业的ApplicationMaster向schedule申请资源。</p><p><strong>NodeManager</strong>：</p><p>NodeManager是YARN在每台机器上的代理，负责启动并管理节点上的container，container执行具体的由ApplicationMaster划分的任务。</p><p><strong>整体流程</strong>：</p><ol><li>客户端向ResourceManager的ApplicationManager提交程序；</li><li>ResourceManager的ApplicationManager在NodeManager启动第一个container执行ApplicationManager</li><li>ApplicationManager拆分程序，划分成一个个的task，这些task可以在container上运行，然后向ResourceManager申请资源执行task，并向ResourceManager发送心跳；</li><li>申请到container后，ApplicationMaster会和NodeManager通信，并将task发送到对应的container执行，task会向ApplicationMaster发送心跳；</li><li>程序执行完成，ApplicationMaster会向ResourceManager注销并释放资源；</li></ol></li></ol><h3 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h3><ol><li><p>Spark有几种部署模式，每种模式的特点</p><ul><li>local模式（本地模式）：运行在一台机器上，常用于本地开发测试，本地模式还分为local单线程和local-cluster多线程；</li><li>standalone模式（集群模式）：典型的Master/Slave模式，起初Master是有单点故障的；</li><li>yarn模式（集群模式）：运行在yarn资源管理器框架之上，由yarn负责资源管理，Spark负责任务调度和计算；</li><li>mesos模式（集群模式）：运行在mesos资源管理器框架之上，由mesos负责资源管理，Spark负责任务调度和计算；</li></ul></li><li><p>Spark为什么比MapReduce快（Run workloads 100x faster）</p><ul><li><p>Spark是基于内存计算的，减少了低效的磁盘交互；而MapReduce是基于磁盘的迭代。</p><ul><li>MapReduce的设计：中间结果保存在文件中，提高了可靠性，减少了内存占用，但是牺牲了性能；</li><li>Spark的设计：数据在内存中进行交换，要更快一些，所以性能要比MapReduce好，但是内存的可靠性不如磁盘；</li></ul></li><li><p>高效的调度算法，基于DAG；</p></li><li>容错机制Linage；</li></ul></li><li><p>Hadoop和Spark的shuffle相同和差异</p></li><li><p>RDD宽依赖和窄依赖</p></li><li><p>cache和pesist的区别</p></li><li><p>RDD有哪些缺陷</p></li><li><p>RDD有哪几种操作类型</p></li><li><p>Spark的工作机制</p></li><li><p>Spark的优化怎么做</p></li><li><p>Spark中数据的位置是被谁管理的</p></li><li><p>Spark的数据本地性有哪几种</p></li><li><p>Spark的常用算子区别</p></li><li><p>Transformation和action是什么，有什么区别，举出一些常用方法</p></li><li><p>Spark on Yarn模式有哪些优点</p></li><li><p>描述Yarn执行一个任务的过程</p></li></ol><h3 id="Storm"><a href="#Storm" class="headerlink" title="Storm"></a>Storm</h3><ol><li>Storm的工作原理是什么</li><li>流的模式是什么？默认是什么？</li><li>Storm Group分类</li><li>Storm的特点和特性是什么<ul><li>编程简单：开发人员只需要关注应用逻辑，而且跟Hadoop类似，Storm提供的编程语言也很简单</li><li>高性能，低延迟：可以应用于广告搜索引擎等要求实时响应的场景</li><li>分布式：可以轻松应对数据量大，单机搞不定的场景</li><li>可拓展：随着业务的发展，数据量和计算量越来越大，系统可水平扩展</li><li>容错：单个节点挂了是不影响应用的</li><li>消息不丢失：保证了消息处理</li></ul></li><li>Storm组件有哪些</li></ol><h3 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h3><ol><li>Kafka的设计是怎么样的</li><li>数据传输的事物定义有哪三种</li><li>Kafka判断一个节点是否还活着的两个条件</li><li>Kafka与传统消息系统之间的三个关键区别</li><li>Kafka高消息文件存储设计的特点</li><li>Kafka有哪几个组件</li></ol><h3 id="ZooKeeper"><a href="#ZooKeeper" class="headerlink" title="ZooKeeper"></a>ZooKeeper</h3><ol><li>ZooKeeper都要哪些功能</li><li>ZooKeeper怎么保证主从节点的状态同步</li><li>ZooKeeper有几种部署模式<ul><li>单机部署：一台集群上运行；</li><li>集群部署：多台集群上运行；</li><li>伪集群部署：一台集群启动多个ZooKeeper实例运行</li></ul></li><li>ZooKeeper的通知机制</li><li>集群中有 3 台服务器，其中一个节点宕机，这个时候 Zookeeper 还可以使用吗</li><li>两阶段提交和三阶段提交的过程</li><li>ZooKeeper宕机如何处理</li><li>获得分布式锁的流程</li><li>ZooKeeper队列管理</li><li>ZooKeeper下Server的工作状态</li><li>ZooKeeper是如何保证事务的顺序一致性的</li><li>ZooKeeper负载均衡和nginx负载均衡区别</li></ol><h3 id="Flink"><a href="#Flink" class="headerlink" title="Flink"></a>Flink</h3><h3 id="Flume"><a href="#Flume" class="headerlink" title="Flume"></a>Flume</h3><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><ol><li>Hive中存放的是什么</li><li>Hive与关系型数据库的关系</li></ol><h3 id="Hbase"><a href="#Hbase" class="headerlink" title="Hbase"></a>Hbase</h3><h3 id="Pig"><a href="#Pig" class="headerlink" title="Pig"></a>Pig</h3><h3 id="Sqoop"><a href="#Sqoop" class="headerlink" title="Sqoop"></a>Sqoop</h3><h3 id="Kylin"><a href="#Kylin" class="headerlink" title="Kylin"></a>Kylin</h3><h3 id="布隆过滤器"><a href="#布隆过滤器" class="headerlink" title="布隆过滤器"></a>布隆过滤器</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Algorithm)</title>
      <link href="/2020/06/06/Interview-Review(Algorithm)/"/>
      <url>/2020/06/06/Interview-Review(Algorithm)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的算法部分。</p><a id="more"></a><h2 id="深度学习"><a href="#深度学习" class="headerlink" title="深度学习"></a>深度学习</h2><h3 id="模型评估方法"><a href="#模型评估方法" class="headerlink" title="模型评估方法"></a>模型评估方法</h3><ol><li><p>Accuracy作为指标有哪些局限性</p><p> 准确率的定义是：分类正确的样本占总样本个数的比例，$Accuracy = \frac{n_{correct}}{n_{total}}$。但是此指标存在以下缺陷：</p><p> 当正负样本非常不均衡时，占比大的类别就成为了影响准确率的主要因素，比如负样本占90%时，即使把所有样本都预测为负样本，也可以轻松获得90%的准确率，而这样的准确率是没有意义的，不足以说明分类器的好坏。</p></li><li><p>ROC曲线和PR曲线各是什么</p></li><li><p>编程实现AUC的计算，复杂度是多少</p></li><li>AUC指标有什么特点？放缩结果对AUC是否有影响</li><li>余弦距离与欧氏距离有什么特点</li></ol><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><ol><li><p>如何划分训练集？如何选择验证集？</p><p> 有以下几种不同的方法划分训练集与验证集：</p><ul><li><p>留出法：</p><ol><li>把数据集划分成互不相交的两部分，一部分作为训练集，一部分作为测试集；</li><li>保持数据的分布大致一致，类似分层抽样；</li><li>训练集数据所占比例应该为2/3或4/5左右</li><li>为了保证随机性，将数据集多次随机划分为训练集和测试集，然后再对多次划分的结果去平均</li></ol></li><li><p>k折交叉验证法：</p><ol><li>将数据集随机分为互斥的k个子集，为保证随机性，使用p次随机划分取平均；</li><li>将k个子集随机分为k-1个组，剩下一个为另一组，有k种分法；</li><li>在每一种方法的分组结果中，那个k-1个子集的组都作为训练集，剩下的一个组作为测试集，这样就产生了k次预测，并对其取平均；</li><li>这种方法称为p次k折交叉验证，一般k取10</li></ol></li><li><p>自助法：</p><ol><li>当样本量足够时，使用自助法不如使用留出法和交叉验证法，因为无法满足数据分布一致。而如果样本量较小，无法划分，就可以使用自助法；</li><li>每次随机从数据集中抽取一个样本，然后再放回（可能会被重复抽出），m次之后会得到有m个样本的数据集，将其作为训练集；</li><li>始终没有抽到的样本的比例按概率算约是36.8%，这也保证了训练集占比大概在2/3左右</li></ol></li></ul></li><li><p>什么是偏差和方差？</p></li><li><p>什么是过拟合？在深度学习中，解决过拟合的方法有哪些？</p><p> 过拟合（overfitting）是指在模型参数拟合过程中的问题。由于训练数据包含了抽样误差，而训练时，复杂的模型将抽样的误差也考虑在内。</p><p> 过拟合具体的表现就是最终模型在<strong>训练集</strong>上效果很好，但<strong>测试集</strong>上效果很差。模型的泛化能力弱。</p><p> 产生过拟合的原因有：</p><ul><li>样本方面的原因。样本数量太少或者抽出的样本数据不能有效地代表场景；</li><li>样本里的噪声数据干扰过大，使得模型过分地记住了噪声特征，反而忽略了真实的输入输出间的关系；</li><li><p>参数太多以及模型复杂度高；</p><p>降低过拟合的方法有：</p></li><li><p>正则化：可以使用L0正则化、L1正则化或L2正则化，机器学习中一般采用L2正则化；</p></li><li>dropout：可以随机地，以一定的概率让一部分神经元失活或者丢弃；</li><li>batch normalization：BN在训练某层时，会对每一个batch数据都进行标准化或者叫归一化（normalization）处理，使得输出的规范呈正态分布；</li><li>early stopping：当随着模型的能力提升，训练集的误差会先减小后增大，所以可以提前终止算法缓解过拟合的现象（例如决策树的预剪枝方法）；</li><li>重新清洗数据：有可能是因为数据不纯导致的，所以需要重新清洗数据；</li><li>Data expending：增大数据的训练量。过拟合有可能是因为训练集的数据量太小导致的，或者训练数据占总数据的比例太小导致的；</li></ul></li><li><p>深度模型参数调整的一般方法论</p></li></ol><h3 id="优化方法"><a href="#优化方法" class="headerlink" title="优化方法"></a>优化方法</h3><ol><li><p>简述了解的优化器</p><ol><li><p>SGD(Stochastic Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J\left(\theta ; x^{(i)} ; y^{(i)}\right)$</p><p> SGD随机梯度下降参数的更新原则是<strong>一条数据都可以对参数进行一次更新</strong>。其它的优化器都是在这个优化器的基础上改善得来的。</p><p> 优点：参数的更新速度快；</p><p> 缺点：由于每次参数更新时采用的数据量小，造成梯度更新时的震荡幅度较大，但是大多数情况是向着梯度较小的方向；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> example <span class="keyword">in</span> data:</span><br><span class="line">        params_grad = eval_gradient(loss_function, example, params)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p> <img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/25/tpQUgK.png" alt="tpQUgK.png"></p><p> 从上图可以看出，SGD的噪音较多，不是每次迭代都向着整体最优化方向。所以虽然训练速度快，但是准确率下降，并不是<strong>全局最优</strong>。</p></li><li><p>BGD(Batch Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J(\theta)$</p><p> BGD批量梯度下降的参数更新原则是：<strong>所有数据</strong>都参与梯度的每一次更新。</p><p> 优点：因为每次参数更新时采用的数据量都非常大，所以梯度更新时比较平滑；</p><p> 缺点：由于参数更新时需要的数据量大，所以更新的速度非常慢；</p> <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    params_grad = eval_gradient(loss_function, example, params)</span><br><span class="line">    params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure></li><li><p>MBGD(Mini-Batch Gradient Descent)</p><p> $\theta=\theta-\eta \cdot \nabla_{\theta} J\left(\theta ; x^{(i: i+n)} ; y^{(i: i+n)}\right)$</p><p> MBGD是每一次利用一小批样本，即<strong>n个样本</strong>进行计算，这样就可以<strong>降低参数更新时的方差，收敛更稳定</strong>。</p><p> 优点：相比SGD，由于参与梯度更新的数据量大，所以梯度更新时较为平滑；相比BGD，参与梯度更新的数据量小，参数更新速度会更快一些。</p><p> 缺点：</p><ol><li>如果数据是稀疏的，希望对出现频率低的特征进行更大的更，learning_rate会随着更新的次数逐渐变小；</li><li><p>不能保证很好的收敛性，learning_rate如果选择得太小，收敛速度会很慢，如果太大，loss_function就会在极小值处不停地震荡甚至偏离。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(nb_epochs):</span><br><span class="line">    np.random.shuffle(data)</span><br><span class="line">    <span class="keyword">for</span> batch <span class="keyword">in</span> get_batches(data, batch_size=n):</span><br><span class="line">        params_grad = eval_gradient(loss_function, batch, patams)</span><br><span class="line">        params = params - learning_rate * params_grad</span><br></pre></td></tr></table></figure><p>这里的<code>batch_size=n</code>的n一般取值在50~256之间。</p></li></ol></li><li><p>Momentum</p><p> $v_{n+1}=\gamma v_{n}+\eta \theta J(\theta)$</p><p> $\theta^{n+1}=\theta^{n}-v_{n+1}$</p><p> Momenntum通过引入$\gamma v_{n}$，加速SGD，并且抑制震荡。$\gamma$一般取值为0.9左右，</p><p> 优点：因为当我们将一个小球从山上滚下来时，没有阻力的话，它的动量就会越来越大，但是如果遇到了阻力，速度就会变小。所以加入了动量，**可以使得梯度方向不变的维度速度变快，梯度方向有所改变的维度上的更新速度变慢，这样就可以加快收敛并且减小震荡。</p><p> 缺点：当梯度方向改变时，梯度更新速度不能及时减小导致适应性差。</p></li><li><p>Adagrad(Adaptive gradient algorithm)</p><p> Adagrad解决了不能根据参数重要性而对不同参数进行不同程度更新的问题。它的参数更新原则是：对低频的参数做较大的更新，对高频的参数做较小的更新。一般超参数$\eta$取值0.01。</p><p> $\theta_{t+1, i}=\theta_{t, i}-\frac{\eta}{\sqrt{G_{t, i i}+\epsilon}} \cdot g_{t, i}$</p><p> 其中g是t时刻时参数$\theta_i$的梯度。</p><p> $g_{t, i}=\nabla_{\theta} J\left(\theta_{i}\right)$</p><p> 优点：对于稀疏的数据它的表现很好，很好地提高了SGD的鲁棒性。</p><p> 缺点：它的缺点是分母会不断的积累，这样学习率就会收缩最终会变得非常小。</p></li><li><p>Adadelta</p><p> Adadelta解决的就是Adagrad的缺点，即分母不断积累，导致学习率收缩变得非常小的问题。</p><p> Adadelta的参数更新原则就是和Adagrad相比，将分母的$G_{t, i i}$换成了过去的梯度平方的衰减平均值，指数衰减平均值。</p><p> $\Delta \theta_{t}=-\frac{\eta}{\sqrt{E\left[g^{2}\right]_{t}}+\epsilon} g_{t}$</p></li><li><p>RMSprop</p><p> 同样是为了解决Adagrad的学习率急剧下降的问题。参数更新原则同样是使用指数加权平均。</p><p> $E\left[g^{2}\right]_{t}=0.9 E\left[g^{2}\right]_{t-1}+0.1 g_{t}^{2}$</p><p> $\theta_{t+1}=\theta_{t}-\frac{\eta}{\sqrt{E\left[g_{t}^{2}\right]+\epsilon}} g_{t}$</p><p> 超参数$\gamma$为0.9，学习率$\eta$为0.001。</p></li><li><p>Adam(Adaptive Moment Estimation)</p><p> Adam相当于RMSprop+Momentum。</p></li></ol></li><li><p>常用的损失函数有哪些，分别适用于场景</p><p> 损失函数是用来<strong>估量模型的预测值$f(x)$与真实值Y的不一致程度</strong>。它是一个非负实值函数，通常使用$L(Y, f(x))$来表示。<strong>损失函数越小，模型的鲁棒性就越好</strong>。</p><ul><li><p>LogLoss对数损失函数</p><p>  可以适用于<strong>逻辑回归，交叉熵损失</strong>等。$\log$损失函数的标准形式是：</p><p>  $L(Y, P(Y | X))=-\log P(Y | X)$</p><p>  softmax使用的是<strong>交叉熵损失函数</strong>，binary_crossentropy使用的是<strong>二分类交叉熵损失函数</strong>，categorical_crossentropy使用的是<strong>多分类交叉熵损失函数</strong>。</p></li><li><p>平方损失函数</p><p>  可以适用于<strong>最小二乘法</strong>等。平方损失函数的标准形式如下：</p><p>  $L(Y, f(X))=(Y-f(X))^{2}$</p><p>  在实际应用中，通常使用均方差MSE作为一项衡量指标，公式如下：</p><p>  $M S E=\frac{1}{n} \sum_{i=1}^{n}\left(\tilde{Y}_{i}-Y_{i}\right)^{2}$</p></li><li><p>指数损失函数</p><p>  可以使用于Adaboost算法。</p></li><li><p>Hinge损失函数</p><p>  在机器学习算法中，hinge损失函数与SVM是息息相关的。其标准形式是：</p><p>  $L(y)=\max (0,1-y \tilde{y}), y=\pm 1$</p></li><li><p>其它损失函数</p><p>  0-1损失函数：$L(Y, f(X))=\left\{\begin{array}{ll}</p><pre><code>          1, &amp; Y \neq f(X) \\          0, &amp; y=f(X)          \end{array}\right.$</code></pre><p>  绝对值损失函数：$L(Y, f(X))=|Y-f(X)|$</p></li><li><p>Keras/Tensorflow中常用的cost function：</p><ul><li>mean_squared_error或者MSE</li><li>mean_absolute_error或者MAE</li><li>mean_absolute_percentage_error或者MAPE</li><li>mean_squared_logarithmic_error或者MSLE</li><li>squared_hinge</li><li>hinge</li><li>categorical_hinge</li><li>binary_crossentropy</li><li>logcosh</li><li>categorical_crossentropy</li></ul></li></ul></li><li><p>梯度下降与牛顿法、拟牛顿法的异同</p></li><li><p>L1和L2正则分别有什么特点？为什么L1更稀疏</p></li><li><p>如何提高小型网络的精度</p></li></ol><h3 id="深度学习基础"><a href="#深度学习基础" class="headerlink" title="深度学习基础"></a>深度学习基础</h3><ol><li>用一层隐藏层的神经网络，以ReLU作为激活函数，MSE作为损失函数推导反向传播</li><li>NN的权重参数能否初始化为0</li><li>什么是梯度消失和梯度爆炸，梯度爆炸的解决方法</li><li>常用的激活函数和导数</li><li>ReLU的优点和局限性，改进方法是什么</li><li>sigmoid和tanh为什么会导致梯度消失</li><li>相比sigmoid激活函数，ReLU激活函数有什么优势</li><li>一个隐藏层需要多少个节点能实现包含n元输入的任意布尔函数</li><li>多个隐藏层实现包含n元输入的任意布尔函数，需要多少个节点和网络层</li><li>Dropout为什么能够防止过拟合</li><li>Dropout和BN在前向传播和反向传播阶段的区别</li><li>解释批量归一化的原理</li><li>什么是反卷积，有哪些用途</li></ol><h3 id="CNN"><a href="#CNN" class="headerlink" title="CNN"></a>CNN</h3><ol><li>给定卷积核的尺寸，特征图大小的计算方法</li><li>网络容量的计算方法</li><li>共享参数有什么优点</li><li>常用的池化操作有哪些，有什么特点，池化层有什么作用</li><li>CNN如何用于文本分类</li><li>ResNet提出的背景和核心理论是什么</li><li>空洞卷积是什么？有什么应用场景，作用是什么</li></ol><h3 id="RNN"><a href="#RNN" class="headerlink" title="RNN"></a>RNN</h3><ol><li>简述RNN，LSTM，GRU的区别和联系</li><li>画出LSTM的结构图，写出公式</li><li>RNN的梯度消失问题，如何解决</li><li>LSTM中是否可以用ReLU作为激活函数</li><li>LSTM各个门分别使用什么作为激活函数</li><li>简述seq2seq模型</li><li>seq2seq在解码的时候有哪些方法</li><li>注意力机制是什么</li></ol><h2 id="机器学习"><a href="#机器学习" class="headerlink" title="机器学习"></a>机器学习</h2><h3 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h3><ol><li><p>样本不均衡如何处理（如何解决不平衡数据集的分类问题）</p><p> 样本不均衡是指不同类别样本的比例相差悬殊，就会对算法的学习过程造成重大的干扰。例如，有1000个样本，只有5个正样本，995个负样本，那么算法把所有的样本都预测为负样本，精度也能达到99.5%。虽然精度很高，但是没有任何意义。</p><p> 解决方法有：</p><ul><li><p>欠采样，减少数量较多的那一类的样本的数量，使得正负样本的比例均衡。</p><p>  欠采样又分为随机欠采样、EasyEnsemble和BalanceCascade以及基于KNN欠采样。</p><ul><li>随机欠采样是指随机从多数类样本中抽取一部分数据进行删除。缺点就是未考虑到样本的分布情况，而采样过程又具有很大的随机性，可能会误删多数类样本中的一些重要信息。</li><li>EasyEnsemble是通过从多数的那一类样本中<strong>有放回</strong>的随机抽取一部分样本生成多个子数据集，将每个子集与少数类数据联合起来进行训练生成多个模型，然后综合多个模型的结果进行判断。方法和随机森林的原理很相似。</li><li>BalanceCascade是通过一次随机欠采样产生训练集，训练一个分类器，对于那些分类正确的多数类的样本不放回，然后剩下的多数类样本再次进行欠采样产生第二个训练器，训练第二个分类器，同样进行操作，以此类推，直到满足某个停止条件。最终的模型也是多个分类器的组合。</li><li>基于KNN欠采样：有四种KNN欠采样的方法。<ul><li>NearMiss-1：选择到最近的三个少数类样本平均距离最小的那些多数类样本</li><li>NearMiss-2：选择到最远的三个少数类样本平均距离最小的那些多数类样本</li><li>NearMiss-3：为每个少数类样本选择给定数目的最近多数类样本，目的是保证每个少数类样本都被一些多数类样本包围</li><li>最远距离：选择到最近的三个少数类样本平均距离最大的那些多数类样本</li></ul></li></ul></li><li><p>过采样，增加数量较少的那一类的样本的数量，使得正负样本的比例均衡。</p><p>  过采样又分为随机过采样、SMOTE算法和Borderline-SMOTE算法以及基于K-means过采样。</p><ul><li>随机过采样是指多次随机从少数类样本中有放回的抽取数据，采取数量大于原有的少数类样本的数量。其中的有一部分数据会出现重复，而重复数据的出现会增大方差造成模型的过拟合。</li><li>SMOTE的全称是Synthetic Minority Oversampling Technique，即合成少数类过采样技术。它是基于随机过采样算法的一种改机方案。SMOTE算法的基本思想是对少数类样本进行分析并根据少数类样本人工合成新样本添加到数据集中。</li><li>Borderline-SMOTE算法较SMOTE算法提升的地方是只为那些K近邻中有一半以上多数类样本的少数类样本生成新样本，因为这些样本容易被错分，而在这些少数类样本附近生存人工合成样本，有助于少数类样本的分类正确。而如果少数类样本周围全是多数类样本，这种情况下，这个样本会被认定为噪声样本。</li><li>基于K-means聚类过采样方法是首先分别对正负例进行K-means聚类，聚类之后，对其中较小的蔟进行上面的过采样方法扩充样本数量。然后再进行正负类样本的均衡扩充。</li></ul></li><li><p>不处理样本，样本分类阈值移动。</p></li></ul></li><li><p>什么是生成模型什么是判别模型</p></li><li><p>什么是鞍点问题</p></li><li><p>集成学习的分类？有什么代表性的模型和方法</p></li><li><p>常用的特征筛选方法有哪些</p></li><li><p>文本如何构造特征</p></li><li><p>类别变量如何构造特征</p></li><li><p>连续值变量如何构造特征</p></li><li><p>哪些模型需要对特征进行归一化</p></li><li><p>什么是组合特征？如何处理高维组合特征</p></li></ol><h3 id="处理分类问题常用算法"><a href="#处理分类问题常用算法" class="headerlink" title="处理分类问题常用算法"></a>处理分类问题常用算法</h3><h4 id="逻辑回归"><a href="#逻辑回归" class="headerlink" title="逻辑回归"></a>逻辑回归</h4><ol><li><p>逻辑回归怎么实现多分类</p><p> 我们知道，普通的逻辑回归只能解决二分类问题。要想实现多分类，就要改进逻辑回归。</p><ol><li>第一种方式是One-Vs-All（或者叫One-Vs-Rest）。直接根据每个类别，都建立一个二分类器。带有这个类别的样本标记为1，带有其它样本的标记为0。如果有k个类别，那么最终就得到了k个针对不同标记的普通的逻辑分类器。</li><li>第二种方式是One-Vs-One。让不同类别的数据两两组合训练分类器。</li><li>第三种方式是修改逻辑回归的损失函数，让其适应多分类问题。即softmax回归。</li></ol></li><li><p>交叉熵公式</p></li><li><p>LR公式，LR的推导和损失函数</p></li><li><p>LR与SVM的区别和联系</p><p> 相同点有：</p><ul><li>都是<strong>监督</strong>的分类算法</li><li>都会线性分类算法</li><li><p>都会判别模型</p><p>不同点有：</p></li><li><p>损失函数不同。LR的损失函数是cross entropy：，SVM的损失函数是最大化间隔距离：</p></li><li>SVM不能产生概率，LR可以产生概率</li><li>SVM依赖于数据的测度，而LR不受影响</li><li>SVM自带结构风险最小化，LR是经验风险最小化</li><li>SVM会用核函数而LR一般不用核函数的原因</li></ul></li><li><p>LR和线性回归的区别</p></li><li><p>为什么正则化可以防止过拟合（为什么L1和L2正则化可以降低过拟合）</p></li><li><p>L1正则和L2正则有什么区别</p></li><li><p>L1正则化不可导，怎么求解</p></li><li><p>逻辑回归为什么一般性能差</p></li><li><p>如何使用LR解决非线性问题</p></li></ol><h4 id="SVM"><a href="#SVM" class="headerlink" title="SVM"></a>SVM</h4><ol><li>SVM什么时候使用线性核，什么时候使用高斯核</li><li>SVM的作用和基本实现原理</li><li>SVM的硬间隔和软间隔表达式</li><li>SVM使用对偶计算的目的是什么，如何推导出来的，手写推导</li><li>SVM为什么要求解决对偶问题？为什么对偶问题与原问题等价</li><li>SVM的物理意义是什么</li><li>SVM的核函数的选择</li><li>SVM的核函数的作用</li><li>SVM的核函数的原理</li><li>SVM为什么采用间隔最大化（与感知机的区别）</li><li>为什么SVM对缺失数据敏感</li><li>SVM的优缺点</li><li>SVM如何调节惩罚因子C</li><li>如何处理SVM中样本不平衡的问题</li><li>SVM如何处理多分类问题</li><li>SVM对噪声敏感的原因</li><li>如何使用SMO最优化方法求解SVM模型</li><li>SMO算法优化的终止条件是什么</li><li>是否一定存在参数使得SVM的训练误差到0</li></ol><h4 id="随机森林"><a href="#随机森林" class="headerlink" title="随机森林"></a>随机森林</h4><ol><li>随机森林与SVM的区别</li><li>随机森林不会发生过拟合的原因</li><li>随机森林与梯度提升树（GBDT）的区别</li><li>随机森林是怎么避免ID3算法信息增益的缺点的</li><li>为什么随机森林能降低方差</li></ol><h4 id="朴素贝叶斯"><a href="#朴素贝叶斯" class="headerlink" title="朴素贝叶斯"></a>朴素贝叶斯</h4><ol><li>朴素贝叶斯的要求（前提假设）是？</li><li>朴素贝叶斯算法原理和工作流程</li><li>什么是先验概率和后验概率</li><li>什么是条件概率</li><li>朴素贝叶斯为什么“朴素”</li><li>朴素贝叶斯可以做多分类吗</li><li>什么是朴素贝叶斯中的零概率问题？如何解决</li><li>朴素贝叶斯中概率计算的下溢问题如何解决</li><li>朴素贝叶斯分类器对异常值敏感吗</li><li>朴素贝叶斯对缺失值敏感吗</li><li>朴素贝叶斯有哪几种常用的分类模型</li><li>朴素贝叶斯算法中使用拉普拉斯平滑，拉普拉斯因子的大小如何确定</li><li>为什么说是朴素贝叶斯是高偏差低方差的</li><li>朴素贝叶斯为什么是增量计算</li><li>高度相关的特征对朴素贝叶斯有什么影响</li><li>朴素贝叶斯有什么优缺点</li></ol><h4 id="决策树"><a href="#决策树" class="headerlink" title="决策树"></a>决策树</h4><ol><li>ID3，C4.5和CART三种决策树的区别</li><li>简述决策树的原理</li><li>简述决策树的构建过程</li><li>决策树有哪些划分指标，其区别和联系</li><li>信息增益率有什么优缺点</li><li>如何对决策树进行剪枝操作，为什么要进行剪枝</li><li>树模型如何调参</li><li>树模型如何剪枝</li><li>预剪枝和后剪枝</li><li>简述一下分类树和回归树</li><li>决策树对缺失值如何处理</li><li>如果决策树属性用完了，但仍未对决策树完成划分该怎么办</li><li>如何避免决策树的过拟合</li><li>决策树需要进行归一化处理吗</li><li>与其它模型比较，决策树有哪些优点和缺点</li></ol><h3 id="处理回归问题常用算法"><a href="#处理回归问题常用算法" class="headerlink" title="处理回归问题常用算法"></a>处理回归问题常用算法</h3><h4 id="线性回归"><a href="#线性回归" class="headerlink" title="线性回归"></a>线性回归</h4><ol><li>简单介绍一下线性回归的原理（什么是线性回归）</li><li>线性回归的求解方法有哪些</li><li>线性回归为什么用均方差</li></ol><h4 id="普通最小二乘回归"><a href="#普通最小二乘回归" class="headerlink" title="普通最小二乘回归"></a>普通最小二乘回归</h4><ol><li>最小二乘法的推导</li><li>最小二乘法和梯度下降法有哪些区别</li></ol><h4 id="逐步回归"><a href="#逐步回归" class="headerlink" title="逐步回归"></a>逐步回归</h4><ol><li>简述逐步回归算法</li></ol><h4 id="多元自适应回归样条"><a href="#多元自适应回归样条" class="headerlink" title="多元自适应回归样条"></a>多元自适应回归样条</h4><ol><li>简述多元自适应回归样条</li></ol><h3 id="处理聚类问题常用算法"><a href="#处理聚类问题常用算法" class="headerlink" title="处理聚类问题常用算法"></a>处理聚类问题常用算法</h3><h4 id="K均值（基于划分的聚类）"><a href="#K均值（基于划分的聚类）" class="headerlink" title="K均值（基于划分的聚类）"></a>K均值（基于划分的聚类）</h4><ol><li>简述一下K-means算法的原理和工作流程</li><li>K-means有什么缺点</li><li>K值如何确定</li><li>初始点选择方法</li><li>K-means不能处理哪种数据</li><li>K-means如何处理大数据（几十亿）</li><li>K-means与KNN有何不同</li></ol><h4 id="DBSCAN（基于密度的聚类）"><a href="#DBSCAN（基于密度的聚类）" class="headerlink" title="DBSCAN（基于密度的聚类）"></a>DBSCAN（基于密度的聚类）</h4><ol><li>DBSCAN与传统的K-means的不同</li><li>DBSCAN的聚类法原理</li></ol><h4 id="LDA"><a href="#LDA" class="headerlink" title="LDA"></a>LDA</h4><h3 id="推荐系统常用算法"><a href="#推荐系统常用算法" class="headerlink" title="推荐系统常用算法"></a>推荐系统常用算法</h3><h4 id="协同过滤算法"><a href="#协同过滤算法" class="headerlink" title="协同过滤算法"></a>协同过滤算法</h4><ol><li>itemCF与userCF的区别和适用场景</li></ol><h4 id="FM"><a href="#FM" class="headerlink" title="FM"></a>FM</h4><h3 id="模型融合和提升的常用算法"><a href="#模型融合和提升的常用算法" class="headerlink" title="模型融合和提升的常用算法"></a>模型融合和提升的常用算法</h3><h4 id="Bagging"><a href="#Bagging" class="headerlink" title="Bagging"></a>Bagging</h4><h4 id="Adaboost"><a href="#Adaboost" class="headerlink" title="Adaboost"></a>Adaboost</h4><h4 id="GBDT"><a href="#GBDT" class="headerlink" title="GBDT"></a>GBDT</h4><h4 id="GBRT"><a href="#GBRT" class="headerlink" title="GBRT"></a>GBRT</h4><h4 id="Stacking"><a href="#Stacking" class="headerlink" title="Stacking"></a>Stacking</h4><h4 id="Blending"><a href="#Blending" class="headerlink" title="Blending"></a>Blending</h4><h4 id="XGBoost"><a href="#XGBoost" class="headerlink" title="XGBoost"></a>XGBoost</h4><h3 id="其它重要算法"><a href="#其它重要算法" class="headerlink" title="其它重要算法"></a>其它重要算法</h3><h2 id="CV"><a href="#CV" class="headerlink" title="CV"></a>CV</h2><h2 id="NLP"><a href="#NLP" class="headerlink" title="NLP"></a>NLP</h2><ol><li>word2vec的原理</li><li>glove的原理</li><li>fasttext的原理</li><li>了解elmo和bert吗？简述与word embedding的联系与趋避</li></ol><h2 id="常用算法"><a href="#常用算法" class="headerlink" title="常用算法"></a>常用算法</h2><h3 id="搜索回溯"><a href="#搜索回溯" class="headerlink" title="搜索回溯"></a>搜索回溯</h3><ol><li>八皇后，全排列，组合</li><li>重复数字的排列，重复数字的组合</li><li>图的搜索</li><li>A star</li></ol><h3 id="概率题"><a href="#概率题" class="headerlink" title="概率题"></a>概率题</h3><ol><li>用rand7构造rand10</li><li>轮盘赌</li></ol><h3 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h3><ol><li>编辑距离</li><li>背包问题</li><li>LCS</li><li>备忘录方法</li></ol><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><ol><li>给定字符串是否符合正则表达式</li><li>给定字符串是否是数字</li><li>KMP</li><li>超大数相加</li></ol><h3 id="海量数据"><a href="#海量数据" class="headerlink" title="海量数据"></a>海量数据</h3><ol><li>海量日志的出现最多的K个字符串</li><li>10亿个1-10的数字排序</li><li>trie树</li><li>布隆过滤器</li></ol><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>算法的几个特征是什么</li><li>算法复杂性的定义，大O、θ、Ω、小o分别表示的含义</li><li>递归算法的定义、递归算法的两个要素</li><li>分治算法的思想</li><li>动态规划算法的两个要素是什么</li><li>贪心算法的思想，贪心算法的两个要素</li><li>回溯法的思想，回溯法中有哪两种典型的模型</li><li>分支限界法思想，有哪两种分支限界法</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(OS)</title>
      <link href="/2020/06/06/Interview-Review(OS)/"/>
      <url>/2020/06/06/Interview-Review(OS)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的操作系统部分。</p><a id="more"></a><ol><li><p><strong>操作系统的四个特性</strong>：</p><ol><li><strong>并发</strong>：同一段时间内多个程序执行</li><li><strong>共享</strong>：系统中的资源可以被内存中多个并发执行的进线程共同使用</li><li><strong>虚拟</strong>：通过时分复用以及空分复用技术实现把一个物理实体虚拟为多个</li><li><strong>异步</strong>：系统中的进程以走走停停的方式执行，且以一种不可预知的速度推进</li></ol></li><li><p><strong>进程和线程的区别</strong></p><ul><li>进程是具有一定功能的程序关于某个数据集合上的<strong>一次运行活动</strong>，<strong>是系统进行资源调度和分配的一个独立单位</strong>；</li><li><strong>线程是进程的实体</strong>，是CPU调度和分派的基本单位，<strong>它是比进程更小的独立运行的基本单位</strong>（<strong>线程不拥有资源</strong>）；</li><li><strong>一个进程可以有多个线程</strong>，多个线程也可以并发执行；</li></ul></li><li><p><strong>线程同步的方式有哪些</strong></p><ul><li><strong>互斥量（CMutex）</strong>：采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权利。因为互斥对象可以保证公共资源不会被多个线程同时访问「<strong>必须是拥有互斥对象的线程</strong>」；</li><li><strong>信号量（CSemphore）</strong>：它允许同一时刻多个线程访问同一资源，但是需要<strong>控制同一时刻访问此资源的最大线程数量</strong>；</li><li><strong>事件（信号）</strong>：通过通知操作的方式来保持多线程同步，还可以方便的实现多线程优先级的比较操作</li></ul></li><li><p><strong>进程的通信方式有哪些</strong></p><p> 主要分为：<strong>管道</strong>（普通管道PIPE、流管道（s_pipe）、命名管道（name_pipe））、<strong>系统IPC</strong>（包括消息队列、信号量、共享存储）、<strong>SOCKET</strong></p><ul><li><strong>管道</strong>是一种半双工的通信方式，数据只能单项流动，并且只能在具有亲缘关系的进程间流动，进程的亲缘关系通常是父子进程；</li><li><strong>命名管道</strong>是一种半双工的通信方式，它允许无亲缘关系的进程间进行通信；</li><li><strong>信号量</strong>是一个计数器，用来控制多个进程对资源的访问，通常作为一种<strong>锁机制</strong>；</li><li><strong>消息队列</strong>是消息的链表，存放在内核中并由消息队列标识符标识；</li><li><strong>信号</strong>是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生；</li><li><strong>共享内存</strong>就是映射一段能被其它进程访问的内存，这段共享内存由一个进程创建，但是多个进程可以访问；</li><li><strong>套接字</strong>（<strong>SOCKET</strong>）也是一种进程间通信机制，与其它通信机制不同的是，<strong>它可用于不同进程间的进程通信</strong>。</li></ul></li><li><p><strong>什么是缓冲区溢出？有什么危害？其原因是什么？</strong></p><p> 缓冲区溢出（Buffer Overflow）是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上；</p><p> 危害：</p><ul><li>程序崩溃，导致拒绝额外服务；</li><li><p>跳转并且执行一段恶意代码</p><p>原因：造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入</p></li></ul></li><li><p><strong>什么是死锁？死锁产生的四个条件？</strong></p><p> 在两个或者多个并发进程中，如果每个进程持有某种资源而又等待其它进程释放它们持有的资源，在未改变这种状态之前都不能向前推进，称这一组进程产生了死锁。即<strong>两个或者多个进程因争夺资源而造成的无限期的阻塞、相互等待的一种状态</strong>。</p><p> 死锁产生的四个条件（有任一条件不成立都不会产生死锁）：</p><ul><li><strong>互斥条件</strong>：一个资源一次只能被一个进程使用</li><li><strong>请求与保持条件</strong>：一个进程因请求资源而被阻塞时，又对已有的资源保持不放</li><li><strong>不剥夺条件</strong>：进程获得的资源，在未完全使用之前，不能强行剥夺</li><li><strong>循环等待条件</strong>：若干进程之间形成一种头尾相接的环形等待资源关系</li></ul></li><li><p><strong>进程有哪几种状态</strong></p><ul><li><strong>就绪状态</strong>（Ready）：当进程已获得除处理机以外的所需资源，等待分配处理机资源，只要获得处理机便可立即执行</li><li><strong>运行状态</strong>（Running）：已获得处理机，占用处理机资源运行，处于此状态的进程数小于等于CPU数</li><li><p><strong>阻塞状态</strong>（Blocked）：进程等待某种条件，在条件满足之前无法执行，放弃处理机处于阻塞状态</p><p><strong>就绪→执行</strong>：处于就绪状态的进程，当进程调度程序为之分配了处理机后，就会从就绪状态变成执行状态；</p><p><strong>执行→就绪</strong>：处于执行状态的进程在其执行过程中，因分配给它的一个时间片已用完而就不得不让出处理机，进程从执行状态转变成就绪状态；</p><p><strong>执行→阻塞</strong>：正在执行的进程因等待某种事件发生而无法继续执行时，便从执行状态变成阻塞状态</p><p><strong>阻塞→就绪</strong>：处于阻塞状态的进程，若其等待的事件已经发生，于是进程由阻塞状态转变为就绪状态</p></li></ul></li><li><p><strong>分页和分段有什么区别</strong></p><p> <strong>分页</strong>：用户程序的地址空间被划分为若干固定大小的区域，称为“<strong>页</strong>”。相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。</p><p> <strong>分段</strong>：将用户程序地址空间分成若干个大小不等的段，每段可以定义一组相对完整的逻辑信息。存储分配时，以段的单位，段与段在内存中可以不相连接，这样也实现了离散分配。</p><p> <strong>区别</strong>：</p><ul><li>段是信息的<strong>逻辑单位</strong>，它是<strong>根据用户的需要划分</strong>的，因此段对用户是<strong>可见的</strong>；页是信息的<strong>物理单位</strong>，是为了<strong>管理主存的方便而划分</strong>的，对用户是<strong>透明的</strong>；</li><li>段的大小是<strong>不固定</strong>的，由完成它的<strong>功能决定</strong>；页的大小是<strong>固定</strong>的，由<strong>系统决定</strong>；</li><li>段向用户提供二维地址空间；页向用户提供的是一维地址空间；</li><li><p>段是信息的逻辑单位，便于存储保护和信息的共享；页的保护和共享受到限制</p><p><strong>抽象的比喻</strong>：用一个笔记本（100页纸）去上课做笔记，课程有语数英三门课。那么记笔记的方式有两种：</p></li><li><p><strong>分段管理</strong>：从笔记本的第1页开始记笔记，事先规划好，比如2~30页做语文笔记，30~70页做数学笔记，70~100页做英语笔记。最后在第一张纸（第1页）上做个列表，记录三门课笔记的页数范围。这就是<strong>分段管理</strong>，第1页叫段表。</p></li><li><strong>分页管理</strong>：因为课是交叉上的，即这节课语文课，下节课可能是英语课。所以就有可能将各笔记连接起来记。第2页是语文，第3页是英语，第4页是数学，然后又是语文，这样交叉记笔记。然后在第1页做一个<strong>目录</strong>，记录语文的笔记在哪几页，数学的在哪几页。这种做法就是<strong>分页管理器</strong>，第1页就叫做<strong>页表</strong>。</li></ul></li><li><p><strong>常用的页面置换算法</strong></p><ul><li><strong>先进先出算法</strong>：最简单粗暴的一种置换算法，没有考虑页面访问的频率信息。<strong>每次都是淘汰最早调入的页面</strong>。</li><li><strong>最佳置换算法</strong>：是一种只具有理论意义的算法。策略是<strong>将当前页面中在未来最长时间内不会被访问的页面置换出去</strong>。</li><li><strong>最近最久未使用置换算法（LRU）</strong>：算法会赋予每个页面一个访问字段，用来记录上次页面被访问到现在所经历的时间间隔t，每次置换的时候就把t值最大的页面置换出去（可以通过寄存器或者栈的方式来实现）。</li><li><strong>最近未使用置换算法（NRU）</strong>：也叫<strong>时钟算法clock</strong>。页面设置一个访问位，并将页面链接为一个环形队列，页面被访问的时候访问位设置为1。页面置换的时候，如果当前指针所指页面访问为0，那么就置换，否则就将其置为0，循环，直到遇到一个访问位为0的页面。</li><li><strong>改进型clock算法</strong>：在时钟算法clock的基础上，再添加一个<strong>修改位</strong>。替换时，根据访问位和修改位综合判断。优先替换访问位和修改位都为0的页面，其次是替换访问位为0修改位为1的页面。</li><li><strong>最少使用算法（LFU）</strong>：设置寄存器记录页面被访问次数，每次置换的时候都置换当前访问次数最少的页面。</li></ul></li><li><p><strong>操作系统中进程调度策略有哪几种</strong></p><ul><li><strong>先来先服务调度算法</strong>：先来先服务（FCFS）调度算法是一种最简单的调度算法，该算法<strong>既可用于作业调度，也可用于进程调度</strong>。当在作业调度中采用该算法时，每次调度都是从后备作业队列中选择一个或者多个最先进入到该队列的作业，将它们掉入内存中，为它们分配资源、创建进程，然后放入就绪队列中。在进程调度中采用FCFS算法时，每次调度都是从就绪队列中选择一个最先进入该队列的进程，为之分配处理机，使之投入运行。该进程一直运行到完成或发生某事件而阻塞后才放弃处理机。</li><li><strong>短作业(进程)优先调度算法</strong>：短作业优（进程）先调度算法，可以分别用于作业调度和进程调度。<strong>短作业优先（SJF）</strong>调度算法是从<strong>后备队列</strong>中选择一个或若干个<strong>估计运行时间最短</strong>的作业，将它们调入内存运行；<strong>短进程优先（SPF）</strong>调度算法则是从<strong>就绪队列</strong>中选出一个<strong>估计运行时间最短</strong>的进程，将处理机分配给它，使它立即执行并一直执行到完成，或发生某事件而阻塞放弃处理机时再重新调度。</li><li><strong>高优先权优先调度算法</strong>：<strong>最高优先权优先（FPF）调度算法</strong>常作用于批处理系统中，也作为多种操作系统中的进程调度算法，还可用于实时系统中。当把该算法用于<strong>作业调度</strong>时，系统会从<strong>后备队列</strong>中选择若干个优先权最高的作业装入内存。当用于<strong>进程调度</strong>时，该算法是把处理机分配给<strong>就绪队列</strong>中优先权最高的进程。<ul><li><strong>非抢占式优先权算法</strong>：系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程就会一直执行下去，直到完成为止；如果因为某个事件使得该进程放弃处理机，那么系统那可以把处理机分配给另一个优先权最高的进程。这种方法主要作用与批处理系统中，也可以用于某些对实时性要求不严格的实时系统中；</li><li><strong>抢占式优先权算法</strong>：系统同样是把处理机优先分配给优先权最高的进程。但是在执行期间，如果出现了一个优先权更高的进程，那么调度程序就会停止当前进程的执行，重新把处理机分配给新到的优先权更高的进程。这种算法能够更好地满足紧迫作业的需求，所以常用于要求比较严格的实时系统中，以及对性能要求较高的批处理和分时系统中。</li></ul></li><li><strong>高响应比优先调度算法</strong>：在批处理系统中，<strong>短作业优先算法</strong>是一种比较好的算法，但是其不足之处是长作业可能会长时间轮不到运行。如果我们能<strong>为每个作业引入前面所述的动态优先权，并使作业的优先级随着等待时间的增加而以速率a提高</strong>，则长作业在等待一定的时间后，必然有机会分配到处理机。该优先权的变化规律可描述为：<script type="math/tex; mode=display">R_{p} = \frac{等待时间 + 要求服务时间}{要求服务时间} = \frac{响应时间}{要求服务时间}</script>缺点是在每次进行调度之前，都需要先进行响应比的计算，这会增加系统的开销。</li><li><strong>时间片轮转算法</strong>：系统将所有的就绪进程按先来先服务的原则排成队列，每次调度时，都把CPU分配给队首的进程，并令其执行一个时间片。时间片的大小从几ms到几百ms。当执行的时间片用完时，就由一个计时器发出时钟中断请求，调度程序便根据此信号来停止该进程的执行，并将该进程送往就绪队列的队尾。接着把CPU分配给就绪队列中的新的队首的进程，同时让它也执行一个时间片。这样就能保证就绪队列中的每个进程都可以在给定的时间内均能获得一定的执行时间（循环操作）。</li><li><strong>多级反馈队列调度算法</strong>：多级反馈队列算法是目前公认的一种较好的进程调度算法，它不必事先知道各种进程所需的执行时间，而且可以满足各种类型进程的需要。该调度算法的实施过程如下所示：<ol><li>事先设置多个就绪队列，并为每个队列赋予不同的优先级。比如，第一个队列的优先级最高，第二个队列次之，其余各个队列的优先级逐个降低。该算法是赋予各个队列中进程执行时间片的大小也是不相同的。<strong>优先级越高的队列，每个进程的执行时间片就愈小。</strong>这意味着，优先级低的进程，一个时间片的执行时间就越长。</li><li>当一个新进程进入内存后，首先放在第一队列的末尾，按照<strong>先进先出</strong>的原则排队等待进行调度。当轮到该进程执行的时候，如果能够在第一队列设置的时间片内完成，就完成后撤离系统；如果尚未完成，则转而进入第二队列的队尾，同样按照<strong>先进先出</strong>的原则进行等待；以此类推。即「当一个长作业（进程）从第一队列依次降到第n队列进行执行后，在第n队列便会采取按照时间轮转的方式进行」。</li><li>同时，仅有当第一队列是空闲的时候，调度程序才会调度第二队列的进程去运行。即「<strong>仅当第1～（i-1）队列均为空时，才会调用第i队列中的进程运行</strong>」。假如处理机正在第i队列中为某进程服务时，又有新的进程进入到了优先权更高的队列中，则新的进程会抢占现在正在执行进程的处理机，即调度程序会把正在运行的进程放回到第i队列的队尾，把处理机分配给优先权更高的进程。</li></ol></li></ul></li><li><p><strong>进程同步有哪几种机制</strong></p><ul><li><strong>信号量机制（Semaphore）</strong>：一个信号量只能置一次初值，以后只能对之进行p操作或v操作。<ul><li>优点：PV操作能够实现对临界区的管理要求；实现简单；允许使用它的代码休眠，持有锁的时间可相对较长</li><li>缺点：信号量机制必须有公共内存，不能用于分布式操作系统，这是它最大的缺点。</li></ul></li><li><strong>自旋锁</strong>：自旋锁是为了保护共享资源提出的一种锁机制。调用者申请的资源如果被占用，即自旋锁被已经被别的执行单元保持，则调用者一直循环在那里看是否该自旋锁的保持着已经释放了锁。<ul><li>缺点：自旋锁是一种比较低级的保护数据结构和代码片段的原始方式，可能会引起<strong>死锁</strong>或者<strong>过多地占用CPU资源</strong></li></ul></li><li><strong>管程</strong>：是一种集中式同步进程。其基本思想是将共享变量和对它们的操作集中在一个模块中，操作系统或并发程序就由这样的模块构成。这样模块之间联系清晰，便于维护和修改，易于保证正确性。</li><li><strong>会合</strong>：进程直接进行相互作用。</li><li><strong>分布式系统</strong>：由于在分布式操作系统中没有公共内存，因此参数全为值参，而且不可为指针。</li></ul></li><li><p><strong>死锁的处理基本策略和常用方法</strong></p><p>解决死锁的常用策略：<strong>鸵鸟策略</strong>、<strong>预防策略</strong>、<strong>避免策略</strong>、<strong>检测与解除策略</strong></p><p>解决死锁的基本方法：<strong>预防死锁</strong>、<strong>避免死锁</strong>、<strong>检测死锁</strong>、<strong>解除死锁</strong></p><ol><li><p><strong>预防死锁</strong>：</p><ul><li><p><font color="red">破坏互斥条件</font>：允许进程同时访问某些资源，即资源一次性分配。（因为有的资源是不允许被同时访问的，所以这种方法有时没有实用价值）。</p></li><li><p><font color="red">破坏请求和等待的条件</font>：实行资源的预先分配策略。即进程在运行前一次性地向系统申请它所需要的全部资源。如果某个进程所需的全部资源得不到满足，则不分配任何资源，这个进程就暂不运行。只有当系统能够满足当前进程的全部资源需求时，才一次性地将它所申请的资源都全部分配给该进程。这样这个运行的进程已占有了它所需的全部资源，又不会再去申请资源，所以就不会发生死锁现象。</p><p>  <strong>缺点</strong>：</p><ul><li>在许多情况下，一个进程在执行之前不可能知道它所需要的全部资源是多少。因为进程在执行是动态的，是不可预测的；</li><li>资源利用率低。因为无论这个进程申请的资源何时才要用到，一个进程也只有在占有所需的全部资源后才能执行。也就是说，即使有些资源仅仅被该进程只使用一次，也只能等到该进程结束后才能释放，这就会出现长期占有资源却不利用的情况，是一种资源的极大浪费；</li><li>降低了进程的并发性。因为资源是有限的，再加上又存在浪费，所以这样能分配到全部资源的进程个数就少了。</li></ul></li><li><p><font color="red">破坏了不可剥夺的条件</font>：即允许进程强行从占有者那里夺取资源。即当一个进程已占有了某些资源，它申请新的资源失败了或者不能立即满足的话，就必须释放锁占有的全部资源。它将所释放的资源分配给其它进程，就相当于它的进程占有的资源被其它资源强行占有了（实现很困难，会降低系统性能）。</p></li><li><p><font color="red">破坏环路等待条件</font>：采用<strong>资源有序分配</strong>的方法。即把资源事先分类编号，按编号分配，使得资源在使用时不会形成环路。要求所有进程对资源的请求必须严格按照资源序号递增的顺序申请。</p><p>  <strong>缺点</strong>：</p><ul><li>限制了进程对资源的请求，同时给系统中所有资源合理地编号也很困难，会增加系统的开销；</li><li>为了遵循按照编号去申请的次序，暂不使用的资源也需要提前申请，这样会增加进程对资源的占用时间；</li></ul></li></ul></li><li><p><strong>避免死锁</strong>：</p><p> 因为<strong>预防死锁</strong>的几个策略都会严重的损害系统性能，所以在避免死锁这块要添加较弱的限制，从而获得较满意的系统性能。</p><p> 由于在避免死锁的策略中，可以<strong>允许进程动态地申请资源</strong>。所以，系统在进行资源分配之前可以预先计算好资源分配的安全性。若此次分配不会导致系统进入不安全状态，则将资源分配给进程；否则，就让<strong>进程等待</strong>。最有代表性的避免死锁算法是<strong>银行家算法</strong>。</p><p> <strong>银行家算法</strong>由Dijstra首先提出并解决的。即「<strong>当一个进程申请使用资源的时候，银行家算法通过先试探分配给该进程资源，然后通过安全性算法判断分配后的系统是否处于安全状态，若不安全则试探的分配就作废，让进程继续等待</strong>」。</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20180508204335770.png" alt=""></p></li><li><p><strong>检测死锁</strong>：</p><p> 首先为每个进程和每个资源指定一个唯一的号码；然后建立<font color="red">资源分配表</font>和<font color="red">进程等代表</font>。例如：</p></li><li><p><strong>解除死锁</strong>：</p><p> 当发现有进程死锁后，就可以立即把它从死锁状态中解脱出来。常用的方法有：</p><ul><li><strong>剥夺资源</strong>：从其他进程剥夺足够数量的资源给死锁进程，就可以接触死锁状态</li><li><strong>撤销进程</strong>：可以直接撤销死锁进程或者撤销代价最下的进程，直至有足够的资源可用让死锁状态消除为止；（<font color="red">代价</font>是指优先级、运行代价、进程的重要性和价值等）</li></ul></li></ol></li><li><p><strong>线程里面sleep和wait什么区别</strong></p></li><li><strong>sleep不释放锁和wait释放锁，底层怎么做的</strong></li><li><strong>说一下操作系统里的缓存</strong></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(DataStructure)</title>
      <link href="/2020/06/06/Interview-Review(DataStructure)/"/>
      <url>/2020/06/06/Interview-Review(DataStructure)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的数据结构部分。</p><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><ol><li><p>数据结构的定义</p><ul><li>数据的<strong>逻辑结构</strong>：反映数据元素之间的关系的数据元素集合的表示。逻辑结构包括：<strong>集合</strong>、<strong>线形结构</strong>、<strong>树形结构</strong>、<strong>图形</strong>结构四种。</li><li>数据的<strong>存储结构</strong>：数据的逻辑结构在计算机存储空间中的存放形式称为数据的存储结构。常用的存储结构有<strong>顺序</strong>、<strong>链接</strong>、<strong>索引</strong>等存储结构。</li></ul></li></ol><h1 id="哈希表（散列表）"><a href="#哈希表（散列表）" class="headerlink" title="哈希表（散列表）"></a>哈希表（散列表）</h1><p>哈希表（Hash Table，也叫散列表），是根据关键码值 (Key-Value) 而直接进行访问的数据结构。也就是说，它通过把关键码值映射到表中一个位置来访问记录，以加快查找的速度。哈希表的实现主要需要解决两个问题，<strong>哈希函数</strong>和<strong>哈希冲突</strong>。</p><h2 id="哈希函数"><a href="#哈希函数" class="headerlink" title="哈希函数"></a>哈希函数</h2><h2 id="哈希冲突"><a href="#哈希冲突" class="headerlink" title="哈希冲突"></a>哈希冲突</h2><h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><ol><li><p>简述一下Java中的HashMap的实现原理</p><blockquote><p>HashMap的底层就是<strong>数组</strong>加上<strong>链表</strong>的结构实现的。结构如下图：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/hashmap.png" alt=""></p><p>数组用来存放元素位置，链表用来解决哈希冲突。</p><p>当需要往HashMap中添加对象时，需要先计算key的hashCode，然后hashCode计算出元素应该放在数组的哪个位置。找到该位置后，判断该位置上是否已经存在键值对，如果已存在就覆盖，如果不存在就直接放到该位置。链表的存在是为了解决不同的key出现了Hash冲突的问题。一般元素会放到链表的头，这样做会减少操作。</p><p>HashMap有一个扩容因子0.75，当元素数量大于数组长度乘以扩容因子时，会触发扩容操作。扩容时，将数组长度变为原来2倍，然后将元素重新计算hashCode放到相应的位置。</p></blockquote></li><li><p>往HashMap中put元素的时候，先根据key计算hashCode，然后找到了数组中的对应位置。那么，是如何根据hashCode找到在数组中的具体位置呢？采用什么算法？</p></li></ol><ol><li><p>底层数组的初始长度是多少？为什么会设计成这个数呢？</p><blockquote><p>底层数组的默认长度是16。每次扩容都乘以2，都保证长度length是2的n次幂。原因就是这样可以使用位运算来加快计算在数组中的位置。</p></blockquote></li><li><p>扩容因子0.75，那么什么时候会触发扩容呢？是数组中元素占用位置的数量超过扩容因子时会触发还是HashMap的总元素数量超过扩容因子时会触发？</p><blockquote><p>HashMap中元素总个数达到阈值时就会扩容。</p></blockquote></li><li><p>为什么扩容的时候要重新计算hashCode呢？直接从旧的数组中移到新的数组中移到新的数组响应的位置不可以吗？</p><blockquote><p>扩容的时候是需要重新计算hash的，并且重新放置元素。但是并不可以从旧的数组直接移到新的数组响应的位置。因为虽然key的hashCode不会变，但是数组的长度发生了变化，那么根据hashCode计算数组位置时，得出的索引值也肯定是不同的。如果直接平移过来，会直接导致扩容前添加到HashMap中的数据无法被<code>get()</code>到。因为数组中的索引变化了，所以无法找到。</p></blockquote></li><li><p>HashMap是数据结构中哈希表的一个具体实现，还有哪些哈希表的其它实现方式？</p></li></ol><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h2 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h2><h2 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h2><h1 id="栈和队列"><a href="#栈和队列" class="headerlink" title="栈和队列"></a>栈和队列</h1><h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><blockquote><p>栈是一种「先进后出」的线性表，可以由数组或者链表来实现。通过链表或者数组的栈顶（Top）指针指针对数据进行压栈或者出栈的操作。</p></blockquote><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/Stack" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/Stack</a></p><h2 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h2><h3 id="堆和栈的区别"><a href="#堆和栈的区别" class="headerlink" title="堆和栈的区别"></a>堆和栈的区别</h3><p>Java中的栈主要是用来存放八个基本数据类型的，以及方法调用的上下文。栈是与每一个线程相关联的，JVM在创建每一个线程，都会分配一定的栈空间给线程，主要存放线程执行过程中的局部变量。栈的空间会随着线程的终止而释放。</p><p>栈的优势<strong>存取速度要比堆更快，栈数据可以共享</strong>。缺点是<strong>存储在栈中的数据大小与生存期都是确定的，缺乏灵活性</strong>。</p><p>Java中的堆是<strong>所有的线程可以共享的一块内存区域</strong>。堆是用来存储各种Java的对象和数组的，是一个运行时数据区。堆是由垃圾回收来负责的，不需要程序代码来显式地释放。</p><p>堆的优势是<strong>可以动态地分配内存的大小，生存期也无需事先告知编译器，因为是在运行时动态分配内存的</strong>。Java的垃圾回收器会自动收走这些不再使用的数据。缺点是存取速度较慢，因为运行时要动态分配内存。</p><p>除此之外，<strong>静态存储区</strong>是主要存放静态数据、全局<code>static</code>数据和常量的。这块内存在程序编译时就已经分配好，并且在程序整个运行期间都存在。总的来说：<strong>堆和栈针对非静态数据，而方法区针对静态数据</strong>。</p><h3 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h3><ul><li>堆是一个完全二叉树(除了最后一层，其他层从左到右的节点都是满的)</li><li>堆中的节点，都大于等于或小于等于其子节点</li><li>堆通常使用数组来存储</li></ul><p>在这棵树中，<strong>所有父节点都满足大于等于其子节点的堆叫大根堆</strong>，<strong>所有父节点都满足小于等于其子节点的堆叫小根堆</strong>。堆虽然是一颗树，但是通常存放在一个数组中，父节点和孩子节点的父子关系通过数组下标来确定。</p><p><strong>添加节点</strong>：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/11.png" alt=""></p><ul><li>将新节点添加到树的末尾，即数组的末尾</li><li>再将插入的节点与其父节点做对比，如果父节点大于插入的节点，则交换二者的位置，直到插入的节点比父节点小为止</li></ul><p><strong>删除根节点</strong>：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/12.png" alt=""></p><p>删除根节点则是删除后再依次比较其与子节点的大小，直到找到新的父节点</p><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><blockquote><p>队列是一种『先进先出』的线性表，一般可以用链表和数组来实现，只允许在尾部插入，在头部删除。</p></blockquote><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/Queue" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/Queue</a></p><h2 id="栈和队列的区别"><a href="#栈和队列的区别" class="headerlink" title="栈和队列的区别"></a>栈和队列的区别</h2><blockquote><p>栈和队列都是两种操作受限的线性表。</p></blockquote><p>栈是限制在表的一端进行插入和删除运算的线性表，是「先进后出」的；队列是一种运算受限的线性表，只允许在标的一端进行插入，而在另一端进行删除，是『先进先出』的。</p><p><strong>相同点</strong>：</p><ul><li>都是线性结构的</li><li>插入操作都是限定在表尾进行</li><li>都可以通过顺序结构和链式结构实现</li><li>插入和删除的复杂度都是$O(1)$，空间复杂度也一样</li><li>多链栈和多链队列的管理模式相同</li></ul><p><strong>不同点</strong>：</p><ul><li>删除数据元素的位置不同：栈的删除操作在表尾进行，队列的删除操作在表头进行</li><li>顺序栈能够实现多栈的空间共享，而顺序队列不能</li></ul><h1 id="数组和链表"><a href="#数组和链表" class="headerlink" title="数组和链表"></a>数组和链表</h1><p>数组和链表的区别：</p><p><strong>数组的优点</strong>：</p><ul><li>随机访问性强，<strong>查找速度快</strong>，时间复杂度为$O(1)$。</li></ul><p><strong>数组的缺点</strong>：</p><ul><li>头插和头删的效率低，时间复杂度为$O(N)$</li><li>空间利用率不高</li><li>内存空间要求高，必须有足够的连续的内存空间</li><li>数组空间的大小固定，不能动态拓展</li></ul><p><strong>链表的优点</strong>：</p><ul><li>任意位置插入元素和删除元素的速度快，时间复杂度为$O(1)$</li><li>内存利用率高，不会浪费内存</li><li>链表的空间大小不固定，可以动态拓展</li></ul><p><strong>链表的缺点</strong>：</p><ul><li>随机访问效率低，时间复杂度为$O(N)$</li></ul><hr><p>综上，「对于想要快速访问数据，不经常有插入和删除元素的时候，选择数组；对于需要经常的插入和删除元素，而对访问元素时的效率没有很高要求的话，选择链表。」</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><blockquote><p>数组是由相同元素的集合所组成的数据结构，存储在一块连续的内存单元，根据元素的索引可以计算出该元素对应的存储地址。</p></blockquote><p><strong>数组的特点</strong>：</p><ul><li>在内存中，数组是一块连续的区域</li><li>数组需要预留空间（在使用前需要提前申请所占内存的大小，这样不知道需要多大的空间，就预先申请可能会浪费内存空间，即<strong>数组空间利用率低</strong>）</li><li>在数组起始位置处，<strong>插入数据</strong>和<strong>删除数据</strong>效率低。<br>  插入数据时，待插入位置的的元素和它后面的所有元素都需要向后搬移；删除数据时，待删除位置后面的所有元素都需要向前搬移；这导致了<strong>插入数据</strong>和<strong>删除数据</strong>效率较低。</li><li>随机访问效率很高，时间复杂度可以达到$O(1)$。<br>  因为数组的内存是连续的，想要访问那个元素，直接从数组的首地址处向后偏移就可以访问到了。这意味着数组的<strong>查找效率</strong>更高。</li><li>数组开辟的空间，在不够使用的时候需要扩容，扩容的话，就会涉及到需要把旧数组中的所有元素向新数组中搬移。</li><li>数组的空间是从<strong>栈</strong>分配的。</li></ul><h2 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h2><blockquote><p>由一串节点组成，每个节点包含任意的实例数据和一个或两个用来指向下一节点或者上一节点位置的链接。</p></blockquote><p><strong>链表的特点</strong>：</p><ul><li>在内存中，元素的空间可以在任意地方，空间是分散的，不需要连续</li><li>链表中的元素都会两个属性，一个是元素的值，另一个是指针，此指针标记了下一个元素的地址；每一个数据都会保存下一个数据的内存的地址，通过此地址可以找到下一个数据</li><li><strong>查找</strong>数据时效率低,时间复杂度为$O(N)$；因为链表的空间是分散的，所以不具有随机访问性，如要需要访问某个位置的数据，需要从第一个数据开始找起，依次往后遍历，直到找到待查询的位置，故可能在查找某个元素时，时间复杂度达到$O(N)$</li><li>空间不需要提前指定大小，是动态申请的，根据需求动态的申请和删除内存空间，扩展方便，故空间的利用率较高</li><li>任意位置插入元素和删除元素效率较高，时间复杂度为$O(1)$</li><li>链表的空间是从<strong>堆</strong>中分配的</li></ul><h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><blockquote><p>实现抽象数据类型的数据结构。</p></blockquote><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/BinaryTree" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/BinaryTree</a></p><p>定义树节点为类：TreeNode。具体实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span> val; <span class="comment">// 数据域</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode left; <span class="comment">// 左子树根节点</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode right; <span class="comment">// 右子树根节点</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">TreeNode</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.val = val;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="遍历二叉树"><a href="#遍历二叉树" class="headerlink" title="遍历二叉树"></a>遍历二叉树</h3><h4 id="前序遍历"><a href="#前序遍历" class="headerlink" title="前序遍历"></a>前序遍历</h4><p>根$\rightarrow$左$\rightarrow$右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DLRTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示结点的数据</span></span><br><span class="line">        treeNodeData(treeNode);</span><br><span class="line">        DLRTree(treeNode.left);</span><br><span class="line">        DLRTree(treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>左$\rightarrow$根$\rightarrow$右</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LDRTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示结点的数据</span></span><br><span class="line">        LDRTree(treeNode.left);</span><br><span class="line">        treeNodeData(treeNode);</span><br><span class="line">        LDRTree(treeNode.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>左$\rightarrow$右$\rightarrow$根</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LRDTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 显示结点的数据</span></span><br><span class="line">        LRDTree(treeNode.left);</span><br><span class="line">        LRDTree(treeNode.right);</span><br><span class="line">        treeNodeData(treeNode);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="层次遍历"><a href="#层次遍历" class="headerlink" title="层次遍历"></a>层次遍历</h4><p>分层遍历二叉树（按层次从上到下，从左到右）迭代，相当于<strong>广度优先搜索</strong>，使用<strong>队列</strong>实现。队列初始化，将根节点压入队列。当队列不为空，进行如下操作：弹出一个节点，访问，若左子节点或右子节点不为空，将其压入队列。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 按层遍历算法</span></span><br><span class="line"><span class="comment"> * 首先处理第1层即根结点，再处理第1层根结点的左右子树，即第2层...循环处理，就可以逐层遍历</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> treeNode</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">levelTree</span><span class="params">(TreeNode treeNode)</span> </span>&#123;</span><br><span class="line">    TreeType p;</span><br><span class="line">    <span class="comment">// 定义一个顺序栈</span></span><br><span class="line">    TreeNode[] q = <span class="keyword">new</span> TreeNode[MAXLEN];</span><br><span class="line">    <span class="keyword">int</span> head = <span class="number">0</span>, tail = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果队首引用不为空</span></span><br><span class="line">    <span class="keyword">if</span> (treeNode != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 计算循环队列队尾序号</span></span><br><span class="line">        tail = (tail + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">        <span class="comment">// 将二叉树根引用进队</span></span><br><span class="line">        q[tail] = treeNode;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 队列不为空，进行循环</span></span><br><span class="line">    <span class="keyword">while</span> (head != tail) &#123;</span><br><span class="line">        <span class="comment">// 计算循环队列的队首序号</span></span><br><span class="line">        head = (head + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">        <span class="comment">// 获取队首元素</span></span><br><span class="line">        p = q[head];</span><br><span class="line">        <span class="comment">// 处理队首元素，输出显示</span></span><br><span class="line">        treeNodeData(p);</span><br><span class="line">        <span class="comment">// 如果结点存在左子树</span></span><br><span class="line">        <span class="keyword">if</span> (p.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算循环队列的队尾序号</span></span><br><span class="line">            tail = (tail + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">            q[tail] = p.left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果结点存在右子树</span></span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 计算循环队列的队尾序号</span></span><br><span class="line">            tail = (tail + <span class="number">1</span>) % MAXLEN;</span><br><span class="line">            q[tail] = p.right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p>线索化的二叉树就是：在原有的二叉树基础上有些改动，将没有孩子结点的链域声明为线，<strong>左孩子指向前驱，右孩子指向后继节点</strong>。有孩子结点的为链，表示指向原先的左右孩子。</p><p>发明线索二叉树的原因是因为，在原先的二叉链表中，查找节点的左、右孩子节点是可以直接实现的，但查找该节点的前驱和后继节点就会变得十分困难。所以，每个节点中可以增加两个指针域来存放遍历时得到的前驱节点和后继节点，这样就可以通过指针来访问。</p><h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p>若二叉树的深度为h，那么除了第h层外，其余各层都达到了最大个数的节点个数，并且第h层（最底层）的所有节点都集中在最左边，这就是完全二叉树。</p><p>正是因为二叉树这个性质，所以当它缺少节点时，总是从叶子层（即最底层）的右子树开始缺少节点。</p><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><blockquote><p>国内定义：如果一个二叉树的每一层的节点树都达到了最大值，那么这个树就是满二叉树。</p><p>国外定义：满二叉树的节点必须满足要么是叶子节点，度为0；要么是度为2的节点，不存在度为1的节点；</p></blockquote><h3 id="霍夫曼树"><a href="#霍夫曼树" class="headerlink" title="霍夫曼树"></a>霍夫曼树</h3><h2 id="树与森林"><a href="#树与森林" class="headerlink" title="树与森林"></a>树与森林</h2><h1 id="图"><a href="#图" class="headerlink" title="图"></a>图</h1><p>图是一种网状结构，图分为<strong>有向图</strong>和<strong>无向图</strong>。边有方向的称为有向图，边无方向的称为无向图。通常使用<code>G=&lt;V,E&gt;</code>来表示一个图，V表示顶点，E表示边。</p><p>图有两种表示方法：邻接表和邻接矩阵。邻接矩阵就是用二维数组来表示，这种情况很容易造成空间浪费，所以进行空间优化后可以选择使用邻接表的方式来表示。</p><p>邻接表是数组嵌套链表，会比邻接矩阵节省不少空间，但是对于无向图来说，仍然会浪费一半的空间。</p><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p><strong>弧</strong>：在有向图中，通常将边称为弧，含箭头的一端成为弧头，另一端称为弧尾，记作$<vi,vj>$，它表示从顶点vi到顶点vj有一条边。边就是弧。</p><p><strong>顶点的度</strong>：与它关联的边的数量。</p><p><strong>子图</strong>：一张图的一部分。</p><p><strong>连通图与非连通图</strong>：连通图是指图内任意两个节点间，都有一条路径能连接它们。否则，就是非连通图。<strong>如果图中有孤立的岛，则说明是非连通图</strong>。</p><p><strong>加权图与非加权图</strong>：加权图含有权重，非加权图的节点和边上有没有权重。</p><p><strong>非循环图和循环图</strong>：非循环图是指图中不存在循环路径（起点和终点是同一个顶点），反之循环图则是包含循环路径。有向图和无向图都可能包含循环。</p><p><strong>树与图的关系</strong>：树是一个无向连通图，其中任何两个顶点只通过一条路径连接。 换句话说，一个任何没有简单环路的连通图都是一棵树。</p><h2 id="广度优先遍历和深度优先遍历"><a href="#广度优先遍历和深度优先遍历" class="headerlink" title="广度优先遍历和深度优先遍历"></a>广度优先遍历和深度优先遍历</h2><h3 id="广度优先遍历"><a href="#广度优先遍历" class="headerlink" title="广度优先遍历"></a>广度优先遍历</h3><h3 id="深度优先遍历"><a href="#深度优先遍历" class="headerlink" title="深度优先遍历"></a>深度优先遍历</h3><h2 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h2><h2 id="Dijikstra算法——最短路径问题"><a href="#Dijikstra算法——最短路径问题" class="headerlink" title="Dijikstra算法——最短路径问题"></a>Dijikstra算法——最短路径问题</h2><h1 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h1><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/tree/master/Sort" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/tree/master/Sort</a></p><p>常见的<strong>稳定排序算法</strong>有：</p><ul><li>冒泡排序（Bubble Sort） — $O(n^2)$</li><li>插入排序（Insertion Sort）— $O(n^2)$</li><li>桶排序（Bucket Sort）— $O(n)$; 需要$O(k)$额外空间</li><li>计数排序 (Counting Sort) — $O(n+k)$; 需要$O(n+k)$额外空间</li><li>归并排序（Merge Sort）— $O(nlogn)$; 需要$O(n)$额外空间</li><li>二叉排序树排序 （Binary tree sort） — $O(nlogn)$ 期望时间; $O(n^2)$最坏时间; 需要$O(n)$额外空间</li><li>基数排序（Radix sort）— $O(n·k)$; 需要 $O(n)$额外空间</li></ul><p>常见的<strong>不稳定排序算法</strong>有：</p><ul><li>选择排序（Selection Sort）— $O(n^2)$</li><li>希尔排序（Shell Sort）— $O(nlogn)$</li><li>堆排序（Heapsort）— $O(nlogn)$</li><li>快速排序（Quicksort）— $O(nlogn)$ 期望时间, $O(n^2)$ 最坏情况; 对于大的、乱数串行一般相信是最快的已知排序</li></ul><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序是最简单的也是最基础的排序之一。其大体思想就是通过与<strong>相邻元素</strong>的比较和交换来把较小的树都排到前面。</p><p>比如，一个无序序列5,3,8,6,4。首先从前向后冒泡，5和3比较，把3交换到前面，序变成3,5,8,6,4。5和8无需交换。同理8和6交换，变成3,5,6,8,4。8和4交换，变成3,5,6,4,8。这样一次冒泡就完了，把最大的数8排到最后面了。对剩下的序列<strong>依次冒泡</strong>就会得到一个有序序列。</p><script type="math/tex; mode=display">5,3,8,6,4\\\downarrow\\3,5,8,6,4\\\downarrow\\3,5,6,8,4\\\downarrow\\3,5,6,4,8\\\downarrow\\3,5,4,6,8\\\downarrow\\3,4,5,6,8\\</script><p>冒泡排序的时间复杂度为：$O(n^2)$。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>思想其实和冒泡排序有点类似，都是在一次排序后把最小的元素放到最前面。但是过程不同，冒泡排序是通过<strong>相邻的比较和交换</strong>。而选择排序是通过<strong>对整体的选择</strong>。</p><p>举个例子，对5,3,8,6,4这个无序序列进行简单选择排序，首先要选择5以外的最小数来和5交换，也就是选择3和5交换，一次排序后就变成了3,5,8,6,4。对剩下的序列一次进行选择和交换，最终就会得到一个有序序列。其实选择排序可以看成冒泡排序的优化，因为其目的相同，只是选择排序只有在确定了最小数的前提下才进行交换，大大减少了交换的次数。</p><script type="math/tex; mode=display">5,3,8,6,4\\\downarrow\\3,5,8,6,4\\\downarrow\\3,4,8,6,5\\\downarrow\\3,4,5,6,8</script><p>选择排序的时间复杂度为：$O(n^2)$。</p><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>对5,3,8,6,4这个无序序列进行简单插入排序，首先假设第一个数的位置时正确的，没必要整理。然后3要插到5前面，把5后移一位，变成3,5,8,6,4。然后8不用动，6插在8前面，8后移一位，4插在5前面，从5开始都向后移一位。注意在插入一个数的时候要保证这个数前面的数已经<strong>有序</strong>。</p><script type="math/tex; mode=display">5,3,8,6,4\\\downarrow\\3,5,8,6,4\\\downarrow\\3,5,6,8,4\\\downarrow\\3,4,6,8,5\\\downarrow\\3,4,5,8,6\\\downarrow\\3,4,5,6,8</script><p>简单插入排序的时间复杂度为：$O(n^2)$。</p><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>比如5,3,8,6,4的无序序列，以5作为基准（<strong>单独拎出来放在顶上</strong>）。思路是右指针找比基准数小的，左指针找比基准数大的，交换之。5,3,8,6,4 用5作为比较的基准，最终会把5小的移动到5的左边，比5大的移动到5的右边。5,3,8,6,4 首先设置i,j两个指针分别指向两端，j指针先扫描（思考一下为什么？）4比5小停止。然后i扫描，8比5大停止。交换i,j位置。5,3,4,6,8 然后j指针再扫描，这时j扫描4时两指针相遇。停止。然后交换4和基准数。4,3,5,6,8 一次划分后达到了左边比5小，右边比5大的目的。之后对左右子序列递归排序，最终得到有序序列。</p><script type="math/tex; mode=display">5,3,8,6,4\\\downarrow\\4,3,8,6,5\\\downarrow\\3,4,5,6,8\\</script><p>快速排序是不稳定的，其时间平均时间复杂度是：$O(nlogn)$。</p><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><h1 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h1><h2 id="顺序查找"><a href="#顺序查找" class="headerlink" title="顺序查找"></a>顺序查找</h2><p>顺序查找也称为线性查找，属于无序查找算法。它是最简单的查找策略，对于小规模的数据，顺序查找是一个不错的选择。</p><p><strong>基本思想</strong>是从数据的第一个元素开始，依次比较，直到找到目标数据或查找失败。</p><ol><li>从表中的第一个元素开始，依次与关键字进行比较；</li><li>若某个元素匹配关键字，则查找成功；</li><li>若查找到最后一个元素还未匹配关键字，则查找失败；</li></ol><p><strong>时间复杂度</strong>：顺序查找平均关键字匹配次数为表长的一半，其时间复杂度为$O(n)$。</p><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/blob/master/Search/src/SequentialSearch.java" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/blob/master/Search/src/SequentialSearch.java</a></p><h2 id="有序查找"><a href="#有序查找" class="headerlink" title="有序查找"></a>有序查找</h2><h2 id="二分查找"><a href="#二分查找" class="headerlink" title="二分查找"></a>二分查找</h2><p>二分查找（binary search）也称为折半查找（half-interval search），属于有序查找算法，是一种在<strong>有序数组</strong>中查找某一特定元素的搜索算法。元素必须是有序的，如果是无序的则要限进行排序操作。</p><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程就结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且同样是从中间元素开始查找（递归）。这样每一次比较都会使搜索范围缩小一半。</p><p><strong>时间复杂度</strong>：因为正常情况下每次查找的元素都在一半一半地减少，所以二分查找的时间复杂度是$log_2(n)$</p><p>代码位于：<a href="https://github.com/HurleyJames/DataStructure/blob/master/Search/src/BinarySearch.java" target="_blank" rel="noopener">https://github.com/HurleyJames/DataStructure/blob/master/Search/src/BinarySearch.java</a></p><h2 id="插值查找"><a href="#插值查找" class="headerlink" title="插值查找"></a>插值查找</h2><p>其实二分查找就是折半，那么为什么不能折四分之一或者其它数字呢？</p><p>即二分查找的查找点计算为$mid=(low+high)/2$，那么通过类比，可以将查找的点改进为：</p><p><script type="math/tex">mid=low+(key-a[low])/(a[high]-a[low])*(high-low)</script></p><p><strong>基本思想</strong>就是基于二分查找的改进，将折半改为自适应，可以提高查找效率。但插值查找的前提也必须是已经有序排列。</p><p>代码位于：</p><h2 id="斐波那契查找"><a href="#斐波那契查找" class="headerlink" title="斐波那契查找"></a>斐波那契查找</h2><h2 id="线性索引查找"><a href="#线性索引查找" class="headerlink" title="线性索引查找"></a>线性索引查找</h2><h2 id="哈希查找"><a href="#哈希查找" class="headerlink" title="哈希查找"></a>哈希查找</h2><h2 id="二叉查找树"><a href="#二叉查找树" class="headerlink" title="二叉查找树"></a>二叉查找树</h2><p>二叉查找树（BinarySearch Tree）也叫二叉搜索树，也可以叫二叉排序树（BinarySort Tree），是具有以下性质的二叉树：</p><ol><li>若任意节点的左子树不为空，则左子树上所有节点的值均小于它的根节点的值；</li><li>若任意节点的右子树不为空，则右子树上所有节点的值均大于它的根节点的值；</li><li>任意节点的左、右子树也分别为二叉查找树；</li></ol><p>即 右 &gt; 根 &gt; 左，同时对二叉查找树进行<strong>中序遍历</strong>，即可得到有序的数列。</p><p>使用二叉查找树的思路是：</p><ul><li>如果相等，即查找成功；</li><li>如果比较结果为根节点的关键字值较大（大了），则说明可能在左子树中；</li><li>如果比较结果为根节点的关键字值较小（小了），则说明可能在右子树中；</li></ul><h2 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h2><p>平衡二叉树是对二叉查找树的一种改进。二叉查找树有一个明显的缺点就是树的结构仍然具有极大的变动性，最坏的情况下就是一颗单支二叉树，丢失了二叉查找树的一些原有的优点。</p><p><strong>平衡二叉树（AVL）</strong>：它可以是一颗空树，也可以是具有以下性质的二叉查找树：</p><blockquote><p>它的节点左子树和右子树的深度之差不超过1，而且该节点的左子树和右子树都是一颗平衡二叉树（即同样满足这个性质）。</p></blockquote><p><strong>平衡因子</strong>：节点左子树的深度 - 节点右子树的深度。值可以为0、-1、1。</p><h2 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>红黑树是一种特殊二叉查找树。红黑树上的每个节点都有存储位以表示节点的颜色，可以是红色也可以是黑色。</p><p>其特点有：</p><ul><li>每个节点都是黑色或者红色</li><li>根节点是黑色</li><li>每个叶子节点都是黑色（叶子节点是指为空（NIL或者NULL）的节点）</li><li>如果一个节点是红色的，其子节点就是黑色的</li><li>从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点。</li></ul><p>因为特性5，所以红黑树是一个相对接近平衡的二叉树。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/14.jpg" alt=""></p><h3 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h3><p>红黑树主要用来存储有序的数据，它的时间复杂度是$O(lg_n)$。</p><p>Java集合中的TreeSet和TreeMap，C++ STL中的set、map，以及Linux虚拟内存的管理，都是通过红黑树去实现的。</p><h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><p>也称为多路查找树。</p><h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>将一个问题拆成几个子问题，分别求解这些子问题，即可推断出大问题的解。</p><h2 id="动态规划与分治法的区别"><a href="#动态规划与分治法的区别" class="headerlink" title="动态规划与分治法的区别"></a>动态规划与分治法的区别</h2><h3 id="共同点"><a href="#共同点" class="headerlink" title="共同点"></a>共同点</h3><p>二者都是要求原问题具有最优子结构的特征，都是将原问题分而治之，分解成若干个规模较小的子问题，然后将子问题的解合并，形成原问题的解。</p><h3 id="实现方法"><a href="#实现方法" class="headerlink" title="实现方法"></a>实现方法</h3><ul><li><strong>分治法</strong>常常利用<strong>递归</strong>来实现。</li><li><strong>动态规划</strong>通常利用迭代法自底向上求解，但也可使用具有记忆功能的递归法自顶向下求解。</li></ul><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ul><li>分治法将分解后的子问题看成是相互独立的；</li><li>动态规划将分解后的子问题理解为相互间是有联系的，有重叠部分的。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Database)</title>
      <link href="/2020/06/06/Interview-Review(Database)/"/>
      <url>/2020/06/06/Interview-Review(Database)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的数据库部分。</p><a id="more"></a><h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2><h3 id="非关系型数据库（NoSQL）"><a href="#非关系型数据库（NoSQL）" class="headerlink" title="非关系型数据库（NoSQL）"></a>非关系型数据库（NoSQL）</h3><ul><li>mongoDB</li><li>Hbase</li><li>Neo4j</li><li>redis</li><li>CouchDB</li></ul><h3 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h3><ul><li>SQLite</li><li>SQL Server</li><li>MySQL</li><li>ORACLE</li><li>PostgreSQL</li><li>Microsoft Access</li><li>Teradata</li><li>SAP</li></ul><h2 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h2><p>存储过程就像编程语言中的函数一样，封装了代码（PLSQL、T-SQL）。</p><h3 id="优点："><a href="#优点：" class="headerlink" title="优点："></a>优点：</h3><ul><li>能够将代码封装起来</li><li>保存在数据库之中</li><li>让编程语言进行调用</li><li>存储过程是一个预编译的代码块，执行效率比较高</li><li>一个存储过程替代大量T_SQL语句，可以降低网络通信量，提高通信速率</li></ul><h3 id="缺点："><a href="#缺点：" class="headerlink" title="缺点："></a>缺点：</h3><ul><li>每个数据库的存储过程几乎都是不一样的，十分难以维护</li><li>业务逻辑放在数据库上，比较难迭代</li></ul><h2 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>触发器是一种特殊的存储过程，主要是<strong>通过「事件」来触发而被执行的</strong>。它可以强化约束，来维护数据的完整性和一致性，可以跟踪数据库内的操作从而不允许未经许可的更新和变化。<strong>触发器不能由用户显示调用</strong>，而是只有当出发时间发生并且被捕捉到后，才会被触发。</p><h3 id="语句"><a href="#语句" class="headerlink" title="语句"></a>语句</h3><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 创建触发器</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">trigger</span> trigger_name</span><br><span class="line">trigger_time</span><br><span class="line">trigger_event <span class="keyword">on</span> tbl_name</span><br><span class="line"><span class="keyword">for</span> <span class="keyword">each</span> <span class="keyword">row</span></span><br><span class="line">trigger_stmt</span><br></pre></td></tr></table></figure><ul><li><code>trigger_name</code>：标识触发器名称，由用户自定义</li><li><code>trigger_time</code>：标识触发器的时机，取值可以是<code>before</code>和<code>after</code></li><li><code>tbl_name</code>：标识建立触发器的表名，即在哪张表上建立触发器</li><li><code>trigger_stmt</code>：触发器的程序体，可以是一句SQL语句或者用<code>begin</code>和<code>end</code>包含的多条SQL语句，即触发后会执行的操作</li></ul><p>可以建立6种触发器：<code>before insert</code>、<code>before update</code>、<code>before delete</code>、<code>after insert</code>、<code>after update</code>、<code>after delete</code>。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">// 查看触发器</span><br><span class="line"><span class="keyword">select</span> * <span class="keyword">from</span> information_schema.<span class="string">`triggers`</span>;</span><br><span class="line">// 或者（[]代表可省略）</span><br><span class="line"><span class="keyword">show</span> <span class="keyword">triggers</span> [<span class="keyword">from</span> schema_name];</span><br><span class="line"></span><br><span class="line">// 删除触发器</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">trigger</span> trigger_name;</span><br></pre></td></tr></table></figure><p><code>schema_name</code>在这里指数据库名称，<code>trigger_name</code>是触发器名称。</p><h2 id="三个范式"><a href="#三个范式" class="headerlink" title="三个范式"></a>三个范式</h2><h3 id="第一范式1NF"><a href="#第一范式1NF" class="headerlink" title="第一范式1NF"></a>第一范式1NF</h3><blockquote><p><strong>字段是最小的单元不可再分</strong>。</p></blockquote><p>例如，学生信息组成了学生信息表，由年龄、性别、学号、名字等组成。这些字段都是不可再分的，所以就是满足第一范式的。</p><h3 id="第二范式2NF"><a href="#第二范式2NF" class="headerlink" title="第二范式2NF"></a>第二范式2NF</h3><blockquote><p>第二范式首先是满足第一范式的，然后表中的字段必须完全依赖于全部的主键而非部分的主键。</p></blockquote><p>即其它字段组成的记录和这个主键表示的都是同一个东西，而主键是唯一的，它们这些字段都只需要依赖于这个主键。</p><p>比如，一个学号为1的学生，他年龄23，女，姓名X。在这行记录中，学号就是这个学生的主键，年龄、性别、姓名等其它字段都是依赖于学号这个主键的。</p><h3 id="第三范式3NF"><a href="#第三范式3NF" class="headerlink" title="第三范式3NF"></a>第三范式3NF</h3><blockquote><p>第三范式是满足第二范式的，非主键外的所有字段必须互不依赖。</p></blockquote><p>即数据只会在一个存储，不会重复地出现在多张表中，这样就消除了传递依赖。</p><p>比如，大学里有很多不同的学院（计算机学院、软件学院、商学院等）。那个学院信息列表可以由以下字段组成：学院编号，院长，学院名称，学院介绍等。在这个记录中，学院编号就是学院这张表的主键。那么学生信息表中，就不能再添加学院编号，院长，学院简介等属性，否则就重复。就会发生<strong>非主键外的字段形成了依赖关系</strong>，也就是学院表中的一些非主键的属性和学生表有依赖关系了。这是不行的，正确的做法是：学生表中只能增加一个学院表的主键，即学院编号字段。</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><blockquote><p>视图是一种基于数据表的虚表。</p></blockquote><ul><li>视图是一张虚表</li><li>视图建立在已有表的基础之上，视图赖以建立的这些表就叫做基表</li><li><strong>向视图提供数据内容的语句为<code>SELECT</code>语句，可以将视图理解为存储起来的SELECT语句</strong></li><li>视图向用户提供基表数据的另一钟表现形式</li><li>视图没有存储真正的数据，真正的数据是存储在基表中</li><li>我们可以操作视图，但是操作视图最终还是会转化成操作基表</li><li>一个基表可以有0个或者多个视图</li></ul><p>因为在查询时会编写很长的SQL语句，而视图是基于查询的一种虚表，视图可以将查询出来的数据进行封装，在使用时就会非常方便。</p><p>使用视图可以专注逻辑，但不会提高查询的效率。</p><p>视图是永远不会自动消失的，除非手动删除它。</p><h3 id="表和视图的区别"><a href="#表和视图的区别" class="headerlink" title="表和视图的区别"></a>表和视图的区别</h3><ol><li>视图是已经编译好的SQL语句，而表不是</li><li>视图没有实际的物理内容，表有</li><li>表是内容，视图是窗口</li><li>表占用物理空间，视图不占用物理空间，只是逻辑概念的存在，表可以及时对它进行修改，但视图只能由创建的语句来修改</li><li>表是内模式，视图是外模式</li><li>从安全的角度来说，视图可以不给用户接触到数据表，从而不知道表的结构</li><li>表属于全局模式中的表，是实表；视图属于局部模式的表，是虚表</li><li>视图的建立和删除只会影响视图本身，不会影响对应的表</li><li>可以用<code>update</code>、<code>insert</code>、<code>delete</code>等SQL语句修改表中的数据，但是对于视图只能进行<code>select</code>操作</li></ol><h2 id="SQL语句种类"><a href="#SQL语句种类" class="headerlink" title="SQL语句种类"></a>SQL语句种类</h2><ul><li>DDL(Data Definition Language)：数据定义语言，定义对数据库对象（库、表、列、索引）的操作，比如有<code>create</code>、<code>drop</code>、<code>alter</code>、<code>rename</code>、<code>truncate</code>等命令；</li><li>DML(Data Manipulation Language)：数据操作语言，定义对数据库记录的操作，代表指令有<code>insert</code>、<code>delete</code>、<code>update</code>、<code>select</code>等命令；</li><li>DCL(Data Control Language)：数据控制语言，定义对数据库、表、字段、用户的访问权限和安全级别。代表指令有<code>grant</code>、<code>revoke</code>、<code>commit</code>、<code>rollback</code>、<code>savepoint</code>等命令。</li></ul><h3 id="DEOP、DELETE和TRUNCATE的区别"><a href="#DEOP、DELETE和TRUNCATE的区别" class="headerlink" title="DEOP、DELETE和TRUNCATE的区别"></a>DEOP、DELETE和TRUNCATE的区别</h3><p><code>drop table</code>：</p><ol><li>属于DDL</li><li>不可回滚</li><li>不可以接<code>where</code></li><li>表的内容和结构都被删除</li><li>删除的速度快</li></ol><p><code>truncate table</code>：</p><ol><li>属于DDL</li><li>不可回滚</li><li>不可以接<code>where</code></li><li>只删除表的内容</li><li>删除的速度快</li></ol><p><code>delete from</code>：</p><ol><li>属于DML</li><li>可以回滚</li><li>可以接<code>where</code></li><li>表的结构还在，表的内容是否在要取决于<code>where</code>执行的情况</li><li>删除的速度慢，需要逐行删除</li></ol><p><strong>使用场景</strong>：</p><ul><li>当不再需要一张表的时候，就用<code>drop</code>命令</li><li>只想删除表中部分数据行时，用<code>delete</code>命令，并且需要带上<code>where</code>子句</li><li>保留表的结构但是删除所有的数据要用<code>truncate</code>命令</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><blockquote><p>索引（index）是一种快速查询表中内容的机制，类似于字典的目录。它运用在表中的某些字段上，但存储时，独立于表之外。它是用于提高数据库表数据访问速度的数据库对象。</p></blockquote><ul><li>索引可以避免全盘扫描。多数查询可以仅扫描少量索引页及数据页，而不是遍历所有数据页。</li><li>对于非聚集索引，有些查询甚至不用访问数据页。</li><li>对于聚集索引，可以避免数据插入操作集中于表的最后一个数据页。</li><li>在某些情况下，查询甚至可以不用访问数据页。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><ul><li>索引一旦建立，Oracle系统会对其自动维护，而且由Oracle系统决定何时使用索引</li><li>用户不用在查询语句中指定要使用哪个索引</li><li><strong>在定义了<code>primary key</code>或者<code>unique</code>约束后，系统会自动在相应的列上创建索引</strong></li><li>用户可以根据自己需求，对指定的单个字段或者多个字段，添加索引</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>唯一索引</strong>：唯一索引不允许两行具有相同的索引值</li><li><strong>主键索引</strong>：为表定义一个主键将自动创建主键索引，主键索引是唯一索引的特殊类型。主键索引会要求主键中的每个值都是唯一的，并且不能为空</li><li><strong>聚集索引</strong>（Clustered）：表中各行的物理顺序与键值的逻辑（索引）的顺序是相同的，每个表中只能有一个</li><li><strong>非聚集索引</strong>（Non-Clustered）：非聚集索引指定了表的逻辑顺序。数据存储在一个位置，索引存储在另一个位置，而索引中包含了指向数据存储位置的指针。数量可以有多个，但是要小于249个</li></ul><h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><ul><li>索引加快了数据库的检索速度（显而易见）</li><li>索引降低了插入、删除、修改等维护任务的速度（因为大部分数据更新的时候，同时也需要更新索引，所以会导致数据库系统更新数据的性能下降）</li><li>唯一索引可以确保每一行数据的唯一性，通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能</li><li>索引需要占物理和数据空间</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 普通索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">index</span> index_name (column_list);</span><br><span class="line">// 唯一索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> <span class="keyword">unique</span> (column_list);</span><br><span class="line">// 主键索引</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">add</span> primary <span class="keyword">key</span> (column_list);</span><br></pre></td></tr></table></figure><p>创建索引的方式包括普通索引、<code>unique</code>索引和<code>primary key</code>索引，<code>table_name</code>是要增加索引的表名，<code>column_list</code>是指出对哪些列要进行索引，如果是多列时，各列之间用逗号分隔。索引名<code>index_name</code>是可选的，如果缺醒，MySQL会根据第一个索引列赋一个名称。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">create</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (column_list);</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">unique</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name (column_list);</span><br></pre></td></tr></table></figure><p>这同样是一种创建索引的方法，与<code>alter</code>语句具有相同的含义，索引名是不可选的。除此之外，<strong>不能用<code>create index</code>语句创建<code>primary key</code>索引</strong>。</p><h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> index_name <span class="keyword">on</span> table_name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> <span class="keyword">index</span> index_name;</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table_name <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br></pre></td></tr></table></figure><p>在前两句中，是使用不同的命令删除了<code>table_name</code>中的索引<code>index_name</code>，而最后一句则是删除<code>primary key</code>的索引中才会使用。如果没有创建<code>primary key</code>索引，但是表具有一个或多个<code>unique</code>索引，就删除第一个<code>unique</code>索引。</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p><strong>需要创建索引的场景</strong>：</p><ul><li>表经常要进行<code>select</code>操作</li><li>表很大（很多记录），记录的内容分布范围也很广</li><li>列名经常在<code>where</code>子句或者连接条件中出现</li></ul><p><strong>不需要创建索引的场景</strong>：</p><ul><li>表经常要进行<code>insert</code>、<code>update</code>或<code>delete</code>操作</li><li>表很小，记录很少</li><li>列名不经常在<code>where</code>子句或者连接条件中出现</li></ul><h3 id="创建索引的注意事项"><a href="#创建索引的注意事项" class="headerlink" title="创建索引的注意事项"></a>创建索引的注意事项</h3><ul><li>非空字段：</li><li>取值离散大的字段：</li><li>索引字段越小越好：</li></ul><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><blockquote><p>数据库事务（transaction）是访问并可能操作各种数据项的一个数据库操作序列，这些操作要么全部执行，要么全部不执行，是一个不可分割的工作单位。事务由事务开始与事务结束之间执行的全部数据库操作组成。</p></blockquote><h3 id="四个特性"><a href="#四个特性" class="headerlink" title="四个特性"></a>四个特性</h3><h4 id="原子性（Atomicity）"><a href="#原子性（Atomicity）" class="headerlink" title="原子性（Atomicity）"></a>原子性（Atomicity）</h4><p>原子性是指<strong>事务中一个不可再分割的工作单元，事务中的操作要么全部执行，要么全部不执行</strong>。要么全部提交成功，要么全部失败回滚。即对于一个事务来说，不能只执行其中的一部分操作。</p><h4 id="一致性（Consistency）"><a href="#一致性（Consistency）" class="headerlink" title="一致性（Consistency）"></a>一致性（Consistency）</h4><p>一致性是指<strong>在事务开始之前和事务结束之后，数据库的完整性约束都没有遭到破坏</strong>。数据库事务不能破坏关系数据的完整性以及业务逻辑上的一致性。</p><p>比如A给B转账，不论转账是否成功，A和B两人的存款总额是不会发生变化的。</p><h4 id="隔离性（Isolation）"><a href="#隔离性（Isolation）" class="headerlink" title="隔离性（Isolation）"></a>隔离性（Isolation）</h4><p><strong>当多个事务同时并发访问时，事务之间是隔离的，一个事务不应该影响其它事务的运行结果</strong>。</p><h4 id="持久性（Durability）"><a href="#持久性（Durability）" class="headerlink" title="持久性（Durability）"></a>持久性（Durability）</h4><p><strong>该事务对数据库所做的更改持久地保存在数据库之中，并不会发生回滚</strong>。即完成的事务是永久的部分，对系统的影响是永久存在的。</p><h3 id="事务隔离级别"><a href="#事务隔离级别" class="headerlink" title="事务隔离级别"></a>事务隔离级别</h3><p>数据库定义了四个隔离级别：</p><ul><li>Serializable（序列化）：Serializable是最高的事务隔离级别，花销也最高，性能很低，一般很少使用。在该级别下，事务顺序执行，可以避免脏读、不可重复读和幻读。</li><li>Repeatable read（重复读）：可以避免不可重复读，但有可能出现脏读和幻读。例如，只要事务开始，就不能再对该记录进行修改，所以会发生不可重复读。（MySQL默认隔离级别就是Repeatable read）</li><li>Read committed（读提交）：避免了脏读，但是有可能会发生不可重复读和幻读。（SQL Server和Oracle的默认级别就是Read committed）。</li><li>Read uncommitted（读未提交）：脏读、不可重复读和幻读都可能发生。</li></ul><p>分别对应<code>Connection</code>类中的四个常量：</p><ul><li><code>TRANSACTION_SERIALIZABLE</code></li><li><code>TRANSACTION_REPEATABLE_READ</code></li><li><code>TRANSACTION_READ_COMMITTED</code></li><li><code>TRANSACTION_READ_UNCOMMITTED</code></li></ul><div class="table-container"><table><thead><tr><th style="text-align:center">隔离级别</th><th style="text-align:center">脏读</th><th style="text-align:center">不可重复读</th><th style="text-align:center">幻读</th></tr></thead><tbody><tr><td style="text-align:center">Serializable</td><td style="text-align:center">❎</td><td style="text-align:center">❎</td><td style="text-align:center">❎</td></tr><tr><td style="text-align:center">Repeatable read</td><td style="text-align:center">❎</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">Read committed</td><td style="text-align:center">❎</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr><tr><td style="text-align:center">Read uncommitted</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td><td style="text-align:center">✅</td></tr></tbody></table></div><center>✅：可能出现❎：不会出现</center><h4 id="隔离级别与锁的关系"><a href="#隔离级别与锁的关系" class="headerlink" title="隔离级别与锁的关系"></a>隔离级别与锁的关系</h4><h4 id="脏读"><a href="#脏读" class="headerlink" title="脏读"></a>脏读</h4><blockquote><p>一个事务读取到另外一个事务未提交的数据。</p></blockquote><p>比如，A向B转账，A已经执行了转账语句，但是A还没有提交事务，这时候B读取数据时发现自己账户余额已经变多了。如果B通知A已经收到钱后，A又执行回滚事务（rollback），那么B再查看账户就会发现余额没有变多。</p><h4 id="不可重复读"><a href="#不可重复读" class="headerlink" title="不可重复读"></a>不可重复读</h4><blockquote><p>一个事务读取到另外一个事务已经提交的数据，即一个事务可以看到其它事务所做的修改。</p></blockquote><p>例如，A查询数据库，而B修改了数据库的数据，这就会导致A多次查询数据库的结果都不一样。这就发生了在一个事务内多次读到的数据是不一样的，就称为不可重复读。</p><h4 id="幻读（虚读）"><a href="#幻读（虚读）" class="headerlink" title="幻读（虚读）"></a>幻读（虚读）</h4><blockquote><p>一个事务读取到了别的事务插入的数据，导致前后读取不一致。</p></blockquote><p>例如，事务A对一个表中的所有数据都进行了修改，同时，事务B向这个表插入了一行新的数据，那么操作事务A的用户就发现有一行新的数据没有修改到，前后读取不一致，仿佛产生了幻觉，叫做幻读（虚读）。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>脏读是不可容忍的，不可重复读和幻读在一定情况下是可以的。</p><h2 id="数据库的乐观锁和悲观锁"><a href="#数据库的乐观锁和悲观锁" class="headerlink" title="数据库的乐观锁和悲观锁"></a>数据库的乐观锁和悲观锁</h2><p><strong>乐观锁和悲观锁是并发控制主要采用的技术手段</strong>。</p><ul><li>悲观锁：假如会发生并发冲突，就屏蔽一切可能会违反数据完整性的操作<ul><li><strong>在查询完数据后就把事务锁起来，直到提交事务</strong></li><li>实现方式：使用数据库中的锁机制</li></ul></li><li>乐观锁：假如不会发送并发冲突，只在提交操作时检查是否会违反数据完整性<ul><li><strong>在修改数据的时候把事务锁起来，通过<code>version</code>的方式来进行锁定</strong></li><li>实现方式：使用<code>version</code>版本或者时间戳</li></ul></li></ul><h2 id="超键、候选键、主键、外键"><a href="#超键、候选键、主键、外键" class="headerlink" title="超键、候选键、主键、外键"></a>超键、候选键、主键、外键</h2><ul><li>超键（super key）：在关系中能唯一标识元组的属性集称为关系模式的超键。</li><li>候选键（candidate key）：不含有多余属性的超键叫做候选键，即最小的超键，没有冗余元素</li><li>主键（primary key）：数据库表中对存储数据对象予以唯一和完整标识的数据列或属性的组合叫做主键。一个数据列只能有一个主键，且主键的取值不能为空</li><li>外键（foreign key）：在一个表中，存在另一个表的主键，就叫做这个表的外键</li></ul><p>假如有以下两个表：</p><p>学生表（学号，身份证号，姓名，性别，老师编号）；老师表（老师编号，姓名，性别）。</p><p><strong>超键</strong>：因为超键的定义是关系中能够唯一标识的属性，所以对于学生表来说，<strong>学号</strong>和<strong>身份证号</strong>是可以表示学生的（都是唯一的），所以超键就是含有<strong>学号</strong>和<strong>身份证号</strong>的任意组合。比如：<code>(学号)</code>、<code>(学号，姓名)</code>、<code>(身份证号，性别)</code>等等。</p><p><strong>候选键</strong>：候选键属于超键，是最小的超键，所以对于学生表而言的候选键为：<strong>学号</strong>和<strong>身份证号</strong>。</p><p><strong>主键</strong>：主键就是候选键中的一个（当然有时候选键只有一个），是人为规定的。例如，我们通常设置学号为主键。</p><p><strong>外键</strong>：外键就是两个表之间的连接。例如，在学生表中有一个字段是老师编号，而老师编号又是老师表中的主键，那么老师编号这个字段就是学生表中的外键。</p><h2 id="SQL约束"><a href="#SQL约束" class="headerlink" title="SQL约束"></a>SQL约束</h2><ul><li>空值约束<code>not null</code>：用于控制字段内容一定不为空</li><li>唯一约束<code>unique</code>：控制字段不能重复，一个表中可以多个<code>unique</code>约束</li><li>主键约束<code>primary key</code>：用于控制字段内容不能重复，但是每个表中只能出现一个</li><li>外键约束<code>foreign key</code>：用于与另一张表相关联，是能确认另一张表记录的字段，用于保持数据的一致性</li><li>检查约束<code>check</code>：用于控制字段的值范围</li><li>默认值约束<code>default</code>：用于向列中插入默认值。如果没有规定其它的值，那么会将默认值添加到所有的新纪录</li></ul><h2 id="内连接、外连接、全连接"><a href="#内连接、外连接、全连接" class="headerlink" title="内连接、外连接、全连接"></a>内连接、外连接、全连接</h2><h3 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h3><p>内连接语句的关键字是<code>inner</code>、<code>join</code>、<code>on</code>。执行语句例如：<code>select * from a_table a inner join b_table b on a.a_id = b.b_id;</code>。</p><p>即匹配两张表中相关联的记录，也就是两张表中都有的记录，返回两个表的交集部分。</p><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><p>左外连接的关键字是<code>left</code>、<code>join</code>、<code>on</code>。执行语句例如：<code>select * from a_table a left join b_table b on a.a_id = b.b_id;</code>。</p><p>即除了匹配两张表相关联的所有记录，还会匹配左表中剩余的记录（相当于整个左边的记录都全部显示出来），右表中未匹配到的记录用<code>NULL</code>表示。</p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><p>右外连接的关键字是<code>right</code>、<code>join</code>、<code>on</code>。执行语句例如：<code>select * from a_table a right join b_table b on a.a_id = b.b_id;</code>。</p><p>与左表相反，即除了匹配两张表相关联的所有记录，还会匹配右表中剩余的记录（相当于整个右边的记录都全部显示出来），左表中未匹配到的记录用<code>NULL</code>表示。</p><h3 id="全连接"><a href="#全连接" class="headerlink" title="全连接"></a>全连接</h3><p>返回左右表中所有的记录和左右表中相关联的记录（左右表的交集部分）。</p><p>目前MySQL是不支持全连接的。</p><h2 id="分片、分区、分表、分库"><a href="#分片、分区、分表、分库" class="headerlink" title="分片、分区、分表、分库"></a>分片、分区、分表、分库</h2><h3 id="分片"><a href="#分片" class="headerlink" title="分片"></a>分片</h3><p>分片（Sharding）是将一个数据分成两个或者多个较小的块，称为逻辑分片（logical shards）。然后逻辑分片分布在单独的数据库节点上，称为物理分片（physical shards）。物理分片可以容纳多个逻辑分片。</p><p>数据库分片（Database shards）是无共享架构的一个例子。这意味着分片是<strong>自治</strong>的：分片间不共享任何相同的数据或者服务器资源。</p><h3 id="分区"><a href="#分区" class="headerlink" title="分区"></a>分区</h3><p>数据分区是一种物理数据库的设计技术，它的目的是在特定的SQL操作中减少数据读写的总量以缩短响应时间。分区不会形成新的数据表，实际上还是一张表，只是将表的数据均衡分摊到了不同的硬盘空间里，底层是由N个物理区块组成的。</p><p><strong>分区的好处</strong>：</p><ul><li><strong>存储更多的数据</strong>。分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。相比单个磁盘或文件系统，可以存储更多的数据。</li><li><strong>优化查询</strong>。在使用<code>where</code>语句时，可以只扫描一个或者多个分区表来提交查询效率。</li><li><strong>分区表更容易维护</strong>。</li></ul><p><strong>分区的局限</strong>：</p><ul><li>一个表最多只能有1024个分区</li><li>如果分区字段中含有主键或者唯一索引的列，那么主键列和唯一索引的列都必须要包含进来。</li><li>分区表中无法使用外键约束。</li></ul><h4 id="水平分区"><a href="#水平分区" class="headerlink" title="水平分区"></a>水平分区</h4><p>水平分区是对表的行进行分区。所有在表中定义的列都能在每个分区的数据集中找到，所以这个表的特性仍然是存在的。</p><p>例如，一个大学四年的成绩单，可以被分为四个不同的分区，每个分区中含有的数据集是每一年的成绩。（水平分区一定要按照某个属性列来分区，即这里分区的就是学年这个列）。</p><h4 id="垂直分区"><a href="#垂直分区" class="headerlink" title="垂直分区"></a>垂直分区</h4><p>这种分区一般来说是通过对表的垂直划分来减少表的宽度，使某些特定的列被划分到了特定的分区。</p><p>例如，一个学院表中有学院标号、学院名称、院长、学院简章、学院历史等属性列。学院简章和学院历史数据列的每一行都含有text等大字段，但是又不会经常被访问到，所以就将这两个属性列划分到另一个分区，在保证它们数据相关性的同时还能提高访问速度。</p><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><p>分表就是把一张表按照一定的规则分解成N个具有独立存储空间的实体表。</p><h3 id="分库"><a href="#分库" class="headerlink" title="分库"></a>分库</h3><p>数据分布在不同的数据库之中（数据量极大）。</p><h2 id="游标"><a href="#游标" class="headerlink" title="游标"></a>游标</h2><p>游标是一种能从包括多条数据记录的结果中每次提取一条记录的机制。它的设计是一种数据缓冲区的思想，用来存放SQL语句执行的结果。尽管游标能遍历结果中的所有行，但一次只会指向一行。它的作用就是用于对查询数据库所返回的记录进行遍历，以便进行相应的操作。</p><p>游标具有三个属性：</p><ul><li>不敏感（Asensitive）：数据库可以选择不复制结果集</li><li>只读（Read only）</li><li>不滚动（Nonscrollable）：游标是只能向一个方向前进的，并且不可以跳过任何一行数据</li></ul><p>它的优点是对从数据库中查询得到的结果集的每一行都可以进行分开的独立的相同或者不相同的操作，是一种分离的思想。它的主要是就是性能不高，只能一行一行操作。在数据量较大的情况下，速度过慢。游标可能会造成死锁，内存不足等。</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">// 定义游标，cursor_name是游标名称，select_statement是查询语句</span><br><span class="line"><span class="keyword">declare</span> cursor_name <span class="keyword">cursor</span> <span class="keyword">for</span> select_statement</span><br><span class="line">// 打开游标</span><br><span class="line"><span class="keyword">open</span> cursor_name</span><br><span class="line">// 取游标中的数据</span><br><span class="line"><span class="keyword">fetch</span> cursor_name <span class="keyword">into</span> var_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">next</span> <span class="keyword">from</span> cursor_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">prior</span> <span class="keyword">from</span> cursor_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">first</span> <span class="keyword">from</span> cursor_name</span><br><span class="line"><span class="keyword">fetch</span> <span class="keyword">last</span> <span class="keyword">from</span> cursor_name</span><br><span class="line">// 关闭游标</span><br><span class="line"><span class="keyword">close</span> cursor_name</span><br><span class="line">// 释放游标</span><br><span class="line"><span class="keyword">deallocate</span> cursor_name</span><br></pre></td></tr></table></figure><h2 id="常用SQL语句"><a href="#常用SQL语句" class="headerlink" title="常用SQL语句"></a>常用SQL语句</h2><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">// 创建数据库</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">database</span> db_name;</span><br><span class="line">// 删除数据库</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">database</span> db_name;</span><br><span class="line">// 创建新表，包含主键tbl_id和name两个属性</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">table</span> tbl_name (tbl_id <span class="built_in">int</span>(<span class="number">11</span> <span class="keyword">not</span> <span class="literal">null</span> auto_increment, <span class="keyword">name</span> <span class="built_in">varchar</span>(<span class="number">255</span>) <span class="keyword">default</span> <span class="literal">null</span>, primary <span class="keyword">key</span>(tbl_id)));</span><br><span class="line">// 删除表</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">table</span> tbl_name;</span><br><span class="line">// 增加一个列</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> <span class="keyword">column</span> column_name <span class="keyword">type</span>;</span><br><span class="line">// 添加主键</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">add</span> primary <span class="keyword">key</span>(<span class="keyword">id</span>);</span><br><span class="line">// 删除主键（一个表只有一个主键，所以不需要指定名称或者某一列）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">drop</span> primary <span class="keyword">key</span>;</span><br><span class="line">// 创建外键（表已经创建）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">add</span> <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">references</span> table2(<span class="keyword">id</span>);</span><br><span class="line">// 创建外键（定义多个列的外键约束）</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> table1 <span class="keyword">add</span> <span class="keyword">constraint</span> fk_tbl1tbl2 <span class="keyword">foreign</span> <span class="keyword">key</span> (<span class="keyword">id</span>) <span class="keyword">references</span> table2(<span class="keyword">id</span>);</span><br><span class="line">// 撤销外键约束</span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">table</span> tbl_name <span class="keyword">drop</span> <span class="keyword">foreign</span> <span class="keyword">key</span> fk_tbl1tbl2;</span><br><span class="line">// 创建索引（[]为可选）</span><br><span class="line"><span class="keyword">create</span> [<span class="keyword">unique</span>] <span class="keyword">index</span> idx_name <span class="keyword">on</span> tbl_name;</span><br><span class="line">// 删除索引（索引是不可更改的，必须删除后重新创建）</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">index</span> idx_name;</span><br><span class="line">// 创建视图</span><br><span class="line"><span class="keyword">create</span> <span class="keyword">view</span> view_name <span class="keyword">as</span> select_statement;</span><br><span class="line">// 删除视图</span><br><span class="line"><span class="keyword">drop</span> <span class="keyword">view</span> view_name;</span><br><span class="line">// 查询</span><br><span class="line">selct * from tbl_name where 查询条件;</span><br><span class="line">// 插入</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_name <span class="keyword">values</span>(value1, value2);</span><br><span class="line">// 插入（指定所要插入的数据的列）</span><br><span class="line"><span class="keyword">insert</span> <span class="keyword">into</span> tbl_name (column1, column2) <span class="keyword">values</span> (value1, value2);</span><br><span class="line">// 删除</span><br><span class="line"><span class="keyword">delete</span> <span class="keyword">from</span> tbl_name <span class="keyword">where</span> 删除范围;</span><br></pre></td></tr></table></figure><h2 id="ORM"><a href="#ORM" class="headerlink" title="ORM"></a>ORM</h2><p>ORM（Object Relational Mapping，对象关系映射）是一种思想，就是把对象（Object）转变成数据库中的记录，或者把数据库中的记录转变成对象。ORM通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。那么，在后端具体操作数据库时，就不需要编写复杂的SQL语句，而是向操作对象一样就可以了。</p><p>这里需要了解两个概念，持久化（Persistence）和持久层（Persistence layer）。持久化，是把数据（如内存中的对象）保存到可永久保存的存储设备中。而持久层，是专注于实现数据持久化应用领域的某个特定系统的一个逻辑层面，将数据使用者和数据实体相关联。</p><p>传统的使用JDBC操作数据库时，业务处理逻辑和数据存取逻辑是混淆在一起的。一般是如下几个步骤：</p><ol><li>建立数据库连接，获得<code>Connection</code>对象；</li><li>根据用户的输入<strong>组装</strong>成SQL语句（复杂）；</li><li>根据SQL语句建立<code>Statement</code>对象或者<code>PreparedStatement</code>对象；（<code>PreparedStatement是预编译的</code>，比<code>Statement</code>访问速度更快，代码的可读性和可维护性也更好）</li><li>用<code>Connection</code>对象执行SQL语句，获得返回的结果集<code>ResultSet</code>对象；</li><li>然后逐行读取结果集<code>ResultSet</code>对象中的数据；</li><li>根据读取到的数据，按特定的业务逻辑进行操作；</li><li>根据操作得到的结果再组装成新的SQL语句；</li><li>再使用<code>Connection</code>对象执行更新的SQL语句去更新数据库中的数据；</li><li>最后依次关闭<code>Statement</code>对象和建立连接的<code>Connection</code>对象；</li></ol><p>从上可以看出，这个使用JDBC的逻辑是十分复杂的，除了上面的情况，还需要考虑到语句可能执行失败的处理逻辑。而如果使用ORM技术，例如流行的Hibernate或者MyBatis技术，业务逻辑会简化很多：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Double <span class="title">calaAmount</span><span class="params">(String c_id, <span class="keyword">double</span> amount)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 根据id获取到Customer对象</span></span><br><span class="line">    Customer customer = CustomerManager.getCustomer(id);</span><br><span class="line">    <span class="comment">// 根据顾客的等级获取相应的优惠政策</span></span><br><span class="line">    Promo promo = PromoManager.getPromo(customer.getLevel());</span><br><span class="line">    <span class="comment">// 计算最终的价格</span></span><br><span class="line">    customer.getAmount(customer.getAmount().add(amount));</span><br><span class="line">    <span class="comment">// 返回优惠后的价格</span></span><br><span class="line">    <span class="keyword">return</span> amount * promo.getRate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上就是业务逻辑的代码，可见是与数据存取逻辑完全分离的。数据存储逻辑等操作全部放在两个类中<code>CustomerManager</code>和<code>PromoManager</code>这两个类中完成。</p><h2 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h2><p>数据库连接池的基本思想就是为数据库连接建立一个“缓冲池”。预先在缓冲池中放入一定数量的连接，当需要建立数据库连接时，只需要从缓冲池中取出一个，使用完毕之后再放回去。<strong>可以通过设定连接池最大连接数来防止系统无尽地与数据库连接</strong>。</p><p>连接池的核心思想是连接的复用，工作原理主要由三部分组成，分别为连接层的建立，连接池连接的使用管理，连接池的关闭。</p><ol><li><p><strong>连接池的建立</strong>。一般在系统初始化时，连接池会根据系统配置建立，并在池中建立几个连接对象，以便使用时能从连接池中获取。</p></li><li><p><strong>连接池的管理</strong>。连接池管理策略是连接池机制的核心，连接池内连接的分配和释放对系统的性能有很大的影响。其策略是：</p><p> 当客户请求数据库连接时，首先检查连接池中是否有空闲连接；如果存在空闲连接，则将连接分配给客户使用并作相应处理（即标记该连接为正在使用中，引用计数加1）；如果没有空闲连接，则查看当前所打开的连接数是否已经达到最大连接数，如果没有达到最大连接数，就重新创建一个新的连接给请求的客户；如果已经达到，那么就设定最大的等待时间让其等待，如果超出了这个等待时间，就抛出异常给用户。</p><p> 当客户释放数据库连接时，则要先判断该连接的<strong>引用次数</strong>是否超过了规定值，如果超过了就要从连接池中删除该连接，并判断当前连接池内总的连接数是否小于最小连接数，如果小于了又要将连接池充满；如果没超过就将这个连接标记为开放状态，可供再次复用；</p></li><li><p><strong>连接池的关闭</strong>。当程序退出时，关闭连接池中所有的连接，释放连接池相关资源，该过程正好与创建是相反的。</p></li></ol><p><strong>连接池的主要优点</strong>：</p><ol><li><strong>减少连接的创建时间</strong>。连接池中的连接是早已准备好的，可以重复使用的，获取后就可以直接访问数据库进行操作，减少了连接创建的次数和时间；</li><li><strong>更快的系统响应速度</strong>。数据库连接池在初始化过程中，往往已经创建了若干的数据库连接置于池中备用。此时连接的初始化工作均已完成。利用现有可用连接，避免了数据库连接初始化和释放过程的时间开销，从而缩减了系统整体响应时间；</li><li><strong>统一的连接管理</strong>。如果不使用连接池，每次访问数据库都要创建一个连接，系统的稳定性受连接需求的影响很大，容易产生资源浪费和高负载异常。而连接池可以使性能最大化，将资源利用在一定的水平之下。连接池能够控制池中的连接数量，增强了稳定性。</li></ol><h2 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h2><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><h3 id="B树的好处"><a href="#B树的好处" class="headerlink" title="B树的好处"></a>B树的好处</h3><h3 id="B-树的好处"><a href="#B-树的好处" class="headerlink" title="B+树的好处"></a>B+树的好处</h3><h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="数据库引擎"><a href="#数据库引擎" class="headerlink" title="数据库引擎"></a>数据库引擎</h3><h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><p>MySQL支持多种类型，大致可以分为三类：数值、日期/时间、字符串（字符）类型。所有数据类型详情可见：<a href="https://www.runoob.com/mysql/mysql-data-types.html" target="_blank" rel="noopener">MySQL数据类型</a></p><ol><li><code>in</code>和<code>exist</code>的区别</li><li><code>varchar</code>和<code>char</code>的区别</li><li><code>varchar(50)</code>中50的含义</li><li><code>int(20)</code>中20的含义</li><li><code>int(10)</code>和<code>char(10)</code>和<code>varchar(10)</code>的区别</li></ol><h3 id="有关权限的表"><a href="#有关权限的表" class="headerlink" title="有关权限的表"></a>有关权限的表</h3><p>MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在MySQL数据库里，由<code>mysql_install_db</code>脚本初始化。</p><ul><li>user权限表：记录允许连接到服务器的用户账号信息，里面的权限是全局级的；</li><li>db权限表：记录各个账号在各个数据库上的操作权限；</li><li>table_priv权限表：记录数据<strong>表级</strong>的操作权限；</li><li>columns_priv权限表：记录数据<strong>列级</strong>的操作权限；</li><li>host权限表：配合db权限表对给定主机上数据库级操作权限做更细致的控制，这个权限表不受<code>grant</code>和<code>revoke</code>语句的影响</li></ul><h2 id="SQL优化"><a href="#SQL优化" class="headerlink" title="SQL优化"></a>SQL优化</h2><ol><li><p>如何定位及优化SQL语句的性能问题？创建的索引有没有被使用到？如何才能知道这条语句执行很慢的原因？</p><p> 对于低性能的SQL语句的定位，最重要也是最有效的方法就是<strong>使用执行计划</strong>，MySQL提供了<code>explain</code>命令来查看语句的执行计划。我们知道，不管是哪种数据库，或者是哪种数据库引擎，在对一条SQL语句进行执行的过程中都会做很多相关的优化。对于查询语句，最重要的优化方式就是<strong>使用索引</strong>。而执行计划，就是显示数据库引擎对于SQL语句的执行的详细情况，其中包含了是否使用索引，使用什么索引，使用的索引的相关信息等。</p></li><li><p>SQL的生命周期</p></li><li>大表的数据查询怎么优化</li><li>超大分页怎么处理</li><li>MySQL分页</li><li>慢查询日志</li><li>主键使用自增长ID还是UUID？</li><li>优化关联查询</li><li>优化LIMIT分页</li><li>优化UNION查询</li><li>优化WHERE子句</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Network)</title>
      <link href="/2020/06/06/Interview-Review(Network)/"/>
      <url>/2020/06/06/Interview-Review(Network)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的计算机网络部分。</p><a id="more"></a><ol><li><p><strong>HTTP和HTTPS的区别</strong></p><ul><li><strong>开销</strong>：HTTPS协议需要到CA申请证书或者自制证书</li><li><strong>安全性</strong>：HTTP的信息是明文传输，是简单无状态的；HTTPS则是具有安全性的SSL加密传输，HTTPS协议是由SSL+HTTP协议构建的，可进行加密传输、身份认证的网络协议，比HTTP协议安全</li><li><strong>资源消耗</strong>：HTTP是直接与TCP进行数据传输；HTTPS运行在SSL/TSL之上，SSL/TSL运行在TCP之上，需要消耗更多的CPU和内存资源；</li><li><strong>端口不同</strong>：HTTP用到的端口是80（需要国内备案），HTTPS用到的端口是443</li></ul></li><li><p><strong>HTTP2与HTTP1.x相比的新特性</strong></p><ul><li><p>HTTP2使用新的二进制格式传输，HTTP1.x使用文本（字符串）传输。二进制协议解析起来更高效</p></li><li><p>HTTP2支持多路复用，即连接共享，即每一个<code>request</code>都是用作连接共享机制的。</p><blockquote><p>在HTTP1.x协议中，「浏览器客户端在同一时间，针对同一域名下的请求有一定的数量限制。超过限制数目的请求会被阻塞」。HTTP2的多路复用（Multiplexing）允许同时超过单一的HTTP2连接发起多重的请求-响应消息。</p></blockquote><p>  <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/http16.jpg" alt=""></p></li><li><p>HTTP2头部压缩，通过<code>gzip</code>和<code>compress</code>压缩头部然后再发送，既避免了重复<code>header</code>的传输，又减小了需要传输的大小</p></li><li><p>HTTP2支持服务器推送</p></li></ul></li><li><p><strong>HTTP2和HTTPS的关系</strong></p><p> HTTP2与HTTPS<strong>同属为一种网络传输协议</strong>。HTTP2（原名HTTP/2.0）即超文本传输协议2.0，是下一代HTTP协议。HTTPS是以安全为目标的HTTP通道，在HTTP的基础上通过传输加密和身份认证保证了传输过程的安全性，HTTPS在HTTP的基础下加入SSL层，HTTPS的安全基础是SSL，因此加密的详细内容就需要SSL。</p><p> HTTP2虽然是下一代HTTP协议，做了一些改动（如二进制分帧、多路复用、头部压缩、服务器推送等），但是依然采取的是<strong>不加密的传输方式</strong>，容易导致数据在传输过程中被截取或篡改，无法保证数据的完整性。</p><p> 而HTTPS采用的则是<strong>加密传输</strong>，就是在HTTP协议下增加了一层SSL协议，通过对整个通信线路进行加密来防止通信内容被窃听、篡改或伪装。</p><p> 所以：</p><ul><li>https: <strong>加密</strong>的http协议，默认443端口，<strong>基于TCP协议</strong>。</li><li>http2: <strong>第二代</strong>http协议，相较于HTTP1.x，大幅度的提升了web性能。在与HTTP/1.1完全语义兼容的基础上，进一步<strong>减少了网络延迟和传输的安全性</strong>，<strong>基于TCP协议</strong>。</li></ul></li><li><p><strong>什么是数字签名和数字证书</strong></p><ul><li><strong>数字签名</strong>：为了避免数据在传输过程中被替换（例如被黑客修改了报文内容），所以需要发送端发送一个数字签名，即把数据的摘要消息进行加密，比如使用MD5进行加密，得到一个数字签名，然后把这个数字签名和数据一起发送。然后接收端把收到的数据摘要部分进行MD5（相同加密算法）进行加密，如果加密后的结果和数字签名是一样的，就说明数据是正确的真实的。</li><li><strong>数字证书</strong>：因为在对称加密中，发送端和接收端双方都是使用公钥进行解密的。<strong>数字签名可以保证数据不被替换</strong>，但是不能保证公钥不被替换。因为数据是通过公钥加密的，如果公钥被替换了，那么数据也可以被伪造。所以我们要确保公钥也是真的。那么，CA证书机构会负责颁发一个证书，里面的公钥保证是真的，用户在请求服务器时，服务器将证书发给用户，而这个证书是由系统内置证书备案的，就能保证证书里的公钥是真的。</li></ul></li><li><p><strong>对称加密与非对称加密</strong></p><p> <strong>对称密钥加密</strong>指的是使用同一个密钥进行加密和解密，这种方法存在的问题就是密钥如何安全地发送给对方。</p><p> <strong>非对称加密</strong>是指使用一对非对称密钥，即公钥和私钥。公钥是可以任意发布的，但是私钥只有自己知道。发送方使用接收方的公钥进行加密处理，接收方收到加密信息后，使用自己的私钥进行解密。</p><p> 因为非对称加密的方式只会发送公钥而不会发送用来解密的私钥，所以可以保证安全性。但是相比对称加密，它的速度非常慢。所以，我们仍然使用对称加密来传送消息，但对称加密所使用的密钥可以通过非对称加密的方式发送出去。</p></li><li><p><strong>TCP与UDP的区别</strong></p><ul><li>TCP是面向连接的，UDP是无连接的；</li><li>TCP传输性可靠，UDP传输性不可靠；</li><li>TCP以<strong>字节流</strong>的形式传输，UDP以<strong>数据报文段</strong>的形式传输；</li><li>TCP传输效率慢，UDP传输效率快；</li><li>TCP所需资源多，UDP所需资源少；</li><li>TCP首部字节是20-60，UDP首部字节是8；</li><li>TCP应用于要求通信数据可靠的场景，例如文件传输，邮件传输等；UDP则要求通信速度较快的场景，如域名转换，直播等；</li><li>TCP的可靠性是通过顺序编号和确认（ACK）来实现的。</li></ul></li><li><p><strong>TCP的字节流是什么机制</strong></p></li><li><p><strong>字节流和字符流说一下</strong></p></li><li><p><strong>TCP协议的可靠性是如何保证的</strong></p><ul><li><strong>数据包校验</strong>：目的是检测数据在传输过程中的任何变化，若校验出包有错，则丢弃报文段并且不做任何响应，这样TCP发送数据端就会超时而重发数据；</li><li><strong>对失序的数据报重排序</strong>：既然TCP报文段作为IP数据报来传输，因为IP数据报到达时可能会失效，所以TCP报文段的到达也可能会失序。所以TCP会对失序数据进行重新排序，然后再上交给应用层；</li><li><strong>丢弃重复数据</strong></li><li><strong>应答机制</strong>：当TCP收到发自TCP连接另外一端的数据，它将发送一个确认（不是立即发送）；</li><li><strong>超时重发</strong>：当TCP发出一个段后，会启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到这个确认，就需要重新发送这个报文段；</li><li><strong>流量控制</strong>：TCP连接的每一方都有固定大小的缓冲空间。TCP接收端只需要另一端（发送端）发送接收端的缓冲区能够容纳得下的数据，这样做可以防止较快主机致使较慢主机的缓冲区溢出，这就是所谓的流量控制（TCP使用的流量控制协议是可变大小的滑动窗口协议）。</li></ul></li><li><p><strong>TCP和UDP对应的常见应用层协议</strong></p><ul><li>TCP对应的应用层协议有：<ul><li>FTP：定义了文件传输协议</li><li>SMTP：定义了简单邮件传输协议</li><li>POP3：POP3是用于接收邮件的，和SMTP对应</li><li>HTTP：从Web服务器传输超文本到本地浏览器的传送协议</li></ul></li><li>UDP对应的应用层协议有：<ul><li>DNS：用于域名解析服务，将域名地址转换为IP地址</li><li>SNMP：简单网络管理协议</li><li>TFTP：简单文件传输协议</li></ul></li></ul></li><li><p><strong>为什么TCP连接需要三次握手？为什么要四次挥手？画出全过程，并标注ack确认号和seq序列号的值</strong></p><p><strong>三次握手</strong>：</p><ol><li>第一次握手：客户端发送SYN=1的包到服务器，进入SYN_SEND状态，等待服务器确认；</li><li>第二次握手：服务器收到SYN的包后，必须使用确认包ACK确认客户的SYN，同时自己也发送SYN包给客户端，即发送ACK=1，SYN=1的包，此时服务器进入SYN_RECY状态；</li><li>第三次握手：客户端收到服务器的SYN+ACK的包，向服务器发送确认包ACK=1，发送完毕后，就进行ESTABLISHED状态，完成三次握手。</li></ol><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/t1.jpeg" alt=""></p><p><strong>四次挥手</strong>：</p><ol><li>客户端主动发送FIN=1</li><li>服务端收到后发送ACK=1</li><li>服务端再发送FIN=1，ACK=1</li><li>客户端最后向服务端发送ACK=1</li></ol><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/t2.jpeg" alt=""></p></li><li><p><strong>TCP握手连接确认号为什么要+1，不变不行吗？为什么？</strong></p></li><li><p><strong>HTTP与TCP的区别</strong></p><p>TCP是传输层协议，主要解决数据如何在网络中进行传输。HTTP协议是应用层协议，主要解决如何包装数据。</p></li><li><p><strong>保活计时器的作用</strong></p><p>除了时间等待计时器之外，TCP还有一个保活计时器。比如，一个客户与服务器建立了TCP连接，如果这时突然客户端主机发生故障，那么服务器也不应该再白白等待下去，所以需要使用到保活计时器。</p><p>服务器每次收到一次客户的数据，就要重新设置保活计时器，时间通常设置是两个小时。如果在这个时间内都没有收到客户端的数据，服务端就会发送一个探测报文段（每隔75秒发送一次）。若连续发送10次后都没有收到客户端的响应，服务端就会认为客户端出现了故障，从而关闭连接。</p></li><li><p><strong>TCP的拥塞处理</strong></p><p>拥塞控制和流量控制的不同的，拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器以及与降低网络传输性能相关的所有因素；流量控制是指点对点通信量的控制，是一个端到端的问，它的作用是抑制发送端发送数据的速率，以便使接收端来得及接收。</p><p><strong>拥塞</strong>是指在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，那么网络的性能就会变坏。为了进行拥塞控制，TCP发送方要维持一个拥塞窗口（cwnd）的状态变量，拥塞控制窗口的大小取决于网络的拥塞程度，并且可以动态变化。发送方的发送窗口会从拥塞窗口和接收方的接收窗口这两者中取较小的那个。</p><p>TCP的拥塞控制采用了四种算法：<strong>慢开始</strong>、<strong>拥塞避免</strong>、<strong>快重传和快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略，以减少网络拥塞的发生；</p><ul><li><strong>慢开始</strong>：当主机开始发送数据时，如果立即把大量的数据字节同时注入到网络，很有可能会引起网络阻塞。所以，较好的方法是先探测一下，即由小到大逐渐增大发送窗口（逐渐增大拥塞窗口数值）。例如，cwnd的初始值为1，每经过一个传播轮次，cwnd加倍。</li><li><strong>拥塞避免</strong>：拥塞避免算法的思路是让拥塞窗口cwnd缓慢增大，即每经过一个往返时间RTT就把发送方的cwnd加。</li><li><strong>快重传和快恢复</strong>：快重传和快恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。如果没有FRR，那么如果数据包丢失了，TCP就会使用定时器要求传输暂停；而如果有了FRR，当接收方收到了不按顺序的数据段，就会立即给发送发发送一个<strong>重复确认</strong>，当发送方收到了三个重复确认，就会假定这个数据报丢失了，并立即重传这些丢失的数据段。所以，有了FRR，就不会因为暂停而耽误重传要求。当单个数据包丢失时，FRR十分有效；当多个数据包在短时间内丢失，FRR不能很有效地工作；</li></ul></li><li><p><strong>HTTP方法有哪些</strong></p><ul><li>GET：获取资源，网络中绝大部分请求都会GET请求；</li><li>HEAD：获取报文首部，使用和GET相似，但是不会返回报文的实体主体部分；</li><li>POST：传输实体主体；</li><li>PUT：上传文件，不带有验证机制，所有任何人都能上传文件，存在安全性问题，一般不推荐使用该方法；</li><li>PATCH：对资源进行部分修改。PUT也可以修改资源，但是是完全替代，而PATCH允许部分修改；</li><li>OPTIONS：查询指定的URL支持的方法；</li><li>CONNECT：要求与代理服务器通信时建立隧道；使用SSL和TLS协议把通信内容加密后经网络隧道传输；</li><li>TRACE：追踪路径，服务器会把通信路径返回给客户端</li></ul></li><li><p><strong>HTTP中，POST与GET的区别</strong></p><ul><li>用途不同：GET是从服务器上获取数据，POST向服务器传送数据；</li><li>数据传输方式不同：GET请求通过URL传输数据，POST通过<strong>请求体</strong>传输数据（先发送请求头再发请求体，实际上是两次请求）；</li><li>传输数据量限制不同：GET传送的数据量小，不能大于2KB（因为浏览器对URL的长度有限制）；POST传送的数据量大，一般默认为不受限制；</li><li>GET的数据在URL中，通过历史记录或缓存可以很容易查到数据信息；POST的数据在请求主体内，所以有一定的安全性保证</li><li>GET是安全且幂等（同一个请求方法执行多次和仅执行一次的效果完全相同）；POST是非安全非幂等（每次请求对资源的改变并不是相同的），所以GET不会改变服务器上的资源，而POST会对服务器资源进行改变；</li></ul></li><li><p><strong>HTTP的长连接和短连接分别是什么</strong></p><p>HTTP的长连接和短连接实际上是TCP的长连接和短连接。</p><ul><li><strong>长连接</strong>：HTTP1.1规定了默认保持长连接，也称为<strong>持久连接</strong>。当数据传输完成后保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。但是长连接不是永久的连接，它有一个保持时间。使用长连接的HTTP协议，会在响应头加入这行代码：<code>Connection:keep-alive</code></li><li><strong>短连接</strong>：在HTTP/1.0中，默认使用短连接。浏览器和服务器每进行一次HTTP操作，就要建立一个连接，但任务结束就会中断这个连接</li></ul><p>使用长连接的好处：</p><ul><li>同一个客户端可以使用这个长连接处理其他请求，避免HTTP重新连接和断开消耗时间；</li><li>服务器可以利用这个连接<strong>主动推送</strong>消息到客户端</li></ul></li><li><p><strong>DNS是什么，DNS协议的原理</strong></p><p>DNS的全程是Domain Name System或者Domain Name Service，主要作用就是将网址（域名）解析成电脑可以理解的IP地址，这个过程就是DNS域名解析（一个域名往往对应多个DNS地址）。</p></li><li><p><strong>DNS的解析过程</strong></p><ol><li>输入<code>www.baidu.com</code>这个域名，操作系统会先检查自己本地的hosts文件中是否已经有这个网址映射关系，如果有，就先调用这个已存在的IP地址映射去完成域名解析；</li><li>如果本地hosts文件中没有这个域名的映射，则查找本地DNS解析器缓存中是否有这个网址的映射，如果有就返回这个完成域名解析；</li><li>如果hosts和本地DNS解析器缓存里都没有这个域名的映射，那么就会找本地DNS服务器，此服务器收到查询请求时，如果要查询的域名包含在本地配置区域资源中，就返回解析结果给客户机，完成域名解析（此解析具有权威性）；</li><li>如果要查询的域名不由本地DNS服务器区域解析，但该服务器已缓存了此网址的映射关系，就调用这个进行IP地址映射，完成域名解析（此解析不具有权威性）；</li><li>如果本地DNS服务器本地区域资源和缓存解析都失败了，就让根DNS服务解析，如果自己无法解析，就联系下一级顶级域DNS服务器查询，如果还无法解析就联系下一级次级域名解析，如果还无法解析就使用下一级——主机名（host），又称三级域名进行解析，直到找个这个域名的主机为止。</li></ol><p><strong>另外一种表述方法是</strong>：</p><ol><li>发起基于域名的请求后，首先检查<strong>本地缓存</strong>（浏览器缓存$\longrightarrow$操作系统的hosts文件）；</li><li>如果<strong>本地缓存</strong>有，直接返回目标IP地址，否则将域名解析请求发送给<strong>本地DNS服务器</strong>；</li><li>如果<strong>本地DNS服务器</strong>中有，直接返回目标IP地址；如果没有，<strong>本地DNS服务器</strong>将解析请求发送给<strong>根DNS服务器</strong>;</li><li><strong>根DNS服务器</strong>会返回给<strong>本地DNS服务器</strong>一个所查询的<strong>TLD服务器（顶级域名服务器）</strong>地址列表；</li><li><strong>本地DNS服务器</strong>再向上一步返回的<strong>TLD服务器</strong>发送请求，<strong>TLD服务器</strong>查询并返回域名对应的域名对应的<strong>权威域名服务器</strong>的地址；</li><li><strong>本地DNS服务器</strong>再向上一步返回的<strong>权威域名服务器</strong>发送请求，<strong>权威域名服务器</strong>会查询存储的域名和IP的映射关系表，将IP连同一个<code>TTL</code>（过期时间）值返回给<strong>本地DNS服务器</strong>；</li><li><strong>本地DNS服务器</strong>会将IP和主机名的映射保存起来，保存时间由<code>TTL</code>来控制；</li><li><strong>本地DNS服务器</strong>把解析的结果返回给用户，用户根据<code>TTL</code>值缓存在<strong>本地系统缓存</strong>中，域名解析过程结束。</li></ol><p><strong>递归查询与迭代查询</strong>：</p><ol><li>主机向本地域名服务器的查询一般都是采用递归查询（客户端只发出一次请求，要求对方给出最终结果）。递归查询时，返回的结果只有两种：查询成功或者查询失败；</li><li>本地域名服务器向根域名服务器的查询时迭代查询（客户端发出了一次请求，对方如果没有授权回答，它就会返回一个能解答这个查询的其它名称服务器列表，客户端会再向返回的列表中发出请求，直到找到最终负责所查域名的名称服务器，从它那得到最终结果，即根域名服务器$\rightarrow$顶级域服务器$\rightarrow$次级域服务器$\rightarrow$主机名host）。迭代查询（又称重指引）时，返回的是最佳的查询点或者主机地址。</li></ol></li><li><p><strong>浏览器输入一个URL后发生了什么（从输入网址到获得页面的过程）</strong></p><ol><li><strong>DNS解析</strong>：浏览器会查询DNS，获取该域名（URL）对应的IP地址；具体过程包括了浏览器搜索自身的DNS缓存、搜索操作系统的DNS缓存、读取本地的Host文件和向本地的DNS服务器进行查询等；<ol><li>首先向本地DNS服务器查询缓存。本地DNS服务器会让根DNS服务器查询，如果不知道就再向顶级域DNS服务器查询，如果还不知道就再向权威DNS服务器查询；(一个域名为<code>www.baidu.com.</code>，根域名就是最后的<code>.</code>，只是因为每个域名都有根域名，所以通常省略了；根域名的下一级是顶级域名，比如<code>.com</code>，<code>.org</code>等；再下一级就是次级域名，比如<code>.baidu</code>；再下一级就是主机名（host）了，比如<code>www</code>，这个又称为三级域名)。所以，整个解析流程就是<strong>分级查询</strong>；</li><li>这里查询使用了<strong>递归查询</strong>和<strong>迭代查询</strong></li></ol></li><li><strong>TCP连接</strong>：浏览器获得了域名对应的IP地址之后，浏览器就会向服务器请求建立连接，发起三次握手；</li><li><strong>发送HTTP请求</strong>：TCP连接建立之后，浏览器会向服务器发送HTTP请求；</li><li><strong>服务器处理请求并返回HTTP报文</strong>：服务器接收到这个请求，并根据路径参数映射到特定的请求处理器进行处理，并将处理结果及相应的视图返回给浏览器；</li><li><strong>浏览器解析渲染界面</strong>：浏览器解析并渲染视图，如果有对js、css和图片等静态资源的引用，就重复上述步骤并向服务器请求这些资源；浏览器会根据其请求到的资源、数据渲染页面，最终向用户呈现一个完整的页面。</li><li><strong>连接结束</strong></li></ol></li><li><p><strong>HTTP响应码（状态码）</strong></p><ul><li>1XX：Informational（信息性状态码），表示请求已经被收到了，需要进一步的处理才能完成；</li><li>2XX：Success（成功状态码），成功处理请求；</li><li>3XX：Redirection（重定向状态码），重定向使用Location指向的资源或者缓存中的资源；</li><li>4XX：Client Error（客户端错误状态码），客户端出现错误，请求失败；</li><li>5XX：Server Error（服务端错误状态码），服务端出现错误，请求失败</li></ul><p><strong>常见状态码</strong>：</p><ul><li>100：Continue，表示到目前为止都很正常，客户端可以继续发送请求；</li><li>200：OK，请求正确；</li><li>301：Moved Permanently，永久性重定向；</li><li>302：Found，临时性重定向；</li><li>400：Bad Request，请求报文中存在语法错误；</li><li>403：Forbidden，请求被拒绝；</li><li>404：Not Found；</li><li>500：Internal Server Error，服务器正在执行请求时发生错误；</li></ul></li><li><p><strong>cookie/session的区别</strong></p><ul><li>cooike数据保存在用户的浏览器上（临时文件夹中），session数据保存在服务器上；</li><li>cookie是以明文的方式存放在客户端的，不是很安全，别人可以通过分析存在在本地的cookie来进行COOKIE诈骗；</li><li>cookie会传递消息给服务器；session本身存放在服务器中，不会有传送流量；</li><li>生命周期：<ul><li>cookie的生命周期是累加的，从创建时开始计时，20分钟后生命周期结束</li><li>session的生命周期是间隔的，创建后20分钟内没有访问session就会被销毁；但如果20分钟内访问了session，就又要重新计算session的生命周期；</li></ul></li><li>session是一定时间内会存储在服务器中。当访问增多时会增加服务器的性能消耗，此时就可以考虑使用cookie；</li><li>cookie为多个用户浏览器共享，session为一个用户浏览器独享；</li></ul></li><li><p><strong>OSI和TCP/IP的网络模型，路由器和交换机位于哪一层</strong></p><p><strong>OSI七层模型</strong>由上到下分别是：<strong>应用层</strong>、<strong>表示层</strong>、<strong>会话层</strong>、<strong>传输层</strong>、<strong>网络层</strong>、<strong>数据链路层</strong>和<strong>物理层</strong>。</p><ul><li>物理层：网卡、网线、集线器（采用广播的形式来传输信息）、中继器、调制解调器等</li><li>数据链路层：网桥、交换机（用来进行报文交换，能够进行地址学习，采用存储转发的形式来交换报文）等</li><li>网络层：路由器（一个作用是连通不同的网络，另一个作用是选择信息传送的线路）</li><li>传输层以以上：网关工作</li></ul><p>所以，路由器位于OSI七层模型的第三层，网络层；二层交换机位于OSI的第二层数据链路层，三层交换机位于OSI的第三层网络层，因为其具有路由功能；</p><p><strong>TCP/IP四层模型</strong>由上到下分别是：应用层、传输层（TCP和UDP协议）、网络层（整个TCP/IP协议栈的核心，定义了IP协议）和网络接口层。</p></li><li><p><strong>IP地址的分类</strong></p><p>IP地址编址方案将IP地址空间划分为A、B、C、D、E五类，A、B、C是基本类，D、E类作为多播和保留使用，为特殊地址；</p><p>每个IP地址包括两个标识码（ID）：网络ID和主机ID。<strong>同一个物理网络下的所有主机都使用同一个网络ID，而网络上的一个主机（网络工作站、服务器和路由器等）则有一个主机ID与其对应</strong>。</p><p>A~E类地址的特点如下：</p><ul><li>A类地址：以0开头，第一个字节范围是：0~127</li><li>B类地址：以10开头，第一个字节范围是：128~191</li><li>C类地址：以110开头，第一个字节范围是：192~223</li><li>D类地址：以1110开头，第一个字节范围是：224~239</li><li>E类地址：以1111开头，保留地址</li></ul></li><li><p><strong>私有IP地址的范围</strong></p><ul><li>A类私有IP地址：<strong>10.0.0.0~10.255.255.255</strong></li><li>B类私有IP地址：<strong>172.16.0.0~172.31.255.255</strong></li><li>C类私有IP地址：<strong>192.168.0.0~192.168.255.255</strong></li></ul></li><li><p><strong>为什么有了MAC地址还有IP地址</strong></p><ul><li>每台主机在出厂时都一个唯一的MAC地址，但是IP地址的分配是根据网络的拓扑结构，得以保证路由选择方案建立在网络所处的拓扑位置基础而不是设备制造商的基础上</li><li>使用IP地址更方便传输数据。数据包在这些节点之间的移动都是由ARP协议负责将IP地址映射到MAC地址上来完成的</li></ul></li><li><p><strong>五层网络协议体系结构的理解和每一层对应的网络协议有哪些</strong></p><ul><li><strong>应用层</strong>的任务是通过应用进程之间的监护来完成特定的网络应用。应用层的协议有域名系统DNS，超文本传输协议HTTP，文本传输协议FTP，支持电子邮件的SMTP协议，安全外壳协议SSH等；</li><li><strong>传输层</strong>的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务。应用进程利用该服务传送应用层报文。传输层的协议有传输控制协议TCP和用户数据报协议UDP；</li><li><strong>网络层</strong>的任务就是选择合适的网间路由和交换结点，确保数据及时传送。在发送数据时，网络层把传输层产生的报文段或用户数据封装成分组和包进行传送。网络层使用IP协议，所以分组也叫IP数据报，简称数据报。网络层的协议有网际协议IP协议和地址转换协议ARP等；</li><li><strong>数据链路层</strong>：在两个相邻节点之间传送数据时，数据链路层将网络层传下来的IP数据报组装成帧，在两个相邻节点之间的链路上传送帧。帧中包含了数据和必要的控制信息（同步信息，地址信息，差错控制等）。控制信息使接收端能知道一个帧从哪个比特开始和到哪个比特结束，还可以让接收端检测帧中是否有差错，如果有，就丢弃。数据链路层的协议主要有自动重传请求协议ARQ和点对点协议PPP等；</li><li><strong>物理层</strong>：在物理层上所传送的数据单位是比特。它的作用是实现相邻计算机之间比特流的透明传送。</li></ul></li><li><p><strong>停止等待协议的理解</strong><br>停止等待协议是为了实现可靠传输的，它的基本原理就是每发送完一个分组就停止发送，等待对方确认，收到确认再发送下一个分组；在停止等待协议中，若接收方收到了重复的分组，就丢弃该分组，但同时还要发送确认。主要包括几种情况：无差错情况、超时重传、确认丢失和确认迟到。</p></li><li><p><strong>ARQ协议</strong></p><ul><li><strong>自动重传请求ARQ协议</strong>：停止等待协议中有一个超时重传的情况，指只要超过一段时间仍然没有收到确认，就会重传前面发送过的分组（默认之前发送的那个分组已经丢失了）。所以，每个发送完一个分组都要设置一个超时计时器，其重传时间会设置得比分组传输的平均往返时间要更长（如果更短，就可能是传输还有到达，不可取）。这种自动重传的方式就叫做<strong>自动重传请求ARQ</strong>。</li><li><strong>连续ARQ协议</strong>：连续ARQ协议是用来提高信道利用率的。发送方维持一个发送窗口，位于发送窗口内的分组都可以连续发送出去，不需要等待对方确认。而接收方则采用累计确认，对按序到达的最后一个分组发送确认，就能表明这个分组之前的所有分组（包括这个分组）都已经正确收到了。</li></ul></li><li><p><strong>电路交换和分组交换</strong></p><ul><li><strong>分组交换</strong>：每个分组由首部和尾部组成，包含源地址和目的地址等控制信息，在同一个传输线路上同时传输多个分组是互不影响的，因此<strong>在同一条传输线路上允许同时传输多个分组</strong>。</li><li><strong>电路交换</strong>：两个用户之间建立通信前需要有一条专用的物理链路，而且在通信过程中<strong>始终占有该链路</strong>。<strong>电路交换对线路的利用率非常低</strong>。</li></ul></li><li><p><strong>时延</strong></p><ul><li>排队时延：分组在路由器的输入和输出队列中排队所需要等待的时间，取决于当前网络的通信量；</li><li>处理时延：主机或者路由器接收到分组后进行处理所需的时间，处理包括分析首部、从分组中提取数据、进行差错校验等；</li><li>传输时延：主机或路由器传输数据帧所需的时间，$delay = \frac{length(bit)}{v(bit/s})$，length是数据帧的长度，v是传播速率</li><li>传播时延：电磁波（光波）在信道中传输所需的时间，$delay = \frac{length(m)}{v(m/s)}$，length是信道的长度，v是电磁波在信道中的传播速度</li></ul></li><li><p><strong>URL和URI的区别</strong></p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Java)</title>
      <link href="/2020/06/06/Interview-Review(Java)/"/>
      <url>/2020/06/06/Interview-Review(Java)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的Java部分。</p><a id="more"></a><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p><code>final</code>关键字主要用在三个地方：变量、方法、类。</p><ol><li>如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li><strong>当用<code>final</code>修饰一个类时，表明这个类不能被继承。</strong><code>final</code>类中的所有成员方法都会被隐式的指定为<code>final</code>方法。</li><li>使用<code>final</code>的原因有两个。一个是把方法锁定，以防任何继承类来修改它的含义。所以类中所有的<code>private</code>方法都被隐式的指定为<code>final</code>；第二个原因是效率。</li></ol><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p><code>static</code>关键字的主要意义是在于创建独立于具体对象的域变量和方法。即使没有创建对象，也会使用属性和调用方法。<code>static</code>关键字可以用来形成静态代码块以优化程序性能。<code>static</code>块可以放置于类中的任何地方，类中可以有多个<code>static</code>块。当类被<strong>初次</strong>加载时，就会按照<code>static</code>块的顺序来执行每个<code>static</code>块，并且<strong>只会执行一次</strong>。</p><p><code>static</code>优化性能的原因是在于它只会在类加载的时候执行一次。所以有时候可以将一些只需要执行一次的初始化操作放在<code>static</code>代码块中执行。</p><p><code>static</code>关键字主要有以下四种使用场景：</p><ol><li><strong>修饰成员变量和成员方法</strong>：被<code>static</code>修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以直接通过类名调用。被<code>static</code>声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。调用格式：<code>类名.静态变量名</code>和<code>类名.静态方法名()</code>。<strong><code>static</code>是不允许修饰局部变量的</strong>。</li><li><strong>静态代码块</strong>：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，静态代码块只执行一次。</li><li><strong>静态内部类（<code>static</code>只能修饰内部类）</strong>：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用意味：1. 它的创建是不需要依赖外围类的创建；2. 它不能使用任何外围类的非<code>static</code>成员变量和方法。这种方式不仅具有延迟初始化的好处，而且由 JVM 提供了对线程安全的支持。</li><li><strong>静态导包（用来导入类中的静态资源）</strong>：格式为<code>import static</code>，这个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。因为会影响代码的可读性，所以一般情况下不建议使用。</li></ol><h4 id="静态变量"><a href="#静态变量" class="headerlink" title="静态变量"></a>静态变量</h4><p>被<code>static</code>修饰的成员变量叫静态变量，也叫<code>static</code>变量。它是属于这个类的，而不是属于这个对象的。比如一个类名是A的类，那么调用它就是<code>A.func()</code>，而不用<code>A a = new A();</code>去实例化A后，再使用<code>a.func()</code>的方式去调用。</p><p>静态变量在内存中只会有一份，在类的加载过程中，JVM只会为静态变量分配一次内存空间。</p><h4 id="实例变量"><a href="#实例变量" class="headerlink" title="实例变量"></a>实例变量</h4><p>没有被<code>static</code>修饰的成员变量叫做实例变量，实例变量是属于这个类的实例对象。即必须使用上述的<code>a.func()</code>的方式，先实例话这个类的对象，再调用。</p><p>在每次创建对象时，都会为每个对象分配成员变量内存空间。而实例变量是属于实例对象的，所以在内存中，创建几次对象，就会有几份成员变量。</p><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p>用<code>static</code>修饰的方法也叫做静态方法。注意<strong>构造方法不是静态方法</strong>。</p><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 语句体;</span></span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中的出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。</p><h3 id="this和super关键字"><a href="#this和super关键字" class="headerlink" title="this和super关键字"></a>this和super关键字</h3><p><code>this</code>关键字用于引用类的当前实例，此关键字是可选的，使用此关键字可能会使代码更易读或易懂。</p><p><code>super</code>关键字用于从子类访问父类的变量和方法。</p><ul><li>使用<code>super()</code>调用父类中的其它构造方法时，该语句必须处于首行，否则编译器会报错。另外，<code>this</code>调用本类中的其它构造方法时，也要放在首行。</li><li><code>this</code>、<code>super</code>不能用在<code>static</code>方法中。</li></ul><h3 id="synchroinzed关键字"><a href="#synchroinzed关键字" class="headerlink" title="synchroinzed关键字"></a>synchroinzed关键字</h3><h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p><code>volatile</code>主要用在多线程、同步变量。当一个共享变量被<code>volatile</code>修饰之后，就具备了两个含义：</p><ul><li>线程修改了变量的值时，变量的新值对于其它线程是立即可见的，即「不同线程对这个变量进行操作时具有<strong>可见性</strong>」。</li><li>禁止使用指令重排序。</li></ul><p>禁止指令重排序包含两个含义：</p><ul><li>当程序执行到<code>volatile</code>变量的操作时，在其前面的操作已经全部执行完毕，并且结果会对后面的操作可见，在其后面的操作还没有进行；</li><li>在进行指令优化时，<code>volatile</code>变量之前的语句不能在<code>volatile</code>后面执行，<code>volatile</code>之后的也不会在之前执行；</li></ul><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ol><li><strong>语法形式</strong>：成员变量是<strong>属于类</strong>的，而局部变量是在<strong>方法中定义的变量</strong>或者是<strong>方法的参数</strong>；成员变量可以被<code>public</code>、<code>private</code>、<code>static</code>等修饰符修饰，而局部变量不能被访问控制修饰符及<code>static</code>所修饰；但是它们都能被<code>final</code>修饰符修饰。</li><li><strong>变量在内存中的存储方式</strong>：如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的；如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>变量在内存中的生存时间</strong>：成员变量是对象的一部分，随着对象的创建而存在；而局部变量会随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（如果被<code>final</code>修饰，则必须显式赋值），而局部变量不会自动赋值。</li></ol><h2 id="Object通用方法"><a href="#Object通用方法" class="headerlink" title="Object通用方法"></a>Object通用方法</h2><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a><code>==</code>与<code>equals</code></h3><p><strong>==</strong>：判断两个对象的地址是否相等，即判断<strong>两个对象是否是同一个对象</strong>。</p><p><strong>equals()</strong>：判断两个对象是否相等，但有两种使用情况：</p><ul><li>如果类没有覆盖<code>equals()</code>方法，则通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象。</li><li>如果类覆盖了<code>equals()</code>方法，一般都覆盖<code>equals()</code>方法来比较两个对象的内容是否相等，若相等则直接返回<code>true</code>。</li></ul><h3 id="hashCode-与equals"><a href="#hashCode-与equals" class="headerlink" title="hashCode()与equals()"></a><code>hashCode()</code>与<code>equals()</code></h3><p><code>hashCode()</code>的作用是获取哈希码，也称为散列码；它实际上是返回一个<code>int</code>整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在JDK的<code>Object.java</code>中，意味着Java的任何类都包含<code>hashCode()</code>函数。<code>hashCode()</code>在散列表中才有用，在其它情况下没用。在散列表中<code>hashCode()</code>的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><ol><li>如果两个对象相等，则<code>hashCode</code>也一定是相同的</li><li>如果两个对象相等，则对两个对象分别调用<code>equals()</code>方法都返回<code>true</code></li><li>两个对象有相同的<code>hashCode</code>值，也不一定是相等的</li><li><code>equals</code>方法被覆盖过，则<code>hashCode</code>方法也必须被覆盖</li><li><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写<code>hashCode()</code>，则该 <code>class</code>的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h2 id="String"><a href="#String" class="headerlink" title="String"></a>String</h2><h3 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String StringBuffer StringBuilder的区别"></a>String StringBuffer StringBuilder的区别</h3><p>三者都是<code>final</code>类，都是不允许被继承的。</p><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p><code>String</code>类中是使用<code>final</code>关键字修饰字节（字符，取决于JDK版本）数组来保存字符串，所以<code>String</code>对象是<strong>不可变的</strong>。<code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中没有用<code>final</code>关键字修饰，所以这两种对象是<strong>可变的</strong>。</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p><strong><code>String</code>中的对象是不可变的</strong>，也可以理解为常量，<strong>线程安全</strong>。</p><p><code>StringBuffer</code>中的所有方法都添加了同步锁<code>synchronized</code>关键字或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。</p><p><code>StringBuilder</code>并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对<code>String</code>类型进行改变时，都会生成一个新的<code>String</code>对象，然后将指针指向新的<code>String</code>对象。</p><p><code>StringBuffer</code>每次都会对<code>StringBuffer</code>对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<code>StringBuilder</code>相比使用<code>StringBuffer</code>能获得10%~15%左右的性能提升，但是要冒线程不安全的风险。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>操作<strong>少量数据</strong>：适用<code>String</code></li><li><strong>单线程</strong>操作字符串缓冲区下操作大量数据：适用<code>StringBuilder</code></li><li><strong>多线程</strong>操作字符串缓冲区下操作大量数据：适用<code>StringBuffer</code></li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><h3 id="基本类型与运算"><a href="#基本类型与运算" class="headerlink" title="基本类型与运算"></a>基本类型与运算</h3><p>Java的基本数据类型包括<code>byte</code>、<code>int</code>、<code>char</code>、<code>long</code>、<code>float</code>、<code>double</code>、<code>boolean</code>、<code>short</code>。</p><p>所以<code>String</code>不是基本数据类型，<code>void</code>也不是基本数据类型。</p><div class="table-container"><table><thead><tr><th>数据类型</th><th>大小</th><th>包装类</th></tr></thead><tbody><tr><td>byte</td><td>8</td><td>Byte</td></tr><tr><td>short</td><td>16</td><td>Double</td></tr><tr><td>int</td><td>32</td><td>Integer</td></tr><tr><td>long</td><td>64</td><td>Long</td></tr><tr><td>float</td><td>32</td><td>Float</td></tr><tr><td>double</td><td>64</td><td>Double</td></tr><tr><td>char</td><td>16</td><td>Character</td></tr><tr><td>boolean</td><td>1</td><td>Boolean</td></tr></tbody></table></div><h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><p>引用类型是指向一个对象，不是原始值，指向对象的变量是引用变量。</p><p>在Java中，除了基本数据类型之外都是引用数据类型，包括自己定义的class类也是引用类型。</p><p>常见的引用类型有：String | StringBuffer | StringBuilder | ArrayList | HashSet | HashMap等。</p><p>引用类型（reference type）指向一个对象，不是原始值，指向对象的变量是引用变量。</p><p>在java里面除去基本数据类型的其它类型都是引用数据类型，自己定义的class类都是引用类型，可以像基本类型一样使用。</p><p>引用类型常见的有：String，StringBuffer，ArrayList，HashSet，HashMap等。String也属于引用数据类型。</p><h3 id="两种类型的对比"><a href="#两种类型的对比" class="headerlink" title="两种类型的对比"></a>两种类型的对比</h3><div class="table-container"><table><thead><tr><th>基本数据类型</th><th>引用数据类型</th></tr></thead><tbody><tr><td>在栈中分配内存</td><td>在堆中分配内存，堆的读写速度远不及栈</td></tr><tr><td>变量名指向具体的数值</td><td>变量名指向存数据对象的内存地址，即变量名指向的是hash值</td></tr><tr><td>基本数据类型之间的赋值是创建新的拷贝</td><td>对象之间的赋值只是传递引用</td></tr><tr><td><code>==</code>和<code>!=</code>是在比较值</td><td><code>==</code>和<code>!=</code>是在比较两个引用是否相同，需要自己实现<code>equals()</code>方法</td></tr><tr><td>基本类型变量创建和销毁很快</td><td>类对象需要创建JVM去销毁</td></tr></tbody></table></div><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><p>在<code>Java</code>中，所有的异常都有一个共同的祖先<code>java.lang</code>包中的<code>Throwable</code>类。<code>Throwable</code>有两个重要的子类：<code>Exception</code>（异常）和<code>Error</code>（错误），二者都是<code>Java</code>异常处理的重要子类，各自包含大量的子类。异常和错误的区别：异常能被程序本身处理，错误是无法处理的。</p><h3 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h3><p><strong>是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误表示代码运行时JVM（Java虚拟机）出现的问题，例如JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些错误表示故障是发生于虚拟机自身或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（<code>Virtual MachineError</code>）、类定义错误（<code>NoClassDefFoundError</code>）等。这些错误在运行前是不可查的。</p><h3 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h3><p><strong>是程序本身可以处理的异常</strong>。<code>Exceptiton</code>类有一个重要的子类<code>RuntimeException</code>。除此之外，还有<code>NullPointerException</code>和<code>ArrayIndexOutOfBoundsException</code>等。</p><h4 id="Runtime-Exception（运行时异常）"><a href="#Runtime-Exception（运行时异常）" class="headerlink" title="Runtime Exception（运行时异常）"></a>Runtime Exception（运行时异常）</h4><h3 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h3><ul><li><code>public string getMessage()</code>：返回异常发生时的简要描述</li><li><code>public string toString()</code>：返回异常发生时的详细信息</li><li><code>public string getLocalizedMessage()</code>：返回异常对象的本地化信息。如果<code>Throwable</code>的子类有覆盖这个方法，则可以生成本地化信息。如果子类没有覆盖这个方法，则方法返回的信息与<code>getMessage()</code>返回的结果相同</li><li><code>public void printStackTrace()</code>：在控制台上打印<code>Throwable</code>对象封装的异常信息</li></ul><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>try块</strong>：用于捕获异常，其后可以接多个<strong>catch块</strong>或者不接。如果其后没有<strong>catch块</strong>，则必须跟一个<strong>finally块</strong>。</li><li><strong>catch块</strong>：用于处理<code>try</code>捕获到的异常。</li><li><strong>finally块</strong>：无论是否捕获或处理异常，<strong>finally块</strong>里的语句都会被执行。如果在<strong>try块</strong>或者<strong>catch块</strong>中有<code>return</code>语句，则在<code>return</code>返回之前执行<strong>finally语句</strong>。</li></ul><p>有四种特殊情况下，<code>finally</code>块不会执行：</p><ol><li>在<code>finally</code>语句块第一行发生了异常。</li><li>在前面的代码中使用了<code>System.exit()</code>退出程序。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><p>如果一个方法接收<code>List&lt;Object&gt;</code>作为形式参数，那么如果尝试将<code>List&lt;String&gt;</code>的对象作为实际参数传进去，就会发现无法通过编译。尽管<code>String</code>是<code>Object</code>的子类，但是实际上会<strong>产生隐含的类型转换问题</strong>，所以编译器是禁止这样的行为的。</p><h3 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h3><p>在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数会被编译器在编译的时候去掉，这个过程就叫做<strong>类型擦除</strong>。比如，<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>等类型在编译之后都会变成<code>List</code>。JVM看到的只有<code>List</code>，而由泛型附加的类型信息对于JVM来说是不可见的。</p><h3 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h3><p>在使用泛型类的时候，既可以指定一个具体的类型，如<code>List&lt;String&gt;</code>就声明了具体类型是<code>String</code>类型；但也可以通过通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就表示了<code>List</code>中包含的元素类型是未知的，也就意味着所有类型都是可以的。</p><p>但注意<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。因为<code>List&lt;Object&gt;</code>确定了<code>List</code>中包含的是<code>Object</code>及其子类，在使用的时候都可以通过<code>Object</code>来进行引用，而<code>List&lt;?&gt;</code>其中包含的元素是不确定的。如果其包含的是<code>String</code>类型的，那往里添加<code>Integer</code>类型的元素就是错误的。</p><p>在某些情况下，可以使用<strong>上下界</strong>来限制未知类型的范围。如通过<code>List&lt;? extends Number&gt;</code>来说明<code>List</code>中可能包含的元素类型是<code>Number</code>及其子类。而<code>List&lt;? super Number&gt;</code>则说明<code>List</code>中包含的是<code>Number</code>及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。</p><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h2 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h2><h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立类的技术，新的类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p><ul><li>子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul><h4 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h4><ol><li>接口的方法默认是<code>public</code>，所有方法在接口中不能实现，而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其它变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可以通过<code>extends</code>关键字扩展多个接口。</li><li>接口方法默认修饰符是<code>public</code>，抽象方法可以有<code>public</code>、<code>protected</code>和<code>default</code>这些修饰符（不能使用<code>private</code>关键字修饰）</li></ol><h4 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h4><h5 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h5><p>发生在同一类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。简单的说，就是<strong>多个方法有相同的名字、不同的参数</strong>，便产生了重载。</p><h5 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h5><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为<code>private</code>则子类不能重写该方法。</p><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中可以有两种形式实现多态：<strong>继承</strong>和<strong>接口</strong>。</p><h3 id="构造方法的作用和特性"><a href="#构造方法的作用和特性" class="headerlink" title="构造方法的作用和特性"></a>构造方法的作用和特性</h3><p>构造方法的主要作用是完成对类对象的初始化工作。</p><ol><li>名字与类名相同。</li><li>没有返回值，但是也不能用<code>void</code>声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul><li><strong>面向过程：面向过程比面向对象的性能更高</strong>。因为类调用时需要实例化，开销比较大。但是，面向过程没有面向对象易维护、易复用、易拓展。</li><li><strong>面向对象：易维护、易复用、易拓展</strong>。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。</li></ul><h3 id="JVM、JDK和JRE"><a href="#JVM、JDK和JRE" class="headerlink" title="JVM、JDK和JRE"></a>JVM、JDK和JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><p><strong>字节码</strong></p><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><p><strong>Java程序从源代码到运行的步骤</strong></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67.png" alt=""></p><h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK是Java Development Kit，是Java SDK。它拥有JRE的一切，还有编译器（javac）和工具（例如javadoc）。<strong>它能够创建和编译程序。</strong></p><p>JRE是Java运行时的环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令等。<strong>但它不能用于创建新程序</strong>。</p><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多态</li><li>Java<strong>不提供指针</strong>来直接访问内存，程序内存会更加安全</li><li>Java的类是<strong>单继承</strong>的，C++支持<strong>多重继承</strong>；Java的接口可以多继承</li><li>Java有自动内存管理机制</li></ul><h2 id="IO流"><a href="#IO流" class="headerlink" title="IO流"></a>IO流</h2><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li><li>按照操作单元分，可以分为<strong>字节流</strong>和<strong>字符流</strong>；</li><li>按照流的角色分，可以分为<strong>节点流</strong>和<strong>处理流</strong>；</li></ul><p>Java的IO流中的类都是从4个抽象类基类中派生出来的。</p><ul><li><code>InputStream/Reader</code>：所有的输入流的基类，前者是<strong>字节输入流</strong>，后者是<strong>字符输入流</strong>。</li><li><code>OutputStream/Writer</code>：所有的输出流的基类，前者是<strong>字节输出流</strong>，后者是<strong>字符输出流</strong>。</li></ul><h2 id="集合框架"><a href="#集合框架" class="headerlink" title="集合框架"></a>集合框架</h2><h3 id="集合的特点"><a href="#集合的特点" class="headerlink" title="集合的特点"></a>集合的特点</h3><ul><li>集合可以用于存储<strong>对象</strong>。</li><li>对象的个数确定的话可以使用数组，对象的个数不确定的话可以使用集合，因为集合是可变长度的。</li></ul><h3 id="集合和数组的区别"><a href="#集合和数组的区别" class="headerlink" title="集合和数组的区别"></a>集合和数组的区别</h3><ul><li>数组是固定长度的；集合是可变长度的。</li><li>数组可以存储基本数据类型，也可以存储引用数据类型；集合只能存储引用数据类型。</li><li>数据存储的元素必须是同一个数据类型；集合存储的对象可以是不同数据类型的。</li></ul><h3 id="常用的集合类"><a href="#常用的集合类" class="headerlink" title="常用的集合类"></a>常用的集合类</h3><p>Map接口和Collection接口是所有集合框架的父接口：</p><ul><li>Collection接口的子接口包括：Set接口和List接口</li><li>Map接口的实现类主要有：HashMap、TreeMap、Hashtable、ConcurrentHashMap以及Properties等</li><li>Set接口的实现类主要有：HashSet、TreeSet、LinkedHashSet等</li><li>List接口的实现类主要有：ArrayList、LinkedList、Stack以及Vector等</li></ul><p>ArrayList与LinkedList都是List接口的实现类，因此都实现了List的所有未实现的方法。List接口继承了Collection接口，Collection接口又继承了Iterable接口，因此可以看出List同时拥有了Collection与Iterable接口的特性。</p><h3 id="List-Set-Map-三者的区别"><a href="#List-Set-Map-三者的区别" class="headerlink" title="List | Set | Map 三者的区别"></a>List | Set | Map 三者的区别</h3><p>List接口存储一组不唯一（即可以有多个元素引用相同的对象），有序的对象</p><p>Set中不允许有重复的集合，不会有多个元素引用相同的对象。</p><p>Map是使用键值对来存储。Key是不能重复的，是唯一的，Value的值可以相同。</p><h3 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h3><ul><li>ArrayList实现了List接口，即ArrayList实现了<strong>可变大小</strong>的数组。它允许所有元素，包括<code>null</code>。</li><li>当更多的元素添加到ArrayList时，它的大小会动态增大。它的元素可以通过<code>get/set</code>的方式直接访问，因为ArrayList本质上是一个数组。</li><li>ArrayList没有同步方法，这意味着它不是线程安全的。如果多个线程同时访问一个List，则必须要自己实现访问同步：<code>List list = Collections.synchronizedList(new LinkedList(...));</code></li></ul><h4 id="ArrayList的原理"><a href="#ArrayList的原理" class="headerlink" title="ArrayList的原理"></a>ArrayList的原理</h4><h3 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/162f6300886a70ea" alt=""></p><ul><li>LinkedList是通过双向链表实现的，添加、删除元素的性能比ArrayList好，但是查询元素的性能较差。</li><li>LinkedList没有同步方法，这意味着它不是线程安全的。如果多个线程同时访问一个List，则必须要自己实现访问同步。一种解决方法是在创建List时构造一个同步的List：<code>List list = Collections.synchronizedList(new LinkedList(...));</code></li></ul><h4 id="LinkedList的原理"><a href="#LinkedList的原理" class="headerlink" title="LinkedList的原理"></a>LinkedList的原理</h4><h3 id="ArrayList与LinkedList的区别"><a href="#ArrayList与LinkedList的区别" class="headerlink" title="ArrayList与LinkedList的区别"></a>ArrayList与LinkedList的区别</h3><ul><li>ArrayList是<strong>动态数组</strong>的数据结构实现，而LinkedList是<strong>双向链表</strong>的数据结构实现。</li><li>对于随机访问<code>get</code>和<code>set</code>，ArrayList要优于LinkedList，因为<strong>LinkedList需要移动指针</strong>。</li><li>对于增删操作<code>add</code>和<code>remove</code>，LinkedList比较占优势，因为<strong>ArrayList要移动数据</strong>。</li><li><strong>LinkedList比ArrayList更占内存</strong>，因为LinkedList的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li></ul><h3 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h3><p>Vector和ArrayList几乎一样，区别是<strong>Vector是线程安全的</strong>。因为这个原因，所以它的<strong>性能较差</strong>，开销比ArrayList大。所以通常情况下推荐使用ArrayList。</p><p>Vector类可以实现可增长的对象数组。与数组一样，它包含可以使用整数索引进行访问的组件。这意味着，Vector是「基于数组实现的」。</p><h3 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h3><h3 id="HashSet"><a href="#HashSet" class="headerlink" title="HashSet"></a>HashSet</h3><h3 id="HashTable"><a href="#HashTable" class="headerlink" title="HashTable"></a>HashTable</h3><h3 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h3><p>在JDK1.8之前，ConcurrentHashMap是使用了「<strong>分段锁</strong>」的方式，具体可以理解为把一个大的Map拆分成N个小的HashTable，根据<code>key.hashCode()</code>来决定把key放到哪个HashTable中，即把Map分成了N个Segment，put和get的时候，都是现根据<code>key.hashCode()</code>算出放到哪个Segment中。</p><h3 id="HashMap与HashTable的区别"><a href="#HashMap与HashTable的区别" class="headerlink" title="HashMap与HashTable的区别"></a>HashMap与HashTable的区别</h3><ul><li><strong>HashMap是非线程安全的</strong>，<strong>HashTable是线程安全的</strong>，HashTable内部的方法基本都用了同步锁<code>synchronized</code>修饰。</li><li>因为线程安全的问题，所以HashMap要比HashTable效率更高，这也是HashTable几乎要被淘汰的原因。</li><li><strong>HashMap允许有null值</strong>的存在，而在<strong>HashTable中键值只要有一个null</strong>，就会直接抛出空指针异常。</li></ul><blockquote><p>如果使用的JDK5以上的版本，又需要满足线程安全的话，推荐使用ConcurrentHashMap。</p></blockquote><p>可以使用如下两种方法让HashMap同步，即线程安全：</p><ul><li><code>Collections.synchronized(hashMap)</code></li><li>使用ConcurrentHashMap</li></ul><h3 id="HashMap与HashSet的区别"><a href="#HashMap与HashSet的区别" class="headerlink" title="HashMap与HashSet的区别"></a>HashMap与HashSet的区别</h3><ul><li>HashMap实现了Map接口，HashSet实现了Set接口，所以HashSet中不允许有重复的元素</li><li>HashMap存储的是键值对，HashSet仅存储了对象</li><li>HashMap使用key来计算hashcode的值，HashSet使用成员对象来计算hashcode的值。如果两个对象的hashcode值相同，就需要使用<code>equals()</code>方法来判断对象的相等性，如果两个对象不同，就返回false。</li><li>HashMap比较快，因为是使用唯一的键来获取对象，HashSet较HashMap来说比较慢。</li><li>HashMap和HashSet都是线程不安全的</li></ul><blockquote><p>使用HashSet，首先要确保在将对象存储在HashSet之前，确保对象重写<code>equals()</code>和<code>hashCode()</code>方法，这样才能比较对象的值是否相等，因为需要确保set中没有存储相等的对象。</p></blockquote><h3 id="HashMap与ConcurrentHashMap的区别"><a href="#HashMap与ConcurrentHashMap的区别" class="headerlink" title="HashMap与ConcurrentHashMap的区别"></a>HashMap与ConcurrentHashMap的区别</h3><ul><li>HashMap是线程不安全的，ConcurrentHashMap是线程安全的。</li><li><strong>HashMap的键值对允许有null</strong>，但是<strong>ConCurrentHashMap都不允许</strong>。</li></ul><h3 id="Collections工具类常用方法："><a href="#Collections工具类常用方法：" class="headerlink" title="Collections工具类常用方法："></a>Collections工具类常用方法：</h3><ol><li>排序</li><li>查找，替换操作</li><li>同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包的并发集合）</li></ol><p><strong>排序操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">// 反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span> <span class="comment">// 随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span> <span class="comment">// 按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span> <span class="comment">// 定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">// 交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span> <span class="comment">// 旋转。当distance为正数时，将list后distatnce个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><p><strong>查找，替换操作</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span> <span class="comment">// 对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">// 根据元素的自然顺序，返回最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span> <span class="comment">// 根据定制排序，返回最大元素，排序规则由Comparatator类控制</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span> <span class="comment">// 用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span> <span class="comment">// 统计元素出现个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span> <span class="comment">// 统计target在list中第一次出现的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span> <span class="comment">// 用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><p><strong>同步控制</strong></p><p><strong>因为<code>HashSet</code>、<code>TreeSet</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>TreeMap</code>都是线程不安全的。</strong><code>Collections</code>提供了多个<code>synchronizedXxx()</code>静态方法可以把它们包装成线程同步的集合。</p><p><strong>最好不要使用下面这些方法，因为效率非常低</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt; c);</span><br><span class="line">synchronizedList(List&lt;T&gt; list);</span><br><span class="line">synchronizedMap(Map&lt;K, V&gt;, m);</span><br><span class="line">synchronizedSet(Set&lt;T&gt; s);</span><br></pre></td></tr></table></figure><h3 id="Arrays类的常见操作"><a href="#Arrays类的常见操作" class="headerlink" title="Arrays类的常见操作"></a>Arrays类的常见操作</h3><ol><li>排序：<code>sort()</code></li><li>查找：<code>binarySearch()</code></li><li>比较：<code>equals()</code></li><li>填充：<code>fill()</code></li><li>转列表：<code>asList()</code></li><li>转字符串：<code>toString()</code></li><li>赋值：<code>copyOf()</code></li></ol><h2 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h2><h3 id="开启线程的方式"><a href="#开启线程的方式" class="headerlink" title="开启线程的方式"></a>开启线程的方式</h3><h4 id="Thread类和Runnable接口实现多线程哪个更好"><a href="#Thread类和Runnable接口实现多线程哪个更好" class="headerlink" title="Thread类和Runnable接口实现多线程哪个更好"></a>Thread类和Runnable接口实现多线程哪个更好</h4><h4 id="Callable和Runnable接口的区别是什么"><a href="#Callable和Runnable接口的区别是什么" class="headerlink" title="Callable和Runnable接口的区别是什么"></a>Callable和Runnable接口的区别是什么</h4><ul><li>Callable只能运行在线程池中，而Runnable既能运用在Thread中，又能运行在线程池中。</li><li>Callable是一个<strong>泛型接口</strong>，该接口又一个返回值的<code>call()</code>函数，而Runnable的<code>run()</code>函数不能将结果返回给客户程序。</li></ul><h2 id="JVM-1"><a href="#JVM-1" class="headerlink" title="JVM"></a>JVM</h2><h3 id="内存"><a href="#内存" class="headerlink" title="内存"></a>内存</h3><h4 id="JVM内存是如何划分的"><a href="#JVM内存是如何划分的" class="headerlink" title="JVM内存是如何划分的"></a>JVM内存是如何划分的</h4><h4 id="工作内存和主内存的关系。在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施"><a href="#工作内存和主内存的关系。在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施" class="headerlink" title="工作内存和主内存的关系。在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施"></a>工作内存和主内存的关系。在Java内存模型有哪些可以保证并发过程的原子性、可见性和有序性的措施</h4><h3 id="JVM、Dalvik、ART的区别"><a href="#JVM、Dalvik、ART的区别" class="headerlink" title="JVM、Dalvik、ART的区别"></a>JVM、Dalvik、ART的区别</h3><h3 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h3><blockquote><p>垃圾回收（GC）是一种自动的<strong>内存管理</strong>的机制。当一个电脑上的动态内存不再需要时，就应该予以释放，以让出内存，这种内存资源管理，被称为垃圾回收。</p></blockquote><p>垃圾回收主要根据以下几点判断算法性能和优缺点：</p><ul><li>吞吐量（throughput）</li><li>最大暂停时间</li><li>堆使用效率</li><li>访问的局限性</li></ul><h4 id="标记-清除算法（Mark-Sweep-GC）"><a href="#标记-清除算法（Mark-Sweep-GC）" class="headerlink" title="标记-清除算法（Mark-Sweep GC）"></a>标记-清除算法（Mark-Sweep GC）</h4><p>分为<strong>标记</strong>和<strong>清除</strong>两个阶段。</p><ol><li>标记阶段：从根集合出发，将所有活动对象及其子对象打上标记</li><li>清除阶段：遍历堆，将非活动对象（未打上标记）的连接到空闲链表上</li></ol><p><strong>优点</strong>：</p><ul><li>实现简单，容易与其他算法组合使用</li></ul><p><strong>缺点</strong>：</p><ul><li>碎片化，会导致无数小分块散落在堆的各处</li><li>分配速度不理想，每次分配都需要遍历空闲列表，找到足够大的分块</li></ul><h4 id="标记-压缩算法（Mark-Compact-GC）"><a href="#标记-压缩算法（Mark-Compact-GC）" class="headerlink" title="标记-压缩算法（Mark-Compact GC）"></a>标记-压缩算法（Mark-Compact GC）</h4><h4 id="引用计数算法（Reference-Counting-GC）"><a href="#引用计数算法（Reference-Counting-GC）" class="headerlink" title="引用计数算法（Reference Counting GC）"></a>引用计数算法（Reference Counting GC）</h4><p><strong>为什么引用计数器判定对象是否回收不可行</strong></p><h4 id="GC复制算法"><a href="#GC复制算法" class="headerlink" title="GC复制算法"></a>GC复制算法</h4><h4 id="保守式GC"><a href="#保守式GC" class="headerlink" title="保守式GC"></a>保守式GC</h4><h4 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h4><h4 id="增量式GC"><a href="#增量式GC" class="headerlink" title="增量式GC"></a>增量式GC</h4><h3 id="垃圾回收机制"><a href="#垃圾回收机制" class="headerlink" title="垃圾回收机制"></a>垃圾回收机制</h3><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式<span id="designpattern"></h2><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式下，对应类只能生成一个实例。但是也有很多种不同的写法。</p><h4 id="饿汉模式"><a href="#饿汉模式" class="headerlink" title="饿汉模式"></a>饿汉模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance = <span class="keyword">new</span> Singleton();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方式在类加载时就完成了初始化操作，所以类加载速度慢，但是获取对象的速度快。这种方式基于类加载机制，避免了多线程的同步问题，但是也不能确定有其它的方式或者其它的静态方法会导致类加载。此时的初始化<code>instance</code>是没有达到<strong>懒加载</strong>的效果的。</p><h4 id="懒汉模式（线程不安全）"><a href="#懒汉模式（线程不安全）" class="headerlink" title="懒汉模式（线程不安全）"></a>懒汉模式（线程不安全）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>懒汉模式使用了懒加载的模式，申明了一个静态对象，只在用户第一次调用时需要初始化。虽然节约了资源，但是第一次加载时仍需要实例化，速度稍慢，而且<strong>在多线程下不能工作</strong>。因为当有多个线程并行调用<code>getInstance()</code>的时候，就会创建多个实例了。</p><h4 id="懒汉模式（线程安全）"><a href="#懒汉模式（线程安全）" class="headerlink" title="懒汉模式（线程安全）"></a>懒汉模式（线程安全）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了解决线程不安全的问题，就是将整个<code>getInstance()</code>方法设置为同步（<code>synchronized</code>）。这种写法能够在多线程中很好的工作，但是每次调用<code>getInstance()</code>方法时都需要进行同步，会造成不必要的同步开销。因为在任何时候都只能有一个线程调用<code>getInstance()</code>方法。但是大部分时候我们是用不到同步的，只需要在第一次调用时用到，所以<strong>不建议使用这种方式</strong>。</p><h4 id="双重检验锁模式（double-checked-locking-pattern）"><a href="#双重检验锁模式（double-checked-locking-pattern）" class="headerlink" title="双重检验锁模式（double checked locking pattern）"></a>双重检验锁模式（double checked locking pattern）</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>DCL模式是一种使用同步块加锁的方法，在<code>getSingleton()</code>方法中对<code>instance</code>进行了两次判空，第一次是为了不必要的同步，第二次是在<code>instance == null</code>的情况下才创建实例。之所以还要在同步块内再检验一次，就是因为可能会有多个线程一起进入同步块外的<code>if</code>，如果不进行二次检验就会生成多个实例了。</p><p>但是上面这段代码仍然有问题。主要是<code>instance = new Singleton()</code>这句代码，<strong>并非是一个原子操作</strong>。在JVM中,这句代码会执行下面三个操作:</p><ul><li>给<code>instance</code>分配内存</li><li>调用<code>Singleton</code>的构造函数来初始化成员变量</li><li>将<code>instance</code>对象指向分配的内存空间（执行完这步后<code>instance</code>就为非空了）</li></ul><p>但是在JVM的即时编译器中存在指令重排序的优化，即第二步和第三步的顺序不能保证谁先执行。解决方法就是<strong>将<code>instance</code>变量声明成<code>volatile</code>就可以了</strong>。因为<code>volatile</code>是可以禁止指令重排序优化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class) &#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>volatile</code>的DCL模式的优点是资源利用率高，第一次执行<code>getInstance()</code>时，单例对象才会被实例化，效率高。缺点是第一次加载时反应会慢一些。</p><h4 id="静态内部类单例模式"><a href="#静态内部类单例模式" class="headerlink" title="静态内部类单例模式"></a>静态内部类单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> class <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> SingletonHolder.sInstance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton sInstance = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法也是《Effect Java》推荐使用的。在第一次加载<code>Singleton</code>类时并不会初始化<code>sInstance</code>，只有第一次调用<code>getInstance()</code>方法的时候虚拟机加载<code>SingletonHolder</code>并初始化<code>sInstance</code>。这样首先初始化这个成员变量，由Java虚拟机来保证其线程安全性，确保该成员变量只能初始化一次。由于<code>getInstance()</code>方法没有任何线程锁定，因此其性能不会造成任何影响。</p><p>由于<code>SingletonHolder</code>是私有的，除了<code>getInstance()</code>方法之外没有方法能够访问它，所以它是懒汉式的；同时读取实例的时候不会进行同步，没有性能缺陷，也不依赖JDK版本。</p><h4 id="枚举单例"><a href="#枚举单例" class="headerlink" title="枚举单例"></a>枚举单例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用枚举实现单例的方式十分简单。默认枚举实例的创建是线程安全的，并且在任何情况下都是单例，而且能够防止反序列化导致创建新的对象。但是大部分应用开发很少使用到枚举，因为可读性不是很高，不建议使用。</p><h4 id="使用容器实现单例模式"><a href="#使用容器实现单例模式" class="headerlink" title="使用容器实现单例模式"></a>使用容器实现单例模式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonManager</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Map&lt;String, Object&gt; objMap = <span class="keyword">new</span> HashMap&lt;String, Object&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">registerService</span><span class="params">(String key, Objectinstance)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!objMap.containsKey(key)) &#123;</span><br><span class="line">            objMap.put(key, instance);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="title">ObjectgetService</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> objMap.get(key);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>使用<code>SingletonManager</code>将多种单例统一管理，使用时根据key获取对象对应类型的对象。这种方式使得我们可以管理多种类型的单例，并且在使用时可以通过统一的接口进行获取操作，降低了用户的使用成本，也对用户隐藏了具体实现的细节，降低了耦合度。</p><h3 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h3><p>简单工厂模式（Simple Factory Pattern），又称为静态工厂方法（Static Factory Method）模式。在简单工厂模式中，可以根据参数的不同返回不同类的实例。它专门定义了一个类来负责创建其它类的实例，被创建的实例通常都会具有共同的父类。</p><p>之所以要使用简单工厂模式，是因为要把“产品”和“生产”完全分开。用户只需要知道自己要使用哪些产品，以及如何使用产品即可，而产品的生产则由工厂来完成。因为不同的产品可能仅仅是因为某些参数的不同而作用于不同的场景，所以工厂只需要根据传进来的不同的参数去生产具体的产品给消费者使用。</p><p>简单工厂模式包含以下角色：</p><ul><li>Factory（工厂角色）：工厂角色负责实现创建所有实例的内部逻辑</li><li>Product（抽象产品角色）：抽象产品角色是所创建的所有产品（实例）的父类，负责描述所有产品（实例）共有的公共接口</li><li>ConcreteProduct（具体产品角色）：具体产品角色是这个角色的具体类的实例，是抽象产品角色根据不同参数的具体实现</li></ul><p>（或者让Product作为具体的产品角色，AbstractProduct作为抽象产品角色）。</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/04/YpjgMt.jpg" alt="YpjgMt.jpg"></p><p>简单工厂模式的优点：</p><ul><li>简单工厂模式实现了对于责任的分割，提供了专门的工厂类用于创建对象，而客户端免除了直接创建产品对象的责任，而是仅仅消费产品；</li><li>客户端无需知道所创建的具体产品类的类名，只需要知道具体产品类对应的参数即可；</li><li>可以在不修改任何客户端代码的情况下更换和增加新的具体产品类，一定程度上提高了系统的灵活性；</li><li><strong>从产品的角度上</strong>符合“开闭原则”</li></ul><p>简单工厂模式的缺点：</p><ul><li>因为工厂类集中了所有的产品创建的逻辑，如果一旦不能正常工作，整个系统都会受到影响；</li><li>使用简单工厂模式会增加系统中类的个数，在一定程度上增加了系统的复杂度和理解难度；</li><li>系统扩展困难，一旦添加新的产品就要修改工厂类的逻辑，<strong>从工厂的角度上</strong>是不符合“开闭原则”的；</li><li>简单工厂模式由于使用了静态工厂方法，造成了工厂角色无法形成基于继承的结构；</li></ul><p>适用场景：</p><ul><li>工厂类负责创建的对象比较少的情况。因为创建的对象较少，就不会造成工厂方法中的业务逻辑太过复杂；</li><li>客户端只知道传入工厂类的参数，对于如何创建对象不关心：客户端既不需要关心创建细节，甚至连类名都不需要记住，只需要知道类型所对应的参数。</li></ul><h3 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h3><p>工厂方法模式（Factory Method Pattern）又称为工厂模式，从名字就可以看出相对于简单工厂模式，工厂模式会更复杂一些。在该模式中，工厂父类负责定义创建产品对象的公共接口，而工厂实现类则负责生成具体的产品对象。抽象产品类和具体产品类的逻辑则与简单工厂模式一致。</p><p>工厂方法模式包含以下角色：</p><ul><li>Product（抽象产品）：定义具体产品的公共接口；</li><li>ConcreteProduct（具体产品）：继承抽象产品类，定义生产的具体产品；</li><li>Factory（抽象工厂）：定义具体工厂的公共接口；</li><li>ConcreteFactory（具体工厂）：定义创建对应具体产品实例的方法；</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/FactoryMethod.jpg" alt=""></p><p>工厂模式的优点：</p><ul><li>更加符合“开闭原则”：当新增一种产品时，只需要增加响应的具体产品类和具体工厂类，抽象工厂和抽象产品无需修改；</li><li>符合“单一职责原则”：每个具体工厂类都只负责创建对应的产品；</li><li>不适用静态工厂方法：可以形成基于继承的结构</li></ul><p>工厂模式可以说是简单工厂模式的一种抽象和拓展，在保留了简单工厂的封装有点的同时，让扩展变得更简单，实现了继承的结构，增加了多态性的体现。</p><p>工厂模式缺点：</p><ul><li>添加新产品时，既要增加新的具体产品类，又要增加新的具体工厂类，系统类的个数成对增加，增加了系统的复杂度；</li><li>考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到OOM、反射等技术，增加了实现难度；</li><li>一个具体工厂类只能对应一个产品；</li><li>如果需要更换产品而不是新增产品，就仍然需要修改实例化的具体工厂类；</li></ul><p>适用场景：</p><ul><li>当一个类希望通过子类来指定创建对象</li><li>当一个类不知道它所需要的对象的类</li><li>将创建对象的任务委托给多个具体工厂类的某一个，客户端在使用时可以无须关心是哪一个具体工厂类创建了该产品，需要时再动态指定即可，可以将具体工厂类的类名存储在配置文件或者数据库中</li></ul><h3 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h3><p>抽象工厂模式（Abstract Factory Pattern），提供一个创建一系列相关或者相互依赖对象的接口，而无须指定它们具体的类；具体的工厂负责实现具体的产品实例。</p><p>因为工厂模式中，每个工厂只能创建一个类，十分浪费；抽象工厂就解决了这个问题。抽象工厂中每个工厂都可以创建多种类的产品。</p><p>抽象工厂模式包含以下角色：</p><ul><li>抽象产品族：描述了抽象产品的公共接口；</li><li>抽象产品：描述了具体产品的公共接口；</li><li>具体产品：描述了具体产品；</li><li>抽象工厂：描述了具体工厂的公共接口；</li><li>具体工厂：描述了具体工厂；</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS01ZDViNjUyOTRhYzE5MjQ2LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA.jpeg" alt=""></p><p>具体代码如下所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建抽象产品族类，定义抽象产品的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建抽象产品类，定义具体产品的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ContainerProduct</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建抽象产品类，定义具体产品的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">MouldProduct</span> <span class="keyword">extends</span> <span class="title">AbstractProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建具体产品类，定义生产的具体产品</span></span><br><span class="line"><span class="comment">// 容器A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerProduct</span> <span class="title">A</span> <span class="keyword">extends</span> <span class="title">ContainerProduct</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了容器产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 容器B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ContainerProductB</span> <span class="keyword">extends</span> <span class="title">ContainerProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了容器产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模具A类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouldProductA</span> <span class="keyword">extends</span> <span class="title">MouldProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了模具产品A"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模具B类</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MouldProductB</span> <span class="keyword">extends</span> <span class="title">MouldProduct</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"生产出了模具产品B"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建抽象工厂类，定义具体工厂的公共接口</span></span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> Product <span class="title">ManufactureMould</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建具体工厂类，定义工厂创建具体产品实例的方法</span></span><br><span class="line"><span class="comment">// 生产A产品的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryA</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContainerProductA();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureMould</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MouldProductA();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 生产B产品的工厂</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FactoryB</span> <span class="keyword">extends</span> <span class="title">Factory</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureContainer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ContainerProductB();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Product <span class="title">ManufactureMould</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> MouldProductB();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体实现类（调用类）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AbstractFactoryPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FactoryA mFactoryA = <span class="keyword">new</span> FactoryA();</span><br><span class="line">        FactoryB mFactoryB = <span class="keyword">new</span> FactoryB();</span><br><span class="line">        <span class="comment">//A厂当地客户需要容器产品A</span></span><br><span class="line">        mFactoryA.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//A厂当地客户需要模具产品A</span></span><br><span class="line">        mFactoryA.ManufactureMould().Show();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//B厂当地客户需要容器产品B</span></span><br><span class="line">        mFactoryB.ManufactureContainer().Show();</span><br><span class="line">        <span class="comment">//B厂当地客户需要模具产品B</span></span><br><span class="line">        mFactoryB.ManufactureMould().Show();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>抽象工厂模式的优点：</p><ul><li>降低耦合：抽象工厂模式将具体产品的创建放在了具体工厂的子类中</li><li>更符合“开闭原则”：新增一种产品时，则需要增加新的具体产品类和相应的工厂子类即可。</li></ul><p>抽象工厂模式的缺点：</p><ul><li>很难支持产品的变化：因为抽象工厂接口中已经确定了可以被创建的产品集合，所以如果需要添加新产品的话，就必须去修改抽象工厂的接口，这样就违背了“开闭原则”。</li></ul><h3 id="建造者模式"><a href="#建造者模式" class="headerlink" title="建造者模式"></a>建造者模式</h3><blockquote><p>建造者模式（Builder Pattern）是将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p></blockquote><p>通俗的说话就是，建造者模式就是如何一步步构建一个包含多个组成部件的对象，相同的构建过程却可以创建出不同的产品。它允许用户只通过指定复杂对象的类型和内容就可以构建它们，而不要知道内部的具体构建细节。</p><p>建造者模式包含以下角色：</p><ul><li>Builder：抽象建造者。给出一个抽象接口，以规范产品对象的各个组成成分的建造。一般而言，此接口是独立于应用程序的商业逻辑的。它必须实现接口要求的两种方法。一个是建造方法<code>buildPart()</code>，一个是返回结构方法<code>getResult()</code>。</li><li>ConcreteBuilder：具体建造者。这个角色的任务在于实现抽象建造者Builder声明的接口，给出一步步完成创建产品实例的操作；在建造过程完成后，提供产品的实例。</li><li>Director：导演者。这个角色负责调用较早者角色以创建产品对象。这个角色不了解任何关于产品的知识，只是负责调用。</li><li>Product：产品。产品就是被建造的对象。</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Builder.jpg" alt=""></p><p>比如以下一个例子可以用于描述KFC如何创建套餐的。KFC套餐是一个复杂的对象，它一般包含主食（如汉堡、鸡翅等）和饮料（如果汁、可乐等）等组成部分，不同的套餐有不同的组成部分。那么服务员这个对象就要根据客户的需要，负责组装这些套餐返回给顾客。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/KFCBuilder.jpg" alt=""></p><p>在上面这个模型中，KFCWaiter就是导演者角色。它并不知道具体的主食、饮料等是如何做出来，只负责组装（调用Builder对象），然后与客户端交流。MealBuilder在这里就是抽象建造者对象，里面的<code>getMeal()</code>方法就是从SubMealBuilder这个具体建造者对象得到建造好的产品。Meal是Product对象。</p><p>建造者模式的优点：</p><ul><li>在建造者模式中，客户端是不知道产品内部组成的细节的，它只与Director交互。通过将产品与产品本身的创建过程解耦，使得相同的创建过程却可以创建出不同的产品对象；</li><li>同样的，每一个具体建造者也是相对独立的。用户可以使用不同的具体建造者建造出不同的产品对象；</li><li>可以更加精细地控制产品的创建过程；</li><li>增加新的具体建造者是无需修改原有类库的代码的，符合<strong>开闭原则</strong>。</li></ul><p>建造者模式的缺点：</p><ul><li>所创建的产品一般具有较多的共同点（如上面例子中饮料的可乐、果汁等）。如果产品之间差异性很大的话，就不适用于建造者模式（因为使用范围受到一定的限制）；</li><li>如果产品的内部变化很复杂，就需要定义很多的具体建造类来实现这种变化，一个是不能满足的，这样系统会很庞大。</li></ul><h3 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h3><p>原型模式是通过给定一个原型对象来指明所有创建的对象的类型，然后用这个原型对象提供的复制方法创建出更多同类型的对象。</p><p>即原型模式要求对象实现一个可以克隆自身的接口（类型）。这样一来，通过原型实例创建新的对象，就不需要关心这个实例本身的类型，只需要实现克隆自身的方法，也无需再去通过<code>new</code>去创建。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/1332722887_7899.jpg" alt=""></p><p>原型对象主要就是用于对象的复制，其核心就是上图中的原型类Prototype。Prototype类需要具备以下两个条件：</p><ul><li>实现<code>Cloneable</code>接口。它的作用是在运行时通知虚拟机可以安全地实现此接口的类上使用<code>clone</code>方法。在JVM中，只有实现了这个接口的类才可以被拷贝；</li><li>重写Object类中的<code>clone</code>方法。</li></ul><p>总之，原型模式十分简单易理解，实现一个接口，重写一个方法就实现了原型模式。在实际应用中，原型模式很少单独出现，经常与其它模式混用，其原型类Prototype也常用抽象类来替代。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Prototype</span> <span class="keyword">implements</span> <span class="title">Cloneable</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Prototype <span class="title">clone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Prototype prototype = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            prototype = (Prototype) <span class="keyword">super</span>.clone();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CloneNotSupportException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prototype;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ConcretePrototype</span> <span class="keyword">extends</span> <span class="title">Prototype</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"原型模式实现类"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ConcretePrototype cp = <span class="keyword">new</span> ConcretePrototype();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            ConcretePrototype clonecp = (ConcretePrototype) cp.clone();</span><br><span class="line">            clonecp.show();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>原型模式的优点：</p><ul><li>简化对象的创建；</li><li>使用原型模式创建对象比直接<code>new</code>一个对象的性能要好得多，因为<code>clone</code>方法是一个本地方法。</li></ul><p>使用原型模式的注意事项：</p><ul><li>使用原型模式复制对象不会调用类的构造方法</li><li>深拷贝与浅拷贝。Object类的<code>clone</code>方法只会拷贝对象中的基本数据类型，对于数组、容器对象、引用对象等都不会去拷贝，所以是浅拷贝。</li></ul><hr><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><blockquote><p>外观模式定义了一个高层接口，为子系统中的一组接口提供了统一的接口。</p></blockquote><p>外观模式包含了如下两个角色：</p><ul><li>外观角色（Facade）：在客户端可以调用它的方法，在外观角色中可以知道相关的子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求都委派到相应的子系统中去，传递给相应的子系统对象去处理；</li><li>子系统角色（SubSystem）：在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不只是一个单独的类，而是一个类的集合，它实现了子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它要处理从外观类传过来的请求；子系统是不知道外观的存在的；</li></ul><p>外观模式的本质是<strong>封装交互，简化调用</strong>。它的目的不是给予子系统添加新的功能接口，而是让外部减少与子系统内多个模块的交互，松散耦合，让外部更简单地使用子系统。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子系统角色，由若干个类组成</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统1中的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统1中的方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SubClass2</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统2中的方法1"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"这是子系统2中的方法2"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 外观角色类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FacadeClass</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把子系统中的几个方法汇总到了一起</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">FacadeMethod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        SubClass1 s1 = <span class="keyword">new</span> SubClass1();</span><br><span class="line">        s1.method1();</span><br><span class="line">        SubClass2 s2 = <span class="keyword">new</span> SubClass2();</span><br><span class="line">        s2.method2();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 客户端主类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClientClass</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        FacadeClass fc = <span class="keyword">new</span> FacadeClass();</span><br><span class="line">        fc.FacadeMethod();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>外观模式为复杂子系统提供了一个简单的接口，并不为子系统添加新的功能和行为；</li><li>外观模式实现了子系统与客户端之间的松耦合的关系；</li><li>外观模式没有封装子系统的类，只是提供了简单的接口。如果有需要，客户其实也是能直接使用子系统的类的。</li><li>外观模式注重的是简化接口，它更多的时候是从架构的层次去看整个系统，而非单个类的层次。</li></ul><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>适配器模式（Adapter Pattern），将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，别名为包装器（Wrapper）。</p><p>适配器模式包含以下角色：</p><ul><li>Target：目标抽象类</li><li>Adapter：适配器类</li><li>Adaptee：适配者类</li><li>Client：客户类</li></ul><p>有两种适配器模式，一种是类的适配器模式，一种是对象的适配器模式。它们都是把适配的类的API转换成目标类的API。</p><h4 id="类的适配器模式"><a href="#类的适配器模式" class="headerlink" title="类的适配器模式"></a>类的适配器模式</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS0yNGM2YmY0NGRhMWI3OWFkLnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA.jpeg" alt=""></p><p>从上图可以看出，Target目标类想要调用<code>Request</code>方法，但是适配者类Adaptee是没有这个方法的，那么就需要中间有一个适配器类Adapter，把Adaptee的API与Target的API衔接起来（通过继承Adaptee，实现Target接口）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">extends</span> <span class="title">Adaptee</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.SpecificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target mAdapter = <span class="keyword">new</span> Adapter();</span><br><span class="line">        mAdapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="对象的适配器模式"><a href="#对象的适配器模式" class="headerlink" title="对象的适配器模式"></a>对象的适配器模式</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/aHR0cDovL3VwbG9hZC1pbWFnZXMuamlhbnNodS5pby91cGxvYWRfaW1hZ2VzLzk0NDM2NS1jNzM2NDE2Zjc4YTViMmQ1LnBuZz9pbWFnZU1vZ3IyL2F1dG8tb3JpZW50L3N0cmlwJTdDaW1hZ2VWaWV3Mi8yL3cvMTI0MA.jpeg" alt=""></p><p>对象的适配器模式就是把<strong>继承</strong>改在了Adapter的内部去实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adaptee</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">SpecificRequest</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Adapter</span> <span class="keyword">implements</span> <span class="title">Target</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Adaptee adaptee;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Adapter</span><span class="params">(Adaptee adaptee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.adaptee.SepcificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AdapterPattern</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Target mAdapter = <span class="keyword">new</span> Adapter(<span class="keyword">new</span> Adaptee());</span><br><span class="line">        mAdapter.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><p>适配器模式的优点：</p><ul><li>将目标类Target与适配者类Adaptee解耦，中间通过一个适配器类Adapter完成；</li><li>增加了类的透明性和复用性；</li><li>灵活性和拓展性非常好</li><li><strong>类适配器模式</strong>：由于适配器类Adater是适配者类Adaptee的子类，所以在适配器类Adapter还可以重写适配者Adaptee的一些方法，灵活性很强；</li><li><strong>对象适配器模式</strong>：一个对象适配器可以把不同的适配者Adaptee适配到同一个目标，即把适配者类Adaptee和它的子类都适配到目标接口Target。</li></ul><p>适配器模式的缺点：</p><p>因为Java等语言不支持多继承，所以一次最多只能适配一个适配者类Adaptee。</p><h3 id="桥接模式"><a href="#桥接模式" class="headerlink" title="桥接模式"></a>桥接模式</h3><p>桥接模式（Bridge Pattern）的主要特点是把抽象（Abstraction）与实现（Implementation）分离开，从而保持各部分的独立性以及对应它们的功能扩展。</p><p>桥接模式的角色：</p><ul><li>Client：调用者</li><li>Abstraction：抽象类接口。它的角色就是一个<strong>桥接类</strong></li><li>Refined Abstraction：是Abstraction类的子类</li><li>Implementer：行为实现类的接口</li><li>ConcreteImplementer：Implementer类的子类</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/683744-20160930102718453-1750189602.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 首先定义Implementer接口，定义了一个operation()方法</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Implementer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了Implementator接口的两个实现类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementerA</span> <span class="keyword">implements</span> <span class="title">Implementer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OperationA"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteImplementerB</span> <span class="keyword">implements</span> <span class="title">Implementer</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"OperationB"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义了桥接类Abstraction，这是一个抽象类，有对Implementer接口的引用</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Implementer implementer;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Implementer <span class="title">getImplementer</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> implementer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setImplementer</span><span class="params">(Implementer implementer)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.implementer = implementer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 通过引用Implementer，调用其operation()方法</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        implementer.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RefinedAbstraction</span> <span class="keyword">extends</span> <span class="title">Abstraction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.getImplementer().operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BridgeTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Abstraction abstraction = <span class="keyword">new</span> RefinedAbstraction();</span><br><span class="line"></span><br><span class="line">        abstraction.setImplementer(<span class="keyword">new</span> ConcreteImplementerA());</span><br><span class="line">        abstraction.operation();</span><br><span class="line"></span><br><span class="line">        abstraction.setImplementer(<span class="keyword">new</span> ConcreteImplementerB());</span><br><span class="line">        abstraction.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>桥接模式的优点：</p><ul><li>实现了抽象和实现部分的分离，从而极大地增加了系统的灵活性。对于系统的高层部分，只需要知道抽象部分和实现部分的接口即可，不用知道具体的实现方法</li><li>更好的拓展性</li><li>可以动态的切换实现</li></ul><p>桥接模式的缺点：</p><ul><li>桥接模式的引入增加了系统的理解与设计难度。它的聚合关联联系建立在抽象层，要求开发者针对抽象进行设计和编程；</li><li>桥接模式要求正确识别出系统中的两个独立变化的维度，所以其使用范围是有一定局限性的。</li></ul><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p>使用代理模式的目的是解决在直接访问对象时带来的问题。比如，要访问的对象在远程机器上，那么可能会因为创建对象开销很大或者其它原因，直接访问对象会给使用者或者系统结构带来很多麻烦，因此需要在访问对象时加上一个对此对象的<strong>访问层</strong>。</p><blockquote><p>代理模式（Proxy Pattern）：给定一个对象提供一个代理，并由代理对象控制对原对象的引用。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Proxy.jpg" alt=""></p><p>代理模式包含以下角色：</p><ul><li>Subject：抽象主题角色</li><li>Proxy：代理主题角色</li><li>RealSubject：真实主题角色</li></ul><p>我们可以通过一个加载图片的过程来说明代理模式。我们创建了一个Image接口和实现了Image接口的实体类。ProxyImage是一个代理类，是用来减少RealImage对象加载的内存占用。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/proxy_pattern_uml_diagram.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建图片接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">display</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建实现图片接口的类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RealImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Image fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">RealImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">        loadFromDisk(fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Displaying "</span> + fileName);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">loadFromDisk</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Loading "</span> + fileName + <span class="string">" from disk"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建代理图片类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyImage</span> <span class="keyword">implements</span> <span class="title">Image</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> RealImage realImage;</span><br><span class="line">    <span class="keyword">private</span> String fileName;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ProxyImage</span><span class="params">(String fileName)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.fileName = fileName;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">display</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (realImage == <span class="keyword">null</span>) &#123;</span><br><span class="line">            realImage = <span class="keyword">new</span> RealImage(fileName);</span><br><span class="line">        &#125;</span><br><span class="line">        readImage.display();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 主测试类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ProxyTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Image image = <span class="keyword">new</span> ProxyImage(<span class="string">"test.jpg"</span>);</span><br><span class="line">        image.display();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>从以上代码可以看出，通过创建一个ProxyImage的实例，调用其中的<code>display()</code>方法，然后如果图片存在，则再创建一个RealImage的实例，去加载和显示图片。</p><p>所以通过代理类ProxyImage，就能够负责协调调用者和被调用者，在一定程度上降低了系统的耦合度。缺点就是可能会造成请求的速度变慢。</p><p>除此之外，还可以举出一些实例来证明代理模式。例如，猪八戒去高老庄找高翠兰。但是通过把高翠兰的外貌给抽离出来，而高翠兰本人和孙悟空都能实现这个外貌的接口。那么猪八戒就无法通过高翠兰的外貌识别这究竟是高翠兰还是孙悟空了。这就是代理模式。</p><p>几种常见的代理模式：</p><ul><li>图片代理：比如对大图浏览的控制。用户通过浏览器访问网页时先不加载真实的大图，而是通过代理对象的方式进行处理。先在代理对象的方法中，先使用一个线程向客户端浏览器加载一个小图片，然后在后台使用另一个线程来调用大图片加载到客户端。当需要浏览大图片的时候，再将大图片在新网页中显示。如果用户在浏览大图时加载工作还未完成，可以再启动一个线程来显示相应的提示信息。通过代理技术结合多线程编程将真实图片的加载放到后台来操作，不影响前台图片的浏览。</li><li>远程代理：远程代理可以将网络的细节隐藏起来，使得客户端不必考虑网络的存在。客户完全可以认为被代理的远程业务对象是局域的而不是远程的，而远程代理对象则承担了大部分的网络通信操作。</li><li>虚拟代理：当一个对象的加载十分消耗资源的时候，虚拟代理的优势就非常明显地体现出来。虚拟代理模式是一种内存节省技术，那些占用大连内存或者处理复杂的对象将推迟到使用它的时候才创建。</li></ul><h3 id="装饰器模式"><a href="#装饰器模式" class="headerlink" title="装饰器模式"></a>装饰器模式</h3><p>装饰器模式（Decorator Pattern）是动态地给一个对象增加一些额外的功能又不改变其结构。就增加对象功能而言，装饰器模式比生成子类的实现更加灵活。其别名也叫包装器（Wrapper）。</p><p>装饰器模式包含以下角色：</p><ul><li>Component：抽象构件。给出一个抽象的接口，以规范准备接受附加功能的对象。</li><li>ConcreteComponent：具体构件。定义一个要接受附加功能的对象。</li><li>Decorator：抽象装饰类。</li><li>ConcreteDecorator：具体装饰类。</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Decorator.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Decorator</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Component component;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">(Component component)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">        <span class="keyword">this</span>.component = component;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Decorator</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        component.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteComponent</span> <span class="keyword">implements</span> <span class="title">Component</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ConcreteComponent</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcreteDecorator</span> <span class="keyword">extends</span> <span class="title">Decorator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.operation();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据上面的类图，可以通过“齐天大圣——孙悟空”的例子来掌握装饰器模式。</p><p>Component的角色就是“齐天大圣”，注意这里的“齐天大圣”是一个名号，是由孙悟空拥有；而ConcreteComponent就是孙悟空本人，它是“齐天大圣”这个名号的实际拥有者；Decorator是齐天大圣拥有的72变，而具体的ConcreteDecoratorA或者ConcreteDecoratorB就是72变可以变化的角色，例如花鸟鱼虫等等。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Snipaste_2020-05-06_15-25-00.png" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 齐天大圣接口</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">MonkeyKing</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 猴子类，是齐天大圣的本尊（具体实现）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Monkey</span> <span class="keyword">implements</span> <span class="title">MonkeyKing</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"Monkey move"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 72变类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Change</span> <span class="keyword">implements</span> <span class="title">MonkeyKing</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> MonkeyKing king;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Change</span><span class="params">(MonkeyKing king)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.king = king;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.king.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的变化类，变成鱼</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Fish</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Fish</span><span class="params">(MonkeyKing king)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(king);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"Change fish"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 具体的变化类，变成鸟</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Bird</span> <span class="keyword">extends</span> <span class="title">Change</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Bird</span><span class="params">(MonkeyKing king)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(king);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">move</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.move();</span><br><span class="line">        System.out.println(<span class="string">"Change bird"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MonkeyKing king = <span class="keyword">new</span> Monkey();</span><br><span class="line">        MonkeyKing bird = <span class="keyword">new</span> Bird(king);</span><br><span class="line">        bird.move();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>装饰模式是符合“开闭原则”的。再比如，定义一个抽象类Tea，它的功能是只能提供白开水。而通过装饰类BlackTea装饰之后就拓展了新功能，可以用白开水泡红茶，还可以选择加配料等等。</p><p>装饰器模式的使用场景：</p><ul><li>当需要扩展一个类的功能或者给一个类增加附加功能时；</li><li>需要动态地给一个对象增加功能，而且这些功能还可以动态地撤销</li></ul><p>装饰器模式的优点：</p><ul><li>继承关系的目的都是拓展对象的功能，而装饰器模式可以提供更多的灵活性；</li><li>通过使用不同的具体修饰类以及这些修饰类的排列组合，可以创造出很多不同的组合；</li></ul><p>装饰器模式的缺点：</p><ul><li>使用装饰器模式就是会比继承关系产生更多的类，而且这些类看上去都比较接近。</li></ul><h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><blockquote><p>享元模式（Flyweight Pattern）：运用共享技术有效地支持大量<strong>细粒度对象</strong>的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。</p></blockquote><p>在很多情况下，我们需要在系统中增加类和对象的个数，这样会付出很多代价，带来性能下降等问题。而享元模式就是来解决这一问题的。它通过共享技术来实现相同或相似对象的重用。</p><p>在享元模式中，可以共享的相同内容被称为<strong>内部状态（IntrinsicState）</strong>，而那些需要外部环境来设置不能共享的内容称为<strong>外部状态（ExtrinsicState）</strong>。在享元模式中，通过会出现工厂模式，需要创建一个享元工厂来负责维护一个<strong>享元池（Flyweight Pool）</strong>，用于存储具有相同内部状态的享元对象。</p><p>享元模式包含的角色：</p><ul><li>Flyweight（抽象享元类）：通常是一个接口或者抽象类。在这里声明了具体享元类的公共方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li>ConcreteFlyweight（具体享元类）：它实现了抽象享元类中的具体方法，其实例就是享元对象。在具体享元类中为内部状态提供存储空间。</li><li>UnsharedConcreteFlyweight（非共享具体享元类）：并不是所有的抽象享元类的子类都需要被共享，所以与ConcreteFlyweight相反的就是不可被共享的子类，即非共享具体享元类。</li><li>FlyweightFactory（享元工厂类）：享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各个类型的具体享元对象存储在一个享元池中（享元池一般设计成一个存储键值对的集合）。</li></ul><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Flyweight.jpg" alt=""></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 享元工厂类（含有一个享元池）</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FlyweightFactory</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 定义一个HashMap用于存储享元对象，实现享元池</span></span><br><span class="line">    <span class="keyword">private</span> HashMap flyweights = <span class="keyword">new</span> HashMap();</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Flyweight <span class="title">getFlyweight</span><span class="params">(String key)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果对象存在，则直接从享元池中获取</span></span><br><span class="line">        <span class="keyword">if</span> (flyweights.containsKey(key)) &#123;</span><br><span class="line">            <span class="keyword">return</span> (Flyweight)flyweights.get(key);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回它</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            Flyweight fw = <span class="keyword">new</span> ConcreteFlyweight();</span><br><span class="line">            flyweights.put(key, fw);</span><br><span class="line">            <span class="keyword">return</span> fw;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 享元类</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Flyweight</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的</span></span><br><span class="line">    <span class="keyword">private</span> String intrinsicState;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Flyweight</span><span class="params">(String intrinsicState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.intrinsicState = intrinsicState;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是外部状态，则使用时由外部设置，不保存在享元对象中，即使是同一个对象</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operation</span><span class="params">(String extrinsicState)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>享元模式的优点：</p><ul><li>可以极大地较少内存中对象的数量，使得相同的或者相似的对象在内存中只保留一份，从而可以节约系统资源，提高系统性能；</li><li>享元模式的外部状态相对独立，而且不会影响到内部状态，从而使得享元对象可以在不同的环境中被共享；</li></ul><p>享元模式的缺点：</p><ul><li>使得系统复杂化</li><li>读取外部状态将使得运行时间变长</li></ul><hr><h3 id="职责链模式"><a href="#职责链模式" class="headerlink" title="职责链模式"></a>职责链模式</h3><h3 id="命令模式"><a href="#命令模式" class="headerlink" title="命令模式"></a>命令模式</h3><h3 id="解释器模式"><a href="#解释器模式" class="headerlink" title="解释器模式"></a>解释器模式</h3><h3 id="迭代器模式"><a href="#迭代器模式" class="headerlink" title="迭代器模式"></a>迭代器模式</h3><h3 id="中介者模式"><a href="#中介者模式" class="headerlink" title="中介者模式"></a>中介者模式</h3><h3 id="备忘录模式"><a href="#备忘录模式" class="headerlink" title="备忘录模式"></a>备忘录模式</h3><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><h3 id="状态模式"><a href="#状态模式" class="headerlink" title="状态模式"></a>状态模式</h3><h3 id="策略模式"><a href="#策略模式" class="headerlink" title="策略模式"></a>策略模式</h3><h3 id="模板方法模式"><a href="#模板方法模式" class="headerlink" title="模板方法模式"></a>模板方法模式</h3><h3 id="访问者模式"><a href="#访问者模式" class="headerlink" title="访问者模式"></a>访问者模式</h3>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Interview-Review(Android)</title>
      <link href="/2020/03/25/Interview-Review(Android)/"/>
      <url>/2020/03/25/Interview-Review(Android)/</url>
      
        <content type="html"><![CDATA[<p>本篇主要是面试复习内容的Android部分。</p><p>Android主要分为以下几个部分：</p><ul><li><a href="#Activity">Activity</a></li><li><a href="#Fragment">Fragment</a></li><li><a href="Service">Service</a></li><li><a href="#broadcastreceiver">Broadcast Receiver</a></li><li><a href="#contentprovider">Content Provider</a></li><li><a href="#数据存储">数据存储</a></li><li><a href="#bitmap">Bitmap</a></li><li><a href="#handler">Handler</a></li><li><a href="#asynctask">AsyncTask</a></li><li><a href="#view">View</a></li><li><a href="#animation">Animation</a></li><li><a href="#window">Window</a></li><li><a href="#布局">布局</a></li><li><a href="#事件">事件</a></li><li><a href="#设计模式">设计模式</a></li></ul><a id="more"></a><h1 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h1><h2 id="Activity生命周期"><a href="#Activity生命周期" class="headerlink" title="Activity生命周期"></a>Activity生命周期</h2><ul><li>启动Activity：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code>，进入运行状态；</li><li>Activity退居后台（Home或者启动了新的Activity）：<code>onPause()</code>⟶<code>onStop()</code>；</li><li>Activity返回前台：<code>onRestart()</code>⟶<code>onStart()</code>⟶<code>onResume()</code>;</li><li>如果Acitivity后台期间内存不足，再次启动时就会重新执行启动流程；</li><li>锁屏：<code>onPause()</code>⟶<code>onStop()</code>；</li><li>解锁：<code>onStart()</code>⟶<code>onResume()</code>；</li></ul><p><strong>具体方法介绍</strong>：</p><ul><li><code>onCreate()</code>：在每个Activity中都会重写这个方法，它会在活动第一次被创建的时候调用；</li><li><code>onStart()</code>：这个方法由不可见变为可见时调用；</li><li><code>onResume()</code>：这个方法在Activity准备好和用户进行交互时调用。此时的活动肯定位于活动返回栈的栈顶，并且处于运行状态；</li><li><code>onPause()</code>：这个方法是当系统准备启动或者恢复另一个活动的时候调用。通常会在这个方法里释放一些非常消耗CPU的资源等；</li><li><code>onStop()</code>：这个方法在完全不可见的时候调用；</li><li><code>onDestroy()</code>：这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态；</li><li><code>onRestart()</code>：这个方法在活动由停止状态变为运行状态之前调用，即活动被重新启动了</li></ul><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/01/JO9941.png" alt=""></p><p><strong>三个时期</strong>：</p><ul><li><strong>完整生存期</strong>：活动在<code>onCreate()</code>到<code>onDestroy()</code>方法之间所经历的就是<strong>完整生存期</strong>。一般情况下，一个活动会在<code>onCreate()</code>方法中完成各种初始化操作，而在<code>onDestroy()</code>方法中完成释放内存的操作；</li><li><strong>可见生存期</strong>：活动在<code>onStart()</code>到<code>onStop()</code>方法之间所经历的就是<strong>可见生存期</strong>。<strong>可见生存期的</strong>的意思就是活动对于用户总是可见的（即使有可能与用户无法交互）；</li><li><strong>前台生存期</strong>：活动在<code>onResume()</code>和<code>onPause()</code>方法之间的就是时期就是<strong>前台生存期</strong>。在<strong>前台生存期</strong>内，活动总是处于运行状态的，即此时的活动是可以和用户进行交互的。</li></ul><h3 id="横竖屏切换时Activity的生命周期变化"><a href="#横竖屏切换时Activity的生命周期变化" class="headerlink" title="横竖屏切换时Activity的生命周期变化"></a>横竖屏切换时Activity的生命周期变化</h3><p>这需要判断<code>AndroidManifest.xml</code>中是否设置了<code>configChanges</code>属性。而<code>configChanges</code>常用的属性有：</p><ul><li><code>orientation</code>：屏幕在纵向和横向间旋转</li><li><code>keyboardHidden</code>：键盘显示或者隐藏</li><li><code>screenSize</code>：屏幕大小改变了</li></ul><p><strong><code>AndroidManifest</code>没有设置<code>configChanges</code>属性</strong></p><p>如果是从<strong>竖屏启动切换横屏</strong>：</p><p><strong>竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onPause()</code>⟶<code>onSavedInstanceState()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>⟶<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onRestoreInstanceState()</code>⟶<code>onResume()</code>⟶<code>onPause()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>（Android6.0、7.0、8.0适用）</p><p>如果是从<strong>横屏启动切换竖屏</strong>：</p><p>生命周期与<strong>从竖屏启动切换横屏一样</strong>。</p><p><strong>总结</strong>：如果没有设置<code>configChanges</code>属性的话，在Android6.0、7.0、8.0的手机上表现是一样的。首先是正常地走一遍流程（在<code>onPause()</code>之后会有<code>onSavedInstanceState()</code>），然后重新创建之后在<code>onStart()</code>之后会有<code>onRestoreInstanceState()</code>。</p><p><strong><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation&quot;</code></strong></p><p>如果是从<strong>竖屏启动切换横屏</strong>：</p><p><strong>Android 6.0 竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onPause()</code>⟶<code>onSavedInstanceState()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>⟶<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onRestoreInstanceState()</code>⟶<code>onResume()</code>⟶<code>onPause()</code>⟶<code>onStop()</code>⟶<code>onDestory()</code></p><p><strong>Android 7.0 竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onConfigurationChanged()</code>⟶<code>onPause()</code>⟶<code>onSavedInstanceState()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code>⟶<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onRestoreInstanceState()</code>⟶<code>onResume()</code>⟶<code>onPause()</code>⟶<code>onStop()</code>⟶<code>onDestroy()</code></p><p><strong>Android 8.0 竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onConfigurationChanged()</code></p><p><strong>总结</strong>：在设置了<code>configChanges</code>属性为<code>orientation</code>之后，Android 6.0的生命周期与没有设置是一样的。而Android 7.0则会先多回调一个<code>onConfigurationChanged()</code>方法，剩下的流程一样。Android 8.0则只是回调了<code>onConfigurationChanged()</code>方法，并没有走Activity生命周期的方法。</p><p>如果是从<strong>横屏启动切换竖屏</strong>：</p><p>生命周期与<strong>从竖屏启动切换横屏一样</strong>。</p><p><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize&quot;</code></p><p><strong>竖屏启动</strong>：<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code><strong>切换横屏</strong>：<code>onConfigurationChanged()</code>（Android6.0、7.0、8.0适用）</p><p><strong>总结</strong>：当设置了<code>android:configChanges=&quot;orientation|keyboardHidden|screenSize</code>时，就不会调用Activity其它生命周期的方法，只会调用<code>onConfigurationChanged()</code>方法。</p><p><strong><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation|screenSize&quot;</code></strong></p><p>与<code>orientation|keyboardHidden|screenSize</code>相同，只回调<code>onConfigurationChanged()</code>方法。</p><p><strong><code>AndroidManifest</code>设置了<code>android:configChanges=&quot;orientation|keyboardHidden&quot;</code></strong></p><p>与只设置了<code>orientation</code>的相同，Android 6.0、7.0会回调生命周期的方法，Android 8.0则只回调<code>onConfigurationChanged()</code>方法。</p><p><strong>总结（不同手机系统系统可能会有略微差异）</strong></p><ol><li>不设置<code>configChanges</code>属性是不会回调<code>onConfigurationChanged()</code>方法的，且切屏的时候会回调生命周期的方法；</li><li>只有设置了<code>orientation</code>和<code>screenSize</code>才会保证不会调用生命周期的方法，且切屏的时候只会回调<code>onConfigurationChanged()</code>方法；</li><li>如果设置了<code>orientation</code>而没有设置<code>screenSize</code>，那么切屏就会调用<code>onConfigurationChanged()</code>方法，但仍然会走生命周期；</li></ol><h3 id="Activity-A启动了Activity-B，它们的生命周期的变化"><a href="#Activity-A启动了Activity-B，它们的生命周期的变化" class="headerlink" title="Activity A启动了Activity B，它们的生命周期的变化"></a>Activity A启动了Activity B，它们的生命周期的变化</h3><ol><li><p><strong>启动Activity A</strong></p><p><code>onCreate()</code>创建活动A，<code>onStart()</code>显示在屏幕上，<code>onResume()</code>处于运行状态；</p></li><li><p><strong>在Activity A中启动Activity B</strong></p><p>活动A被暂停，使用<code>onPause()</code>进入暂停状态；<code>onCreate()</code>创建活动B，<code>onStart()</code>显示活动B在屏幕上，<code>onResume()</code>让活动B进入运行状态；活动A经过<code>onStop()</code>进入停止状态；</p></li><li><p><strong>从Activity B中返回Activity A（比如按物理返回键）</strong></p><p>活动B用<code>onPause()</code>方法进入暂停状态；活动A被重启，使用<code>onRestart()</code>方法从停止状态进入活动状态，调用<code>onStart()</code>方法使活动A显示在屏幕上，<code>onResume()</code>方法进入运行状态；活动B被<code>onStop()</code>方法进入停止状态，最后使用<code>onDestroy()</code>方法销毁；</p></li><li><p><strong>继续按物理返回键</strong></p><p>活动A用<code>onPause()</code>方法暂停，然后用<code>onStop()</code>方法停止，最后用<code>onDestroy()</code>方法被销毁；</p></li></ol><h3 id="onSaveInstanceState-和onRestoreInstanceState-调用的过程和时机"><a href="#onSaveInstanceState-和onRestoreInstanceState-调用的过程和时机" class="headerlink" title="onSaveInstanceState()和onRestoreInstanceState()调用的过程和时机"></a><code>onSaveInstanceState()</code>和<code>onRestoreInstanceState()</code>调用的过程和时机</h3><ul><li><strong>调用时机</strong>：Activity的异常情况下（例如转动屏幕或者被系统回收）的情况下，会调用到<code>onSaveInstanceState</code>和<code>onRestoreInstanceState</code>。如果是单独按Home或者启动新Activity仍然会单独触发<code>onSaveInstanceState</code>调用。</li><li><strong>调用过程</strong>：在<strong>异常情况</strong>下，会在调用<code>onStop()</code>方法之前，调用<code>onSaveInstanceState</code>方法保存；而新的Activity重建时，就可以通过<code>onRestoreInstanceState</code>方法取出之前保存的数据并恢复，<code>onRestoreInstanceState</code>的调用时机在<code>onCreate()</code>之后。</li></ul><h3 id="优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态"><a href="#优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态" class="headerlink" title="优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态"></a>优先级低的Activity在内存不足被回收后怎么做可以恢复到销毁前状态</h3><h2 id="Activity四种启动模式"><a href="#Activity四种启动模式" class="headerlink" title="Activity四种启动模式"></a>Activity四种启动模式</h2><h3 id="standard标准模式"><a href="#standard标准模式" class="headerlink" title="standard标准模式"></a>standard标准模式</h3><p>是默认启动的模式，每次都会新创建一个实例对象；每次发送的Intent都会创建一个新的Activity（<code>onCreate()</code>⟶<code>onStart()</code>⟶<code>onResume()</code>），并且将其放入返回栈的栈顶。这样每次都新建一个实例的话太浪费。</p><h3 id="singleTop栈顶复用模式"><a href="#singleTop栈顶复用模式" class="headerlink" title="singleTop栈顶复用模式"></a>singleTop栈顶复用模式</h3><p>如果在返回栈顶发现了相同的实例则重用，不会新建；否则就新建并压入栈顶；同时Activity的<code>onNewIntent()</code>方法会被回调。在这个模式下，我们必须同时在<code>onCreate()</code>和<code>onNewIntent()</code>两个方法中处理好传入的Intent</p><h3 id="singleTask栈内复用模式"><a href="#singleTask栈内复用模式" class="headerlink" title="singleTask栈内复用模式"></a>singleTask栈内复用模式</h3><p>如果在整个返回栈中发现了相同的实例，就将其最上面的任务终止并移除，重用该实例，同时回调<code>onNewIntent()</code>方法；否则新建实例并压入栈；</p><h3 id="singleInstance单实例模式"><a href="#singleInstance单实例模式" class="headerlink" title="singleInstance单实例模式"></a>singleInstance单实例模式</h3><p>允许不同的应用，进程线程等共用一个实例，无论如何应用调用该实例都会重用；即持有这个Activity的Task不能再有其它Activity的实例了；</p><p>例如，如果从这个Activity中启动另外一个不同的Activity，将会自动创建一个新的Task来存放新的Activity；如果从一个已经存在许多Activity的的Task中调用启动模式是<code>singleInstance</code>的Activity，这个新的Activity同样会被放在一个新的Task中。不管怎么样，都会创建一个新的Task来存放Activity。</p><h3 id="onNewIntent-调用时机"><a href="#onNewIntent-调用时机" class="headerlink" title="onNewIntent()调用时机"></a><code>onNewIntent()</code>调用时机</h3><p>如果一个Activity的启动模式是<code>singleTop</code>、<code>singleTask</code>、<code>singleInstance</code>，在复用Activity时就会在「调用<code>onStart()</code>方法之前调用<code>onNewIntent()</code>方法」。作用就是让已经创建的Activity处理新的Intent。</p><h3 id="Activity的启动过程"><a href="#Activity的启动过程" class="headerlink" title="Activity的启动过程"></a>Activity的启动过程</h3><h1 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h1><h2 id="Fragment的生命周期"><a href="#Fragment的生命周期" class="headerlink" title="Fragment的生命周期"></a>Fragment的生命周期</h2><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/01/JOCbOU.png" alt=""></p><p><strong>具体方法介绍</strong>：</p><ol><li><code>onAttach()</code>：完成Fragment与Activity的绑定，参数中的Activity即为要绑定的Activity，可以进行赋值等操作；</li><li><code>onCreate()</code>：完成Fragment的初始化；</li><li><code>onCreateView()</code>：加载View布局，绑定布局文件；</li><li><code>onActivityCreated()</code>：与Fragment绑定的Activity已经执行完成了<code>onCreate()</code>，可以与Activity进行交互操作；</li><li><code>onStart()</code>：Fragment变为可见状态；</li><li><code>onResume()</code>：Fragment变为可交互状态；</li><li><code>onPause()</code>：Fragment变为不可交互状态（不代表是不可见）；</li><li><code>onSaveInstanceState()</code>：保存当前Fragment的状态，记录一些数据；</li><li><code>onStop()</code>：Fragment变为不可见状态；</li><li><code>onDestroyView()</code>：销毁Fragment的有关视图，但并未和Activity解绑，还可以通过<code>onCreateView()</code>重新创建视图；</li><li><code>onDestroy()</code>：销毁Fragment时调用；</li><li><code>onDetach()</code>：解除和Activity的绑定，是Fragment销毁的最后一步。</li></ol><p>添加Fragment可以分为<strong>静态添加</strong>和<strong>动态添加*</strong>两类。<strong>静态添加</strong>是指在XML中直接Fragment，缺点是添加之后不能删除。一般推荐是在代码中FragmentManager中使用一系列的<code>FragmentTransaction</code>事务操作动态控制。</p><ul><li><code>add</code></li><li><code>remove</code></li><li><code>show</code></li><li><code>hide</code></li><li><code>replace</code></li><li><code>replace</code>+<code>addToBackStack</code></li><li><code>detach</code></li></ul><h2 id="Activity与Fragment的异同"><a href="#Activity与Fragment的异同" class="headerlink" title="Activity与Fragment的异同"></a>Activity与Fragment的异同</h2><ul><li>相同点：Activity与Fragment都可以包含布局，都有自己的生命周期；</li><li>不同点：因为Fragment是依附在Activity上的，多了一些和宿主Activity相关的生命周期方法，例如<code>onAttch()</code>、<code>onActivityCreated()</code>、<code>onDetach()</code>等；Fragment的生命周期方法都是由宿主Activity而不是由操作系统调用的，Activity中的生命周期方法都是是<code>protected</code>，而Fragment的生命周期方法都是<code>public</code>，因为Activity需要调用Fragment这些方法并管理它。</li></ul><h2 id="Activity和Fragment的关系"><a href="#Activity和Fragment的关系" class="headerlink" title="Activity和Fragment的关系"></a>Activity和Fragment的关系</h2><ul><li>Fragment的出现是为了解决Android碎片化，可以作为Activity界面的组成部分，可以在Activity运行中实现动态地加入、移除和交换；</li><li>一个Activity可以同时出现多个Fragment，而一个Fragment也可以在多个Activity中使用；</li><li>Activity中的<code>FragmentManager</code>负责调用队列中Fragment的生命周期方法；</li></ul><h1 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h1><h2 id="Service的两种启动方式和生命周期"><a href="#Service的两种启动方式和生命周期" class="headerlink" title="Service的两种启动方式和生命周期"></a>Service的两种启动方式和生命周期</h2><p>Service有两种启动方式，一种是通过<code>startService()</code>来启动的，另一种是通过<code>bindService()</code>来启动的；</p><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/01/JO9lgf.png" alt=""></p><h3 id="通过startService-来启动（各自飞）"><a href="#通过startService-来启动（各自飞）" class="headerlink" title="通过startService()来启动（各自飞）"></a>通过<code>startService()</code>来启动（各自飞）</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2018053114134692.jpg" alt=""></p><p><strong>使用方法</strong>：</p><ol><li>定义一个类，并继承Service</li><li>在<code>AndroidManifest.xml</code>文件中配置此Service</li><li>使用Context的<code>startService(Intent)</code>方法来启动此Service</li><li>不使用该服务时，调用<code>stopService(Intent)</code>方法停止此Service（当使用IntentService时调用<code>stopSelf</code>方法）</li></ol><blockquote><p>如果服务已经开启，就不会重复地执行<code>onCreate()</code>方法，而是调用<code>onStart()</code>或者<code>onStartCommand()</code>方法。服务停止时就调用<code>onDestroy()</code>方法。</p></blockquote><p><strong>特点</strong>：</p><ul><li>一旦服务开启了，就与开启者没有任何关系了</li><li>开启者退出之后，服务还是可以在后台长期运行的（前提是没有调用<code>stopService(Intent)方法</code>）</li><li>开启者不能调用服务里面的方法</li></ul><h3 id="通过bindService-来启动（共存亡）"><a href="#通过bindService-来启动（共存亡）" class="headerlink" title="通过bindService()来启动（共存亡）"></a>通过<code>bindService()</code>来启动（共存亡）</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20180531142740474.jpg" alt=""></p><p><strong>使用方法</strong>：</p><ol><li>定义一个类，并继承Service</li><li>在<code>AndroidManifest.xml</code>文件中配置此Service</li><li>使用Context的<code>bindService(Intent, ServiceConnection, int)方法来启动此Service</code></li><li>不使用该服务时，调用<code>unbindService(ServiceConnection)方法停止此Service</code></li></ol><blockquote><p>绑定服务是不会调用<code>onStart()</code>或者<code>onStartCommand()</code>方法的。</p></blockquote><p><strong>特点</strong>：</p><ul><li>使用<code>onBind()</code>的方式开启服务绑定服务，如果调用者销毁，服务也会被销毁</li><li>绑定者可以调用服务内部的方法</li></ul><h3 id="如果一个Service既被startService-启动又被bindService-启动，生命周期是怎么样的（或者问如何把Service停止）"><a href="#如果一个Service既被startService-启动又被bindService-启动，生命周期是怎么样的（或者问如何把Service停止）" class="headerlink" title="如果一个Service既被startService()启动又被bindService()启动，生命周期是怎么样的（或者问如何把Service停止）"></a>如果一个Service既被<code>startService()</code>启动又被<code>bindService()</code>启动，生命周期是怎么样的（或者问如何把Service停止）</h3><ol><li><code>startService()</code>和<code>bindService()</code>可以同时启动同一Service，执行时会回调对应的<code>onStartCommand()</code>或者<code>onBind()</code>方法，但是<code>onCreate()</code>方法只会被执行一次，不会被重复执行；</li><li>在停止Service时，既需要调用<code>stopService()</code>方法，又需要调用<code>unBindService()</code>方法，没有先后顺序要求，只有两个方法都执行完毕之后，才会执行Service的<code>onDestroy()</code>方法，<code>onDestroy()</code>方法只会被执行一次（最后一个<code>stopService</code>或者<code>unBindService</code>方法会导致Service执行<code>onDestroy()</code>）。</li></ol><h3 id="Service的生命方法运行在哪个线程中"><a href="#Service的生命方法运行在哪个线程中" class="headerlink" title="Service的生命方法运行在哪个线程中"></a>Service的生命方法运行在哪个线程中</h3><p>Service默认运行在主线程中，所以其生命方法也是运行在主线程中。如果需要在Service中进行耗时的操作，那必须另起线程或者使用IntentService，否则会引起ANR。</p><h2 id="IntentService与Service的区别"><a href="#IntentService与Service的区别" class="headerlink" title="IntentService与Service的区别"></a>IntentService与Service的区别</h2><ul><li>Service默认运行在主线程中，如果需要耗时的操作，就必须开启子线程；而IntentService可用于长时间的任务，通常不会与主线程通信。如果需要通信，可以使用主线程处理程序或者广播意图。另一种使用情况是需要回调（意图触发任务）。</li><li>Service是由<code>startService()</code>方法触发，而IntentService是使用Intent触发的，产生了一个新的工作线程，并且在这个线程上调用了<code>onHandlerIntent()</code>方法。</li><li>Service和IntentService可以从任何线程，活动或其它应用程序组件中触发</li><li>Service在后台运行，但是是在应用程序的主线程运行；IntentService在单独的工程线程中运行；</li><li>Service可能会阻止应用程序的主线程；IntentService不能并行执行任务，所以所有连续的Intent都将进入工程线程的消息队列并将按顺序执行；</li><li>如果使用Service，是调用<code>stopSelf()</code>或者<code>stopService()</code>来结束它的工作；而IntentService会在处理完所有启动请求后停止服务，不必调用方法；</li></ul><p><strong>IntentService的优点</strong>：</p><ul><li>会创建独立的工作线程来处理所有的Intent请求；</li><li>会创建独立的工作线程来处理<code>onHandleIntent()</code>方法实现的代码，无需处理多线程问题；</li><li>在所有请求处理完成后，IntentService会自动停止；</li><li>为Service的<code>onBind()</code>方法提供默认实现，返回<code>null</code>；</li><li>为Service的<code>onStartCommand()</code>方法提供默认实现，将请求Intent添加到队列中；</li><li>IntentService不会阻塞UI线程；</li><li>IntentService若未执行完成上一次的任务，不会重新开启一个线程，而是等待之前的任务完成后，再执行新的任务，等任务完成后再次调用<code>stopSelf()</code>方法</li></ul><h2 id="如何保证Service不被杀死（如何提高Service的优先级）"><a href="#如何保证Service不被杀死（如何提高Service的优先级）" class="headerlink" title="如何保证Service不被杀死（如何提高Service的优先级）"></a>如何保证Service不被杀死（如何提高Service的优先级）</h2><ol><li><strong>在<code>onStartCommand()</code>方法中返回<code>START_STICKY</code></strong>。这种情况下，当内存不足需要回收该Service时，系统会将该Service标记为<code>started</code>状态，并在合适的时机重新调用<code>onStartCommand()</code>方法重新启动该Service，这种情况下不会保留<code>onStartCommand()</code>方法中的<code>intent</code>对象（<code>intent</code>对象为<code>null</code>）。如果需要在重启Service时保留<code>onStartCommand()</code>中的<code>intent</code>对象，就可以返回<code>START_REDELIVER_INTENT</code>，此时则会保留<code>intent</code>最近一次的值，并传入到<code>onStartCommand()</code>方法中。</li><li><strong>提高该Service在所有Service中的优先级</strong>。可以在<code>AndroidManifest.xml</code>中为每一个Service都配置一个优先级<code>android:priority</code>，数值越大，优先级就越高。</li><li><strong>将Service设置为前台Service</strong>。因为Service是默认在后台运行的，但调用<code>Service.startForeground()</code>就可以将该Service设置为前台Service，从而提高Service的优先级。当系统的进程空间紧张时，会按照进程优先级依次回收，Android系统的进程优先级如下：<ol><li>前台进程（foreground_app）</li><li>可见进程（visible_app）</li><li>次要服务进程（secondary_app）</li><li>后台进程（hidden_app）</li><li>内容提供者进程（content_provider）</li><li>空进程（empty_app）</li></ol></li><li><strong>在Service的<code>onDestroy()</code>方法里发送一个自定义广播</strong>，在广播的<code>onReceiver()</code>里重新启动该Service。</li><li><strong>监听开机广播，开机时自动启动Service</strong>。</li></ol><h2 id="Service与Activity如何实现通信"><a href="#Service与Activity如何实现通信" class="headerlink" title="Service与Activity如何实现通信"></a>Service与Activity如何实现通信</h2><p>可以通过<code>bindService()</code>的方式。先在Activity里实现一个ServiceConnection接口，并将该接口传递给<code>bindService()</code>方法，在ServiceConnection接口的<code>onServiceConnected()</code>方法里执行相关操作。</p><h2 id="常用的系统Service"><a href="#常用的系统Service" class="headerlink" title="常用的系统Service"></a>常用的系统Service</h2><div class="table-container"><table><thead><tr><th style="text-align:center">传入的Name</th><th style="text-align:center">返回的对象</th><th style="text-align:center">说明</th></tr></thead><tbody><tr><td style="text-align:center">WINDOW_SERVICE</td><td style="text-align:center">WindowManager</td><td style="text-align:center">管理打开的窗口程序</td></tr><tr><td style="text-align:center">LAYOUT_INFLATER_SERVICE</td><td style="text-align:center">LayoutInflater</td><td style="text-align:center">取得XML里定义的View</td></tr><tr><td style="text-align:center">ACTIVITY_SERVICE</td><td style="text-align:center">ActivityManager</td><td style="text-align:center">管理应用程序的系统状态</td></tr><tr><td style="text-align:center">POWER_SERVICE</td><td style="text-align:center">PowerManager</td><td style="text-align:center">电源服务</td></tr><tr><td style="text-align:center">ALARM_SERVICE</td><td style="text-align:center">AlarmManager</td><td style="text-align:center">闹钟服务</td></tr><tr><td style="text-align:center">NOTIFICATION_SERVICE</td><td style="text-align:center">NotificationManager</td><td style="text-align:center">状态栏服务</td></tr><tr><td style="text-align:center">KEYGUARD_SERVICE</td><td style="text-align:center">KeyguardManager</td><td style="text-align:center">键盘锁服务</td></tr></tbody></table></div><h1 id="BroadcastReceiver"><a href="#BroadcastReceiver" class="headerlink" title="BroadcastReceiver"></a>BroadcastReceiver</h1><blockquote><p>广播是一种广泛运用的在应用程序之间传输信息的机制，主要用来监听系统或者应用发出的广播信息，然后根据广播信息作为相应的逻辑处理，也可以用来传输少量、频率低的数据。例如，在实现开机启动服务和网络状态改变、电量变化、短信和来电时通过接受系统的广播让应用程序作出相应的处理。</p></blockquote><h2 id="动态注册和静态注册的区别"><a href="#动态注册和静态注册的区别" class="headerlink" title="动态注册和静态注册的区别"></a>动态注册和静态注册的区别</h2><ul><li><strong>静态注册</strong>：在<code>AndroidManifest.xml</code>中进行注册。常驻系统，不受组件生命周期的影响。即便应用退出了，广播还是可以被接收、耗电、占内存等；</li><li><strong>动态注册</strong>：在代码中使用<code>IntentFilter</code>进行注册。非常驻系统，跟随组件的生命变化，组件结束了广播就结束了。在组件结束前，需要先移除广播，否则容易造成内存泄漏。动态注册的广播永远要快于静态注册的广播，不论静态注册的优先级多高。</li></ul><h2 id="广播的各种形式"><a href="#广播的各种形式" class="headerlink" title="广播的各种形式"></a>广播的各种形式</h2><ul><li><strong>普通广播</strong>：使用<code>sendBroadcast()</code>发送，是最常用的广播。一种<strong>完全异步</strong>执行的广播，在广播发出之后，所有的广播接收器几乎都会在同一时刻接受到这条广播信息，因此它们接受的先后是随机的；</li><li><strong>有序广播</strong>：使用<code>sendOrderedBroadcast()</code>，发送出去的广播会被接收者按照顺序接收，而广播接收者按照优先级Priority属性值从大到小排序（优先级相同，则动态注册的广播优先）。是一种<strong>同步执行</strong>的广播，在广播发出之后，同一时刻就只有一个广播接收器能够收到这条广播信息；</li><li><strong>本地广播</strong>：发出的广播只能够在应用程序的<strong>内部</strong>进行传递，并且广播接收器也只能本应用程序发出的广播；</li><li><strong>粘性广播</strong>：这种类型的广播会一直逗留，当有匹配该广播的接收器被注册后，该接收器就会收到这条广播。</li></ul><h2 id="顺序"><a href="#顺序" class="headerlink" title="顺序"></a>顺序</h2><blockquote><p>我们知道动态注册的广播的优先级始终高于静态注册的广播，而静态注册的广播的优先级主要根据Priority属性值的大小排序，那么如果都是静态注册的广播，优先级大小又一样，那接收的顺序是怎么样的呢？</p></blockquote><p>在都是静态注册的情况下，最高安装的程序优先级别最高 | 按照<strong>字符</strong>排列顺序决定谁先接收到广播信息。</p><p>所以，有序广播的优先级遵循如下的规则：</p><ol><li>动态注册优先级级别最高，其次是静态注册</li><li>在动态注册中，最早动态注册的优先级别最高</li><li>在静态注册中，最早安装的程序，静态注册的优先级别最高</li><li>如果都是静态注册，按照<strong>字符</strong>排列顺序决定谁先收到广播信息</li><li><code>adb install</code>安装的比<code>adb push</code>到其它目录的应用程序优先级更高</li></ol><h1 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h1><blockquote><p>ContentProvider（内容提供者）是Android的四大组件之一，管理Android以结构化的方式存放的数据，以相对安全的方式封装数据（表）并且提供简易的处理机制和统一的访问接口给<strong>其它应用程序</strong>调用。不同的应用程序之间进行数据共享，它还可以选择只对哪一部分数据进行共享，从而保证程序中的隐私数据不会有泄漏风险。</p></blockquote><ul><li>ContentProvider：管理数据，提供数据的增删改查操作，数据源可以是数据库、文件、XML、网络等，ContentProvider为这些数据的访问提供了统一的接口，可以用来做<strong>进程间数据共享</strong>。</li><li>ContentResolver：ContentResolver可以不同URI操作不同的ContentProvider中的数据，外部进程可以通过ContentResolver与ContentProvider进行交互。</li><li>ContentObserver：观察ContentProvider中的数据变化，并将变化通知给外界。</li></ul><h1 id="网络框架"><a href="#网络框架" class="headerlink" title="网络框架"></a>网络框架</h1><h2 id="OkHttp"><a href="#OkHttp" class="headerlink" title="OkHttp"></a>OkHttp</h2><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20191120233736397.png" alt=""></p><ol><li>通过OkHttpClient创建一个Call，并发起同步或者异步的请求；</li><li>OkHttp会通过Dispatcher线程池会对所有的RealCall（即具体实现类）进行统一管理，并通过<code>execute()</code>以及<code>enqueue()</code>方法对同步或者异步请求进行解决；</li><li><code>execute()</code>以及<code>enqueue()</code>两个方法，会最终调用RealCall的<code>getResponseWithInterceptorChain()</code>方法，从拦截器链中获取返回结果；</li><li>拦截器链中，包括重定向拦截器、桥接拦截器、缓存拦截器、连接拦截器、网络拦截器等依次解决，最后将结果返回给调用方。</li></ol><hr><p>OkHttp的底层是通过Java的Socket发送HTTP请求与接收响应的(HTTP就是基于TCP协议的)，但是OkHttp实现了连接池的概念，即对于同一主机的多个请求，其实可以公用一个Socket连接，而不是每次发送完HTTP请求就关闭底层的Socket，这样就实现了连接池的概念。而OkHttp对Socket的读写操作使用的Okio库进行了一层封装。</p><h2 id="Retrofit"><a href="#Retrofit" class="headerlink" title="Retrofit"></a>Retrofit</h2><h3 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h3><p>Retrofit通过接口以及注解的方式来描述网络请求，并用动态代理的方式生成网络请求的request，然后通过client调用底层的网络框架OkHttp来发起网络请求，将返回的response通过convertrFactory转换成相应的数据model，最后通过callAdapter转化成其它的数据方式。</p><h3 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h3><p>静态代理类由程序员创建或工具生成代理类的源码，再编译代理类，所谓静态就是<strong>在程序运行前就已经存在代理类的字节码文件</strong>，代理类和委托类的关系在<strong>运行前</strong>就确定了。</p><p>动态代理类是程序运行期间由JVM根据反射等机制动态的生成，所以不存在代理类的字节码文件。代理类和委托类的关系是在程序运行时确定的。</p><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理业务类只需要关注业务逻辑本身，保证了业务类的重用性。代理对象的一个接口只服务于一种类型的对象，如果要代理的方法很多，需要为每一种方法都进行代理，静态代理在程序规模稍大时就无法胜任。如果接口增加一个方法，除了所有实现类需要实现这个方法外，所有代理类也需要实现此方法，增加了代码维护的复杂度。</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p>动态代理与静态代理相比较，最大的好处是接口中声明的所有方法都被转移到调用处理器一个集中的方法中处理（InvocationHandler invoke）。这样，在接口方法数量比较多的时候，可以进行灵活处理，而不需要像静态代理那样每一个方法进行中转。而且动态代理的应用使类职责更加单一，复用性更强。</p><h2 id="Volley"><a href="#Volley" class="headerlink" title="Volley"></a>Volley</h2><h1 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h1><h2 id="Android中提供哪些数据持久存储的方法"><a href="#Android中提供哪些数据持久存储的方法" class="headerlink" title="Android中提供哪些数据持久存储的方法"></a>Android中提供哪些数据持久存储的方法</h2><ul><li>文件存储</li><li>SharedPreference存储</li><li>数据库存储</li><li>ContentProvider存储</li><li>网络存储</li></ul><h3 id="文件存储"><a href="#文件存储" class="headerlink" title="文件存储"></a>文件存储</h3><p>文件存储是通过文件的方式将数据不做任何处理的存储进文件系统中，适合一些简单的文本数据或者二进制数据。主要是通过文件IO流的存储提供了<code>FileInputStream()</code>和<code>FileOutputStream()</code>方法来存储和提取文件中的数据。</p><h3 id="SharedPreferences存储"><a href="#SharedPreferences存储" class="headerlink" title="SharedPreferences存储"></a>SharedPreferences存储</h3><p>SharedPreferences的存储数据和读取数据十分简单，提供了<code>get</code>和<code>put</code>方法。</p><h3 id="数据库存储"><a href="#数据库存储" class="headerlink" title="数据库存储"></a>数据库存储</h3><p>Android自身就支持SQLite这种轻量级的数据库。</p><h3 id="ContentProvider存储"><a href="#ContentProvider存储" class="headerlink" title="ContentProvider存储"></a>ContentProvider存储</h3><p>之所以不选择与数据库直接交互，而选择通过ContentProvider进行交互，是因为Android的安全性问题决定的。它的数据库是私有的，所以外部数据无法直接访问这个数据库。而通过ContentProvider，将数据库的内容提供给外部应用，同时将外部应用的数据存储到数据库中。如果外部应用想要操作数据库暴露的数据时，需要ContentResolver来操作ContentProvider暴露的数据。一旦某个应用通过ContentProvider暴露了数据，那么不管该应用程序是否启动，其他的应用都能通过该接口操作暴露的数据，对数据进行增删查改的操作。</p><h3 id="网络存储"><a href="#网络存储" class="headerlink" title="网络存储"></a>网络存储</h3><p> Android提供了通过网络来实现数据的存储和获取的方法，即将数据存储在网络（服务器）中。</p><h2 id="SharedPreferences适用情形？使用中需要注意什么？"><a href="#SharedPreferences适用情形？使用中需要注意什么？" class="headerlink" title="SharedPreferences适用情形？使用中需要注意什么？"></a>SharedPreferences适用情形？使用中需要注意什么？</h2><p>SharedPreferences是Android平台上一个轻量级的存储辅助类，特别适合保存软件的配置参数。它提供了<code>string</code>，<code>set</code>，<code>int</code>，<code>long</code>，<code>float</code>，<code>boolean</code>六种数据类型，它是以key-value的形式保存在 <code>data/data/&lt;packagename&gt;/shared_prefs</code> 下的xml文件中。</p><p>由于系统对SharedPreferences的读/写有一定的缓存策略，即在内存中有一份该文件的缓存，因此在多进程模式下，其读/写会变得不可靠，甚至丢失数据。</p><p><strong>注意</strong>：</p><ul><li>SharedPreferences是以单例形式存在的</li><li>创建sp单例是将文件的内容全部都载入内存中</li><li>单进程下读取安全</li><li>用<code>apply()</code>异步提交的方法代替<code>commit</code></li><li>因为sp的数据常驻内存，所以不适合存储过大的数据（例如接口数据，达到了MB的级别）</li></ul><h2 id="SQLite的事务处理？是如何做的？"><a href="#SQLite的事务处理？是如何做的？" class="headerlink" title="SQLite的事务处理？是如何做的？"></a>SQLite的事务处理？是如何做的？</h2><p>SQLite在做CRUD操作时都默认开启了事务，然后把SQL语句翻译成对应的SQLiteStatement并调用其相应的CRUD方法，此时整个操作还是在rollback journal这个临时文件上进行，只有操作顺利完成才会更新.db数据库，否则会被回滚。</p><h1 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h1><h2 id="图片框架的三级缓存机制"><a href="#图片框架的三级缓存机制" class="headerlink" title="图片框架的三级缓存机制"></a>图片框架的三级缓存机制</h2><ol><li><strong>内存缓存</strong>（优先加载，速度最快）：首次加载的时候通过网络加载，获取图片，然后保存到内存中和本地中；之后运行时，优先访问内存中的图片缓存；</li><li><strong>本地缓存</strong>（次优先加载，速度快）：如果内存中没有，则访问本地的图片；</li><li><strong>网络缓存</strong>（最后加载，速度慢，浪费流量）：如果本地还没有，就有可能是第一次访问，所以进行网络请求；</li></ol><p><strong>三级缓存的原理</strong>：内存作为一级缓存，本地作为二级缓存，网络加载为最后。其中，内存使用LruCache，其内部通过<code>LinkedHashMap</code>来持有外界缓存对象的强引用；对于本地缓存，使用DiskLruCache。而加载图片的时候，首先使用LRU方式进行寻找，找不到指定内容，就按照三级缓存的策略，再进行本地搜索，最后进行网络加载。</p><h2 id="LRU算法的原理"><a href="#LRU算法的原理" class="headerlink" title="LRU算法的原理"></a>LRU算法的原理</h2><p>LRU（Least Recently Used）算法是近期最少使用算法，其核心思想是当缓存满时，会优先淘汰那些近期最少使用的缓存对象。主要是通过两种方式：</p><ul><li>LruCache（<strong>内存缓存</strong>）：LruCache类是一个<strong>线程安全</strong>的<strong>泛型类</strong>：内部采用一个<code>LinkedHashMap</code>以强引用的方式存储外界的缓存对象，并提高<code>get</code>和<code>put</code>方法来完成缓存的获取和添加操作，当缓存满了就会移除较早使用的缓存对象，再添加新的</li><li>DiskLruCache（<strong>磁盘缓存</strong>）：通过将缓存对象写入文件系统从而实现缓存效果。DiskLruCache的缓存添加的操作是通过Editor完成的，Editor表示一个缓存对象的编辑对象。</li></ul><h2 id="Android中缓存更新策略"><a href="#Android中缓存更新策略" class="headerlink" title="Android中缓存更新策略"></a>Android中缓存更新策略</h2><h1 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h1><p>AsyncTask、IntentService、HandlerThread的表现形式都和传统的线程有区别，但本质上仍然是传统的线程。对于AsyncTask来说，底层用到了线程池，对于IntentService和HandlerThread来说，底层则是直接使用到了线程。</p><ul><li>AsyncTask底层封装了线程池和Handler，主要是为了方便开发者在子线程中更新UI。</li><li>HandlerThread是一种具有消息循环的线程，在它的内部可以使用Handler。</li><li>IntentService是一个服务，系统对其进行了封装使其可以更方便地执行后台任务，内部采用HandlerThread来执行任务，当任务执行完毕后会自动退出。</li></ul><h2 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h2><p>AsyncTask在具体的使用过程中也有条件限制：</p><ul><li>AsyncTask的类必须在主线程中加载，即第一次访问AsyncTask必须发生在主线程；</li><li>AsyncTask的对象必须在主线程中创建；</li><li>execute方法必须在UI线程调用；</li><li>一个AsyncTask对象只能执行一次，即只能调用一次execute方法，否则会异常；</li></ul><h3 id="原理-2"><a href="#原理-2" class="headerlink" title="原理"></a>原理</h3><p>AsyncTask中有两个线程池（SerialExecutor和THREAD_POOL_EXECUTOR）和一个Handler（IntentHandler），其中线程池SerialExecutor用于任务的排队，而线程池THREAD_POOL_EXECUTOR用于真正地执行任务。IntentHandler用于将执行环境从线程池切换到主线程。</p><h2 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h2><p>IntentService是一种特殊的Service，它继承了Service并且是一个抽象类，所以必须构建它的子类才可以使用IntentService。IntentService可用于执行后台耗时的任务，当任务执行完毕后会自动停止。它的优先级比很多单纯的线程要高很多，所以IntentService比较适合执行一些高优先级的后台任务。</p><p>IntentService底层是封装了HandlerThread和Handler。</p><h2 id="线程池的好处、原理、类型"><a href="#线程池的好处、原理、类型" class="headerlink" title="线程池的好处、原理、类型"></a>线程池的好处、原理、类型</h2><h3 id="好处"><a href="#好处" class="headerlink" title="好处"></a>好处</h3><p>在编程中经常会使用线程来异步处理任务，但是每个线程的创建和销毁都需要一定的开销。如果每次执行一个任务都需要开启一个新的线程去执行，则这些线程的创建和销毁将消耗大量的资源；并且线程都是“各自为政”的，很难对其进行控制，这时候就需要线程池来对线程进行管理。</p><ul><li>重用线程池中的线程，避免线程的创建和销毁带来的性能消耗；</li><li>有效控制线程池的最大并发数，避免大量的线程之间因互相抢占系统资源而导致阻塞现象；</li><li>进行线程管理，提供定时/循环间隔执行等功能</li></ul><h3 id="原理-3"><a href="#原理-3" class="headerlink" title="原理"></a>原理</h3><p>ThreadPoolExecutor是线程池的真正实现。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize, <span class="keyword">int</span> maximumPoolSize, <span class="keyword">long</span> keepAliveTime, TimeUnit unit, BlockingQueue&lt;Runnable&gt; workQueue, ThreadFactory threadFactory)</span></span></span><br></pre></td></tr></table></figure><ul><li><strong>corePoolSize</strong>核心线程数：一般会在线程中一直存活</li><li><strong>maximumPoolSize</strong>最大线程数：当活动线程数达到这个数值后，后续的任务将会被阻塞</li><li><strong>keepAliveTime</strong>非核心线程超时时间：超过这个时长，闲置的非核心线程就会被回收</li><li><strong>unit</strong>：用于指定keepAliveTime参数的时间单位</li><li><strong>workQueue</strong>任务队列：通过线程池的execute()方法提交的Runnable对象会存储在这个参数中。</li><li><strong>threadFactory</strong>：线程工厂，可创建新线程</li><li><strong>handler</strong>：在线程池无法执行新任务时进行调度</li></ul><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li><strong>FixThreadPool</strong>：线程数量固定的线程池，所有线程都是核心线程，当线程空闲时不会被回收；能快速响应外界请求。</li><li><strong>CachedThreadPool</strong>：线程数量不定的线程池（最大线程数为Integer.MAX_VALUE），只有非核心线程，空闲线程有超时机制，超时回收；适合于执行大量的耗时较少的任务</li><li><strong>ScheduledThreadPool</strong>：核心线程数量固定，非核心线程数量不定；可进行定时任务和固定周期的任务。</li><li><strong>SingleThreadExecutor</strong>：只有一个核心线程，可确保所有的任务都在同一个线程中按顺序执行；好处是无需处理线程同步问题。</li></ul><h2 id="ThreadPoolExecutor的工作策略"><a href="#ThreadPoolExecutor的工作策略" class="headerlink" title="ThreadPoolExecutor的工作策略"></a>ThreadPoolExecutor的工作策略</h2><h1 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h1><p>Android应用程序被创建的时候都会创建一个UI主线程，但有时会有一些比较耗时的操作，为了防止阻塞UI主线程，我们会将耗时的操作放到子线程中进行处理，处理完之后操作UI，但是Android不允许子线程操作UI，因为违背了Android单线程模型的原则（即Android UI操作并不是线程安全的并且这些操作必须在UI线程中执行）。</p><p>消息传递机制主要是为了解决Android应用的多线程问题。Handler是一种异步回调机制，它可以在完成一个耗时任务后做出相应的通知。</p><ul><li><strong>主线程（UI线程）</strong>：当程序第一次启动时，Android会同时启动一个主线程，主要负责处理与UI系相关的事件；</li><li><strong>Message</strong>：Handler用来接收和处理的消息对象（Bean对象），作用是通信时相关信息的存放和传递；</li><li><strong>ThreadLocal</strong>：是线程内部的存储类，通过它可以实现在每个线程中存储自己的私有数据。即数据存储以后，只能在指定的线程中获取这个存储的对象，而其它线程则不能获取到当前线程存储的这个对象。作用简要来说就是负责存储和获取本线程的Looper；</li><li><strong>Message Queue</strong>：采用单链表的数据结构来存储消息列表，用来存放通过Handler发送过来的Message，按照先进先出的方式执行；</li><li><strong>Handler</strong>：就是Message的主要处理者，负责发送Message到消息队列和处理Looper分派过来的Message；</li><li><strong>Looper</strong>：扮演Message Queue和Handler之间的一个桥梁的角色。它循环取出Message Queue中的Message，将取出的Message交付给相应的Handler；</li></ul><p><strong>调用流程</strong>：</p><ol><li>首先调用<code>Looper.prepare()</code>方法，会创建一个Looper实例，该实例包含一个MessageQueue，并将该实例保存在当前线程中Threadlocal</li><li>调用<code>Looper.loop()</code>开始消息循环，不断地向MessageQueue中读取消息，并调用<code>msg.target.dispatchMessage(msg)</code>来处理消息</li><li>构建Handler的时候，会先获取到当前Handler所在线程的Looper并得到其中的MessageQueue</li><li>使用Handler发送消息的时候，会将一个Message到保存当前线程Looper中的MessageQueue</li><li>当<code>Looper.loop()</code>获取到消息的时候，调用<code>msg.target.dispatchMessage(msg)</code>来处理消息,其实<code>Message.target = handler</code>也就是调用Handler的dispatchMessage来处理</li><li>Handler的dispatchMessage最终回去调用handlerMessage方法。到这里就知道，其实Handler的handler在哪条线程执行，取决于构建Handler时所使用的是哪条线程保存的Looper，因为handlerMessage其实是Looper去调用的。</li></ol><h2 id="Handler消息传递机制工作原理"><a href="#Handler消息传递机制工作原理" class="headerlink" title="Handler消息传递机制工作原理"></a>Handler消息传递机制工作原理</h2><p>首先需要在主线程当中创建一个Handler对象，并重写<code>handleMessage()</code>方法。然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler将这条消息发送出去。之后这条消息会被添加到MessageQueue的队列中等待被处理。<code>Looper.prepare()</code>中会先判断线程是否有Looper实例，没有就创建一个Looper实例，然后加入本线程的ThreadLocal中。而Looper则会一直尝试从MessageQueue中使用<code>loop()</code>方法取出待处理消息，最后分发回Handler的<code>handleMessage()</code>方法中。由于Handler是在主线程中创建的，所以此时handleMessage()方法中的代码也会在主线程中运行，于是就可进行UI操作了。一条Message经过这样一个流程的辗转调用后，也就从子线程进入到了主线程，从不能更新UI变成了可以更新UI，整个异步消息处理的核心思想就是如此。<br>「Handler消息机制中的主要功能都由 MessageQueue 和 Looper 去实现了，Handler 主要用于往队列里插入 Message 和 执行 Looper 取出的 Message 两个过程。」</p><p>Android消息机制中引入了消息池。Handler创建消息时首先查询消息池中是否有消息存在，如果有直接从消息池中取得，如果没有则重新初始化一个消息实例。使用消息池的好处是：消息不被使用时，并不作为垃圾回收，而是放入消息池，可供下次Handler创建消息时使用。消息池提高了消息对象的复用，减少系统垃圾回收的次数。</p><h2 id="一个Thread可以有几个Looper？几个Handler？"><a href="#一个Thread可以有几个Looper？几个Handler？" class="headerlink" title="一个Thread可以有几个Looper？几个Handler？"></a>一个Thread可以有几个Looper？几个Handler？</h2><p>由于使用了ThreadLocal机制，所以注定了一个线程只能有一个Looper，但Handler可以new无数个，它们使用的消息队列都是同一个，也就是同一个Looper。</p><p>在主线程可以直接使用handler，是因为主线程已经默认帮我们初始化了Looper，调用了<code>Looper.prepare()</code>和<code>loop()</code>方法，我们可以在主线程定义多个handler都不用自己生成或绑定Looper，所以一个线程只有一个Looper。</p><h2 id="如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？"><a href="#如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？" class="headerlink" title="如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？"></a>如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？</h2><p>我们知道Thread是不具备消息循环的，而Looper恰恰弥补了这点，通过<code>Looper.prepare()</code>方法可以将一个Thread线程转换成Looper线程。Looper类管理线程的消息队列和消息循环，具体来说是为一个线程开启一个消息循环，Looper对象通过MessageQueue来存放消息和事件。一个线程只能有一个Looper，对应一个MessageQueue。而一个Looper对象可以对应多个线程，比如主线程的mainLooper，供主线程和所属子线程共同使用。</p><h2 id="为什么在子线程中创建Handler会抛出异常"><a href="#为什么在子线程中创建Handler会抛出异常" class="headerlink" title="为什么在子线程中创建Handler会抛出异常"></a>为什么在子线程中创建Handler会抛出异常</h2><p>因为这样创建的话，Handler的源码里的mLooper会为null，所以抛出异常。即线程中的mLooper还未被创建，所以<code>Looper.myLooper()</code>中的<code>sThreadLocal.get()</code>就会返回null值。</p><p>MessageQueue是存在于Looper中的，如果没有Looper就没有MessageQueue，所以创建Handler时，Looper不能为空。Looper对象是通过<code>Looper.prepare()</code>方法创建的。</p><h2 id="主线程的Looper是轮询死循环为何没有阻塞主线程"><a href="#主线程的Looper是轮询死循环为何没有阻塞主线程" class="headerlink" title="主线程的Looper是轮询死循环为何没有阻塞主线程"></a>主线程的Looper是轮询死循环为何没有阻塞主线程</h2><p>为什么主线程中的<code>Looper.loop()</code>方法一直在无限循环地检测消息队列中是否有新的消息，却不会造成ANR？</p><p>因为Looper的作用是持有一个Message Queue，这个消息队列中存放着外部来的消息。当有消息过来的时候，Looper就会按顺序把消息一个个取出来进行处理。所以，「只有没有输入事件，此时Message Queue是空的，<strong>Looper进行空闲状态，线程才会进入阻塞</strong>，释放CPU，等待输入事件的唤醒」。</p><h2 id="使用Handler的postDelay-后消息队列会发生什么变化"><a href="#使用Handler的postDelay-后消息队列会发生什么变化" class="headerlink" title="使用Handler的postDelay()后消息队列会发生什么变化"></a>使用Handler的<code>postDelay()</code>后消息队列会发生什么变化</h2><p>在<code>postDelay()</code>这个方法内，如果头部的Message有延迟并且延迟时间内没收到，就会计算时间。在循环开始的时候判断如果这个Message有延迟，那么就会调用某个方法进行阻塞。这个方法的作用相当于<code>Object.wait()</code>。</p><p><code>postDelay()</code>的Message并不是先等待一定时间再放入到MessageQueue中，而是直接进入并阻塞当前线程，然后将其delay的时间和队头的进行比较，按照触发时间进行排序，如果触发时间更近则放入队头，保证队头的时间最小、队尾的时间最大。此时，如果队头的Message正是被delay的，则将当前线程堵塞一段时间，直到等待足够时间再唤醒执行该Message，否则唤醒后直接执行。</p><h2 id="Message可以如何创建？哪种效果更好，为什么？"><a href="#Message可以如何创建？哪种效果更好，为什么？" class="headerlink" title="Message可以如何创建？哪种效果更好，为什么？"></a>Message可以如何创建？哪种效果更好，为什么？</h2><p>创建Message对象的几种方式：</p><ul><li><code>Message msg = new Message();</code></li><li><code>Message msg = Message.obtain();</code></li><li><code>Message msg = handler.obtainMessage();</code></li></ul><p>第一个就最普通的new一个新的Message对象，而后两个是从整个Message池中返回一个新的Message实例，能够有效地避免重复的Message创建对象，因此更鼓励后两种方式。</p><h2 id="runOnUiThread如何实现子线程更新UI"><a href="#runOnUiThread如何实现子线程更新UI" class="headerlink" title="runOnUiThread如何实现子线程更新UI"></a>runOnUiThread如何实现子线程更新UI</h2><p>在<code>runOnUiThread</code>程序中，会首先判断当前线程是否是UI线程，如果是就直接运行；如果不是则post，本质上还是使用Handler机制来处理线程与UI通信。Handler的handlerMessage()方法的执行是在主线程中。</p><h2 id="ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作"><a href="#ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作" class="headerlink" title="ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作?"></a>ThreadLocal有什么作用？如何避免UI线程尽量只做跟UI相关的工作?</h2><ul><li>线程本地存储的功能</li></ul><p>ThreadLocal类可实现线程本地存储的功能，<strong>把共享数据的可见范围限制在同一个线程之内</strong>，无须同步就能保证线程之间不出现数据争用的问题，这里可理解为ThreadLocal帮助Handler找到本线程的Looper。</p><ul><li>怎么存储呢？底层数据结构是什么</li></ul><p>每个线程的Thread对象中都有一个ThreadLocalMap对象，它存储了一组以<code>ThreadLocal.threadLocalHashCode为key</code>、以本地线程变量为value的键值对，而ThreadLocal对象就是当前线程的ThreadLocalMap的访问入口，也就包含了一个独一无二的threadLocalHashCode值，通过这个值就可以在线程键值值对中找回对应的本地线程变量。</p><ul><li>如何避免UI线程尽量只做跟UI相关的工作</li></ul><p>耗时的操作(比如数据库操作，I/O,连接网络或者别的有可能阻塞UI线程的操作)把它放在单独的线程处理尽量用Handler来处理UIthread和别的thread之间的交互。使用Thread或者HandlerThread时，调用<code>Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)</code>设置优先级，否则仍然会降低程序响应，因为默认Thread的优先级和主线程相同。使用Handler处理工作线程结果，而不是使用<code>Thread.wait()</code>或者<code>Thread.sleep()</code>来阻塞主线程。</p><h1 id="AsyncTask-1"><a href="#AsyncTask-1" class="headerlink" title="AsyncTask"></a>AsyncTask</h1><p>AsyncTask，是Android提供的轻量级的异步类，可以直接继承AsyncTask，在类中实现异步操作，并提供接口反馈当前异步执行的程度（可以通过接口实现UI进度更新），最后反馈执行的结果给UI主线程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">AsyncTask</span>&lt;<span class="title">Params</span>, <span class="title">Progress</span>, <span class="title">Result</span>&gt; </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AsyncTask中有4个核心方法，如下所示：</p><ul><li><code>onPreExecute()</code>：在主线程中执行，一般在任务执行前做准备工作，比如对UI做一些标记；</li><li><code>doInBackground(Params...params)</code>：在线程池中运行，用来执行较为耗时的操作；</li><li><code>onProgressUpdate(Progress...values)</code>：在主线程中运行，将进度更新到UI组件上；</li><li><code>onPostExecute(Result result)</code>：在主线层中执行。</li></ul><p>AsyncTask用到了线程，在线程池中运行线程，并且用到了阻塞队列。</p><h2 id="AsyncTask相比Handler有什么优点和缺点"><a href="#AsyncTask相比Handler有什么优点和缺点" class="headerlink" title="AsyncTask相比Handler有什么优点和缺点"></a>AsyncTask相比Handler有什么优点和缺点</h2><p><strong>优点</strong>：</p><p>简单、快捷，过程可控</p><p><strong>缺点</strong>：</p><p>在使用多个异步操作和需要改变UI时，会相对变得复杂。</p><h2 id="使用AsyncTask需要注意什么"><a href="#使用AsyncTask需要注意什么" class="headerlink" title="使用AsyncTask需要注意什么"></a>使用AsyncTask需要注意什么</h2><h2 id="AsyncTask中使用的线程池大小"><a href="#AsyncTask中使用的线程池大小" class="headerlink" title="AsyncTask中使用的线程池大小"></a>AsyncTask中使用的线程池大小</h2><p>在AsyncTask内部实现有<strong>两个</strong>线程池：</p><p>SerialExecutor：用于任务的排队，默认是串行的线程池，在3.0以前核心线程数为5、线程池大小为128，而3.0以后变为同一时间只能处理一个任务；<br>THREAD_POOL_EXECUTOR：用于真正执行任务。</p><h2 id="HandlerThread有什么特点"><a href="#HandlerThread有什么特点" class="headerlink" title="HandlerThread有什么特点"></a>HandlerThread有什么特点</h2><p>HandlerThread是一个线程类，它继承自Thread。与普通Thread不同，HandlerThread具有消息循环的效果，这是因为它内部HandlerThread.run()方法中有Looper，能通过Looper.prepare()来创建消息队列，并通过Looper.loop()来开启消息循环。</p><ul><li>HandlerThread本质上是一个线程类，它继承了Thread；</li><li>HandlerThread有自己的内部Looper对象，可以进行looper循环；</li><li>通过获取HandlerThread的looper对象传递给Handler对象，可以在handleMessage方法中执行异步任务；</li><li>创建HandlerThread后必须先调用<code>HandlerThread.start()</code>方法，Thread会先调用<code>run()</code>方法，创建Looper对象。</li></ul><h2 id="HandlerThread常规使用步骤"><a href="#HandlerThread常规使用步骤" class="headerlink" title="HandlerThread常规使用步骤"></a>HandlerThread常规使用步骤</h2><ol><li><p>创建实例对象</p><p> <code>HandlerThread handlerThread = new HandlerThread(&quot;downloadImage&quot;);</code></p><p> 传入参数的作用主要是标记当前线程的名字，可以任意字符串。</p></li><li><p>启动HandlerThread线程</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 必须先开启线程</span></span><br><span class="line">handlerThread.start();</span><br></pre></td></tr></table></figure><p> 到此，我们创建完HandlerThread并启动了线程。那么我们怎么将一个耗时的异步任务投放到HandlerThread线程中去执行呢？</p></li><li><p>构建循环消息处理机制</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该callback运行于子线程</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChildCallback</span> <span class="keyword">implements</span> <span class="title">Handler</span>.<span class="title">Callback</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">handleMessage</span><span class="params">(Message msg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 在子线程中进行相应的网络请求</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 通知主线程去更新UI</span></span><br><span class="line">        mUIHandler.sendMessage(msg1);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>构建异步handler</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 子线程Handler</span></span><br><span class="line">Handler childHandler = <span class="keyword">new</span> Handler(handlerThread.getLooper(), <span class="keyword">new</span> ChildCallback());</span><br></pre></td></tr></table></figure></li></ol><p>第3步和第4步是构建一个可以用于异步操作的handler，并将前面创建的HandlerThread的Looper对象以及Callback接口类作为参数传递给当前的handler，这样当前的异步handler就拥有了HandlerThread的Looper对象，由于HandlerThread本身是异步线程，因此Looper也与异步线程绑定，从而handlerMessage方法也就可以异步处理耗时任务了，这样我们的Looper+Handler+MessageQueue+Thread异步循环机制构建完成。</p><h2 id="快速实现子线程使用Handler"><a href="#快速实现子线程使用Handler" class="headerlink" title="快速实现子线程使用Handler"></a>快速实现子线程使用Handler</h2><h1 id="View"><a href="#View" class="headerlink" title="View"></a>View</h1><h2 id="View的绘制流程"><a href="#View的绘制流程" class="headerlink" title="View的绘制流程"></a>View的绘制流程</h2><ol><li>测量——<code>onMeasure()</code>：决定View的大小</li><li>布局——<code>onLayout()</code>：决定View在ViewGroup中的位置</li><li>绘制——<code>onDraw()</code>：绘制这个View</li></ol><h2 id="自定义View"><a href="#自定义View" class="headerlink" title="自定义View"></a>自定义View</h2><h3 id="分类-1"><a href="#分类-1" class="headerlink" title="分类"></a>分类</h3><ul><li>继承View，重写<code>onDraw()</code>方法</li><li>继承ViewGroup，派生特殊的Layout</li><li>继承特定的View，例如TextView</li><li>继承特定的ViewGroup，例如LinearLayout</li></ul><h3 id="实现步骤"><a href="#实现步骤" class="headerlink" title="实现步骤"></a>实现步骤</h3><ul><li>继承View类或者其子类</li><li>重写View中的一些函数</li><li>为自定义View类增加属性（两种方式）</li><li>绘制控件（导入布局）</li><li>响应用户事件</li><li>定义回调函数</li></ul><h2 id="View的滑动方式"><a href="#View的滑动方式" class="headerlink" title="View的滑动方式"></a>View的滑动方式</h2><h3 id="通过View本身提供的scrollTo-scrollBy方法"><a href="#通过View本身提供的scrollTo-scrollBy方法" class="headerlink" title="通过View本身提供的scrollTo/scrollBy方法"></a>通过View本身提供的<code>scrollTo</code>/<code>scrollBy</code>方法</h3><p>这个方法移动的是View的内容，而View本身不移动。</p><p><code>scrollTo</code>和<code>scrollBy</code>也是有区别的。<code>scrollBy</code>内部调用了<code>scrollTo</code>，它是基于当前位置的<strong>相对滑动</strong>；而<code>scrollTo</code>是<strong>绝对滑动</strong>，因此如果利用相同输入参数多次调用<code>scrollTo()</code>方法，由于View初始位置是不变的，只会出现一次View滚动的效果而不是多次的。</p><h3 id="通过动画给View施加平移效果实现滑动"><a href="#通过动画给View施加平移效果实现滑动" class="headerlink" title="通过动画给View施加平移效果实现滑动"></a>通过动画给View施加平移效果实现滑动</h3><p>只是通过动画的方式移动View的影像，然而View本身位置不发生改变</p><h3 id="通过改变View的LayoutParams使View重新布局实现滑动"><a href="#通过改变View的LayoutParams使View重新布局实现滑动" class="headerlink" title="通过改变View的LayoutParams使View重新布局实现滑动"></a>通过改变View的LayoutParams使View重新布局实现滑动</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MarginLayoutParams params = mButton.getLayoutParams();</span><br><span class="line">params.width += <span class="number">10</span>;</span><br><span class="line">params.height += <span class="number">10</span>;</span><br><span class="line">mButton.requestLayout();</span><br><span class="line">mButton.setLayoutParams(params);</span><br></pre></td></tr></table></figure><h3 id="三种方法的使用对比"><a href="#三种方法的使用对比" class="headerlink" title="三种方法的使用对比"></a>三种方法的使用对比</h3><ul><li><code>scrollTo</code>/<code>scrollBy</code>：操作简单，适合对View内容的滑动；</li><li>动画：操作简单，主要适合于没有交互的View和实现复杂的动画效果；</li><li>改变布局参数：操作稍微复杂，适合有交互的View</li></ul><h3 id="如何解决View的滑动冲突"><a href="#如何解决View的滑动冲突" class="headerlink" title="如何解决View的滑动冲突"></a>如何解决View的滑动冲突</h3><p>首先判断是什么原因引起的View滑动冲突。</p><ul><li>对于由于外部滑动和内部滑动<strong>方向不一致</strong>导致的滑动冲突，可以根据滑动的方向判断谁来拦截事件；</li><li>对于由于外部滑动方向和内部滑动<strong>方向一致</strong>导致的滑动冲突，可以根据业务需求，规定何时让外部View拦截事件何时让内部View拦截事件；</li><li><p>上面两种情况的嵌套。</p></li><li><p><strong>外部拦截法</strong>：时间都先经过父容器的拦截处理，如果父容器需要此事件就拦截，否则就不拦截；具体方法需要重写父容器的<code>onInterceptTouchEvent</code>方法，在内部做出相应的拦截；</p></li><li><strong>内部拦截法</strong>：父容器不拦截任何事件，而将所有的事件都传递给子容器，如果子容器需要此事件就直接消耗，否则就交由父容器进行处理。具体方法是配合<code>requestDisallowInterceptTouchEvent</code>方法。</li></ul><h2 id="View的事件分发机制"><a href="#View的事件分发机制" class="headerlink" title="View的事件分发机制"></a>View的事件分发机制</h2><p>当我们点击屏幕时，产生了点击事件，这个事件被封装成类：<code>MotionEvent</code>。</p><p>事件的分发机制由三个重要想法来共同完成：<code>dispatchTouchEvent</code>、<code>onInterceptTouchEvent</code>、<code>onTouchEvent</code>。</p><ul><li><p><strong>事件分发</strong>：<code>public boolean dispatchTouchEvent(MotionEvent event)</code></p><p>  用来进行事件的<strong>分发（传递）</strong>。如果事件能够传递给当前View，那么此方法一定会被调用，返回结果受当前的<code>onTouchEvent</code>和下级View的<code>dispatchTouchEvent</code>影响，表示是否消耗了当前事件；</p></li><li><p><strong>事件拦截</strong>：<code>public boolean onInterceptTouchEvent(MotionEvent event)</code></p><p>  用来判断是否<strong>拦截</strong>某个事件，如果当前View拦截了某个事件，那么在同一个事件序列当中，此方法不会被再次调用，返回结果表示是否拦截当前事件；</p></li><li><p><strong>事件响应</strong>：<code>public boolean onTouchEvent(MotionEvent event)</code></p><p>  在<code>dispatchTouchEvent</code>方法中调用，用来处理点击事件，返回结果表示是否消耗当前事件。</p></li></ul><p><strong>三者的关系可以用以下伪代码表示</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">dispatchTouchEvent</span><span class="params">(MotionEvent event)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (onInterceptTouchEvent(event)) &#123;</span><br><span class="line">        result = onTouchEvent(event);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        result = child.dispatchTouchEvent(event);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> consume;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">`onInterceptTouchEvent()`和`onTouchEvent()`方法都是在`dispatchTouchEvent()`方法里调用。</span><br></pre></td></tr></table></figure></p><h2 id="View的工作原理"><a href="#View的工作原理" class="headerlink" title="View的工作原理"></a>View的工作原理</h2><p>View的工作流程就是先measure测量，用于确定View的宽高，再layout布局，用于确定View的最终宽高和四个顶点的位置，最后使用draw绘制，用于将View绘制到屏幕上。</p><p>measure用来测量view的宽和高，layout方法的作用是确定元素的位置，draw的过程则有：</p><ul><li>如果需要，则绘制背景；</li><li>保存当前canvas层；</li><li>绘制view的内容；</li><li>绘制子view；</li><li>如果需要，绘制view的褪色边缘，类似于阴影效果；</li><li>绘制装饰，比如滚动条里；</li></ul><h2 id="View和ViewGroup的区别"><a href="#View和ViewGroup的区别" class="headerlink" title="View和ViewGroup的区别"></a>View和ViewGroup的区别</h2><h2 id="非UI线程可以更新UI吗"><a href="#非UI线程可以更新UI吗" class="headerlink" title="非UI线程可以更新UI吗"></a>非UI线程可以更新UI吗</h2><p>其实是非UI线程是可以刷新UI的。前提是<strong>它要拥有自己的ViewRoot，即更新UI的线程和创建ViewRoot的线程是同一个</strong>，或者<strong>在执行<code>checkThread()</code>方法之前去更新UI</strong>。</p><p>因为在访问UI时，ViewRootImpl会调用<code>checkThread()</code>方法去检查当前访问UI的线程是哪一个，如果不会UI线程就会抛出异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">checkThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (mThread != Thread.currentThread()) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> CalledFromWrongThreadException (</span><br><span class="line">            <span class="string">"Only the original thread that created a view hierarchy can touch its views."</span></span><br><span class="line">        )</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ViewRootImpl的创建是在<code>onResume()</code>方法回调之后，而在执行<code>onCreate()</code>方法的时候还没有创建ViewRootImpl，就无法去检查当前线程。但是一般情况下，我们不会在<code>onCreate()</code>方法中做更新UI的操作。</p><h2 id="MotionEvent是什么？包含几种事件？什么时候会产生？"><a href="#MotionEvent是什么？包含几种事件？什么时候会产生？" class="headerlink" title="MotionEvent是什么？包含几种事件？什么时候会产生？"></a>MotionEvent是什么？包含几种事件？什么时候会产生？</h2><h1 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h1><h2 id="Android中有哪几种类型的动画"><a href="#Android中有哪几种类型的动画" class="headerlink" title="Android中有哪几种类型的动画"></a>Android中有哪几种类型的动画</h2><ul><li><strong>View动画（View Animation）/ 补间动画（Tween Animation）</strong>：对View进行平移、缩放、旋转和透明度变化的动画，不能真正地改变View的位置</li><li><strong>逐帧动画（Drawable Animation）</strong>：是View动画的一种，它会按照顺序播放一组预先定义好的图片</li><li><strong>属性动画（Property Animation）</strong>：通过不断的改变View的属性，不断地重绘而形成动画效果</li></ul><h2 id="View动画和属性动画的区别"><a href="#View动画和属性动画的区别" class="headerlink" title="View动画和属性动画的区别"></a>View动画和属性动画的区别</h2><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">View动画</th><th style="text-align:center">属性动画</th></tr></thead><tbody><tr><td style="text-align:center">动画实现</td><td style="text-align:center">通过不断的<strong>图形变换</strong>（TranslateAnimation，ScaleAnimation，RotateAnimation，AlphaAnimation）</td><td style="text-align:center">通过动态改变<strong>对象属性</strong>（ValueAnimator，ObjectAnimator，AnimatorSet）</td></tr><tr><td style="text-align:center">作用对象</td><td style="text-align:center">View对象</td><td style="text-align:center">任何对象</td></tr><tr><td style="text-align:center">存放位置</td><td style="text-align:center"><code>res/anim/</code></td><td style="text-align:center"><code>res/animator/</code></td></tr><tr><td style="text-align:center">状态变化</td><td style="text-align:center">未真正改变view的位置</td><td style="text-align:center">真正地改变了view的位置</td></tr></tbody></table></div><blockquote><p>View动画改变的只是View的显示，而没有改变View的响应区域；而属性动画会通过反射技术来获取和执行属性的<code>get</code>、<code>set</code>方法，从而改变了对象位置的属性值。</p></blockquote><h2 id="帧动画在使用时需要注意到什么"><a href="#帧动画在使用时需要注意到什么" class="headerlink" title="帧动画在使用时需要注意到什么"></a>帧动画在使用时需要注意到什么</h2><p>使用帧动画时注意不能使用尺寸过大的图片，否则容易造成OOM。</p><h2 id="属性动画中插值器和估值器的作用"><a href="#属性动画中插值器和估值器的作用" class="headerlink" title="属性动画中插值器和估值器的作用"></a>属性动画中插值器和估值器的作用</h2><h3 id="插值器（Interpoloator）"><a href="#插值器（Interpoloator）" class="headerlink" title="插值器（Interpoloator）"></a>插值器（Interpoloator）</h3><ul><li>定义：一个接口</li><li>作用：设置属性值从初始值过渡到结束值的<strong>变化规律</strong>（确定了动画效果变化的模式，如匀速变化、加速变化、减速变化等）</li><li>使用方法：可以在XML和Java代码中设置</li></ul><h3 id="估值器（TypeEvaluator）"><a href="#估值器（TypeEvaluator）" class="headerlink" title="估值器（TypeEvaluator）"></a>估值器（TypeEvaluator）</h3><ul><li>定义：一个接口</li><li>作用：设置属性值从初始值过渡到结束值的<strong>变化具体数值</strong>（估值器决定了具体的变化数值）</li></ul><h1 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h1><h2 id="Activity、View、Window之间的关系"><a href="#Activity、View、Window之间的关系" class="headerlink" title="Activity、View、Window之间的关系"></a>Activity、View、Window之间的关系</h2><p>Activity是界面载体，可以展示页面；而View实际上是一个个视图，这些视图可以搭载在一个Layout文件上，通过Activity的<code>setContentView()</code>方法传递给Activity；Window是一个窗体，每个Activity对应一个Window，通常在代码中通过<code>getWindow()</code>方法获取它。</p><blockquote><p>每个Activity包含了一个Window对象，这个对象是由PhoneWindow实现的。PhoneWindow将内部的DecorView作为了一个应用窗口的根View，这个DecorView又把屏幕划分为了两个区域：一个是ActionBar（TitleBar），一个是ContentView。我们平时编写的XML文件布局就是展示在ContentView中。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://s1.ax1x.com/2020/05/02/JjBNu9.png" alt=""></p><h2 id="Window有哪几种类型"><a href="#Window有哪几种类型" class="headerlink" title="Window有哪几种类型"></a>Window有哪几种类型</h2><ul><li><strong>应用Window</strong>：对应一个Activity</li><li><strong>子Window</strong>：不能单独存在，需附属特定的父Window。比如Dialog。</li><li><strong>系统Window</strong>：需要申明权限才可以创建，比如Toast</li></ul><p>Window是分层的，层级大的会覆盖在层级小的Window上面，对应的是<code>WindowManager.LayoutParams</code>的<code>type</code>参数。</p><div class="table-container"><table><thead><tr><th style="text-align:center">Window</th><th style="text-align:center">层级</th></tr></thead><tbody><tr><td style="text-align:center">应用Window</td><td style="text-align:center">1~99</td></tr><tr><td style="text-align:center">子Window</td><td style="text-align:center">1000~1999</td></tr><tr><td style="text-align:center">系统Window</td><td style="text-align:center">2000~2999</td></tr></tbody></table></div><h1 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h1><h2 id="六大布局"><a href="#六大布局" class="headerlink" title="六大布局"></a>六大布局</h2><ul><li>LinearLayout</li><li>RelativeLayout</li><li>TableLayout</li><li>FrameLayout</li><li>AbsoluteLayout</li><li>GridLayout</li></ul><h2 id="ConstraintLayout"><a href="#ConstraintLayout" class="headerlink" title="ConstraintLayout"></a>ConstraintLayout</h2><p>ConstrainLayout约束布局和RelativeLayout相对布局有点类似控件之间都是依赖关系而存在的，但是会比RelativeLayout更加灵活。</p><p>它的好处就是提升了性能，减少了布局之间的嵌套。</p><h2 id="RecyclerView"><a href="#RecyclerView" class="headerlink" title="RecyclerView"></a>RecyclerView</h2><ul><li>LayoutManager：负责Item视图的布局的显示管理</li><li>ItemDecoration：给每一个item视图添加子View（例如可以添加分割线）</li><li>ItemAnimator：负责处理数据添加或者删除时的动画效果</li><li>Adapter：为每一项item创建视图。一是根据不同的ViewType创建与之相应的item布局，二是访问数据集合并将数据绑定到正确的View上</li><li>ViewHolder：承载item视图的子布局</li><li>Recycler：负责处理View的缓存</li></ul><p><strong>方法的作用</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建Item视图，并返回给相应的ViewHolder</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ViewHolder <span class="title">onCreateViewHolder</span><span class="params">(ViewGroup parent, <span class="keyword">int</span> viewType)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 绑定数据到正确的Item视图上</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onBindViewHolder</span><span class="params">(ViewHolder holder, <span class="keyword">int</span> position)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 返回该Adapter所持有的Item数量</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemCount</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">// 用来获取当前项Item，即position参数是哪种类型的布局</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getItemViewType</span><span class="params">(<span class="keyword">int</span> position)</span></span></span><br></pre></td></tr></table></figure><h3 id="RecyclerView与ListView的区别"><a href="#RecyclerView与ListView的区别" class="headerlink" title="RecyclerView与ListView的区别"></a>RecyclerView与ListView的区别</h3><ol><li><p>缓存机制不同</p><p> ListView是两级缓存，而RecyclerView是四级缓存，支持多个ItemView缓存，支持自定义缓存处理逻辑，支持所有的RecyclerView共用同一个RecyclerViewPool。</p><p> ListView的两级缓存是<code>mActiveViews</code>和<code>mScrapViews</code>。</p><p> RecyclerView的四级缓存是<code>mAttachedScrap</code>和<code>mCacheViews</code>和<code>mViewCatchExtension</code>和<code>mRecyclerPool</code>。</p></li><li><p>局部刷新</p><p> RecyclerView提供了局部刷新的接口，通过局部刷新的机制，可以避免调用许多无用的bindView。</p></li><li><p>ListView不强制要写ViewHolder，而RecyclerView是强制要写ViewHolder的，从而去重写<code>getItemCount()</code>、<code>onCreateViewHolder()</code>、<code>onBindViewHolder()</code>三个方法</p></li><li><p>ListView的分割线是直接设置Divider，而RecyclerView是不支持直接在布局中添加分割线的</p></li><li><p>ListView支持点击事件，而RecyclerView不支持点击事件，只有设置回调接口来设置点击事件。</p></li><li><p>ListView的布局效果单一，只能是纵向效果；RecyclerView布局效果丰富，通过LayoutManager中设置，可以实现线性布局（横向、纵向），表格布局，瀑布流布局等等。</p></li></ol><h3 id="如何理解adapter订阅者模式"><a href="#如何理解adapter订阅者模式" class="headerlink" title="如何理解adapter订阅者模式"></a>如何理解adapter订阅者模式</h3><h3 id="ViewHolder的作用"><a href="#ViewHolder的作用" class="headerlink" title="ViewHolder的作用"></a>ViewHolder的作用</h3><p>ViewHolder内部是存储一些子View，避免时间代价很大的findViewById的操作。</p><h3 id="如何理解ViewHolder的复用"><a href="#如何理解ViewHolder的复用" class="headerlink" title="如何理解ViewHolder的复用"></a>如何理解ViewHolder的复用</h3><p>在重写RecyclerView.Adapter的时候，需要重写两个方法：</p><ul><li><code>onCreateViewHolder()</code></li><li><code>onBindViewHolder()</code></li></ul><p>它的复用机制就是当创建了足够多的ViewHolder对象之后，无论怎么滑动，都只需要复用以前创建的对象即可。</p><p>当数量足够用的时候，会停止调用<code>onCreateViewHolder()</code>方法，但是<code>onBindViewHolder()</code>方法会每次都会调用。</p><hr><p>RecyclerView的复用机制的调用入口是<code>getViewPosition()</code>方法，重点则是在<code>tryGetViewHolderForPositionByDeadline()</code>方法之中。</p><p>它的关键步骤主要如下：</p><ul><li>判断Cache池中是否有相应的ViewHolder对象</li><li>从<code>mViewCacheExtension</code>中寻找对象</li><li>从<code>RecyclerViewPool</code>中寻找对象</li><li>如果之前的步骤都没有寻找到对象，那么就用Adapter的<code>createViewHolder()</code>方法去创建ViewHolder对象</li><li>最后是根据不同的<code>ViewHolderFlags</code>情况（例如是否可复用等）来决定是否执行<code>tryBindViewHolderByDeadline()</code>方法，<code>onBindViewHolder()</code>方法是唯一的入口。</li></ul><h3 id="什么时候停止调用onCreateViewHolder"><a href="#什么时候停止调用onCreateViewHolder" class="headerlink" title="什么时候停止调用onCreateViewHolder"></a>什么时候停止调用onCreateViewHolder</h3><h3 id="LayoutManager的作用是什么"><a href="#LayoutManager的作用是什么" class="headerlink" title="LayoutManager的作用是什么"></a>LayoutManager的作用是什么</h3><p>LayoutManager的作用是用来设置item的位置，并且负责决定何时回收和复用item。一个RecyclerView如果想展示内容，就必须设置LayoutManager。</p><h3 id="LayoutManager的样式有哪些"><a href="#LayoutManager的样式有哪些" class="headerlink" title="LayoutManager的样式有哪些"></a>LayoutManager的样式有哪些</h3><ul><li>LinearLayoutManager：设置水平或者垂直的item视图</li><li>GridLayoutManager：网格状的item视图</li><li>StaggeredGridLayoutManager：交错的网格布局</li></ul><h3 id="上拉加载的功能是如何做的"><a href="#上拉加载的功能是如何做的" class="headerlink" title="上拉加载的功能是如何做的"></a>上拉加载的功能是如何做的</h3><h3 id="添加滚动监听事件需要注意什么"><a href="#添加滚动监听事件需要注意什么" class="headerlink" title="添加滚动监听事件需要注意什么"></a>添加滚动监听事件需要注意什么</h3><h3 id="网格布局上拉加载如何优化"><a href="#网格布局上拉加载如何优化" class="headerlink" title="网格布局上拉加载如何优化"></a>网格布局上拉加载如何优化</h3><h3 id="如何理解RecyclerView三级缓存是如何实现的"><a href="#如何理解RecyclerView三级缓存是如何实现的" class="headerlink" title="如何理解RecyclerView三级缓存是如何实现的"></a>如何理解RecyclerView三级缓存是如何实现的</h3><h4 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h4><blockquote><p>返回布局和内容都有效的ViewHolder</p></blockquote><ol><li>按position或者id匹配</li><li>命中一级缓存是无需使用<code>onCreateViewHolder</code>和<code>onBindViewHolder</code></li><li></li></ol><h3 id="RecyclerView滑动卡顿的原因有哪些？如何解决？"><a href="#RecyclerView滑动卡顿的原因有哪些？如何解决？" class="headerlink" title="RecyclerView滑动卡顿的原因有哪些？如何解决？"></a>RecyclerView滑动卡顿的原因有哪些？如何解决？</h3><h3 id="RecyclerView常见的优化有哪些？"><a href="#RecyclerView常见的优化有哪些？" class="headerlink" title="RecyclerView常见的优化有哪些？"></a>RecyclerView常见的优化有哪些？</h3><h1 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h1><h2 id="Intent"><a href="#Intent" class="headerlink" title="Intent"></a>Intent</h2><h3 id="Intent可以传递哪些类型的数据"><a href="#Intent可以传递哪些类型的数据" class="headerlink" title="Intent可以传递哪些类型的数据"></a>Intent可以传递哪些类型的数据</h3><ul><li>8种基本数据类型及其数组</li><li>String / CharSequence 实例类型的数据及其数组</li><li>实现了Parcelable的对象及其数组</li><li>实现了Serializable的对象及其数组</li></ul><h1 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h1><h2 id="六大原则"><a href="#六大原则" class="headerlink" title="六大原则"></a>六大原则</h2><ul><li><p><strong>单一职责原则</strong>：一个类只负责一个功能领域中的相应职责，或者可以定义为：就一个类而言，应该只有一个引起它变化的原因。</p><blockquote><p>There should never be more than one reason for a class to change.</p></blockquote><p>  不同的类具有不同的职责，各司其职。如果一个类拥有了两种职责，那么就最好将其分为两个类。</p></li><li><p><strong>里氏替换原则（Liskov Substitution Principle）</strong>：所有引用基类的地方必须能够透明地使用其子类的对象。</p><blockquote><p>Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it.</p></blockquote><p>  它是开闭原则的具体实现手段之一。里氏替换原则的核心是<strong>抽象</strong>，而抽象又依赖于<strong>继承</strong>这个特性。继承的优点有：1. 代码重用，减少创建类的成本，每个子类拥有父类的属性和方法；2. 子类和父类基本相似，但是又于父类有区别；3. 提高代码的可拓展性。继承的缺点有：1. 继承是侵入性的，只要继承了就必须拥有父类的所有属性和方法；2. 可能会造成子类代码的冗余，灵活性降低，因为子类必须拥有父类所有的属性和方法。里氏替换原则和开闭原则是相互依赖的，通过里式替换来达到对扩展的开发，对修改的关闭效果。</p></li><li><p><strong>依赖倒转原则（Dependence Inversion Principle）</strong>：高层模块不应该依赖底层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象。</p><blockquote><p>High level modules should not depends upon low level modules. Both should depend upon abstractions. Abstractions should not depends upon details. Details should depend upon abstractions.</p></blockquote><p>  在Java中，<strong>抽象</strong>是指接口或者抽象类（Abstract），两者都是不可以被实例化的（不能被new）；而<strong>细节</strong>指的是具体的实现类，实现接口或者抽象类，是可以被实例化的。高层模块指的就是调用端，低层模块就是具体的实现类。所以依赖倒转原则在Java中的表现就是，模块间的依赖通过抽象产生，实现类之间是不会产生依赖关系的，其依赖关系是通过接口或者抽象类产生的。如果类与类之间直接依赖细节，那么可能会直接耦合。需要修改时，就会同时修改依赖者的代码，限制了可拓展性。</p></li><li><p><strong>接口隔离原则（Interface Segregation Principle）</strong>：客户端不应该依赖它不需要的接口；一个类对另一个类的依赖应该建立在最小的接口上</p><blockquote><p>The dependency of one class to another one should depend on the smallest possible interface.</p></blockquote><p>  接口隔离原则的建立最小的接口是指建立单一接口，不要建立庞大臃肿的接口；尽量细化接口，接口中的方法尽量要少。即为各个类建立专用的接口，而不要试图建立一个很庞大的接口供所有的依赖它的类调用。需要注意以下几点：</p><ul><li>接口尽量要小，但是也有限度。对接口进行细化可以提高程序设计的灵活性；但是如果太小了，则会造成接口数量过多，设计复杂化；</li><li>为依赖接口的类定制服务，只暴露给调用的类需要的方法，它不需要的方法则隐蔽起来。这样才能建立最小的依赖关系；</li><li>提高内聚，减少对外交互。接口方法尽量少用<code>public</code>修饰，接口是对外的承诺，承诺越少对系统开发越有利，变更风险也会越少。</li></ul></li><li><p><strong>迪米特原则（Law of Demeter，最少知道原则）</strong>：一个对象应该对其它对象保持最少的了解，即一个软件实体应当尽可能少地与其它实体发生相互作用</p><blockquote><p>Only talk to your immediate friends.</p></blockquote><p>  一个类应该对自己需要耦合或者调用的类了解最少，类的内部如何实现与调用者或者依赖关系越密切，耦合度就越大。当一个类发生变化时，对另外一个类的影响也越大。即<strong>低耦合、高内聚</strong>。</p><ul><li>在类的划分上，应当尽量创建松耦合的类。类之间的耦合度越低，当一个类修改时，就不会对关联的类造成太大的波及；</li><li>在类的结构设计上，每一个类都应当尽量降低其成员变量和成员函数的访问权限；</li><li>在对其它类的引用上，一个类对其它对象的引用应当降到最低；</li></ul></li><li><p><strong>开放封闭原则（Open Close Principle）</strong>：对扩展开放，对修改关闭</p><blockquote><p>Software entities like classes, modules and functions should be open for extension but closed for modifications.</p></blockquote><p>  即<strong>类、模块、函数等应该是可以拓展的，但是不可修改</strong>。开闭原则指导我们，当软件发生变化时，应该尽量通过<strong>拓展</strong>的方式来实现变化，而不是通过<strong>修改</strong>已有代码来实现（OCP原则并不是说绝对不可以修改原始的类）。</p></li><li><p><strong>合成复用原则（六大原则之外）</strong>：尽量使用对象组合，而不是继承来达到复用的目的。</p><p>  合成复用原则就是在一个新的对象里通过关联关系（包括组合关系和聚合关系）来使用一些已有的对象，使之成为新对象的一部分，新对象通过委派调用已有对象的方法达到复用功能的目的。即首先考虑组合/聚合，可以使系统更灵活，降低类与类之间的耦合度，其次才考虑继承。在使用继承时，也要严格遵循里氏替换原则。</p></li></ul><h2 id="23种设计模式"><a href="#23种设计模式" class="headerlink" title="23种设计模式"></a>23种设计模式</h2><p>23种设计模式分为三大类（分类不同版本有不同的数量）：</p><ul><li><p><strong>创建型模式（6种）</strong>：单例模式、简单工厂模式、工厂方法模式、抽象工厂模式、建造者模式、原型模式</p><blockquote><p>创建型模式对类的实例化过程进行了抽象，能够将模块中对象的创建和对象的使用分离。为了使结构更加清晰，外界对于这些对象只需要知道它们共同的接口，而不清楚具体的细节，使整个系统的设计更加符合单一职责原则。</p></blockquote></li><li><p><strong>结构型模式（6种）</strong>：外观模式、适配器模式、桥接模式、代理模式、装饰者模式、享元模式</p><blockquote><p>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</p></blockquote></li><li><p><strong>行为型模式（11种）</strong>：职责链模式、命令模式、解释器模式、迭代器模式、中介者模式、备忘录模式、观察者模式、状态模式、策略模式、模板方法模式、访问者模式</p><blockquote><p>行为型模式是对在不同的对象之间划分责任和算法的抽象化。行为型模式不仅仅关注类和对象的结构，而且重点关注它们之间的相互作用。通过行为型模式，可以更加清晰地划分类与对象之间的职责，并研究系统在运行时实例对象之间的交互。</p></blockquote></li></ul><p>具体的23种设计模式详见<a href="#designpattern">Java基础部分的设计模式分析</a></p><h1 id="MVC与MVP与MVVM"><a href="#MVC与MVP与MVVM" class="headerlink" title="MVC与MVP与MVVM"></a>MVC与MVP与MVVM</h1><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><blockquote><p>MVC用一种业务逻辑、数据、界面显示分离的方法组织代码。</p></blockquote><p>Android中的MVC的角色定义如下：</p><ul><li>模型层Model：针对业务模型，建立的数据结构和相关的类，可以被理解为是Model。Model与View是无关的，而是与业务相关的。</li><li>视图层View：一般采用XML文件或者Java代码进行界面的描述。</li><li>控制层Controller：Android的控制层通常在Activity、Fragment或者由它们控制的其它业务类中。</li></ul><p>MVC简单来说就是「通过Controller来操作Model层的数据，并且返回给View层展示」。</p><p>MVC的缺点是：</p><ul><li>Android中的Activity或者Fragment并不是一个标准MVC模式中的Controller。随着界面及其逻辑的复杂度不断提升，Activity类的职责也在不断的增加，会变得十分的庞大臃肿。</li><li>View层和Model层相互耦合，不易于开发和维护。</li></ul><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p>在MVP里，Presenter完全将Model和View层进行了分离，把主要的程序逻辑都放在了Presenter里实现。Presenter与具体的View是没有直接关联的，而是通过定义好的接口进行交互，这样变更View时可以保持Presenter的不变。</p><p>View层里只有<code>get</code>/<code>set</code>方法，以及用户输入和设置界面显示的代码，除此之外就没有别的内容了，因为主要的逻辑就放在了Presenter层里实现。</p><ul><li>Model：主要提供数据的存取功能，Preseter层需要通过Model层来存储和获取数据；</li><li>View：负责处理用户事件和视图的展示，Android中对应的是Activity或者Fragment或者某个View；</li><li>Presenter：作为View和Model层之间的桥梁。它从Model层获取数据并显示在View层中，使得View和Model层之间没有耦合。</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p>将Presenter改为ViewModel，不同的是ViewModel与Model和View是双向绑定的。当View发生改变时，ViewModel通知Model进行更新数据；而Model更新之后，ViewModel也会通知View层更新界面。</p><p>通过Data Binding，可以通过声明式布局的方式精简代码来绑定应用程序的逻辑和布局。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>121.Best Time to Buy and Sell Stock</title>
      <link href="/2020/03/12/121.Best-Time-to-Buy-and-Sell-Stock/"/>
      <url>/2020/03/12/121.Best-Time-to-Buy-and-Sell-Stock/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。</p><p>如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。</p><p>注意你不能在买入股票前卖出股票。</p><p>示例 1:</p><p>输入: [7,1,5,3,6,4]<br>输出: 5<br>解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。<br>     注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。</p><p>示例 2:</p><p>输入: [7,6,4,3,1]<br>输出: 0<br>解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。</p></blockquote><a id="more"></a><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>最容易想到的暴力法就是比较每个元素与后面的元素的差值。假设数组长度为n，则第一次要比较n-1次，第二个要比较n-2次，以此类推，第n个要比较n-(n-1)=1次。所以总次数也就是时间复杂度为$O(n^2)$。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 前一个元素</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="comment">// 后一个元素</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">            <span class="comment">// 记录差值</span></span><br><span class="line">            <span class="keyword">int</span> profit = prices[j] - prices[i];</span><br><span class="line">            <span class="comment">// 如果当前差值比maxprofit大，就将maxprofit替换成当前差值</span></span><br><span class="line">            <span class="keyword">if</span> (profit &gt; maxprofit) &#123;</span><br><span class="line">                maxprofit = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：$O(n^2)$，循环进行了$(n-1)+(n-2)+…+1=\frac{n(n-1)}{2}$次。</li><li><strong>空间复杂度</strong>：$O(1)$。因此只使用了常数个变量。</li></ul><h3 id="一次遍历"><a href="#一次遍历" class="headerlink" title="一次遍历"></a>一次遍历</h3><p>遍历一次数组，在遍历每一天时，既要用一个变量判断历史最低价格<code>minprice</code>，也要在当天判断当天与历史最低价格的差值是否是最大利润。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="keyword">int</span>[] prices)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> minprice = Integer.MAX_VALUE;</span><br><span class="line">    <span class="keyword">int</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &lt; minprice) &#123;</span><br><span class="line">            minprice = prices[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit) &#123;</span><br><span class="line">            maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>首先，设置<code>minprice</code>为最大值，<code>maxprofit</code>为0。然后开始遍历数组。</p><p>如果当前数组的值比<code>minprice</code>小，就发生替换；如果更大就不替换。这样就能得到这个数组中最小的值。然后用当前数组的值减去<code>minprice</code>，如果得到的利润大于最大利润，就得到最大利润。因为这个都放在同一个<code>for</code>循环里，所以遍历的顺序是从0从n，从前往后，所以是不存在前面一个数减后面一个数的情况。</p><p>这道题评论有质疑这种做法是话如果最小值在数组的最后一位会不成立。实际上亲测是不影响的。可以通过下图说明。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0240%202.jpg" alt=""></p><p>由上图可发现，尽管最后一位才是数组的最小值，最后的<code>minprice</code>也更新为了1，但是因为之前已经保留了<code>maxprofit</code>的值为4，所以最后一位的最小值被当前元素相减，结果为1仍然小于4，所以不会更新替换<code>maxprofit</code>的值，所以结果仍然是正确的。</p><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：因为只使用了一次<code>for</code>循环遍历了整个数组，所以时间复杂度是$O(n)$。</li><li><strong>空间复杂度</strong>：是使用了常数个变量，所以是$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>463.Island Perimeter</title>
      <link href="/2020/03/12/463.Island-Perimeter/"/>
      <url>/2020/03/12/463.Island-Perimeter/</url>
      
        <content type="html"><![CDATA[<blockquote><p>给定一个包含 0 和 1 的二维网格地图，其中 1 表示陆地 0 表示水域。</p><p>网格中的格子水平和垂直方向相连（对角线方向不相连）。整个网格被水完全包围，但其中恰好有一个岛屿（或者说，一个或多个表示陆地的格子相连组成的岛屿）。</p><p>岛屿中没有“湖”（“湖” 指水域在岛屿内部且不和岛屿周围的水相连）。格子是边长为 1 的正方形。网格为长方形，且宽度和高度均不超过 100 。计算这个岛屿的周长。</p><p>示例 :</p><p>输入:<br>[[0,1,0,0],<br> [1,1,1,0],<br> [0,1,0,0],<br> [1,1,0,0]]</p><p>输出: 16</p><p>解释: 它的周长是下面图片中的 16 个黄色的边：</p></blockquote><a id="more"></a><p>这道题的思路是总的正方形块树的数量乘以4条边，然后减去重合的边树乘以2，就是岛屿的周长。所以解题的关键就是在于<strong>有规律的找到有多少次的重叠</strong>，这样能够避免重复的计算。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><p>最开始想到的代码写法是这样的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该矩阵为空</span></span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 陆地的数量</span></span><br><span class="line">    <span class="keyword">int</span> land = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重叠的数量</span></span><br><span class="line">    <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 规定数组元素为1时是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                land++;</span><br><span class="line">                <span class="comment">// 分别找上下左右是否是陆地，如果是陆地就意味着有重合</span></span><br><span class="line">                <span class="comment">// 下</span></span><br><span class="line">                <span class="comment">// 因为判断下边，所以i要小于grid.length-1，不然就已经是最下边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 右</span></span><br><span class="line">                <span class="comment">// 因为判断右边，所以j要小于grid[i].length-1，不然就已经是最右边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 左</span></span><br><span class="line">                <span class="comment">// 因为判断左边，所以j要大于0，不然就已经是最左边了</span></span><br><span class="line">                <span class="keyword">if</span> (j &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i][j - <span class="number">1</span>]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 上</span></span><br><span class="line">                <span class="comment">// 因为判断上边，所以i要大于0，不然就已经是最上边了</span></span><br><span class="line">                <span class="keyword">if</span> (i &gt; <span class="number">0</span> &amp;&amp; grid[i][j] == grid[i - <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * land - <span class="number">2</span> * overlap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>刚开始想到的就是上下左右进行判断是否是陆地，如果是陆地，就说明了有重叠部分。但是这样去提交代码测试结果却发现是错误的。后来才想明白，其实上下左右只要判断两个方向就可以了。</p><p>例如判断左边的部分，首先条件<code>j &gt; 0</code>本来就是恒成立的，因为<code>for</code>循环是从0开始递增的，所以这里是多余的。然后，在双层循环了里，判断<code>grid[i][j] == grid[i][j + 1]</code>和判断<code>grid[i][j] == grid[i][j - 1]</code>其实是一样的效果。所以如果在这里判断了两侧，就会造成<code>overlap</code>累加了两次，从而计算错误。</p><p><strong>正确的代码</strong>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">islandPerimeter</span><span class="params">(<span class="keyword">int</span>[][] grid)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果该矩阵为空</span></span><br><span class="line">    <span class="keyword">if</span> (grid.length == <span class="number">0</span> || grid[<span class="number">0</span>].length == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 陆地的数量</span></span><br><span class="line">    <span class="keyword">int</span> land = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">// 重叠的数量</span></span><br><span class="line">    <span class="keyword">int</span> overlap = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grid.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">            <span class="comment">// 规定数组元素为1时是陆地</span></span><br><span class="line">            <span class="keyword">if</span> (grid[i][j] == <span class="number">1</span>) &#123;</span><br><span class="line">                land++;</span><br><span class="line">                <span class="comment">// 分别找上下左右是否是陆地，如果是陆地就意味着有重合</span></span><br><span class="line">                <span class="comment">// 纵向</span></span><br><span class="line">                <span class="comment">// 因为判断下边，所以i要小于grid.length-1，不然就已经是最下边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (i &lt; grid.length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i + <span class="number">1</span>][j]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// 横向</span></span><br><span class="line">                <span class="comment">// 因为判断右边，所以j要小于grid[i].length-1，不然就已经是最右边的元素了</span></span><br><span class="line">                <span class="keyword">if</span> (j &lt; grid[i].length - <span class="number">1</span> &amp;&amp; grid[i][j] == grid[i][j + <span class="number">1</span>]) &#123;</span><br><span class="line">                    overlap++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">4</span> * land - <span class="number">2</span> * overlap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>return 4 * land - 2 * overlap</code>的原因是根据规律得知，最终的周长就是陆地的数量乘以4条边然后减去重合数量的2倍（因为重复计算了2条边）。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度</strong>：如果这个二维矩阵的宽高分别为m和n，那么进行了双层循环，所以时间复杂度为$O(mn)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试题02.03.Delete Middle Node</title>
      <link href="/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%9802.03.Delete-Middle-Node/"/>
      <url>/2020/03/12/%E9%9D%A2%E8%AF%95%E9%A2%9802.03.Delete-Middle-Node/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实现一种算法，删除单向链表中间的某个节点（除了第一个和最后一个节点，不一定是中间节点），假定你只能访问该节点。</p><p><strong>示例：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：单向链表a-&gt;b-&gt;c-&gt;d-&gt;e-&gt;f中的节点c</span><br><span class="line">结果：不返回任何数据，但该链表变为a-&gt;b-&gt;d-&gt;e-&gt;f</span><br></pre></td></tr></table></figure></blockquote><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>最简单直接的想法就是遍历一遍链表，得出链表的长度，然后一半即是链表一半的长度，也就是中间节点所在的位置。但是这样缺点也是很明显的，就是在时间复杂度上。假设链表的长度为n，则遍历一遍链表的长度需要$O(n)$的时间，然后又重新遍历一半链表的长度获得中间节点，这里又需要$O(\frac{n}{2})$的时间，总时间即为$O(\frac{3n}{2})$。</p><a id="more"></a><h3 id="方法二：快慢指针法"><a href="#方法二：快慢指针法" class="headerlink" title="方法二：快慢指针法"></a>方法二：快慢指针法</h3><p>在很多场景下都可以用到快慢指针法。在这里设置两个指针，一个指针A每次指向下一个节点，一个指针B指向下两个节点，这样当B走到链表的末尾时，A才走到链表的中间节点（因此B是A速度的两倍）。所以这样A指针走到的位置就是链表的中间节点。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Delete_Middle_Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteNode</span><span class="params">(ListNode node)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 慢指针</span></span><br><span class="line">        node.val = node.next.val;</span><br><span class="line">        <span class="comment">// 快指针</span></span><br><span class="line">        node.next = node.next.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        ListNode next;</span><br><span class="line">        ListNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h4><ul><li><strong>时间复杂度</strong>：因为两个指针是同时进行的，快指针遍历了整个链表，慢指针遍历了半个链表，所以时间复杂度仍然是$O(n)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面经收集</title>
      <link href="/2020/03/03/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/"/>
      <url>/2020/03/03/%E9%9D%A2%E7%BB%8F%E6%94%B6%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h2 id="阿里钉钉三面"><a href="#阿里钉钉三面" class="headerlink" title="阿里钉钉三面"></a>阿里钉钉三面</h2><ol><li>自我介绍</li><li>对MVC和MVP的理解</li><li>Handler的内存泄漏问题具体是什么，解决方案知道有什么，空数据的时候Handler的阻塞问题</li><li>为什么使用MVP，它的优势是什么，内存泄漏是什么样的</li><li>http长连接和短连接的这两个概念</li><li>RecyclerView的复用机制，和ListView的一个区别在哪里</li><li>HashMap和ConcurrentHashMap和HashTable问题</li><li>一个app的启动流程，冷启动和热启动</li></ol><a id="more"></a><h2 id="腾讯电话面一面"><a href="#腾讯电话面一面" class="headerlink" title="腾讯电话面一面"></a>腾讯电话面一面</h2><ol><li>Class编译过程</li><li>自定义View要经过哪些过程吗？</li><li>如何绘制圆形、曲线等？</li><li>自定义View是如何绘制在屏幕上的？</li><li>简述Activity的生命周期</li><li>应用切换到后台，前台Activity的生命周期经过哪些变化？</li><li><code>onNewIntent()</code>方法什么时候会触发？</li><li><code>singleTask</code>和<code>singleTop</code>有什么区别？</li><li>两个Activity如何进行跨进程通信？</li><li>一个进程进行文件读取时，如何设置权限（不让其他进程访问）？</li><li>Android如何实现多线程？</li><li>简述Handler如何实现多线程？</li><li>JVM是什么？为什么需要JVM？</li><li>简述客户端网络请求架构？</li><li>如何保证客户端网络请求的安全性？</li><li>HTTP长连接和短连接的不同</li><li>简述三次握手</li><li>HTTPS是何如加密的</li><li>DNS是什么</li><li>如何从一亿个QQ号中筛选出五个指定的QQ号》</li><li>快排算法实现过程，时间复杂度是多少？有什么弊端</li><li>简述归并排序算法，时间复杂度是多少？</li></ol><h2 id="腾讯暑期Android实习一二面"><a href="#腾讯暑期Android实习一二面" class="headerlink" title="腾讯暑期Android实习一二面"></a>腾讯暑期Android实习一二面</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li><p>ArrayList和LinkedList的区别，它们各自的优缺点是什么以及它们有什么异同点</p></li><li><p>进程和线程的区别</p></li><li><p><code>static</code>这个命名的变量和类有什么不同？</p></li><li><p>二叉树有几种遍历方式？</p><ul><li><p>先序遍历：根、左、右</p></li><li><p>中序遍历：左、根、右</p></li><li><p>后序遍历：左、右、根</p></li><li><p>层次遍历：从上往下层次遍历</p></li></ul></li><li><p>堆和栈的特点</p><ol><li>栈内存是用来存储局部变量和方法调用的，堆内存是用来存储Java中对象的。无论是成员变量、局部变量还是类变量，它们指向的对象都存储在堆内存中。</li><li>栈内存远远小于堆内存。</li><li>数据结构方面：堆可以看成一颗树，栈是一个先进后出的数据解耦股。</li></ol></li><li><p>队列和栈，它们在数据进出顺序的方面有什么不同点？</p><p> 先进先出和先进后出</p></li><li><p>Java有几种内存模式，其中变量/方法/类分别储存在哪里？栈内存主要用来存放什么？</p></li><li><p>介绍一个Java的垃圾回收机制</p><p> 垃圾回收机制只负责回收堆内存中的对象，不会回收任何物理资源。可以调用<code>System.gc()</code>方法或者<code>Runtime.getRuntime().gc()</code>方法。</p></li><li><p>说一下去MVC是什么？</p></li><li><p>Android六大布局，线性布局和相对布局哪个效率高？</p></li><li><p>Activity生命周期</p></li><li><p>Activty从打开状态到运行状态经历了哪几个方法？</p></li></ol><h2 id="阿里淘系技术部Android实习一二面"><a href="#阿里淘系技术部Android实习一二面" class="headerlink" title="阿里淘系技术部Android实习一二面"></a>阿里淘系技术部Android实习一二面</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><ol><li><p>简历项目介绍</p></li><li><p>看过哪些Android或者Java的书籍</p><p> 《第一行代码》、《Android进阶之光》</p></li><li><p>设计一个图片加载框架需要考虑到哪些方面</p><p> 图片加载包含封装、解析、下载、解码、变换、缓存、显示等操作。</p><ol><li>封装参数：这些参数会贯穿整个过程</li><li>解析路径：图片的来源有很多种，格式也不尽相同，需要规范化</li><li>读取缓存：同样的请求，可以从缓存中读取图片</li><li>查找文件/下载文件：如果是本地的文件，直接解码；如果是网络图片，需要先下载</li><li>解码：</li><li>变换：通过解码成bitmap，可能要做一些变换处理（例如圆角等）</li><li>缓存：得到最终的bitmap后，可以缓存起来，以便下次可以使用</li><li><p>显示：显示图片，可能会添加一些动画</p><p>为了防止图片分辨率过大，出现OOM，还需要进行进一步处理。比如说用到<code>BitmapFactory</code>类对大图片进行压缩处理后再放到内存中。</p></li></ol></li><li><p>场景：找出海量字符里面出现次数最多的那个字符</p><ol><li><p>分治法+HashMap：</p><p> 比如说分为很多批，1批有100个字符。这100个字符可以存进<code>String</code>类型的字符串数组中，每批使用循环遍历一次，存入<code>HashMap&lt;String, Integer&gt;</code>里面，<code>String</code>对应这个数的字符串，<code>Integer</code>对应它出现的次数，最后最大的字符就是出现次数最多的。</p></li></ol></li><li><p>Activity的启动流程</p><p> 当在Activity中调用<code>startActivity</code>方法来启动另一个Activity时，调用流程：<code>startActivity$$\rightarrow$$startActivity(intent, bundle)$$\rightarrow$$startActivityForResult(intent, -1, bundle)</code>。最后去调用<code>Instrumentation.execStartActivity</code>方法。</p><p> <code>Instrumentation</code>有什么作用呢？为什么要在<code>Instrumentation</code>中去执行<code>execStartActivity</code>方法呢？</p><p> <code>Instrumentation</code>是在任何应用程序运行前进行初始化的，可以用它来检测系统和应用程序之间的交互。每一个Activity都会持有<code>Instrumentation</code>的引用，但是整个进程只有一个<code>Instrumentation</code>实例，所以<code>Instrumentation</code>相当于一个大管家，管理着Activity和Application的生命周期，包括着Activity的创建。</p></li><li><p>Android性能优化</p></li><li><p>算法：找出单向链表的中间节点</p></li><li><p>算法：单向链表的头尾节点交换</p></li><li><p>算法：给定N个<code>int</code>型的数组，每个数组的元素个数不确定也不一定相同，请将N个<code>int</code>类型的数组合并成一个数组，同时进行降序的排列</p></li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li><p>为什么学习Android</p></li><li><p>Android看的书籍，收获？</p></li><li><p>最满意的项目</p></li><li><p>项目里的多线程</p></li><li><p>Activity启动过程</p></li><li><p>内存泄漏，用什么工具检测？</p><p> <strong>内存泄漏</strong>是指：对象在它有限的生命周期结束后，它们将被垃圾回收，如果在回收时，这个对象还在被一系列的引用，就会导致该对象不会被回收，就会导致内存泄漏。随着泄漏的累积，应用将消耗完内存，应用的流畅性就会大大减弱。</p><p> 可以使用<strong>LeakCanary</strong>检测内存泄漏。当发生内存泄漏时，会进入内存泄漏报告分析。</p></li><li><p>Android页面的刷新频率</p></li><li><p>Android如何发现性能问题</p></li><li><p>操作系统死锁</p><p>死锁的四个条件：</p><ol><li>互斥：该资源任意时刻都只由一个线程占用；</li><li>持有并等待：一个进程因请求资源而阻塞时，对已获得的资源保持不放；</li><li>不可抢占：线程已获得的资源在未使用完之前不能被其它资源所侵占，只有自己使用完毕才能释放资源；</li><li>环路等待：形成进程和请求资源之间的环路，呈一种头尾相接的循环等待资源关系。</li></ol></li><li><p>树的区别（大小顶堆、AVL、排序树）</p><ol><li><p>AVL树：即平衡二叉树，AVL得名于其发明者的名字。</p><p>平衡二叉树的定义：</p><ol><li>左右子树的高度差都小于等于1</li><li>其每一个子树均为平衡二叉树</li></ol></li><li><p>二叉堆：是一种特殊的堆，具有堆的性质（父节点的键值总是大于等于或者小于等于任何一个子节点的键值）。二叉堆又具有二叉树的性质（二叉堆是完全二叉树或者是近似完全二叉树。）</p><ol><li>最大堆：当父节点的键值总是大于等于它的每一个子节点的键值时就是最大堆</li><li>最小堆：当父节点的键值总是小于等于它的每一个子节点的键值时就是最小堆</li></ol><p>二叉堆查找的时间复杂度是$O(n)$，创建二叉堆、插入节点、删除节点的时间复杂度都是$O(\log2n)$。</p></li><li><p>排序树：二叉排序树又叫做二叉查找树或二叉搜索树。它满足以下性质：</p><ol><li>若它的左子树不为空，则左子树的所有节点的值都要小于它的根节点的值；</li><li>若它的右子树不为空，则右子树的所有节点的值都要大于它的根节点的值；</li><li>它的左、右子树也都分别为二叉排序树。</li></ol><p>当然，如果这棵树是一颗空树，那也满足是二叉排序树。</p></li></ol></li><li><p>算法：矩阵逆时针打印每一个元素</p></li></ol><h2 id="CVTE-Android实习一二面"><a href="#CVTE-Android实习一二面" class="headerlink" title="CVTE Android实习一二面"></a>CVTE Android实习一二面</h2><h3 id="一面-2"><a href="#一面-2" class="headerlink" title="一面"></a>一面</h3><ol><li><p>自我介绍</p></li><li><p>Retrofit源码</p></li><li><p>Java线程同步的方法</p><ol><li><p>同步方法<code>synchronized</code>修饰方法</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure><p> Java的每个对象都有一个内置锁，如果使用此关键字修饰方法时，内置锁会保护整个方法。在调用该方法前，需要获得内置锁，否则就会处于阻塞状态。</p></li><li><p>同步代码块<code>synchronized</code>修饰代码块</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(object) &#123;&#125;</span><br></pre></td></tr></table></figure><p> 被该关键字修饰的语句块会被自动加上内置锁，从而实现同步。</p><p> 同步是一种高开销的操作，所以应该尽量减少同步的内容。</p></li><li><p>使用特殊域变量<code>volatile</code>实现线程同步</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">int</span> account = <span class="number">100</span>;</span><br></pre></td></tr></table></figure><p> 只需要加上<code>volatile</code>就可以实现线程同步。</p><ol><li><code>volatile</code>关键字为域变量的访问提供了一种免锁机制</li><li>使用<code>volatile</code>修饰域相当于告诉虚拟机该域可能会被其它线程更新，因此每次使用该域都要重新计算，而不是使用寄存器的值</li><li><code>volatile</code>不会提供任何原子操作，也不能用来修饰<code>final</code>类型的变量</li></ol></li><li><p>使用重入锁实现线程同步</p></li><li><p>使用局部变量实现线程同步</p></li><li><p>使用阻塞队列实现线程同步</p></li><li><p>使用原子变量实现线程同步</p></li></ol></li><li><p><code>Synchronized</code>和<code>Lock</code>的区别</p><p> <code>Synchronized</code>：是Java的关键字，当它用来修饰一个方法或者一个代码块的时候，能够保证在同一时刻只有一个线程执行改该段代码。</p><p> <code>Lock</code>：是一个接口，主要有<code>Lock</code>、<code>ReadWriteLock</code>、<code>ReentrantLock</code>、<code>ReentrantReadWriteLock</code>等。</p><p> <strong>区别</strong>：</p><ul><li><code>Lock</code>是一个接口，而<code>Synchronized</code>是Java中的关键字，是内置的语言实现；</li><li><code>Synchronized</code>在发生异常的时候，会自动释放线程占有的锁，所以不会产生死锁现象；而<code>Lock</code>在发生异常的时候，如果没有主动通过<code>unLock()</code>方法去释放锁，则有可能会造成死锁现象，因此使用<code>Lock</code>时需要在<code>finally</code>块中释放锁；</li><li><code>Lock</code>可以让等待的锁的线程响应中断，而<code>Synchronized</code>不能；使用<code>Synchronized</code>时，等待的线程会一直等待下去，不能响应中断；</li><li><code>Lock</code>可以提高多个线程进行读操作的效率，通过<code>ReadWriteLock</code>去实现读写分离；</li></ul></li><li><p>锁的类型（悲观、乐观、可重入、可中断、公平、读写）</p><p> 见<a href="">Java锁的原理与类型</a></p></li><li><p>四种引用</p><ol><li><p>强引用：</p><p> 使用强引用时，属于不可回收的资源，垃圾回收器绝不会回收它。当内存空间不足时，Java虚拟机宁愿抛出<code>OutOfMemoryError</code>的异常，使程序终止，也不会回收具有强引用的对象来解决内存不足的问题。这是最常使用到的引用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br></pre></td></tr></table></figure></li><li><p>软引用：</p><p> 如果一个对象具有软引用，那么如果此时内存空间足够，垃圾回收器就不会回收它。但如果内存空间不足时，就会回收这些对象的内存。只要垃圾回收器还没有回收它，该对象就可以被程序使用。软引用可以和一个引用队列联合使用，如果软引用的对象被垃圾回收，Java虚拟机就会把这个软引用加入到与之关联的引用队列中。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">SoftReference reference = <span class="keyword">new</span> SoftReference(obj, queue);</span><br><span class="line"><span class="comment">// 强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><p> 当内存不足时，软引用对象被回收，<code>reference.get()</code>为<code>null</code>，将软引用的对象添加进ReferenceQueue队列中。</p></li><li><p>弱引用：</p><p> 弱引用的对象拥有更短的生命周期，只要垃圾回收器扫描到它，不管内存空间是否充足，都会回收它的内存。同理，弱引用也可以和引用队列一起使用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">WeakReference reference = <span class="keyword">new</span> WeakReference(obj, queue);</span><br><span class="line"><span class="comment">// 强引用对象滞空，保留弱引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>虚引用：</p><p> 虚引用不影响对象的生命周期，如果一个对象与虚引用关联，则相当于没有引用与之关联，虚引用在任何时候都可能被垃圾回收器回收。</p><p> 但是注意，虚引用必须和引用队列关联使用，当垃圾回收器准备与虚引用关联的对象时，会把这个虚引用添加到与之关联的引用队列中。</p><p> 因此，程序可以通过判断引用队列中是否已经加入了虚引用来判断对象是否要被垃圾回收。如果某个对象的虚引用已经被加入到引用队列中，那么就可以在该对象的内存被回收之前采取必要的行动。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line">ReferenceQueue queue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">PhantomReference reference = <span class="keyword">new</span> PhantomReference(obj, queue);</span><br><span class="line"><span class="comment">// 强引用对象滞空，保留软引用</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li><li><p>引用总结：</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20170628111722923.png" alt=""></p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20170628191146753.png" alt=""></p></li></ol></li><li><p>GC机制</p></li><li><p>线程池（ThreadPoolExecutor参数、线程池类型、线程池工作策略）</p></li><li><p>binder（binder内部具体类和方法，工作流程，IPC方式的比较）</p></li><li><p>HTTP响应码</p><ul><li>1XX：表示请求已经被收到了，需要进一步的处理才能完成；</li><li>2XX：成功处理请求；</li><li>3XX：重定向使用Location指向的资源或者缓存中的资源；</li><li>4XX：客户端出现错误，请求失败；</li><li>5XX：服务端出现错误，请求失败</li></ul></li><li><p>cookie/session的区别</p><ul><li>cooike数据保存在用户的浏览器上（临时文件夹中），session数据保存在服务器上；</li><li>cookie是以明文的方式存放在客户端的，不是很安全，别人可以通过分析存在在本地的cookie来进行COOKIE诈骗；</li><li>cookie会传递消息给服务器；session本身存放在服务器中，不会有传送流量；</li><li>生命周期：<ul><li>cookie的生命周期是累加的，从创建时开始计时，20分钟后生命周期结束</li><li>session的生命周期是间隔的，创建后20分钟内没有访问session就会被销毁；但如果20分钟内访问了session，就又要重新计算session的生命周期；</li></ul></li><li>session是一定时间内会存储在服务器中。当访问增多时会增加服务器的性能消耗，此时就可以考虑使用cookie；</li><li>cookie为多个用户浏览器共享，session为一个用户浏览器独享；</li></ul></li><li><p>Handler消息传递机制（内部机制、执行流程、线层切换）</p><p>Android应用程序被创建的时候都会创建一个UI主线程，但有时会进行一些比较耗时的操作，为了防止阻塞UI主线程，会把耗时的操作放到子线程中进行处理，处理完之后操作UI，但是又因为Android规定UI只能在主线程中操作，所以消息传递机制是为了解决Android应用的多线程问题。Handler是一种异步回调机制，它可以在完成一个耗时任务后做出相应的通知。</p><blockquote><p>首先需要在主线程中创建一个Handler对象，并重写<code>handleMessage()</code>方法，然后当子线程中需要进行UI操作时，就创建一个Message对象，并通过Handler的<code>sendMessage()</code>方法把这个消息发送出去。这个消息会进入到<code>MessageQueue</code>队列中等待被处理，而<code>Looper</code>会一直尝试从<code>MessageQueue</code>中取出待处理信息，最后发送回Handler的<code>handleMessage()</code>方法。</p><p>因为<code>Handler</code>是在主线程中创建的，所以<code>handleMessage()</code>方法也会在主线程中执行，所以最后就可以进行UI操作了。一条Message经过这个流程从子线程进入到了主线程，从不能更新UI变成了可以更新UI，整个异步消息处理的核心就是这样。</p></blockquote><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20190512113022344.jpg" alt=""></p></li><li><p>Android动画机制</p></li><li><p>自定义View</p></li></ol><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li><p>自我介绍</p></li><li><p>Retrofit源码（动态代理）</p></li><li><p>Glide源码</p></li><li><p>实现一个图片加载框架要考虑什么</p></li><li><p>HashMap源码，线程安全要用哪个（ConcurrentHashMap）</p><p> 官方文档中是这样描述HashMap的：</p><blockquote><p>Hash table based <strong>implementation of the Map interface</strong>. This implementation provides all of the optional map operations, and permits null values and the null key. (The HashMap class is roughly equivalent to Hashtable, except that it is <strong>unsynchronized</strong> and <strong>permits nulls</strong>.) This class makes no guarantees as to the order of the map; in particular, it does not guarantee that the order will remain constant over time.</p></blockquote><p> 这其中有几个关键的信息：基于Map接口实现、允许键/值为<code>null</code>、非同步、不保证有序（比如插入的排序）、也不保证序不随时间变化。</p><p> 所以：</p><ol><li><p>HashMap的特点：</p><p> 是基于Map接口时间的，存储键值对时，它接收键值对为<code>null</code>，是非同步的，HashMap存储着<code>Entry(hash, key, value, next)</code>对象。</p></li><li><p>HashMap的工作原理：</p><p> 通过hash的方法，通过put和get存储和获取对象。</p><p> 存储对象时，将键值对传递给put方法，它调用hashCode计算hash从而得到bucket的位置，进一步存储，HashMap会根据当前的bucket占用的情况自动调整容量（超过Load Factor则resize为原来的2倍）。</p><p> 获取对象时，把key传递给get，它调用hashCode计算hash从而得到bucket的位置，并进一步调用<code>equals()</code>方法确定键值对。如果发生碰撞的时候，HashMap通过链表将产生碰撞冲突的元素组织起来。如果一个bucket中碰撞冲突的元素超过某个限制（默认为8），则使用红黑树来替换链表，从而提高速度。</p></li><li><p>get和put的原理？<code>equals()</code>和<code>hashCode()</code>有什么作用？</p><p> 通过对key的<code>hashCode()</code>进行hashing，计算下标n-1和hash值，从而获得bucket的位置。如果产生碰撞，则利用<code>key.equals()</code>的方法去链表或树中去查找对应的节点。</p></li><li><p>hash如何实现的？</p><p> 在Java1.8中，是通过<code>hashCode()</code>的高16位异或低16位实现的：<code>(h = k.hashCode()) ^ (h &gt;&gt;&gt; 16)</code>，这么做可以在bucket的n比较小时，也能保证考虑到高低bit都参与到hash的计算中，同时不会有太大的开销。</p></li><li><p>如果HashMap大小超过了负载因子（load factor）定义的容量，怎么办？</p><p> 如果超过负载因子（默认为0.75），则resize一个原来长度两倍的HashMap，并且重新调用hash方法。</p></li><li><p>想要线程安全是使用HashMap还是ConcurrentHashMap？</p><p> HashMap线程是不安全的。例如：</p><ol><li>多线程环境下，put的时候导致的多线程数据不一致</li><li><p>HashMap的get操作可能会因为resize而引起死循环</p><p>ConcurrentHashMap是线程安全的。因为：</p></li><li><p>分段机制：segment，每段加reentrantLock可重入锁</p></li><li>定位元素：找segment的数组下标；找segment的HashEntry数组下标</li><li>get方法：不需要加锁，value值使用了volatile关键字修饰</li><li>put方法：hash计算端，锁定段，hash计算HashEntry数组，若超多阈值，就扩容释放；put过程中会modCount+1，为了后续的计算大小</li><li>size方法：为了求Map的大小，需要全局锁，但是性能差；所以采用modCount计算器，用于记录段的大小</li><li>弱一致性：clear时是不加锁的，所以多线程中可能会出现数据不一致</li></ol></li></ol></li><li><p>事件分发机制</p></li><li><p>滑动冲突（手写外部拦截法的伪代码）</p></li><li><p>性能优化</p></li><li><p>手写快排</p></li></ol><h2 id="字节跳动Android实习一二面"><a href="#字节跳动Android实习一二面" class="headerlink" title="字节跳动Android实习一二面"></a>字节跳动Android实习一二面</h2><h3 id="一面-3"><a href="#一面-3" class="headerlink" title="一面"></a>一面</h3><ol><li><p>Parcelable和Serializable是什么，做什么用，谁更高效？</p><p> <code>Serializable</code>是Java原生的接口，<code>Parcelable</code>是Android提供的接口。</p><ul><li><p><code>Parcelabel</code>：实现这个接口要重写三个方法，就是实现序列化过程要实现三个功能——<strong>序列化</strong>、<strong>反序列化</strong>、<strong>内容描述</strong>。</p><ul><li>序列化：由<code>writeToParcel()</code>方法完成，里面主要是<code>write</code>一些对象的属性</li><li>反序列化：由CREATOR完成，内部标明了如何创建序列化对象和数组，并通过<code>read</code>方法来完成反序列化过程</li><li><p>内容描述：重写<code>describeContents()</code>方法来完成，一般返回0，如果当前对象中存在文件描述时返回1</p><p><code>Parcelabel</code>开销小，效率高，使用场景为内存序列化。</p></li></ul></li><li><p><code>Serializable</code>：就是直接实现<code>Serializable</code>接口，无需实现方法，<code>Java</code>就会对这个对象进行高效的序列化操作。它简单，但是开销大，序列化过程的I/O操作过多，使用了反射，序列化过程慢，效率低，使用场景为序列化到本地或者通过网络传输。</p></li></ul></li><li><p>数据库中的事务</p><p> 数据库事务（Transaction）是访问并可能操作各种数据项的一个数据库操作序列，要么全部执行，要么全部不执行，是一个不可分割的工作单位。</p><ul><li>原子性：</li><li>一致性：</li><li>夺隔离性：</li><li>夺持久性：</li></ul></li><li><p>假如手机只有10M内存，想要申请1M的内存是否一定能成功？</p></li><li><p>讲一个时间片</p><p> 时间片表示进程在被抢占之前所能持续运行的时间。</p></li><li><p>对线程池的理解</p><p> 线程池就是事先将线程放到一个容器中，当使用线程的时候，就不用再新建一个线程，直接从线程中取出就好。可以用<code>execute()</code>方法启动线程池。</p><p> <strong>好处</strong>：</p><ol><li>降低资源消耗：重复利用线程池中的线程节省线程创建和销毁带来的消耗；</li><li>提高性能：当任务需求时，可以不用创建线程，而是可以直接从线程池中取出线程去执行，更高效；</li><li>提高线程的可管理性：如果频繁无限制地创建线程会消耗系统资源，降低系统稳定性导致系统崩溃、内存溢出等问题；</li></ol></li><li><p>想要在一个图片的右上角实现一个圆角是怎么实现的？</p></li><li><p>Java的四种引用</p></li><li><p>抖音无限上滑是怎么实现的？</p></li><li><p>什么时候会发生内存泄漏？</p></li><li><p>算法题：两数之和（时间复杂度）</p></li></ol><h3 id="二面-2"><a href="#二面-2" class="headerlink" title="二面"></a>二面</h3><ol><li><p>自我介绍，做过的项目</p></li><li><p>数据库频繁读取数据，可以用什么方式来优化（索引）</p></li><li><p>死锁的四个条件，开发过程中什么情况容易造成死锁</p></li><li><p>手机端应用和电脑端应用的注意事项和区别</p></li><li><p><code>public</code>父类中子类重写能不能用<code>protected</code>，反过来呢？</p></li><li><p>场景题：抖音开屏广告是如何实现的（包括倒计时和要播放的视频），倒计时点击跳过的时候应该如何实现？</p><p> 倒计时用Handler，播放的视频用url打开保存在本地的视频</p></li><li><p>算法题：二叉树的最长路径（DP）</p></li></ol><h2 id="字节跳动Android实习一二三四面"><a href="#字节跳动Android实习一二三四面" class="headerlink" title="字节跳动Android实习一二三四面"></a>字节跳动Android实习一二三四面</h2><h3 id="一面-4"><a href="#一面-4" class="headerlink" title="一面"></a>一面</h3><ol><li>自我介绍</li><li>操作系统线程和进程的同步机制和通信机制</li><li>手写Java双重检验的单例模式</li><li>数据库的索引和它的原理</li><li>Java的四种引用方式</li><li>OSI和TCP/IP的网络模型，路由器和交换机位于哪一层</li><li><code>synchronized</code>的类锁和对象锁的区别，哪些是对象锁，哪些是类锁</li><li>算法题：给一对无序数组，给一个target整数，然后找出数组中两个数字相加为target，并输出下标</li><li>给两对有序的数组，给出合并后有序的数组（数组合并）</li><li>http和https的区别</li><li>HTTP1和HTTP2的区别，HTTP2和HTTPS的关系</li><li>操作系统的分页分段管理，虚拟内存</li><li>Java的GC机制，引用计数和可达性分析算法，<code>finlize()</code>方法，四种回收算法，哪些对象可以作为GC ROOTS的对象</li><li>说一下Java的<code>synchronized</code>和<code>volatile</code>关键字，可见性、重排序、原子性</li><li>智力题：8个物品，有一个质量较大，如何两次称出它</li><li>算法题：最长连续子序列</li></ol><h3 id="二面-3"><a href="#二面-3" class="headerlink" title="二面"></a>二面</h3><ol><li>缓存溢出</li><li>Android中常用哪些控件</li><li>Glide的使用</li><li>RxJava的通信机制</li><li>Android四大组件</li><li>手写SQL语句，分组查询</li><li>中断是什么</li><li>算法题：汉诺塔</li></ol><h3 id="三面"><a href="#三面" class="headerlink" title="三面"></a>三面</h3><ol><li>了解bitmap的解析吗</li><li>设计一个自定义View，View中包含图片和文字，并且只能继承View</li><li>用过约束布局吗？它的特点和原理，比起相对布局的优势</li><li>Glide相关</li><li>https的加密过程，为什么要这么做</li><li>浏览器输入一个url后发生了什么，DNS协议的原理</li><li><code>get</code>和<code>post</code>的区别</li><li>封装一个单链表，要求实现删除，添加，反转的方法</li><li>算法题：数组反转，给定一个target整数，每target长度反转一次</li></ol><h3 id="四面"><a href="#四面" class="headerlink" title="四面"></a>四面</h3><ol><li>看过哪些Android源码</li><li>OkHttp的缓存策略</li><li>除了Glide还用过哪些图片加载框架</li><li>Activity的四种启动方式，区别</li><li>Android的线程同步机制和进程通信机制</li><li>Java中的泛型，类型擦除</li></ol><h2 id="阿里河马Java实习一面"><a href="#阿里河马Java实习一面" class="headerlink" title="阿里河马Java实习一面"></a>阿里河马Java实习一面</h2><ol><li>自我介绍</li><li>面向对象三大特性</li><li>继承和接口的区别</li><li>重写、重载的原理，重载和重写各自应用的场景</li><li><code>int</code>和<code>Integer</code>的区别，为什么会有<code>Integer</code>缓冲池？<code>Integer</code>缓冲池细节，比如<code>Integet a = 1; Integer b = new Integet(1)</code>，a和b比较返回true还是false？</li><li>Object类有什么方法？</li><li><code>HashCode</code>有什么作用？<code>equals</code>和<code>HashCode</code>有什么关系？</li><li><code>HashCode</code>在<code>HashMap</code>中的作用？<code>HashMap</code>和<code>ConcurrentHashMap</code>的区别？</li><li>什么是线程安全的？操作变量情景下怎么样才是线程安全的？怎么样是线程不安全的？</li><li>多个线程操作局部变量，静态变量的情况下，虚拟机是怎么分配内存的？</li><li><code>Synchronized</code>的实现原理，锁的升级过程，修饰实例对象和<code>class</code>的区别</li><li>讲一下<code>wait</code>、<code>notify</code>、<code>notifyAll</code>，<code>notify</code>能具体指定唤醒一个实例吗？为什么是随机唤醒，底层是如何实现的？</li><li>讲一下<code>ClassLoader</code>，jre下的jar包是由什么加载的？</li><li>讲一下<code>Exception</code>和<code>Error</code></li><li>用户线程和守护线程的区别和使用场景？守护线程能否访问数据库？</li><li>TCP三次握手。为什么不能只用两次和四次？TCP四次挥手</li><li>HTTP和HTTPS的区别。给你一个网站，考虑使用HTTP还是HTTPS？</li><li>讲一下你理解的MVC，SpringMVC的处理流程，拦截请求是怎么实现的？</li><li>讲一下IOC和AOP编程</li><li>什么时候用索引？什么时候不用？</li><li>分布式事务如何保证一致性？</li><li><code>HashMap</code>的实现原理？<code>get</code>和<code>put</code></li></ol><h2 id="京东数科一面"><a href="#京东数科一面" class="headerlink" title="京东数科一面"></a>京东数科一面</h2><ol><li>常见的集合<code>collection</code>和<code>collections</code>的区别</li><li><code>list</code>和<code>set</code>的区别，以及各自的子类</li><li><code>HashMap</code>的原理</li><li><code>ConcurrentHashMap</code>的原理</li><li><code>start</code>和<code>run</code>的区别，线程状态等</li><li>线程池工作原理，核心参数，阻塞队列；常见的两种阻塞队列有何不同？</li></ol><h2 id="字节跳动后端实习一二面"><a href="#字节跳动后端实习一二面" class="headerlink" title="字节跳动后端实习一二面"></a>字节跳动后端实习一二面</h2><h3 id="一面-5"><a href="#一面-5" class="headerlink" title="一面"></a>一面</h3><ol><li>数据库隔离级别</li><li>数据库事务特性</li><li><code>select</code>、<code>epoll</code>、<code>poll</code></li><li>Java运行时内存区域</li><li>避免死锁的方式</li><li>手撕代码：<font color="red">最长上升子序列的个数</font></li></ol><h3 id="二面-4"><a href="#二面-4" class="headerlink" title="二面"></a>二面</h3><ol><li>手撕代码：最长的不包含重复字符的子串长度</li><li>DNS解析过程</li></ol><h2 id="美团Java实习一面"><a href="#美团Java实习一面" class="headerlink" title="美团Java实习一面"></a>美团Java实习一面</h2><ol><li><code>Integer</code>缓冲池，<code>long</code>是否有？</li><li><code>HashMap</code>底层实现</li><li><code>HashMap</code>线程安全吗？解释一下发生链表死循环？</li><li><code>Map</code>下有哪些线程安全？</li><li><code>ConcurrentHashMap</code>的实现，<code>HashTable</code>和<code>HashMap</code>的区别</li><li><code>ConcurrentHashMap</code>的<code>size</code>操作是怎么做的？需要加锁吗？</li><li>Java的内存回收，什么时候会内存回收？</li><li>GC算法</li><li>Java垃圾回收器</li><li>MySQL的引擎</li><li>事务的概念</li></ol><h2 id="字节跳动测试开发实习一二面"><a href="#字节跳动测试开发实习一二面" class="headerlink" title="字节跳动测试开发实习一二面"></a>字节跳动测试开发实习一二面</h2><ol><li>Git常用命令，有冲突时会怎么做？</li><li>UDP和TCP的区别？</li><li>进程和线程</li><li>手撕代码：链表判断入环点</li><li>手撕代码：翻转句子中的单词</li><li>Java的<code>int</code>的取值范围</li><li>Java的内存模型</li><li><code>Student s = new Student()</code>在内存中都经历了什么</li><li><code>get</code>和<code>post</code>请求</li><li>输入一个url到显示网页的过程</li><li>编程题：字符串中的英文单词逆序，可能包含N个</li><li>编程题：数组重排，将当前数字成为后面第一个比自己打的数字，如果没有填-1，要求最优的时间复杂度</li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>面试经历</title>
      <link href="/2020/03/03/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/"/>
      <url>/2020/03/03/%E9%9D%A2%E8%AF%95%E7%BB%8F%E5%8E%86/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><p>以下是秋招的面试经历。</p><h2 id="中信银行信用卡中心"><a href="#中信银行信用卡中心" class="headerlink" title="中信银行信用卡中心"></a>中信银行信用卡中心</h2><ol><li>Github主页</li><li>数据库MySQL的底层引擎</li><li>安卓端Java与后端Java有啥区别</li><li>快速排序的原理</li><li>使用$O(n)$的时间复杂度，搭配快速排序的原理，找出第K大的元素</li><li>熟悉设计模式</li><li>机器学习相关的</li></ol><h2 id="交行软开"><a href="#交行软开" class="headerlink" title="交行软开"></a>交行软开</h2><ol><li><p>JVM有了解吗？内存泄漏与内存溢出的区别</p><ul><li><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；</p></li><li><p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存，迟早会被占光。</p></li></ul><hr><p> 内存泄漏的根本原因是长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象已经不再需要，但由于长生命周期对象持有它的引用而导致不能被回收。</p></li><li><p>垃圾回收机制，算法</p></li><li>数据库的主键和索引的区别</li><li><p>了解哪些设计模式？一个计算器，有加减乘除的功能，去计算最终的值，要用到哪中设计模式合适？</p><ul><li>单例模式</li><li>观察/订阅模式</li><li>建造者模式</li><li><p>适配器模式</p><p>我认为可以使用到简单工厂模式。</p></li></ul><hr><p> 经过查找网上类容，发现是使用<strong>解释器模式</strong>。不得不说这个问的模式相对较冷门。</p></li><li><p>熟悉哪些Linux命令</p><ul><li><code>ls</code>：列举出当前工作目录的内容</li><li><code>mkdir</code>：创建一个新的目录</li><li><code>pwd</code>：显示当前工作目录</li><li><code>cd</code>：切换文件路径</li><li><code>rm</code>：删除给定的文件</li><li><code>cp</code>：复制文件</li><li><code>mv</code>：移动文件</li><li><code>cat</code>：在标准输出上查看文件内容</li><li><code>find</code>：在给定位置搜寻与条件匹配的文件</li><li><code>tar</code>：创建、查看和提取tar格式的压缩文件</li><li><code>help</code>：在终端列出所有可用的命令</li><li><code>exit</code>：结束当前的终端会话</li><li><code>ping</code>：通过发送数据报ping远程主机（服务器）</li><li><code>su</code>：切换不同的用户</li><li><code>shutdown</code>：用于关闭计算机</li></ul></li></ol><h2 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h2><h3 id="一面"><a href="#一面" class="headerlink" title="一面"></a>一面</h3><ol><li>ArrayBlockingQueue</li></ol><h3 id="二面"><a href="#二面" class="headerlink" title="二面"></a>二面</h3><ol><li><p>合并两个有序数组的序列</p><p> Leetcode 21.</p></li></ol><h2 id="永辉"><a href="#永辉" class="headerlink" title="永辉"></a>永辉</h2><h2 id="浙商银行"><a href="#浙商银行" class="headerlink" title="浙商银行"></a>浙商银行</h2><ol><li>安卓端与后端怎么交互的</li><li><p>后端交互数据的时候，是怎么加密的？是明文传输吗？没有用到Https吗？</p><ul><li>通信请求使用https</li><li>对请求参数进行签名，防止数据被踹改</li><li>对请求参数以及响应进行加密解密处理</li><li>APP中使用ssl pinning防止抓包操作</li></ul></li></ol><h2 id="万物心选"><a href="#万物心选" class="headerlink" title="万物心选"></a>万物心选</h2><ol><li>了解红黑树吗</li><li>了解动态规划吗</li><li>OkHttp与Retrofit的原理</li><li>HttpConcention的原理</li><li>Handler的原理</li><li>ThreadLocal了解吗</li><li>RecyclerView与ListView的区别</li></ol><h2 id="格力"><a href="#格力" class="headerlink" title="格力"></a>格力</h2><ol><li>MVP架构的理解</li><li>设计数据库</li></ol><h2 id="金山WPS"><a href="#金山WPS" class="headerlink" title="金山WPS"></a>金山WPS</h2><ol><li><p>怎么判断图的两个节点是否是连通的</p><ul><li>深度优先遍历：从根开始深度优先遍历，设置一个全局变量count去记录。如果最终count的值与顶点的数量是相同的，则是连通图，反之则不是。</li><li>广度优先遍历</li><li>并查集</li></ul></li><li><p>介绍一下TCP三次握手</p></li><li><p>类加载的过程，了解双亲委派模型吗</p><p> 类加载的全过程分为：「<strong>加载、验证、准备、解析和初始化</strong>」这5个阶段。</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/12" alt=""></p><p> 类加载器的作用是将编译器编译生成的二进制.class文件加载到内存中，进而转化成虚拟机中的类。Java内置了三种类加载器：</p><ul><li>启动类加载器 Bootstrap Class Loader：负责Java核心类</li><li>扩展类加载器 Extensions Class Loader：负责加载<code>\jre\lib\ext</code>目录下的JAR包</li><li><p>系统类加载器 System Class Loader：负责加载所有应用程序级别的类到JVM</p><p>除此之外，还可以自定义类加载器。</p></li></ul><hr><p> <strong>双亲委派模型</strong>的工作过程如下：</p><p> 当类加载器收到类的加载请求时，首先不会自己去加载这个类，而是会把这个请求委派给父类加载器去完成。每个层次的类加载器都是这样的，所有的加载请求都会传送到顶层的启动类加载器，只有父类加载器无法完成时，才会交给子加载器去完成。</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/13" alt=""></p><p> 双亲委派模型遵循三个原则：</p><ul><li>「委托性原则」：当子类加载器收到类的加载请求时，会将加载请求向上委托给父类加载器。</li><li>「可见性原则」：允许子类加载器查看父类加载器加载的所有类，但是父类加载器不能查看子类加载器加载的类。</li><li>「唯一性原则」：双亲委派的机制保证了Java类的唯一性。比如写了一个和JRE核心类同名的Object类，这时候双亲委派机制就会发挥作用了，避免自定义的类覆盖核心类。它会首先将加载类的请求，委托给Application ClassLoader去加载，再被其委托给Extension ClassLoader去加载，再被委托给BootStrap ClassLoader。因为启动类加载器发现已经加载了核心类Object类，就不会再去加载自定义的Object类。</li></ul></li><li><p>能举例子说明一下多态吗</p><p> Java的多态主要是指在运行时才知道调用哪个方法而不是编译时就能得知的一种机制。</p><p> 方法的<strong>重载</strong>和<strong>重写</strong>就是典型的Java多态性的不同变现。重写是父类与子类的多态表现，重载是一个类的多态的表现。</p></li><li><p>泛型的类型擦除</p><p> 如果一个方法接收<code>List&lt;Object&gt;</code>作为形参，而如果传递<code>List&lt;String&gt;</code>进去作为实参，是无法通过编译的，尽管String是Object的子类。</p></li></ol><h2 id="卓盟科技"><a href="#卓盟科技" class="headerlink" title="卓盟科技"></a>卓盟科技</h2><h2 id="农业银行数据中心"><a href="#农业银行数据中心" class="headerlink" title="农业银行数据中心"></a>农业银行数据中心</h2><p>线下面</p><h2 id="58同城"><a href="#58同城" class="headerlink" title="58同城"></a>58同城</h2><h3 id="一面-1"><a href="#一面-1" class="headerlink" title="一面"></a>一面</h3><h3 id="二面-1"><a href="#二面-1" class="headerlink" title="二面"></a>二面</h3><ol><li>问项目</li><li>手写一个数据结构</li></ol><h2 id="多益网络"><a href="#多益网络" class="headerlink" title="多益网络"></a>多益网络</h2><ol><li>自我介绍</li><li><p>介绍自己的项目，项目中用到了谷歌的ZXing库，如果自己实现这个扫描二维码的框架，因为外界条件不清晰，如何改进</p><p> 面试官给提供的思路是，由于光线或者手机摄像头对准的位置等外界因素，所以会导致二维码模糊不清无法读取，那么改进方法就是精准地显示二维码的位置。常用的技术是界面上会出现一个正方形的框，然后当摄像头识别到二维码后，会放大到二维码那里，聚焦。</p></li><li><p>TCP和UDP的区别</p></li><li><p>现在视频是用TCP还是UDP？如果UDP发送数据丢包，怎么解决这个问题</p><p> UDP丢包率高的原因有：</p><ul><li>接收端处理时间过长导致丢包</li><li>发送的包巨大丢包</li><li>发送的包较大，超过接受者缓存导致丢包</li><li><p>发送的包频率太快</p><p>解决方法有：</p></li><li><p>控制报文大小</p></li><li>增加系统发送或者接受缓冲区的大小</li><li>增加应答机制，处理完一个包后，再继续发包</li><li>在应用层实现丢包重发机制和超时机制，确保数据包不丢失。</li></ul></li><li><p>http和https的区别</p></li><li><p>HashSet了解吗，介绍一下原理是如何实现的</p><p> HashSet实现自set接口，set集合中元素无序且不能重复；</p><p> HashSet底层是基于HashMap实现的，当你new一个HashSet时，实际上是new一个map，执行add方法时，实际上是调用map的put方法；将key-value放入HashMap中，根据key的hashCode返回值决定存储位置，如果hash相同，则存储位置相同。如果两个key的equals比较返回true，那么新添加的value就会覆盖原有的value，key不会覆盖。如果向HashSet中添加一个已经存在的元素，则不会覆盖原有的集合元素。</p></li><li><p>HashMap原理是如何实现的，是线程安全的吗？如果让你来写，怎么实现线程安全</p></li><li><p>RecyclerView怎么实现树形结构TreeView</p><p> 需要构造节点类Node，含有的属性包括：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String id;  <span class="comment">// 节点的唯一标识</span></span><br><span class="line"><span class="keyword">private</span> String pid; <span class="comment">// 当前节点的父节点</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> level;  <span class="comment">// 所在层级</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">boolean</span> expand; <span class="comment">// 当前是否是展开的状态</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> choosed;    <span class="comment">// 选中的状态</span></span><br><span class="line"><span class="keyword">private</span> String showText;    <span class="comment">// 展示的文本</span></span><br><span class="line"><span class="keyword">private</span> List&lt;Node&gt; childs = <span class="keyword">new</span> ArrayList&lt;&gt;();  <span class="comment">// 子节点</span></span><br></pre></td></tr></table></figure></li><li><p>RecyclerView的item复用怎么实现</p></li><li>AsyncTask的底层是如何实现的（原理）</li><li>与Handler之间的区别，Handler消息传递机制</li><li>常用的设计模式怎么写，单例模式怎么写，工厂模式，观察者模式</li><li><p>Retrofit和OkHttp之间的区别</p><p>Retrofit底层对网络的访问默认是基于OkHttp，不过Retrofit非常适合于Restful url风格的请求，更多使用注解的方式提供功能，下面这个网络请求流程图，可以更直观的理解OkHttp和Retrofit的关系。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/0d01a0eacefaf04f4012cb3dc0d05145.png" alt=""></p><p>网络请求：App发起网络请求，Retrofit通过注解配置请求参数、Header、BaseUrl之后，通过OkHttp发送网络请求给服务器；</p><p>服务器响应：服务器返回响应数据，OkHttp将数据传递给Retrofit，再把数据直接传递给应用，界面刷新反馈结果给用户；</p><ul><li>Retrofit主要负责应用层面的封装，主要方便使用，比如请求参数、响应数据的处理，错误处理等等；</li><li>OkHttp主要负责socket部分的优化，比如多路复用、buffer缓存、数据压缩等；</li></ul><p>网上一般推荐RxJava + Retrofit + OkHttp框架，Retrofit负责请求的数据和请求的结果，使用接口的方式呈现，OkHttp负责请求的过程，RxJava负责异步，各种线程之间切换。</p></li><li><p>OkHttp的实现原理</p></li><li>Service的两种启动方式，两种方式之间的区别</li><li>广播的类型和注册方式，静态注册和动态注册之间的区别</li><li>Glide的原理，缓存机制</li><li>Lru算法是如何实现的</li><li>如何判断一个单向链表是否有环，并返回环的长度</li></ol><h2 id="墨迹天气"><a href="#墨迹天气" class="headerlink" title="墨迹天气"></a>墨迹天气</h2><ol><li>自己说项目经历，说一下在项目中遇到的难点并且怎么解决的</li><li>职业规划是什么，为什么选择做移动端</li><li>自定义View的流程</li><li><code>onMeasure()</code>、<code>onLayout()</code>、<code>onDraw()</code></li><li><p>事件分发机制有了解吗</p><p> Android事件分发总是遵循Activity =&gt; ViewGroup =&gt; View的传递顺序；</p><p> 三个与事件分发机制有关的方法：</p><ul><li><code>dispatchTouchEvent()</code>：事件分发</li><li><code>onTouchEvent()</code>：事件处理</li><li><code>onInterceptTouchEvent()</code>：事件拦截</li></ul><hr><p> <code>dispatchTouchEvent()</code>是负责事件分发的。当点击事件发生后，事件首先会传递给当前的Activity，然后会调用Activity的<code>dispatchTouchEvent()</code>方法。</p><p> <code>onTouch()</code>执行总优先于<code>onClick()</code></p></li><li><p>点击一个Button，发起网络请求，将获取到的数据展示到页面上，怎么优化它的速度/流程？</p><p> 从点击按钮出现点击时间，开启子线程发起网络请求，这是一个优化点。</p><p> 请求到的数据如何显示在页面上，这是一个优化点，例如三级缓存机制。</p></li><li><p>Handler的消息传递机制</p></li><li><p>MessageQueue中是以什么样的策略去存储消息的</p><p> MessageQueue实际上是以单链表的形式存储Handler发送过来的消息，有利于插入、删除的操作，主要有两个操作：</p><ul><li>通过<code>enqueueMessage(Message msg, long when)</code>向队列插入一个消息</li><li>通过<code>next()</code>从无限循环队列中取出消息，并从消息队列中删除。</li></ul></li><li><p>进程调度策略</p></li><li><p>内存泄露有了解吗？怎么样去处理内存泄漏</p><blockquote><p>内存泄漏：程序申请的内存空间，在使用完毕后未释放，一直占据内存单元。</p></blockquote><p>我们创建了一个对象，会在<strong>堆内存</strong>中给这个对象申请一块内存空间，假如调用了一次或者几次，之后就没有再调用，但仍然占据着内存。</p><p>Java可以使用垃圾回收机制。</p></li><li><p>三级缓存机制</p></li><li>有了解Glide框架中的最少未使用机制Lru算法吗？</li><li>怎么设计一个数据结构去实现Lru算法</li><li><p>RxJava里的操作符，如果是进行多个网络请求，用哪个操作符</p><p>RxJava操作符<code>zip()</code>：使用一个函数组合多个Observable发射的数据集合，然后再发射这个结果。</p><blockquote><p>通过<code>Observable.zip()</code>方法把多个Observable组合成新的Observable。</p></blockquote></li><li><p>了解哪些设计模式</p></li><li>介绍一下快速排序算法，还了解哪些排序算法</li></ol><h2 id="新浪微博"><a href="#新浪微博" class="headerlink" title="新浪微博"></a>新浪微博</h2><ol><li>ArrayList和LinkedList的区别，它们哪个插入元素是可重复的和不可重复的，哪个是线程安全的</li><li>数据结构中有一个哈希表HashMap，它是不是线程安全的，怎么变成线程安全的</li><li><p>List中存入数据，例如int类型的数据，是直接存入int类型吗？</p><p> 不是，因为存在自动装箱与拆箱，所以是存入它们的引用类型。</p></li><li><p>最近看过什么技术书，说说MVC、MVP和MVVM</p></li><li>图片框架的缓存机制。</li><li>Glide如果加载9张图片，那么是从上往下加载吗？</li><li>除了Http连接和TCP连接之外，还有什么连接</li><li><p>RxJava和Retrofit用到的一些基本的方法</p><p> RxJava的三个概念：</p><ul><li>Observable：被观察者（主题Subject）</li><li>Observer/Subscriber：观察者</li><li><p>Subscribe：订阅</p><blockquote><p>Observable和Observer通过subscribe()方法实现订阅关系</p></blockquote><p>使用的一种简单方法：</p></li></ul><ol><li><p>创建被观察者Observable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;String&gt; <span class="title">getObservable</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> ObservableOnSubscribe&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(ObserableEmitter e)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">// 只需要三个方法onNext | onError | onCompleted</span></span><br><span class="line">            e.onNext(<span class="string">""</span>);</span><br><span class="line">            e.onNext(<span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">            e.onComplete();</span><br><span class="line"></span><br><span class="line">            <span class="comment">// e.onError();</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>创建观察者Observer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observer&lt;String&gt; <span class="title">getObserver</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Observer&lt;String&gt;() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 发生错误时调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onComplete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 数据接收完成时调用</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onSubscribe</span><span class="params">(Disposable d)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 移除订阅关系</span></span><br><span class="line">            <span class="comment">// d.dispose();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 判断是否取消订阅关系</span></span><br><span class="line">            <span class="comment">// d.isDisposed();</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(String s)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// 正常接收数据时调用</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>订阅</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Observable&lt;String&gt; observable = getObservable();</span><br><span class="line">Observer&lt;String&gt; observer = getObserver();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 关联观察者和被观察者 -&gt; 订阅</span></span><br><span class="line">observable.subscribe(observer);</span><br></pre></td></tr></table></figure></li></ol><hr><p> Retrofit的使用方法：</p><ol><li><p>创建接口，设置请求类型和参数，例如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GET</span>(<span class="string">"userInfo/login"</span>)</span><br><span class="line"><span class="function">Call <span class="title">login</span><span class="params">(@Query(<span class="string">"username"</span>)</span> String username, @<span class="title">Query</span><span class="params">(<span class="string">"password"</span>)</span> String password)</span>;</span><br></pre></td></tr></table></figure></li><li><p>创建Retrofit对象，设置数据解析器等</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Retrofit retrofit = <span class="keyword">new</span> Retrofit.Builder().baseUrl(BASE_URL).addConverterFactory(GsonConverterFactory.create()).build();</span><br></pre></td></tr></table></figure></li><li><p>生成接口对象，调用接口方法获取Call对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">My my = retrofit.create(My.class);</span><br><span class="line">Call call = my.login(<span class="string">""</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">call.enqueue(<span class="keyword">new</span> Callback() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onResponse</span><span class="params">(Call call, Response response)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onFailure</span><span class="params">(Call call, Throwable e)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure></li></ol></li><li><p>TCP的三次握手</p></li><li><p>了解什么Jetpack组件吗</p><p>LifeCycle、ViewModel、LiveData、Paging、Room、Navigation、DataBinding等</p></li><li><p>了解Comparable接口吗</p><p>Comparable &amp; Comparator 接口都是用来实现集合中元素的比较、排序的，只是 Comparable 是在集合内部定义的方法实现的排序，Comparator 是在集合外部实现的排序。</p></li><li><p><code>git merge</code>和<code>git rebase</code>的区别</p></li><li><p>使用了哪种Git图形界面客户端</p><p>SourceTree</p></li></ol><hr><p>以下是春招的面试经历。</p><h2 id="华为海思"><a href="#华为海思" class="headerlink" title="华为海思"></a>华为海思</h2><h2 id="字节跳动"><a href="#字节跳动" class="headerlink" title="字节跳动"></a>字节跳动</h2><ol><li><p>算法题：</p><p> 输入一维数组array和n，找出和值为 n 的任意两个元素。例如：</p><p> array = [2, 3, 1, 10, 4, 30]</p><p> n = 31</p><p> 则结果应该输出1, 30 顺序不重要</p><p> 如果有多个满足条件的，返回任意一对即可。要求空间复杂度为 O(1)。</p></li><li><p>自我介绍</p></li><li><p>公司负责了哪些工作？怎么重构的？</p></li><li><p>MVP和MVC的区别？Model层的作用呢？</p></li><li><p>UI界面有哪些布局？</p></li><li><p>约束布局与相对布局有什么不同？</p></li><li><p>线性布局：如果有两个控件，一个宽度固定，一个宽度不固定，怎么让它们横向充满整个父布局？</p></li><li><p>RecyclerView有100个item，怎么让它们显示出来还不会内存泄漏？怎么直接跳转到第53个item？</p><p> 分页显示。</p><p> 第一种：「<strong>能够实现指定位置处于屏幕顶部，但是不具有平滑滚动的视觉效果</strong>」。即使用<code>scrollToPosition()</code>的方法。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (position != -<span class="number">1</span>) &#123;</span><br><span class="line">    mRecycleview.scrollToPosition(position);</span><br><span class="line">    LinearLayoutManager mLayoutManager = (LinearLayoutManager) mRecycleview.getLayoutManager();</span><br><span class="line">    mLayoutManager.scrollToPositionWithOffset(position, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p> 第二种：「<strong>能够实现指定位置处于屏幕顶部，具有平滑滚动视觉的效果</strong>」。</p><ol><li>如果跳转位置在第一个可见位置之前，就用<code>smoothScrollToPosition()</code>方法就可以直接跳转；</li><li>如果跳转位置在第一个可见项之后，最后一个可见项之前，就需要用<code>smoothScrollBy</code>来滑动到指定位置；</li><li>如果要跳转的位置在最后可见项之后，则先调用<code>smoothScrollToPosition()</code>将跳转的位置滚动到可见位置，再<code>addOnScrollListener()</code>里通过<code>onScrollStateChanged()</code>控制，调用<code>smoothMoveToPosition()</code>再次执行判断。</li></ol></li><li><p>Handler的消息传递机制</p></li><li><p>Activity的生命周期？启动方式？</p></li><li><p>从Activity A跳转到Activity B，两个Activity的生命周期？</p></li><li><p>Service的启动方式？</p></li><li><p>Broadcast的相关知识点？</p></li><li><p>Java有哪几种引用？</p></li><li><p>接触过哪些容器类？HashMap的原理有了解吗？如果Hash值计算相同，会发生哈希碰撞吗？怎么解决？</p></li><li><p>泛型的原理与使用</p></li><li><p>http与https的区别</p></li><li><p>https是怎么加密的</p></li><li><p>死锁是什么？死锁的条件</p></li><li><p>操作系统的进程调度策略有哪些？</p><p>FCFS（先来先服务）、优先级、时间片轮转、多级反馈</p></li><li><p>数据库的索引，主键与事务</p></li><li><p>数据库的<code>join()</code>方法</p><p>数据库中的<code>join()</code>方法是连接，主要作用是根据两个或者多个表中的列之间的关系，获取存在于不同表中的数据，有全连接、内连接、外连接等。</p></li></ol><h2 id="微信读书"><a href="#微信读书" class="headerlink" title="微信读书"></a>微信读书</h2><h2 id="腾讯教育"><a href="#腾讯教育" class="headerlink" title="腾讯教育"></a>腾讯教育</h2><ol><li><p>自我介绍</p></li><li><p>实习经历简介，负责了哪些？</p></li><li><p>MVP模式</p><p> 模型层（Model）：主要是获取数据功能，业务逻辑和实体模型。</p><p> 视图层（View）：对应于Activity或Fragment，负责视图的部分展示和业务逻辑用户交互。</p><p> 控制层（Presenter）：负责完成View层与Model层之间的交互，通过Presenter获取Model的数据返回给View，使得View与Model之间没有耦合。</p></li><li><p>网络请求框架有了解过内部的原理吗？</p></li><li><p>主线程怎么把数据交给子线程？Handler和AsyncTask？</p></li><li><p>除了约束布局，还有什么线性布局还是相对布局？它们之间的区别是什么？</p><p> LinearLayout是将多个View水平或者垂直排列；RelativeLayout可以通过确定两个或多个组件的相对位置来摆放组件。</p></li><li><p>有没有遇到过一个布局中嵌套的布局非常多？会出现什么情况？</p><p> Android界面的布局太复杂，嵌套层次过深，会使得整个界面的测量、布局和绘制变得更复杂，对性能会造成影响。</p></li><li><p>有没有遇到过界面卡顿的情况吗？什么情况会造成界面卡顿？</p></li><li><p>View的绘制流程？执行的顺序？</p></li><li><p>有没有了解过一些事件传递机制？</p></li><li><p>Java虚拟机有哪几种内存？哪些内存是独立的，哪些是共享的？方法区分为哪些？</p><p>方法区（线程共享）：各个线程共享的一个区域，用于存储虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。<strong>运行时常量池</strong>是方法区的一部分，用于存放编译器生成的各种字面量和符号引用。</p></li><li><p>HashMap的原理？<code>put</code>方法发生冲突会怎么样？</p></li><li><p>垃圾回收机制？怎么判断什么时候会被回收？</p></li><li><p>https和http的区别？</p></li><li><p>Socket有了解吗？</p><p><strong>Socket相关面试题</strong>：</p><p>Socket是对TCP/IP协议簇的一种封装，是应用层与TCP/IP协议簇通信的中间软件抽象层。</p><p>TCP和UDP的区别：</p><ol><li>TCP提供面向连接的传输，通信前要先建立连接（三次握手机制）；UDP提供无连接的传输，通信前不需要建立连接；</li><li>TCP提供可靠的传输（有序、无差错、不丢失、不重复）；UDP提供不可靠的传输；</li><li>TCP是面向字节流的传输，所以能将信息分隔成组，并在接收端将其重组；UDP是面向数据报的传输，没有分组开销；</li><li>TCP提供拥塞控制和流量控制机制；UDP不提供拥塞控制和流量控制机制</li></ol></li><li><p>长连接和短连接的区别？HTTPS是长连接吗？</p><p>在HTTP/1.0中，默认使用短连接。就是浏览器和服务器每进行一次HTTP操作，都会建立一次连接，任务结束后就会断开连接。</p><p>在HTTP/1.1中。默认使用长连接。使用长连接的情况下，当某个网页打开完毕之后，客户端和服务器之间的TCP连接不会关闭，如果客户端再次访问该服务器上的网页，会使用上一次已经建立的连接。但是长连接不是永久的连接，它有一个保持时间</p></li><li><p>Activity生命周期？切换横竖屏的生命周期？</p><p>切换横竖屏的生命周期：</p><p><code>onPause</code>$\rightarrow$ <code>onSaveInstanceState</code>$\rightarrow$ <code>onStop</code>$\rightarrow$ <code>onDestory</code>$\rightarrow$ <code>onCreate</code>$\rightarrow$ <code>onStart</code>$\rightarrow$ <code>onRestoreInstanceState</code>$\rightarrow$ <code>onResume</code></p></li><li><p>进程和线程的区别是什么？</p></li><li><p>介绍下快排，时间复杂度？</p></li><li><p>如何快速找到一个单链表的中间节点？</p><p>快慢指针法。当快指针遍历完整个链表后，慢指针才遍历到一半的链表，则正好是单链表中间节点的位置。</p></li></ol><h2 id="阿里飞猪"><a href="#阿里飞猪" class="headerlink" title="阿里飞猪"></a>阿里飞猪</h2><ol><li><p>自我介绍</p></li><li><p>问项目相关的。第一个项目，一个做还是团队？练手的还是可以商用的？你做了其中的哪几个部分？给我讲一下，然后看一下代码的风格；</p></li><li><p>第二项目，这个其中的文章是通过url打开webview实现的吗？介绍其中用到的框架？为什么要用这些网络框架，不用自带的网络请求方式？网络框架这么多，为什么选用这个框架？</p><p> Retrofit是一个封装了Http请求的框架，底层的网络请求也是使用OkHttp实现的。使用它主要是能与RxJava配合使用。</p><p> 它的原理大致是：</p><blockquote><ol><li>通过建造者模式构建一个Retrofit实例，配置baseUrl，convertfactory（用来将请求的结果转化为特定的对象，例如GsonConverterFactory）等；</li><li>通过Retrofit对象的create(Class<T> service)方法返回一个Service的动态代理对象，在调用service的方法时去调用动态代理的invoke方法；</li><li>invoke方法会把method进行解析，解析我们在接口中配置的各种注解，最后构造成ServiceMethod对象，并将结果缓存起来，下次调用就不用再解析了。ServiceMethod对象可以生成Request对象，将对象注入到OkHttpCall中，然后通过callAdapter转化为用户希望得到的返回对象，默认直接返回Call对象。</li><li>得到Call对象之后，再调用execute或者enqueue方法，前者是同步请求，后者异步请求，这个方法里面就封装了OkHttp的方法。</li></ol></blockquote></li><li><p>Glide框架你了解多少，大概是怎么实现的？缓存机制有几级缓存？</p><p> Glide的缓存机制分为2种缓存，一种是内存缓存，一种是磁盘内存。</p><p> 用内存缓存的原因是：防止应用重复将图片读入到内存中，造成内存资源浪费；</p><p> 用内存缓存的原因是：防止应用重复的从网络或者其它地方下载和读取数据；</p><p> <strong>缓存机制中有三级缓存原理</strong>：</p><p> 读取一张图片的时候，获取顺序：Lru算法缓存$\rightarrow$ 弱引用缓存$\rightarrow$ 磁盘缓存（如果设置了）。</p><blockquote><p>当想要加载某些图片的时候，先去LruCache中寻找图片，如果LruCache中有图片，就直接取出来用，并将图片放入到WeakReference中，如果LruCache中没有，则去WeakReference中寻找，如果WeakReference中有，就从WeakReference中取出图片使用，如果WeakReference中没有图片，那么就从磁盘缓存/网络中加载图片。</p></blockquote></li><li><p>如果有一张100M的图片，直接打开肯定会造成OOM，那么要怎么实现才能打开？</p><p> 得将该图片进行压缩，可以使用<code>BitmapFactory</code>这个类。首先，获取远图片的大小（这里是100M），然后获取要显示这个图片的控件比如<code>ImageView</code>的大小，然后可以计算出图片和控件的比例，根据这一比例，将图片压缩为适合显示的大小。</p></li><li><p>第三个项目，介绍一个。其中的生成二维码是在端生成吗？</p></li><li><p>Activity的生命周期。假设一个场景，用户按Home键回到桌面后，在后台久了之后点击icon打开这个应用，这个Activity已经被杀掉，那么打开应用后怎么重新恢复到杀掉前的Activity？</p><p> Android系统的回收机制提供了<code>onSaveInstanceState(Bundle outState)</code>和<code>onRestoreInstanceState(Bundle savedInstanceState)</code>方法用于保存和恢复数据。</p><p> 这两个方法主要会在Activty被系统回收，又重新创建了一个新的Activity的时候调用，可能是以下几种情况：</p><ol><li>当用户按下HOME键时</li><li>按下电源锁屏键</li><li>从最近应用中运行其它程序</li><li>从当前Activity启动一个新的Activity</li><li><p>屏幕方向切换（竖屏切横屏或者横屏切竖屏）</p><p>异常生命周期大概如下：</p></li><li><p>当Activity被系统自动回收时，<code>onPause()$$\rightarrow$$onSaveInstanceState()$$\rightarrow$$onStop()$$\rightarrow$$onDestory()$$\rightarrow$$onCreate()$$\rightarrow$$onStart()$$\rightarrow$$onRestoreInstanceState()$$\rightarrow$$onResume()</code></p></li><li>当Activity是用户主动销毁，比如按下back键或者调用<code>finish()</code>方法的话，就不会在<code>onPause()</code>和<code>onStop()</code>方法中调用<code>onSaveInstanceState()</code>方法，所以就是<code>onCreate()$$\rightarrow$$onStart()$$\rightarrow$$onRestoreInstanceState()</code>方法重新创建Activty，其中恢复数据是用<code>onRestoreInstanceState()</code>方法中的<code>Bundle</code>参数恢复。</li></ol></li><li><p>关于RecyclerView，假设一个场景，如果item有不同的类别从而要显示不同的样式，怎么显示？</p><p> <code>RecyclerViewAdapter</code>要继承<code>RecyclerView.Adapter&lt;ViewHolder&gt;</code>这个类，重写三个方法：<code>onCreateViewHolder(ViewGroup parent, int viewType)</code>、<code>onBindViewHolder(ViewHolder holder, int position)</code>和<code>getItemCount()</code>这三个方法，其中的<code>onCreateViewHolder</code>中可以根据<code>viewType</code>的类型去加载不同的布局。</p></li><li><p>有没有写过自定义View？</p><p> 自定义View要实现三个方法，按照执行顺序依次是<code>onMeasure()$$\rightarrow$$onLayout()$$\rightarrow$$onDraw()</code>。其中，<code>onDraw()</code>方法必须要重写，因为这个方法是用来绘制View图像的。如果要改变View的大小，就重写<code>onMeasure()</code>方法；如果要改变View在父控件中的位置，就要重写<code>onLayout()</code>方法。</p></li><li><p><code>public</code>、<code>protected</code>和<code>private</code>的区别</p><p><code>public</code>可以被其它任何类访问；<code>private</code>只能自己访问和自己内部的成员访问；<code>protected</code>就是自身、子类和同一个包中的类都可以访问；默认就是同一个包中的类都可以访问。</p></li><li><p>接口和抽象类的异同？让一个类不能被其它类继承怎么做？</p><ul><li>接口中的方法都是抽象的，抽象类中可以有抽象方法也可以有非抽象方法</li><li>类可以实现多个接口，但只能继承一个抽象类</li><li>Java接口声明的变量默认都是<code>final</code>的</li><li>如果一个类不实现抽象类或者接口中的全部方法，那么它必须也是抽象的；反之，它必须实现所有方法</li><li>接口和抽象类都不能实例化</li></ul></li><li><p>有用过final修饰吗？final能修饰类吗？</p><ul><li><code>final</code>修饰类表示此类不能被继承，不能拥有自己的子类</li><li><code>final</code>修饰方法表示此方法不能重写</li><li><code>final</code>修饰变量表示一旦定义并在首次为其显示初始化之后，<code>final</code>修饰的变量值就不可被改变</li></ul></li><li><p>介绍一下Java的引用</p></li></ol><h2 id="三七互娱"><a href="#三七互娱" class="headerlink" title="三七互娱"></a>三七互娱</h2><p>其实我的毕业时间并不满足三七互娱的春招要求，但是还是收到了三七互娱的笔试机会。</p><h3 id="选择题"><a href="#选择题" class="headerlink" title="选择题"></a>选择题</h3><ol><li><p>一个n个节点的二叉树，每个节点要么没有子节点要么两个子节点，问树的最大高度？</p><p> 这里容易混淆高度和深度的区别，不过不影响，因为<strong>树的高度和深度是相等的</strong>。高度是从下往上数，深度是从上往下数。例如：</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20140416102722296.png" alt=""></p><p> 这里G的高度为3，B的深度为2。所以这里答案应该是$(n+1)/2$。</p></li><li><p>android判断手机电池状态级别的广播action？</p><p> <code>ACTION_BATTERY_CHANGED</code></p></li><li><p>以下是<font color="red">私有IP地址</font>的是？</p><p> 私有IP地址的范围：</p><ul><li>A类私有IP地址：<strong>10.0.0.0~10.255.255.255</strong></li><li>B类私有IP地址：<strong>172.16.0.0~172.31.255.255</strong></li><li>C类私有IP地址：<strong>192.168.0.0~192.168.255.255</strong></li></ul></li><li><p>软件测试的目的？</p><p> 证明软件存在缺陷，使软件中的缺陷降低到一定程度</p></li><li><p><font color="red">Arraylist与linkedlist查找、添加删除区别</font>？</p><p> ArrayList的实现是通过数组，LinkedList的实现是通过链表，ArrayList适用于查找，LinkedList适合增删改。</p></li><li><p><font color="red">HashMap与HashTable键值是否为空</font>？</p><p> HashMap对象的key和value均可为<code>null</code>，HashTable对象的key和value均不可为<code>null</code>。HashTable是Java中的遗留类，目前不太实用。而HashMap的设计者认为<code>null</code>作为key和value是有实际意义的，所以允许其为<code>null</code>。</p></li><li><p>activity的分类是什么？</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20171205094147274.jpeg" alt=""></p></li><li><p>数据库删除test表的语句？</p><p> 这道选择的选项中有<code>drop</code>和<code>delete</code>和<code>truncate</code>。通过查询，发现：</p><ul><li><code>drop</code>：是删除表test，并释放空间，将test完全删除</li><li><code>truncate</code>：删除表test中的内容，并释放空间，但是不删除表的定义，表结构还有，所以test表还在，只是内容为空</li><li><code>delete</code>：可以删除指定数据，也可以删除整个表。如果删除表也是仅删除表test内的所有内容，保留表的定义，也不释放空间</li></ul></li><li><font color="red">针对二叉查找树增加、删除、查找的最坏时间复杂度</font></li><li><p><font color="red">jvm垃圾回收器</font>有哪些？</p><p>常见的垃圾回收器分为3类：</p><ol><li>新生代垃圾回收器：Serial、ParNew、Parallel Scavenge</li><li>新生代和老年代垃圾回收器：Serial Old、Parallel Old、CMS</li><li>老年代垃圾回收器：G1收集器</li></ol></li><li><p>ContentProvider的作用是？</p><p>跨进程通信，不同应用之间可以互相访问对应的数据库</p></li><li><p>袋子里有2个红球，3个绿球，2个蓝球，从中取两个，求一个蓝球都没有的概率？</p></li><li><p>xml布局文件放在哪个目录下</p><p><code>res/layout</code></p></li><li><p>ABCDEF依次入栈，出栈序列为CBDFEA，问栈的最小容量</p></li><li><p>数组未初始化就输出的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">2</span>];</span><br><span class="line">System.out.println(a[<span class="number">0</span>]);</span><br><span class="line">System.out.println(a[<span class="number">1</span>]);</span><br></pre></td></tr></table></figure></li><li><p>类未构造访问其成员变量的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">&#125;</span><br><span class="line">T t;</span><br><span class="line">System.out.println(t.n);</span><br></pre></td></tr></table></figure></li></ol><h3 id="算法题"><a href="#算法题" class="headerlink" title="算法题"></a>算法题</h3><p>2道算法题全部来自Leetcode。</p><ol><li>买卖股票问题求最大利润</li><li>求岛屿的周长</li></ol><h2 id="Taptap"><a href="#Taptap" class="headerlink" title="Taptap"></a>Taptap</h2><ol><li><p>自我介绍</p></li><li><p>为什么不做人工智能方向</p></li><li><p>介绍自己的实习经历，都负责了什么</p></li><li><p>接触Android多久了，Android最新的版本号是什么，<font color="red">Android10相对Android9改进</font>了什么？</p><p> Android10，暗黑模式、更安全的位置权限获取等。</p></li><li><p>讲一讲实习中接触到的网络封装类的用法</p></li><li><font color="red">Activity的生命周期</font><p> 这是面试必问问题，虽然不深究的话其实不难，但是我总感觉我的回答每次都差点意思。</p><p> <img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/347621596238419942633901667161718750.jpg" alt=""></p></li></ol><pre><code>1. Activity启动：`onCreate()$$\rightarrow$$onStart()$$\rightarrow$$onResume()`2. `onCreate()`：表示Activity正在被创建，在这个方法里可以进行一些初始化操作，比如加载布局资源，初始化Activity所需数据等3. `onStart()`：意味着Activity已经启动了，Activity已经可见，但是还没有处于前台，还不能与用户进行交互4. `onResume()`：表示Activity可见并显示在了前台，可以与用户进行交互5. 当用户摁下返回键或者Home键：`onPause()$$\rightarrow$$onStop()`6. `onPause()`：让Activity仍然处于可见状态，但是不可与用户进行交互7. `onStop()`：Activity不可见，处于停止状态。当内存紧张时，Activity会被回收8. 当用户重新打开或者回到该Activity时：`onRestart()$$\rightarrow$$onStart()$$\rightarrow$$onResume()`9. `onResume()`：这里的`onResume()`表示Activitiy重新由不可见状态变为可见状态10. 退出当前Activity：`onPause()$$\rightarrow$$onStop()$$\rightarrow$$onDestory()`11. `onDestory()`：表示该Activity被销毁，可以在此方法中进行一些资源的释放或者回收**Activity的四种状态**：* running状态：Activity处于活跃状态，位于Activitiy返回栈的栈顶* paused状态：Activity仍然可见，但是不能与用户交互，比如表面覆盖了一层，此时这个Activity的状态信息和成员变量等都是保存的；但当内存紧张时，这个Activity会被回收* stopped状态：Activity完全不可见，比如被另外一个Activity覆盖了，但是它的状态信息和成员变量还是被保存的；当内存紧张时，这个Activity会被回收* killed状态：Activity被系统回收，它保存的信息和成员变量也被回收</code></pre><ol><li><p><font color="red">http和https的区别，越详细越好，用到了什么加密算法</font>？</p><p> 因为超文本传输协议HTTP协议以明文形式发送内容，不提供任何方式的数据加密，所以不适合传递一些敏感信息，例如银行卡号、密码等信息。所以采用安全套接字层超文本传输协议HTTPS。HTTPS在HTTP的基础之上，加入了SSL协议，SSL依靠证书来验证服务器的身份，并为浏览器和服务器之间的通信加密。</p><ul><li>https协议需要到ca申请证书，一般免费证书较少，所以是需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的SSL加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用到的端口也不一样，前者是80，后者是443。</li><li><p>http连接简单，无状态；https协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</p><p>SSL协议是一种安全保密协议，在浏览器和服务器之间构造安全通道来进行数据传输，SSL运行在TCP/IP层之上，应用层之下，为应用程序提供加密数据通道。它采用了RC4、MD5和RSA的加密算法。</p><p>HTTPS的工作原理：<a href="https://juejin.im/entry/58d7635e5c497d0057fae036" target="_blank" rel="noopener">详细解析HTTP与HTTPS的区别</a></p></li></ul></li><li><p><font color="red">自定义View要用到哪些方法</font>，有没有写过什么自定义控件</p><p> 自定义View可以重写三个方法：<code>onDraw()</code>、<code>onMeasure()</code>、<code>onLayout()</code>。其中，<code>onDraw()</code>方法必须要重写，因为这个方法是用来绘制View图像的。如果要改变View的大小，就重写<code>onMeasure()</code>方法；如果要改变View在父控件中的位置，就要重写<code>onLayout()</code>方法。</p></li></ol><h2 id="堆糖"><a href="#堆糖" class="headerlink" title="堆糖"></a>堆糖</h2><p>这是大四时找实习的面试。</p><ol><li><p>自我介绍</p></li><li><p>介绍一个自己实际动手做过的项目与项目中遇到的问题</p></li><li><p>Volley的原理</p><p> 已在Notion中记录。</p></li><li><p>OOM内存溢出的解决办法</p><p> 已在Notion中记录。</p></li><li><p>Activity的生命周期</p></li><li><font color="red">Activity的四种启动方式</font></li><li><p>Spring的机制特征，解释一下依赖注入、IOC容器和AOP面向切面编程</p></li><li><p>Spring的依赖注入与ButterKnife依赖注入是否相同或者不同的话有何区别</p></li><li><p>Android滑动遇到的冲突，比如NavigationView与ViewPager的冲突</p></li><li><p>是否写过BaseActivity</p></li><li><p>ANR错误的原因</p><p>已在Notion中记录。</p></li><li><p>View的绘制机制，自定义View的方法</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Introduction to PyTorch</title>
      <link href="/2020/02/20/Introduction-to-PyTorch/"/>
      <url>/2020/02/20/Introduction-to-PyTorch/</url>
      
        <content type="html"><![CDATA[<p>This notebook covers:</p><ul><li>Tensors</li><li>Gradients</li><li>Datasets</li><li>Neural networks</li><li>Training(+ training on a GPU)</li><li>Calculating</li></ul><h3 id="Code"><a href="#Code" class="headerlink" title="Code"></a>Code</h3><p>代码见<a href="https://github.com/HurleyJames/GoogleColabExercise/blob/master/Intro_to_PyTorch.ipynb" target="_blank" rel="noopener">Intro_to_Pytorch</a>。</p><a id="more"></a><h3 id="Tensors"><a href="#Tensors" class="headerlink" title="Tensors"></a>Tensors</h3><p>Tensor is a basic building block.</p><p>它和Numpy的<code>ndarrays</code>相似，但是相比后者，它可以在GPU上使用。</p><p><code>torch.Tensor</code>是一种包含单一数据类型元素的多维矩阵。</p><h3 id="Gradients"><a href="#Gradients" class="headerlink" title="Gradients"></a>Gradients</h3><p>相比Numpy，PyTorch在传播梯度方面更加强大。它可以前向传播也可以反向传播。</p><p>Both the gradient, and forward and backward pass functions are attached to PyTorch’s Tensor object.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x = torch.tensor([<span class="number">4.0</span>, <span class="number">5.0</span>, <span class="number">6.0</span>], requires_grad=<span class="literal">True</span>)</span><br></pre></td></tr></table></figure><p>如果设置<code>requires_grad=True</code>，那么将会追踪对于该张量的操作。当完成计算后，通过调用<code>.backward()</code>，自动计算所有梯度，而这个张量的所有梯度将会自动积累到<code>.grad</code>属性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x.grad_fn</span><br></pre></td></tr></table></figure><p><code>Tensor</code>和<code>Function</code>是互联的并且构成了一个无环计算图，以此来实现对完整计算历程的编码。每个Tensor都有一个<code>.grad_fn</code>属性指向一个<code>Function</code>，正是这个<code>Function</code>创建了那个Tensor。</p><hr><p>然后通过Numpy和Tensor分别创建了两个相同的数组，Numpy通过<code>grad_w = v * w</code>得到的结果与Tensor通过</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">y = w * x</span><br><span class="line">y.backward(v)</span><br><span class="line">w.grad</span><br></pre></td></tr></table></figure><p>得到的结果是相同的。</p><p>可以看到，PyTorch中的<code>backward</code>函数是一个反向求导的函数，通过反向传播的方式，使用链式法则求导。</p><h3 id="Datasets"><a href="#Datasets" class="headerlink" title="Datasets"></a>Datasets</h3><p><strong>Transforms</strong> are common image transformations which can be chained together using Compose().</p><p><code>torchvision.transforms</code>是PyTorch中的图像预处理包，包含了很多种对图像数据进行变换的函数。而<code>Compose</code>方法则是把多种变换组合在一起。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">transform = transforms.Compose([</span><br><span class="line">    transforms.ToTensor(),</span><br><span class="line">    transforms.Normalize((<span class="number">0.5</span>,), (<span class="number">0.5</span>,))</span><br><span class="line">])</span><br></pre></td></tr></table></figure><p><code>.ToTensor()</code>的变换操作是将PILImage转变为<code>torch.FloatTensor</code>的数据形式。然后的<code>.Normalize</code>方法是用给定的均值和标准差分别对每个通道的数据进行正则化，即使用如下公式进行归一化：</p><p><code>channel = (channel - mean) / std</code></p><p><code>DataLoader</code>是PyTorch中的一种数据类型，主要包含以下几个参数：</p><ol><li><p><code>dataset</code>：数据类型<code>dataset</code></p><p> 输入数据类型。例如<strong>数据集</strong>。</p></li><li><p><code>batch_size</code>：数据类型<code>int</code></p><p> 每次输入数据的行数，默认为1。即定义每次喂给神经网络多少行数据，如果是1，那么就是一行一行的进行（效率太低）。</p></li><li><p><code>shuffle</code>：数据类型<code>bool</code></p><p> 洗牌。默认设置为<code>False</code>。如果设置为<code>True</code>，那么系统在返回之前会将张量数据Tensors复制到CUDA内存中。</p></li><li><p><code>batch_sampler</code>：数据类型<code>Sampler</code></p><p> 批量采样，默认设置为<code>None</code>。每次返回的是一批数据的索引。<strong>和<code>batch_size</code>和<code>sampler</code>和<code>drop_last</code>不兼容</strong>。</p></li><li><p><code>sampler</code>：数据类型<code>Sampler</code></p><p> 采样，默认设置为<code>None</code>。根据定义的策略从数据集中采样输入。如果定义了采样规则，则洗牌设置必须为<code>False</code>。</p></li><li><p><code>num_workers</code>：数据类型<code>int</code></p><p> 工作者数量，默认为0。即<strong>使用多少个子进程来导入数据</strong>。如果设置为0，就是使用主进程来导入数据（这个数字必须大于0）。</p></li></ol><p>例如，如果想</p><ul><li>打乱数据的顺序，可以设置<strong>shuffle</strong>为<code>True</code></li><li>改变数据输入的数量，可以设置<strong>batch_size</strong>的数目</li><li>想多线程输入，可以设置<strong>num_workers</strong>的数目</li><li>想随机抽取的模式输入，可以设置<strong>sampler</strong>或者<strong>batch_sampler</strong>。</li></ul><p>然后<code>classes = np.arange(0, 10)</code>的方法就是创建一个数组，默认步长为1，所以这个数组就是<code>array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])</code>。这个的作用主要是后面的绘制混淆矩阵要用到。</p><h3 id="Neural-networks"><a href="#Neural-networks" class="headerlink" title="Neural networks"></a>Neural networks</h3><p>这里主要有两个步骤：</p><ul><li>构建网络</li><li>构建损失函数和优化器</li></ul><p>所有的网络都继承至<code>nn.Module</code>，然后总是需要用到以下两个函数：</p><ul><li><strong>init</strong>, which will be called the moment you instantiate the class.</li><li><strong>forward()</strong> function which will be called during training.</li></ul><h4 id="网络部分"><a href="#网络部分" class="headerlink" title="网络部分"></a>网络部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LinearClassifier</span><span class="params">(nn.Module)</span>:</span></span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, num_classes=<span class="number">10</span>)</span>:</span></span><br><span class="line">        <span class="comment"># Calls __init__() on the parent class, which is nn.Module</span></span><br><span class="line">        super(LinearClassifier, self).__init__()</span><br><span class="line">        </span><br><span class="line">        <span class="comment"># Define each layer of the network as a class variable</span></span><br><span class="line">        <span class="comment"># fc1 stands for first fully-connected layer</span></span><br><span class="line">        self.fc1 = nn.Linear(<span class="number">28</span> * <span class="number">28</span>, num_classes)</span><br><span class="line">        </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(self, x)</span>:</span></span><br><span class="line">        out = x.reshape(x.size(<span class="number">0</span>), <span class="number">-1</span>) <span class="comment"># TODO what does this do? Why do we need it?</span></span><br><span class="line">        out = self.fc1(out)</span><br><span class="line">        <span class="keyword">return</span> out</span><br></pre></td></tr></table></figure><p>这部分代码没有加上卷积层、池化层等操作，而是只有一个简单的全连接层。</p><p>而后面又问了一个问题：<code>out = x.reshape(x.size(0), -1)</code>这句代码的作用是什么？为什么要这样写？</p><p>如果数据集最后一个batch样本数量小于定义的batch_batch大小，会出现mismatch问题。可以自己修改下，如只传入后面的shape，然后通过x.szie(0)，来输入。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">torch.manual_seed(<span class="number">0</span>)</span><br></pre></td></tr></table></figure><p>这行的代码是因为在神经网络中，参数默认是进行随机初始化的。而不同的初始化参数往往会导致不同的结果，而在得到好的结果时我们都希望这个结果是能够<strong>复现</strong>的。因为通过设置<strong>随机数种子</strong>可以达到这个目的。</p><h4 id="损失函数和优化器部分"><a href="#损失函数和优化器部分" class="headerlink" title="损失函数和优化器部分"></a>损失函数和优化器部分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">criterion = nn.CrossEntropyLoss()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Stochastic gradient descent</span></span><br><span class="line">optimizer = optim.SGD(model.parameters(), lr=<span class="number">0.001</span>, momentum=<span class="number">0.9</span>)</span><br></pre></td></tr></table></figure><p>这里用到的损失函数是<code>CrossEntropyLoss()</code>，然后优化器是用<code>SGD</code>，学习率为0,001，动量为0.9。</p><h3 id="Training"><a href="#Training" class="headerlink" title="Training"></a>Training</h3><p><code>optimizer.zero_grad</code>是将梯度重置为0，其余部分主要就是设置epoch次数，然后打印出每轮的损失率。最后通过计算<code>accuracy = correct / total</code>来得到准确率。</p><p>然后可以通过<code>matplotlib.pyplot</code>来生出具体的特征图，例如混淆矩阵。</p><h3 id="Calculating"><a href="#Calculating" class="headerlink" title="Calculating"></a>Calculating</h3><h4 id="卷积操作输出的计算公式"><a href="#卷积操作输出的计算公式" class="headerlink" title="卷积操作输出的计算公式"></a>卷积操作输出的计算公式</h4><p>首先，定义一下参数的概念。</p><p><code>width</code>、<code>height</code>、<code>depth</code>、<code>filter</code>、<code>stride</code>、<code>padding</code></p><p>W：图像的宽；H：图像的高；D：图像的深度（通道数）</p><p>F：卷积核的宽和高；N：卷积核（过滤器）的个数</p><p>S：步长；P：用零填充的个数</p><p>因此，卷积输出的公式为：</p><!-- more --><p><code>output_shape = (input_shape - filter_size + 2 * padding) / stride + 1</code></p><p>即<code>卷积输出大小=(输入大小 - 卷积核大小 + 2 * padding) / 步长 + 1</code></p><h4 id="池化操作输出的计算公式"><a href="#池化操作输出的计算公式" class="headerlink" title="池化操作输出的计算公式"></a>池化操作输出的计算公式</h4><p>同样，W：图像宽；H：图像高；D：图像深度（通道数）</p><p>F：<code>MaxPooling</code>中的卷积核的宽高；S：步长</p><p>因此，池化后输出大小为：</p><p><code>(input_shape - filter_size) / stride + 1</code></p><p>值得注意的是，这里的filter_size不是<code>Conv2d</code>中的卷积核大小，而是池化层中的卷积核大小。例如<code>MaxPool2d(2, 2)</code>这里的卷积核大小就是<code>2x2</code>。</p><h4 id="nn-Conv2d简单说明"><a href="#nn-Conv2d简单说明" class="headerlink" title="nn.Conv2d简单说明"></a>nn.Conv2d简单说明</h4><h5 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h5><ul><li><code>in_channels(int)</code></li><li><code>out_channels(int)</code></li><li><code>kernel_size(int or tuple)</code></li><li><code>stride(int or tuple, optional)</code></li><li><code>padding(int or tuple, optional)</code></li><li><code>groups(int, optional)</code></li><li><code>bias(bool, optional)</code></li></ul>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PyTorch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>206.Reverse Linked List</title>
      <link href="/2020/02/15/206.Reverse-Linked-List/"/>
      <url>/2020/02/15/206.Reverse-Linked-List/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>反转链表</strong></p><p>Reverse a singly linked list.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">Output: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="方法一：递归法"><a href="#方法一：递归法" class="headerlink" title="方法一：递归法"></a>方法一：递归法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>因为之前做了比较多树的题目，发现树的题目都是用递归遍历的方式比用迭代的方式要简单的多。但是对于这题，递归反而更难理解。</p><p>这题的递归主要是通过一个判断条件，当当前节点或者当前节点的下一个节点为<code>null</code>时，就改变节点的指向，将head的下一个节点指向head，具体是用如下一句代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">head.next.next = head;</span><br></pre></td></tr></table></figure><p>我们先看一个动态图来知道大概流程，然后再具体分析代码是如何实现的。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/dacd1bf55dec5c8b38d0904f26e472e2024fc8bee4ea46e3aa676f340ba1eb9d-%E9%80%92%E5%BD%92.gif" alt=""></p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 方法一：递归</span></span><br><span class="line">    <span class="comment">// 如果头结点为空，或者只有一个头结点，那么翻转过来就是头结点本身</span></span><br><span class="line">    <span class="comment">// 终止条件是，当前节点或者下一个节点为 null</span></span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    ListNode p = reverseList(head.next);</span><br><span class="line">    <span class="comment">// 改变节点的指向</span></span><br><span class="line">    head.next.next = head;</span><br><span class="line">    head.next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以根据代码和上面的动图来一步一步走一下这个程序。首先，这句代码<code>ListNode p = reverseList(head.next)</code>采用了递归的方式，假设这个链表是<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>，那么<code>head</code>最开始是1，<code>head.next</code>则是2，那么上面这句递归的代码就跳转去执行<code>reverseList(head.next)</code>即<code>reverseList(2)</code>，这样递归下去最终会执行<code>reverseList(4.next)</code>即<code>reverseList(5)</code>。因为当头结点为5时，<code>5.next</code>为<code>null</code>，所以满足第一行代码<code>if</code>语句的终止条件，就会返回<code>head</code>即返回5。</p><p>然后跳出这最后一层递归，即执行完了<code>reverseList(5)</code>，去接着执行<code>reverseList(4)</code>。这里有一句重要的<strong>改变节点指向</strong>的代码<code>head.next.next = head</code>。我们知道这时候的head是4，所以这句代码其实就是<code>4.next.next = 4</code>，而<code>4.next</code>在该链表中即为5，所以最终就是<code>5.next = 4</code>，即<code>5-&gt;4</code>，5的下一个节点又指向了4。</p><p>这里再注意题目的要求是翻转链表。而我们经过上面的操作后就变成了<code>4-&gt;5</code>，而且<code>5-&gt;4</code>，这就变成了双向链表了，所以我们要解除4指向5的关系，就通过这句代码<code>head.next =  null</code>，即<code>4.next  = null</code>，就把这个关系解除了（具体可以通过观察动图来理解）。</p><p>这样最终会返回原链表的头结点即1，然后头结点的下一个节点为<code>null</code>，就结束翻转了。</p><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为将链表从头走到尾，所以时间复杂度为$O(n)$，n为链表的长度。</li><li><strong>空间复杂度</strong>：因为这个方法使用了递归，递归会使用到<strong>隐式栈空间</strong>，所以递归的深度可能会达到n层，所以是$O(n)$。</li></ul><h3 id="方法二：双指针迭代法"><a href="#方法二：双指针迭代法" class="headerlink" title="方法二：双指针迭代法"></a>方法二：双指针迭代法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>我们可以申请两个指针，<code>prev</code>和<code>curr</code>。<code>prev</code>最初指向<code>null</code>，而<code>curr</code>指向<code>head</code>。然后遍历<code>curr</code>，并通过一个临时指针<code>temp</code>来储存<code>curr</code>的下一个节点即<code>curr.next</code>，然后让这个临时指针记录下一个节点<code>temp = curr.next</code>，然后让<code>curr</code>指向<code>prev</code>。最后继续遍历，让<code>prev</code>和<code>curr</code>都向前进一位，<code>prev = curr; curr = temp</code>。</p><p>具体演示效果如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/7d8712af4fbb870537607b1dd95d66c248eb178db4319919c32d9304ee85b602-%E8%BF%AD%E4%BB%A3.gif" alt=""></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 方法二：迭代</span></span><br><span class="line">    <span class="comment">// 申请节点，pre 和 curr，pre 指向 null</span></span><br><span class="line">    ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">    ListNode curr = head;</span><br><span class="line">    ListNode tmp = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 记录当前节点的下一个节点</span></span><br><span class="line">        tmp = curr.next;</span><br><span class="line">        <span class="comment">// 然后将当前节点指向 pre</span></span><br><span class="line">        curr.next = prev;</span><br><span class="line">        <span class="comment">// pre 和 curr 节点都前进一位</span></span><br><span class="line">        prev = curr;</span><br><span class="line">        curr = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这个过程同样是将链表从头遍历到尾，所以时间复杂度为$O(n)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="方法三：遍历法"><a href="#方法三：遍历法" class="headerlink" title="方法三：遍历法"></a>方法三：遍历法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>递归反转法是从前往后开始依次反转各个节点的指针域的指向。</p><p>就是将当前节点<code>cur</code>的下一个节点<code>cur.next</code>缓存到temp后，然后更改当前节点的指针指向前一个节点<code>pre</code>。结束之后，再往后移，让<code>pre</code>变成<code>cur</code>，<code>cur</code>变成<code>temp</code>。</p><ul><li>pre：上一结点</li><li>cur: 当前结点</li><li>tmp: 临时结点，用于保存当前结点的指针域（即下一结点）</li></ul><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Node <span class="title">reverseByTraverse</span><span class="params">(Node head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// pre指向前一个节点</span></span><br><span class="line">    Node pre = head;</span><br><span class="line">    <span class="comment">// cur指向后一个节点</span></span><br><span class="line">    Node cur = head.getnext();</span><br><span class="line">    <span class="comment">// tmp是临时节点，用来储存cur的下一个节点的</span></span><br><span class="line">    Node tmp;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 用来存储cur的下一个节点</span></span><br><span class="line">        tmp = cur.getnext();</span><br><span class="line">        <span class="comment">// 反转指针的指向</span></span><br><span class="line">        cur.setnext(pre);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 指针都向后移动</span></span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = tmp;</span><br><span class="line">        <span class="comment">// 循环反转</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后将原链表的头节点的指针域置为null，还回新链表的头结点，即原链表的尾结点</span></span><br><span class="line">    <span class="comment">// 因为head相当于尾节点了</span></span><br><span class="line">    head.setnext(<span class="keyword">null</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>21.Merge Two Sorted Lists</title>
      <link href="/2020/02/15/21.Merge-Two-Sorted-Lists/"/>
      <url>/2020/02/15/21.Merge-Two-Sorted-Lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>合并两个有序链表</strong></p><p>Merge two sorted linked lists and return it as a new list. The new list should be made by splicing together the nodes of the first two lists.</p><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Input: 1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">Output: 1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="方法一：递归法"><a href="#方法一：递归法" class="headerlink" title="方法一：递归法"></a>方法一：递归法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>这道题的递归法同样不好理解。之前我一直认为递归是一个比较容易的方法，而迭代更难。看来面对不同的数据结构其实并不相同，树由于其特殊性，采用递归即深度遍历的方式是十分好理解的，而采用迭代则必须要用一个栈或者队列去保存元素反而更加繁琐。但是对于链表这种数据结构，递归反而值得更多的思考。</p><p>首先，这道题采用递归的终止条件是当<code>l1</code>或者<code>l2</code>为空时，结束。而返回值则是<strong>每一层调用都返回排序好的链表头</strong>。</p><p>通俗来说，就是如果<code>l1.val</code>比<code>l2.val</code>更小，那么就将<code>l1.next</code>与排序好的链表头相接；反之，如果<code>l2.val</code>更小，则将<code>l2.next</code>与排序号的链表头相连。具体是通过<code>l1.next = mergeTwoLists(l1.next, l2)</code>这句代码来实现的。</p><p>具体过程如下（但实际上仍然不是很好理解，具体还是要分析代码）：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/s1.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/s2.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/s3.png" alt=""></p><p>通过以上图片过程可以发现，<code>l2.next = merge(l1, l2.next)</code>这句代码就是让原有的<code>l2.next</code>指向的那个链条断开，指向了新的<code>merge(l1, l2.next)</code>。虽然目前我们暂时不知道这个<code>merge(l1, l2.next)</code>是什么，但是这其实是一个持续递归的函数，最终会返回已经排序好的值。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span> &amp;&amp; l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (l2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">        <span class="comment">// 如果 l1 的 val 更小，则将 l1.next 等于排序好的链表头</span></span><br><span class="line">        l1.next = mergeTwoLists(l1.next, l2);</span><br><span class="line">        <span class="keyword">return</span> l1;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 如果 l2 的 val 更小，则将 l2.next 等于排序号的链表头</span></span><br><span class="line">        l2.next = mergeTwoLists(l1, l2.next);</span><br><span class="line">        <span class="keyword">return</span> l2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们通过一个例子来走一遍整个代码的流程。</p><h5 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h5><p>现在有两个链表<code>l1</code>和<code>l2</code>，分别为<code>1-&gt;2-&gt;5</code>和<code>0-&gt;3-&gt;4</code>。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0228.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0229.jpg" alt=""></p><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：很明显，这个过程要把两个链表都走一遍。假设它们的长长度分别为m和n，则时间复杂度为$O(m+n)$。</li><li><strong>空间复杂度</strong>：因为这个过程会调用$m+n$个栈，所以会消耗$O(m+n)$的空间。</li></ul><h3 id="方法二：迭代法"><a href="#方法二：迭代法" class="headerlink" title="方法二：迭代法"></a>方法二：迭代法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>关于链表的合并问题，我们都可以想到去设置一个<strong>哨兵节点</strong>。比如，链表<code>l1</code>和<code>l2</code>分别为<code>1-&gt;2-&gt;4</code>和<code>1-&gt;3-&gt;4</code>，然后设置一个<code>prehead</code>的哨兵节点，如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0230.jpg" alt=""></p><p>然后我们主要关注<code>prehead</code>节点，调整它的<code>next</code>指针，让它总是指向<code>l1</code>和<code>l2</code>中较小的那个节点，直到两个链表中的某一条指向<code>null</code>为止。</p><p>我在这里把步骤一步一步地写出来：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0232.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0233.jpg" alt=""></p><p>完整的过程如下：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_0231.jpg" alt=""></p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 2.迭代法</span></span><br><span class="line">    ListNode prehead = <span class="keyword">new</span> ListNode(-<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ListNode prev = prehead;</span><br><span class="line">    <span class="keyword">while</span> (l1 != <span class="keyword">null</span> &amp;&amp; l2 != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (l1.val &lt;= l2.val) &#123;</span><br><span class="line">            prev.next = l1;</span><br><span class="line">            l1 = l1.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            prev.next = l2;</span><br><span class="line">            l2 = l2.next;</span><br><span class="line">        &#125;</span><br><span class="line">        prev = prev.next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (l1 == <span class="keyword">null</span>) &#123;</span><br><span class="line">        prev.next = l2;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        prev.next = l1;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> prehead.next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>迭代法的算法看起来是十分清晰明了的，如果<code>l1.val &lt;= l2.val</code>，则让哨兵节点指向<code>l1</code>即值更小的节点，反之一样，然后再将那个更小的节点往后走一位，再重新判断值的大小。</p><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这个方法要比较两条链表的每一个节点，所以时间复杂度为$O(m+n)$，即循环的次数等于两个链表的总长度。</li><li><strong>空间复杂度</strong>：迭代的过程会产生几个指针，所以所需空间是常数级别的，为$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>160.Intersection of Two Linked Lists</title>
      <link href="/2020/02/14/160.Intersection-of-Two-Linked-Lists/"/>
      <url>/2020/02/14/160.Intersection-of-Two-Linked-Lists/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>相交链表</strong></p><p>Write a program to find the node at which the intersection of two singly linked lists begins.</p></blockquote><a id="more"></a><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>非常容易想到的就是暴力法。采用双重遍历的方式，先从链表A中选出一个节点，然后遍历整个链表B，看是否能找到与之相同的节点。如果能的话，就返回该节点；如果不能，则继续遍历链表A，然后重复。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果某个链表为空，是肯定不会相交的</span></span><br><span class="line">    <span class="keyword">if</span> (headA == <span class="keyword">null</span> || headB == <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode newHead = headB;</span><br><span class="line">        <span class="keyword">while</span> (newHead != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果相等，就找到了相交点</span></span><br><span class="line">            <span class="keyword">if</span> (headA == newHead) &#123;</span><br><span class="line">                <span class="keyword">return</span> newHead;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                newHead = newHead.next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果遍历完了都没有找到，说明没有相交点</span></span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>虽然这种方法思路上十分简单清晰，但是在代码中仍然有需要注意的地方。</p><ol><li><p>这里判断节点相同，可以直接采用<code>nodeA == nodeB</code>的方式去判断，而不是通过他们的值<code>val</code>去判断。因为，这里仅仅是值相等并没有用，必须要它们的下一个节点以及之后的节点都相等，才是找到了相交节点。</p></li><li><p>在第一层循环的里面，我们又定义了<code>ListNode newHead = headB</code>。这一步看起来是多余的，但是如果不这么定义一个新的变量的话，那么在第二层循环的判断条件那里，就会变成是<code>while (headB != null)</code>。那么当第一遍遍历整个链表B却没有找到与链表A中一个节点$a_i$相同的节点的话，<code>headB = headB.next</code>最终会使得<code>headB == null</code>，即遍历到链表B的末尾。这样就没有再为链表B从头开始遍历了。</p><p> 所以，必须要使用其它元素来保存遍历的链表B的节点。这里用的是<code>ListNode newHead = headB</code>。</p></li></ol><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这里采用的双重循环遍历两个链表。假设链表A的长度为m，链表B的长度为n，所以时间复杂度为$O(mn)$。</li><li><strong>空间复杂度</strong>：$O(1)$。</li></ul><h3 id="方法二：哈希法"><a href="#方法二：哈希法" class="headerlink" title="方法二：哈希法"></a>方法二：哈希法</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>先遍历链表A，把链表A的所有节点放入一个set中。然后再遍历链表B，判断如果链表B中的某个节点出现在set中，那么这就是相交节点。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    Set s = <span class="keyword">new</span> HashSet();</span><br><span class="line">    <span class="comment">// 遍历链表A，把链表A的节点全部存入set中</span></span><br><span class="line">    <span class="keyword">while</span> (headA != <span class="keyword">null</span>) &#123;</span><br><span class="line">        s.add(headA);</span><br><span class="line">        headA = headA.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (headB != <span class="keyword">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 遍历链表B，判断set中是否存在相同的节点</span></span><br><span class="line">        <span class="keyword">if</span> (s.contains(headB)) &#123;</span><br><span class="line">            <span class="keyword">return</span> headB;</span><br><span class="line">        &#125;</span><br><span class="line">        headB = headB.next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这里用到的HashSet的底层是通过HashMap来实现的，所以进行<code>add</code>或者<code>contains</code>等操作的时间复杂度都是$O(1)$。因为进行了两次不是嵌套的循环，所以假设链表A的长度为m，链表B的长度为n，则时间复杂度为$O(m+n)$。</li><li><strong>空间复杂度</strong>：因为这里用了HashSet去存储节点，所以要么存储了链表A的长度要么存储了链表B的长度。所以空间复杂度为$O(m)$或者$O(n)$。</li></ul><h3 id="方法三：双指针法"><a href="#方法三：双指针法" class="headerlink" title="方法三：双指针法"></a>方法三：双指针法</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>在LeetCode的评论区，看到很多人评论这是一种很浪漫的方法。即</p><blockquote><p>错的人迟早会走散，而对的人迟早会相逢！</p></blockquote><p>双指针的方式其实思考起来还是很清晰的。用两个指针a和b分别从链表A和链表B开始遍历，当a遍历完链表A之后，就去遍历链表B；同样的，当b遍历完链表B之后，就去遍历链表A。这样，如果它们是相交的，则最终走过的长度肯定是一样的，即会在交点相遇。可以用下图一样，将两个链表连成一个环。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/6d24c0d2f451f8cfccea0edaff474d5d1e834d2199272974915d80e332f5fb50-1571538464(1" alt="">.jpg)</p><p>然后遍历过程如下动图所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/396526c47e043feb977e59f98d8df9165ae249d5042ca60ee4d3121c05fea067-%E5%8A%A8%E6%80%81%E5%9B%BE.gif" alt=""></p><p>因为连成一个环后，假设有相交的节点，则最终走过的链表A加上链表B的长度是一样，最终都会相遇于交点。</p><p>（今天<strong>情人节</strong>，值得反思一下🤔）</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> </span>&#123;</span><br><span class="line">    ListNode a = headA;</span><br><span class="line">    ListNode b = headB;</span><br><span class="line">    <span class="keyword">while</span> (a != b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 继续遍历链表A</span></span><br><span class="line">            a = a.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去遍历链表B，从头结点开始</span></span><br><span class="line">            a = headB;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 继续遍历链表B</span></span><br><span class="line">            b = b.next;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 去遍历链表A，从头节点开始</span></span><br><span class="line">            b = headA;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-2"><a href="#复杂度分析-2" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：因为这个方法同样遍历了链表A和链表B，所以时间复杂度为$O(m+n)$。</li><li><strong>空间复杂度</strong>：这里没有去存储节点，所以空间复杂度为$O(1)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>572.Subtree of Another Tree</title>
      <link href="/2020/02/08/572.Subtree-of-Another-Tree/"/>
      <url>/2020/02/08/572.Subtree-of-Another-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>另一个树的子树</strong></p><p>Given two non-empty binary trees <strong>s</strong> and <strong>t</strong>, check whether tree <strong>t</strong> has exactly the same structure and node values with a subtree of <strong>s</strong>. A subtree of <strong>s</strong> is a tree consists of a node in <strong>s</strong> and all of this node’s descendants. The tree <strong>s</strong> could also be considered as a subtree of itself.</p><p><strong>Example 1:</strong><br>Given tree s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Given tree t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4 </span><br><span class="line">/ \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Return <strong>true</strong>, because t has the same structure and node values with a subtree of s.</p><p><strong>Example 2:</strong><br>Given tree s:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">4   5</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br><span class="line"> /</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>Given tree t:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4</span><br><span class="line">/ \</span><br><span class="line">1   2</span><br></pre></td></tr></table></figure><p>Return <strong>false</strong>.</p></blockquote><a id="more"></a><h3 id="方法一：先序遍历"><a href="#方法一：先序遍历" class="headerlink" title="方法一：先序遍历"></a>方法一：先序遍历</h3><p>因为我们知道树的表示方式的一种就是以先序遍历的方式表示出来。所以，我们把两棵树s和t分别以先序遍历的方式表示（以字符串表示），然后判断t是否是s的子字符串即可判断出是否是其的子树。</p><p>通常，如果左节点或者右节点为空，我们就会把它以<code>null</code>的形式表示，但是在这里是要判断结构和节点是否相同，所以不能简单地用<code>null</code>来区分。</p><p>当左孩子为空时，要赋值为<code>lnull</code>；当右孩子为空时，要赋值为<code>rnull</code>。</p><p>还有一点非常重要的是，因为我们是把它转化为字符串，用字符串<code>contains</code>的方式来判断是否是子串，这样容易把更小的数字认为是更大的数字的子串。例如，会把<code>3</code>认为是<code>23</code>的子串，但是在这里显然是不同的，如果一个是<code>3</code>，一个是<code>23</code>，那么就不是子树了。所以，我们要为每个节点前加一个<code>#</code>，就可以解决这个问题了。</p><p>关于以上<code>contains</code>方法的问题，如果含有空左孩子或右孩子时，即有<code>lnull</code>或者<code>rnull</code>时也不会有问题，但是如果没有，那么当两棵树为<code>[12]</code>和<code>[2]</code>时，就会输出<code>true</code>，然而实际是<code>false</code>。<strong>所以一定要为数字前加上一个字符</strong>。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Given two non-empty binary trees s and t, check whether tree t has exactly the same structure and node values with a subtree of s. A subtree of s is a tree consists of a node in s and all of this node's descendants. The tree s could also be considered as a subtree of itself.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subtree_of_Another_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        String tree1 = preOrder(s, <span class="keyword">true</span>);</span><br><span class="line">        String tree2 = preOrder(t, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">if</span> (tree1.contains(tree2)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> String <span class="title">preOrder</span><span class="params">(TreeNode node, <span class="keyword">boolean</span> left)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (node == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">// 如果是左孩子节点为空</span></span><br><span class="line">            <span class="keyword">if</span> (left) &#123;</span><br><span class="line">                <span class="comment">// 设置为 lnull</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"lnull"</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 右孩子节点为空，设置为 rnull</span></span><br><span class="line">                <span class="keyword">return</span> <span class="string">"rnull"</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 给每个节点前加上 # 号</span></span><br><span class="line">        <span class="comment">// 如果 preOrder 的第一个参数是 left，那么就是 true</span></span><br><span class="line">        <span class="comment">// 如果 preOrder 的第一个参数是 right，那么就是 false</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"#"</span> + node.val + <span class="string">" "</span> + preOrder(node.left, <span class="keyword">true</span>) + <span class="string">" "</span> + preOrder(node.right, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：采用先序遍历的方式表示树，那么两棵树的花费的时间为$O(m)$和$O(n)$。最后用字符串判断是否包含的方式花费的时间为$O(mn)$，所以总的时间复杂度为$O(m+n+mn)$。</li><li><strong>空间复杂度</strong>：主要取决于哪棵树的空间更大。所以是$O(max(m,n))$。</li></ul><h3 id="方法二：比较节点"><a href="#方法二：比较节点" class="headerlink" title="方法二：比较节点"></a>方法二：比较节点</h3><p>我们可以把每个给定节点t的子树都作为根，然后判断以t为根的子树是否与给定的子树相同。为了检查是否完全相同，我们就需要比较两个子树的所有节点。</p><p>首先，我们定义一个<code>equals(x,y)</code>函数去检查两个树是否相等。它先检查两个树的根是否相等，然后再递归判断左子树和右子树。</p><p>然后，使用一个函数<code>traverse(s,t)</code>，遍历给定的树s并将每个节点都当作子树的根。</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Subtree_of_Another_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSubtree</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> traverse(s, t);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">traverse</span><span class="params">(TreeNode s, TreeNode t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> s != <span class="keyword">null</span> &amp;&amp; (equals(s, t) || traverse(s.left, t) || traverse(s.right, t));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 比较两个树是否相同</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t1</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> t2</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(TreeNode t1, TreeNode t2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> &amp;&amp; t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (t1 == <span class="keyword">null</span> || t2 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果节点值相同，且左孩子和右孩子的节点值也相同，则返回 true</span></span><br><span class="line">        <span class="keyword">return</span> t1.val == t2.val &amp;&amp; equals(t1.left, t2.left) &amp;&amp; equals(t1.right, t2.right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h5><ul><li><strong>时间复杂度</strong>：在最坏的情况下，即一棵树为倾斜树时，需要$O(mn)$时间。</li><li><strong>空间复杂度</strong>：如果n为树的节点数，那么空间复杂度为$O(n)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>437.Path Sum III</title>
      <link href="/2020/02/07/437.Path-Sum-III/"/>
      <url>/2020/02/07/437.Path-Sum-III/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>路径总和III</strong></p><p>You are given a binary tree in which each node contains an integer value.</p><p>Find the number of paths that sum to a given value.</p><p>The path does not need to start or end at the root or a leaf, but it must go downwards (traveling only from parent nodes to child nodes).</p><p>The tree has no more than 1,000 nodes and the values are in the range -1,000,000 to 1,000,000.</p><a id="more"></a><p><strong>Example:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8</span><br><span class="line"></span><br><span class="line">10</span><br><span class="line">/  \</span><br><span class="line">5   -3</span><br><span class="line">/ \    \</span><br><span class="line">3   2   11</span><br><span class="line">/ \   \</span><br><span class="line">3  -2   1</span><br><span class="line"></span><br><span class="line">Return 3. The paths that sum to 8 are:</span><br><span class="line"></span><br><span class="line">1.  5 -&gt; 3</span><br><span class="line">2.  5 -&gt; 2 -&gt; 1</span><br><span class="line">3. -3 -&gt; 11</span><br></pre></td></tr></table></figure></blockquote><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>这道题的描述中没有要求路径的开头必须是根节点，结尾也没有要求是叶子节点，只要求了是从上往下。</p><p>所以，所有情况就分为以根节点开始的，和以根节点的左孩子和右孩子开始这三种。</p><p>具体过程同样是采取了递归的思想，当找到一条值等于sum，就让路径树加1。但需要注意的是递归的循环中，应该是<code>pathSum(root.left/right, sum - root.val)</code>这种形式。因为在递归后，后面一个参数应该从<code>sum</code>变成<code>sum - root.val</code>，因为已经经过了一个节点，需要减去这个节点的值再进行递归。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Path_Sum_3</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pathSum</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 找出根节点的所有路径，再找出以根节点的左孩子和右孩子开始的所有路径</span></span><br><span class="line">        <span class="keyword">return</span> path(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">path</span><span class="params">(TreeNode root, <span class="keyword">int</span> sum)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> pathSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root.val == sum) &#123;</span><br><span class="line">            pathSum++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        pathSum = pathSum + path(root.left, sum - root.val);</span><br><span class="line">        pathSum = pathSum + path(root.right, sum - root.val);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> pathSum;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里刚开始有些疑惑的是为什么一个方法的返回值是<code>return path(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum);</code>，而不是都调用<code>path</code>函数。</p><p>我认为实际上这是把<code>path(root, sum) + pathSum(root.left, sum) + pathSum(root.right, sum)</code>看成一个整体，分别是根节点root和它的左孩子A和右孩子B。第一个<code>path(root, sum)</code>是为了找出以根节点为路径开头的路径数量，第二个<code>pathSum(root.left, sum)</code>就是以左孩子节点作为新的根节点，然后递归，又以这个A作为根节点，找出它作为路径开头的路径数量，依次递归下去。右孩子B同理。</p><p>但是细想起来，这个做法存在着大量的重复计算，其实在效率上还是可以改进的。因为比如第一步，以根节点root作为路径的开头，去遍历可能值等于sum的路径，这时候就已经遍历过一次了，如果在这个遍历的过程中，能够发现路径中的某一部分（即不以根节点作为开头）的值正好等于sum，就明显提高了效率。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>617.Merge Two Binary Trees</title>
      <link href="/2020/02/04/617.Merge-Two-Binary-Trees/"/>
      <url>/2020/02/04/617.Merge-Two-Binary-Trees/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>合并二叉树</strong></p><p>Given two binary trees and imagine that when you put one of them to cover the other, some nodes of the two trees are overlapped while the others are not.</p><p>You need to merge them into a new binary tree. The merge rule is that if two nodes overlap, then sum node values up as the new value of the merged node. Otherwise, the NOT null node will be used as the node of new tree.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Input: </span><br><span class="line">trueTree 1                     Tree 2                  </span><br><span class="line">       1                         2                             </span><br><span class="line">      / \                       / \                            </span><br><span class="line">     3   2                     1   3                        </span><br><span class="line">    /                           \   \                      </span><br><span class="line">   5                             4   7                  </span><br><span class="line">Output: </span><br><span class="line">Merged tree:</span><br><span class="line">true     3</span><br><span class="line">true    / \</span><br><span class="line">true   4   5</span><br><span class="line">true  / \   \ </span><br><span class="line">true 5   4   7</span><br></pre></td></tr></table></figure><p><strong>Note:</strong> The merging process must start from the root nodes of both trees.</p></blockquote><a id="more"></a><h3 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h3><p>如果两棵树的当前节点均不为空，就将它们的值相加，然后继续对它们的左孩子和右孩子进行递归合并；如果有一棵树为空，就直接返回另一颗树的值。</p><h3 id="迭代"><a href="#迭代" class="headerlink" title="迭代"></a>迭代</h3>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Weka中实现J48决策树算法</title>
      <link href="/2020/02/04/Weka%E4%B8%AD%E5%AE%9E%E7%8E%B0J48%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/"/>
      <url>/2020/02/04/Weka%E4%B8%AD%E5%AE%9E%E7%8E%B0J48%E5%86%B3%E7%AD%96%E6%A0%91%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h2 id="WEKA"><a href="#WEKA" class="headerlink" title="WEKA"></a>WEKA</h2><p>WEKA（Waikato Environment for Knowledge Analysis）诞生于University of Waikato（新西兰），并在1997年首次以现代的格式实现。</p><p>为了将数据加载到WEKA，我们必须将数据放入一个我们能够理解的格式。WEKA建议加载的数据格式是Attribute Relation File Format（ARFF）。其中含有三个重要的注解：</p><ul><li>@RELATION</li><li>@ATTRIBUTE</li><li>@DATA</li></ul><a id="more"></a><h2 id="J48决策树算法"><a href="#J48决策树算法" class="headerlink" title="J48决策树算法"></a>J48决策树算法</h2><p>J48的全名是<code>weka.classifiers.trees.J48</code>。J48算法是著名的C4.5算法的改进，Weka对于这个算法赋予了默认的参数：-C 0.25 -M 2。该命令给出了分类器的默认参数配置，一般很少需要为提高性能而修改参数配置。前者是用于剪枝的置信因子，后者指定了每个叶结点最小的实例数。</p><p>通过运行weather.nominal.arff文件，在分类器面板的Test options部分选择Use training set，然后点击Start按钮创建分类器并进行评估。</p><p>运行完成后，可以在右侧的Classifier output中查看结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">=== Run information ===</span><br><span class="line"></span><br><span class="line">Scheme:       weka.classifiers.trees.J48 -C 0.25 -M 2</span><br><span class="line">Relation:     weather.symbolic</span><br><span class="line">Instances:    14</span><br><span class="line">Attributes:   5</span><br><span class="line">              outlook</span><br><span class="line">              temperature</span><br><span class="line">              humidity</span><br><span class="line">              windy</span><br><span class="line">              play</span><br><span class="line">Test mode:    evaluate on training data</span><br><span class="line"></span><br><span class="line">=== Classifier model (full training set) ===</span><br><span class="line"></span><br><span class="line">J48 pruned tree</span><br><span class="line">------------------</span><br><span class="line"></span><br><span class="line">outlook = sunny</span><br><span class="line">|   humidity = high: no (3.0)</span><br><span class="line">|   humidity = normal: yes (2.0)</span><br><span class="line">outlook = overcast: yes (4.0)</span><br><span class="line">outlook = rainy</span><br><span class="line">|   windy = TRUE: no (2.0)</span><br><span class="line">|   windy = FALSE: yes (3.0)</span><br><span class="line"></span><br><span class="line">Number of Leaves  : 5</span><br><span class="line"></span><br><span class="line">Size of the tree : 8</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Time taken to build model: 0.01 seconds</span><br><span class="line"></span><br><span class="line">=== Evaluation on training set ===</span><br><span class="line"></span><br><span class="line">Time taken to test model on training data: 0 seconds</span><br><span class="line"></span><br><span class="line">=== Summary ===</span><br><span class="line"></span><br><span class="line">Correctly Classified Instances          14              100      %</span><br><span class="line">Incorrectly Classified Instances         0                0      %</span><br><span class="line">Kappa statistic                          1     </span><br><span class="line">Mean absolute error                      0     </span><br><span class="line">Root mean squared error                  0     </span><br><span class="line">Relative absolute error                  0      %</span><br><span class="line">Root relative squared error              0      %</span><br><span class="line">Total Number of Instances               14     </span><br><span class="line"></span><br><span class="line">=== Detailed Accuracy By Class ===</span><br><span class="line"></span><br><span class="line">                 TP Rate  FP Rate  Precision  Recall   F-Measure  MCC      ROC Area  PRC Area  Class</span><br><span class="line">                 1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     yes</span><br><span class="line">                 1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     no</span><br><span class="line">Weighted Avg.    1.000    0.000    1.000      1.000    1.000      1.000    1.000     1.000     </span><br><span class="line"></span><br><span class="line">=== Confusion Matrix ===</span><br><span class="line"></span><br><span class="line"> a b   &lt;-- classified as</span><br><span class="line"> 9 0 | a = yes</span><br><span class="line"> 0 5 | b = no</span><br></pre></td></tr></table></figure><h3 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h3><h4 id="Instances"><a href="#Instances" class="headerlink" title="Instances"></a>Instances</h4><p>代表输入的数据量</p><h4 id="Attributes"><a href="#Attributes" class="headerlink" title="Attributes"></a>Attributes</h4><p>代表数据中有哪些数据分类，即属性</p><h4 id="Number-of-Leaves"><a href="#Number-of-Leaves" class="headerlink" title="Number of Leaves"></a>Number of Leaves</h4><p>叶子树</p><h4 id="Size-of-the-tree"><a href="#Size-of-the-tree" class="headerlink" title="Size of the tree"></a>Size of the tree</h4><p>决策树大小</p><h4 id="Kappa-statistic"><a href="#Kappa-statistic" class="headerlink" title="Kappa statistic"></a>Kappa statistic</h4><p>这个参数是把分类器与随机分类器作比较得出的一个对分类器的评价值。</p><h4 id="Mean-absolute-error和Root-mean-squared-error"><a href="#Mean-absolute-error和Root-mean-squared-error" class="headerlink" title="Mean absolute error和Root mean squared error"></a>Mean absolute error和Root mean squared error</h4><p>平均绝对误差，用来衡量分类器预测值和实际结果的差异，越小越好。</p><h4 id="Relative-absolute-error和Root-relative-squared-error"><a href="#Relative-absolute-error和Root-relative-squared-error" class="headerlink" title="Relative absolute error和Root relative squared error"></a>Relative absolute error和Root relative squared error</h4><p>有时候绝对误差不能体现误差的真实大小，而<strong>相对误差</strong>通过体现误差占真值的比重来反映误差大小的效果会更好。</p><h4 id="Confusion-Matrix"><a href="#Confusion-Matrix" class="headerlink" title="Confusion Matrix"></a>Confusion Matrix</h4><p>混淆矩阵。这个矩阵上对角线的数字越大，说明预测得越好。</p>]]></content>
      
      
      <categories>
          
          <category> 数据挖掘 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 开发工具 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>226.Invert Binary Tree</title>
      <link href="/2020/02/03/226.Invert-Binary-Tree/"/>
      <url>/2020/02/03/226.Invert-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>翻转二叉树</strong></p><p>Invert a binary tree.</p><p><strong>Example:</strong></p><p>Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line">/   \</span><br><span class="line">2     7</span><br><span class="line">/ \   / \</span><br><span class="line">1   3 6   9</span><br></pre></td></tr></table></figure><p>Output:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  4</span><br><span class="line">/   \</span><br><span class="line">7     2</span><br><span class="line">/ \   / \</span><br><span class="line">9   6 3   1</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="递归法"><a href="#递归法" class="headerlink" title="递归法"></a>递归法</h3><p>通过观察输入和输出，可以发现就是把所有的子树的左右结点都互换位置。所以可以使用<strong>递归</strong>的方法交换左节点和右节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invert_Binary_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 交换左右子树节点</span></span><br><span class="line">        swap(root);</span><br><span class="line">        <span class="comment">// 递归当前节点的左子树</span></span><br><span class="line">        invertTree(root.right);</span><br><span class="line">        <span class="comment">// 递归当前节点的右子树</span></span><br><span class="line">        invertTree(root.left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换左右子树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>关键的三行代码就是<code>swap(root)</code>和<code>invertTree(root.left)</code>以及<code>invertTree(root.right)</code>。</p><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>因为要递归所有的左子树节点和右子树节点，所有时间复杂度为$O(n)$。</li><li><strong>空间复杂度：</strong>假设树的高度为h，则最坏情况下需要$O(h)$个函数存放。</li></ul><h3 id="迭代法"><a href="#迭代法" class="headerlink" title="迭代法"></a>迭代法</h3><p>递归的实现方式其实就是深度优先搜索BFS的方式，而迭代法就是广度优先搜索DFS的方式。</p><p>广度优先搜索需要额外的数据结构——队列，来存放临时遍历的元素。</p><p>首先将根节点放入到队列中，然后对当前元素调换其左右子树的位置，然后再判断其左子树是否为空，不为空就放入队列中；然后判断其右子树是否为空，不为空就放入到队列中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Invert_Binary_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">invertTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        LinkedList&lt;TreeNode&gt; queue = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">// 每次从队列中拿出一个节点，并交换这个节点的左右子树</span></span><br><span class="line">            TreeNode tmp = queue.poll();</span><br><span class="line">            swap(tmp);</span><br><span class="line">            <span class="comment">// 如果当前节点的左子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.left != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(tmp.left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果当前节点的右子树不为空，则放入队列等待后续处理</span></span><br><span class="line">            <span class="keyword">if</span> (tmp.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">                queue.add(tmp.right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 交换左右子树节点</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> root</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">swap</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        TreeNode tmp = root.left;</span><br><span class="line">        root.left = root.right;</span><br><span class="line">        root.right = tmp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态图如下：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/f9e06159617cbf8372b544daee37be70286c3d9b762c016664e225044fc4d479-226_%E8%BF%AD%E4%BB%A3.gif" alt=""></p><h4 id="复杂度分析-1"><a href="#复杂度分析-1" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>因为每个节点都要判断是否子树为空，即每个节点都被入队出队一次，所以时间复杂度为$O(n)$。</li><li><strong>空间复杂度：</strong>在最坏的情况下，队列里会包含树中的所有的节点。而如果是一颗完整二叉树，那么叶子节点那一层就拥有$[\frac{n}{2}]=O(n)$个节点。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>543.Diameter of Binary Tree</title>
      <link href="/2020/02/03/543.Diameter-of-Binary-Tree/"/>
      <url>/2020/02/03/543.Diameter-of-Binary-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>二叉树直径</strong></p><p>Given a binary tree, you need to compute the length of the diameter of the tree. The diameter of a binary tree is the length of the <strong>longest</strong> path between any two nodes in a tree. This path may or may not pass through the root.</p><p><strong>Example:</strong><br>Given a binary tree</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">    1</span><br><span class="line">   / \</span><br><span class="line">  2   3</span><br><span class="line"> / \     </span><br><span class="line">4   5    </span><br></pre></td></tr></table></figure><p>Return <strong>3</strong>, which is the length of the path [4,2,1,3] or [5,2,1,3].</p></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>关于二叉树直径的定义是：<strong>二叉树中从一个结点到另一个结点最长的路径</strong>，叫做二叉树的直径。</p><p>这里存在一个陷阱，就是容易受到题目中例子的影响，认为二叉树的直径就是左子树的深度+右子树的深度。实际上，二叉树的直径<strong>不一定经过根节点root</strong>。有个例子如下图所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_8D22A19495F3-1.jpeg" alt=""></p><p>所以，采用<strong>分治</strong>和<strong>递归</strong>的思想：二叉树的直径=$Max$（左子树的直径，右子树的直径，左子树的最大深度+右子树的最大深度+1）。</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Diameter_of_Binary_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> diameter = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">diameterOfBinaryTree</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        depth(root);</span><br><span class="line">        <span class="keyword">return</span> diameter;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">depth</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 获得左子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> left = depth(root.left);</span><br><span class="line">        <span class="comment">// 获得右子树的深度</span></span><br><span class="line">        <span class="keyword">int</span> right = depth(root.right);</span><br><span class="line">        diameter = Math.max(diameter, left + right);</span><br><span class="line">        <span class="keyword">return</span> Math.max(left, right) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>因为这题需要对左、右子树都进行递归遍历操作，所以每个节点都要访问一次，因为是$O(n)$。</li><li><strong>空间复杂度：</strong>主要是进行DFS深度优先搜索的栈开销，为$O(n)$。</li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>100.Same Tree</title>
      <link href="/2020/02/02/100.Same-Tree/"/>
      <url>/2020/02/02/100.Same-Tree/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>相同的树</strong></p><p>Given two binary trees, write a function to check if they are the same or not.</p><p>Two binary trees are considered the same if they are structurally identical and the nodes have the same value.</p><p><strong>Example 1:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">       / \       / \</span><br><span class="line">      2   3     2   3</span><br><span class="line"></span><br><span class="line">     [1,2,3],   [1,2,3]</span><br><span class="line"></span><br><span class="line">Output: true</span><br></pre></td></tr></table></figure><p><strong>Example 2:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">       /           \</span><br><span class="line">      2             2</span><br><span class="line"></span><br><span class="line">     [1,2],     [1,null,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure><p><strong>Example 3:</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Input:     1         1</span><br><span class="line">       / \       / \</span><br><span class="line">      2   1     1   2</span><br><span class="line"></span><br><span class="line">     [1,2,1],   [1,1,2]</span><br><span class="line"></span><br><span class="line">Output: false</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>一棵树要么是空树，要么有两个指针，每个指针指向一颗树。树是一种递归结构，很多树的问题都可以使用递归来处理。</p><p>判断两个数是否是相同的树的终止条件时：</p><ol><li>当两颗数的节点都为<code>null</code>时，返回<code>true</code></li><li>当两棵树的节点一个为<code>null</code>一个不为<code>null</code>时，返回<code>false</code></li><li>当两个节点都不为<code>null</code>但是值不等时，返回<code>false</code></li><li>当两个节点都不为<code>null</code>且值相等时，递推判断接下来的节点，如果全部相同，则返回<code>true</code></li></ol><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Same_Tree</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isSameTree1</span><span class="params">(TreeNode p, TreeNode q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> &amp;&amp; q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span> || q == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.val != q.val) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 递推判断</span></span><br><span class="line">        <span class="keyword">return</span> isSameTree1(p.right, q.right) &amp;&amp; isSameTree1(p.left, q.left);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 定义树结构</span></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> val;</span><br><span class="line">        TreeNode left;</span><br><span class="line">        TreeNode right;</span><br><span class="line"></span><br><span class="line">        TreeNode(<span class="keyword">int</span> x) &#123;</span><br><span class="line">            val = x;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><strong>时间复杂度：</strong>$O(n)$，n为节点的数量，因为每个节点都要判断是否相同。</li><li><strong>空间复杂度：</strong>在最优情况下（完全平衡二叉树）时为$O(log(n))$，最坏情况下（完全不平衡二叉树）时为$O(n)$。</li></ul><h4 id="完全二叉树和平衡二叉树"><a href="#完全二叉树和平衡二叉树" class="headerlink" title="完全二叉树和平衡二叉树"></a>完全二叉树和平衡二叉树</h4><h5 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h5><p>只有树最下面的两层的节点度小于2，并且最下面一层的节点都集中在该层的最左边的若干位置的二叉树。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt=""></p><h5 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h5><p>平衡二叉树是为了保证树不至于太倾斜。所以定义如下：</p><p>平衡二叉树要么是一颗空树，要么保证左右子树的高度之差不大于1，同时子树也必须是一颗平衡二叉树。</p>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>785.Is Graph Bipartite</title>
      <link href="/2020/02/02/785.Is-Graph-Bipartite/"/>
      <url>/2020/02/02/785.Is-Graph-Bipartite/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>判断二分图</strong></p><p>Given an undirected <code>graph</code>, return <code>true</code> if and only if it is bipartite.</p><p>Recall that a graph is <em>bipartite</em> if we can split it’s set of nodes into two independent subsets A and B such that every edge in the graph has one node in A and another node in B.</p><p>The graph is given in the following form: <code>graph[i]</code> is a list of indexes <code>j</code> for which the edge between nodes <code>i</code> and <code>j</code> exists. Each node is an integer between <code>0</code> and <code>graph.length - 1</code>. There are no self edges or parallel edges: <code>graph[i]</code> does not contain <code>i</code>, and it doesn’t contain any element twice.</p></blockquote><a id="more"></a><p>这其实可以看做是一个着色问题，即可以转化为「<strong>如果这个图中每个相邻的节点间的颜色都是不一样的，那么就是二分图</strong>」。</p><h3 id="邻接表表示矩阵"><a href="#邻接表表示矩阵" class="headerlink" title="邻接表表示矩阵"></a>邻接表表示矩阵</h3><p>因为LeetCode上图的画法问题，导致我一开始没有看懂这个图是什么形状，是怎么用邻接表形式表示的。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">示例 1:</span><br><span class="line">输入: [[1,3], [0,2], [1,3], [0,2]]</span><br><span class="line">输出: true</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">|    |</span><br><span class="line">|    |</span><br><span class="line">3----2</span><br><span class="line">我们可以将节点分成两组: &#123;0, 2&#125; 和 &#123;1, 3&#125;。</span><br><span class="line"></span><br><span class="line">示例 2:</span><br><span class="line">输入: [[1,2,3], [0,2], [0,1,3], [0,2]]</span><br><span class="line">输出: false</span><br><span class="line">解释: </span><br><span class="line">无向图如下:</span><br><span class="line">0----1</span><br><span class="line">| \  |</span><br><span class="line">|  \ |</span><br><span class="line">3----2</span><br><span class="line">我们不能将节点分割成两个独立的子集。</span><br></pre></td></tr></table></figure><p>如上所示，如果输入<code>[[1,3], [0,2], [1,3], [0,2]]</code>，那么这个邻接表表示的是图的节点有<code>1-&gt;3,0-&gt;2</code>，因此画出的图其实是如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_9C75CB36F198-1.jpeg" style="zoom:50%;" /></p><p>同理，如果输入<code>[[1,2,3], [0,2], [0,1,3], [0,2]]</code>，那么说明<code>1-&gt;2,1-&gt;3,0-&gt;2,0-&gt;1,0-&gt;3</code>，所以图如下所示：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/IMG_FB44338948F8-1.jpeg" style="zoom:50%;" /></p><h3 id="方法：DFS搜索着色"><a href="#方法：DFS搜索着色" class="headerlink" title="方法：DFS搜索着色"></a>方法：DFS搜索着色</h3><p>如果节点属于第一个集合，将其设置为颜色0，否则为颜色1。当这个图为二分图时，就可以使用<strong>贪心思想</strong>给图着色：比如一个节点的颜色为0，则其所有的邻接点的颜色为1，其所有的邻接点的邻接点的颜色为0，以此类推。</p><p>先找到一个未着色的节点$u$，把它染上一种颜色，比如颜色1黑色，然后遍历所有与它相连的节点$v$，如果节点$v$已经被染色并且颜色和$u$是一样的，那么就不是二分图。如果这个节点$v$没有被染色，则先把它染成与节点$u$不同的颜色，例如颜色2红色，然后再遍历所有节点$v$的邻接点，依次递推。</p><p>可以使用数组或者哈希表来记录每个节点的颜色：<code>colors[node]</code>。颜色有两种，分别为1黑色和2红色，0表示未着色。</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Is_Graph_Bipartite</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isBipartite</span><span class="params">(<span class="keyword">int</span>[][] graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (graph == <span class="keyword">null</span> || graph.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> n = graph.length;</span><br><span class="line">        <span class="comment">// 设置 color 数组，0 表示未着色，1 黑，2 红</span></span><br><span class="line">        <span class="keyword">int</span>[] colors = <span class="keyword">new</span> <span class="keyword">int</span>[n];</span><br><span class="line">        <span class="comment">// Arrays.fill 方法将 color 数组中的所有元素的值设置为 0，表示未着色</span></span><br><span class="line">        Arrays.fill(colors, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (!dfs(graph, i, colors, <span class="number">0</span>)) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span>[][] graph, <span class="keyword">int</span> i, <span class="keyword">int</span>[] colors, <span class="keyword">int</span> preColor)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果未被染色</span></span><br><span class="line">        <span class="keyword">if</span> (colors[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">// 与相邻节点进行相反的染色</span></span><br><span class="line">            colors[i] = (preColor == <span class="number">1</span>) ? <span class="number">2</span> : <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; graph[i].length; j++) &#123;</span><br><span class="line">                <span class="comment">// 如果不能够再往下递推</span></span><br><span class="line">                <span class="keyword">if</span> (!dfs(graph, graph[i][j], colors, colors[i])) &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 已染色</span></span><br><span class="line">            <span class="comment">// 如果颜色和邻接点颜色一致</span></span><br><span class="line">            <span class="keyword">if</span> (colors[i] == preColor) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 图 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudSim NetworkExample1</title>
      <link href="/2020/02/02/CloudSim-NetworkExample1/"/>
      <url>/2020/02/02/CloudSim-NetworkExample1/</url>
      
        <content type="html"><![CDATA[<p>CloudSim中的Network包同样含有很多个Example。在NetworkExample1.java文件中，与Example1.java的不同，主要在于模拟之前，需要初始化网络拓扑。即有以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// load the network topology file</span></span><br><span class="line"><span class="comment">// 直接运行有可能会运行失败，报错找不到toplogy.brite文件</span></span><br><span class="line"><span class="comment">// 方法一：buildNetworkTopology()中的参数改为topology.brite的绝对路径</span></span><br><span class="line"><span class="comment">// 方法二：把topology.brite拷贝到项目的根目录下</span></span><br><span class="line">NetworkTopology.buildNetworkTopology(<span class="string">"topology.brite"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// maps CloudSim entities to BRITE entities</span></span><br><span class="line"><span class="comment">// PowerDatacenter will correspond to BRITE node 0</span></span><br><span class="line"><span class="keyword">int</span> briteNode=<span class="number">0</span>;</span><br><span class="line">NetworkTopology.mapNode(datacenter0.getId(),briteNode);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Broker will correspond to BRITE node 3</span></span><br><span class="line">briteNode=<span class="number">3</span>;</span><br><span class="line">NetworkTopology.mapNode(broker.getId(),briteNode);</span><br></pre></td></tr></table></figure><a id="more"></a><p>那么，NetworkTopology这个类的作用是什么呢？</p><p>它的实现主要是根据一个brite文件建立一个网络拓扑模型，topology.brite文件如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Topology: ( 5 Nodes, 8 Edges ) </span><br><span class="line">Model (1 - RTWaxman): 5 5 5 1 2 0.15000000596046448 0.20000000298023224 1 1 </span><br><span class="line">10.0 1024.0 </span><br><span class="line"></span><br><span class="line">Nodes: ( 5 ) </span><br><span class="line">0 1 3 3 3 -1 RT_NODE </span><br><span class="line">1 0 3 3 3 -1 RT_NODE </span><br><span class="line">2 4 3 3 3 -1 RT_NODE </span><br><span class="line">3 3 1 3 3 -1 RT_NODE </span><br><span class="line">4 3 3 4 4 -1 RT_NODE </span><br><span class="line"></span><br><span class="line">Edges: ( 8 ) </span><br><span class="line">0 2 0 3.0 1.1 10.0 -1 -1 E_RT U </span><br><span class="line">1 2 1 4.0 2.1 10.0 -1 -1 E_RT U </span><br><span class="line">2 3 0 2.8284271247461903 3.9 10.0 -1 -1 E_RT U </span><br><span class="line">3 3 1 3.605551275463989 4.1 10.0 -1 -1 E_RT U </span><br><span class="line">4 4 3 2.0 5.0 10.0 -1 -1 E_RT U </span><br><span class="line">5 4 2 1.0 4.0 10.0 -1 -1 E_RT U </span><br><span class="line">6 0 4 2.0 3.0 10.0 -1 -1 E_RT U </span><br><span class="line">7 1 4 3.0 4.1 10.0 -1 -1 E_RT U</span><br></pre></td></tr></table></figure><p>程序运行后会寻找标记<code>Nodes</code>和<code>Edges</code>，<code>Nodes</code>是节点信息，其中第一列是节点序号，第二列是节点的横坐标，第三列是节点的纵坐标；<code>Edges</code>是边信息，第一列是边序号，第二列是始节点序号，第三列是终节点序号，第四列是边长度，第五列是边时延，第六列是边带宽。</p><p>这里有一个关键类<code>ToplogicalGraph</code>，描绘了图的拓扑的数据结构。这里面包含两个链表，分别用来存储节点<code>ToplogicalNode</code>和边<code>ToplogicalLink</code>。</p><p>在<code>ToplogicalGraph</code>中通过<code>readGraphFile</code>方法，将文件中的描述，转化为网络拓扑模型。接着用得到的网络拓扑，通过<code>generateMatrices()</code>和<code>createBwMatrix()</code>生成一个是实体间的时延矩阵和带宽矩阵。</p>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CloudSim Example1</title>
      <link href="/2020/02/01/CloudSim-Example1/"/>
      <url>/2020/02/01/CloudSim-Example1/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>CloudSim是一个云计算基础架构和服务的建模和仿真框架，由Java语言编写，提供给研究人员做仿真实验。</p><h2 id="主要特点"><a href="#主要特点" class="headerlink" title="主要特点"></a>主要特点</h2><ul><li>支持大型云计算数据中心的建模和仿真</li><li>支持对虚拟服务器主机进行建模和仿真，并具有可自定义的策略，用于向虚拟机提供主机资源</li><li>支持对应用程序容器进行建模和仿真</li><li>支持能源感知计算资源的建模和仿真</li><li>支持对数据中心网络拓扑和消息传递应用程序进行建模和仿真</li><li>支持动态插入模拟元素，停止和继续模拟</li><li>支持用于将主机分配给虚拟机的用户定义策略以及用于将主机资源分配给虚拟机的资源</li></ul><a id="more"></a><h2 id="Example1"><a href="#Example1" class="headerlink" title="Example1"></a>Example1</h2><p>Inspect <strong>ClouldSimExample1.java</strong>. Study the code and try to get an overall feel for what it is doing (or supposed to do). You should focus on the following aspects: </p><ul><li>Virtual Machine creation </li><li>Virtual Machine description</li><li>Broker</li><li>Cloudlet</li><li>Data centre</li><li>Simulation parameter setting</li><li>Simulation output</li></ul><p><code>CloudSimExample1.java</code>主要创建了一个含有一个云主机的数据中心，并在其上运行一个云任务。以下是部分代码分析：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CloudSimExample1</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// 云用户数量</span></span><br><span class="line">            <span class="keyword">int</span> num_user = <span class="number">1</span>;</span><br><span class="line">            <span class="comment">// 用当前日期和时间初始化字段的日历</span></span><br><span class="line">            Calendar calendar = Calendar.getInstance();</span><br><span class="line">            <span class="comment">// 事件追踪</span></span><br><span class="line">            <span class="keyword">boolean</span> trace_flag = <span class="keyword">false</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 初始化 CloudSim 工具包</span></span><br><span class="line">            CloudSim.init(num_user, calendar, trace_flag);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建数据中心</span></span><br><span class="line">            Datacenter datacenter0 = createDatacenter(<span class="string">"Datacenter 0"</span>);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建 Broker 代理</span></span><br><span class="line">            DatacenterBroker broker = createBroker();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个虚拟机列表</span></span><br><span class="line">            vmlist = <span class="keyword">new</span> ArrayList&lt;Vm&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建一个虚拟机</span></span><br><span class="line">            Vm vm = <span class="keyword">new</span> Vm(vmid, brokerId, mips, pesNumber, ram, bw, size, vmm, <span class="keyword">new</span> CloudletSchedulerTimeShared());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将虚拟机添加到虚拟机列表中</span></span><br><span class="line">            vmlist.add(vm);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将虚拟机列表提交到数据中心代理</span></span><br><span class="line">            broker.submitVmList(vmlist);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建云任务列表</span></span><br><span class="line">            cloudletList = <span class="keyword">new</span> ArrayList&lt;Cloudlet&gt;();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 创建云任务</span></span><br><span class="line">            Cloudlet cloudlet = <span class="keyword">new</span> Cloudlet(id, length, pesNumber, fileSize, outputSize, utilizationModel, utilizationModel, utilizationModel);</span><br><span class="line">truetruetruecloudlet.setUserId(brokerId);</span><br><span class="line">truetruetruecloudlet.setVmId(vmid);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将云任务添加到列表中</span></span><br><span class="line">            cloudletList.add(cloudlet);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 将云任务列表提交到数据中心代理</span></span><br><span class="line">            broker.submitCloudletList(cloudletList);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 开始模拟</span></span><br><span class="line">            CloudSim.startSimulation();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 结束模拟</span></span><br><span class="line">            CloudSim.stopSimulation();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">// 输出结果</span></span><br><span class="line">            List&lt;Cloudlet&gt; newList = broker.getCloudletReceivedList();</span><br><span class="line">            printCloudletList(newList);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建数据中心</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> Datacenter <span class="title">createDatacenter</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 创建列表用于储存机器，简称主机列表</span></span><br><span class="line">        List&lt;Host&gt; hostList = <span class="keyword">new</span> ArrayList&lt;Host&gt;();</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建处理器，并添加到Pe列表中</span></span><br><span class="line">        peList.add(<span class="keyword">new</span> Pe(<span class="number">0</span>, <span class="keyword">new</span> PeProvisionerSimple(mips)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建处理器，并将其添加到主机列表中</span></span><br><span class="line">        <span class="keyword">int</span> hostId = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> ram = <span class="number">2048</span>;</span><br><span class="line">        <span class="keyword">long</span> storage = <span class="number">1000000</span>;</span><br><span class="line">        <span class="keyword">int</span> bw = <span class="number">10000</span>;</span><br><span class="line">        </span><br><span class="line">        hostList.add(<span class="keyword">new</span> Host(hostId, <span class="keyword">new</span> RamProvisionerSimple(ram), <span class="keyword">new</span> BwProvisionerSimple(bw), storage, peList, <span class="keyword">new</span> VmSchedulerTimeShared(peList)));</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建数据中心特征，它表示了数据中心的静态属性：体系架构、操作系统、主机列表、分配策略、时间或空间共享、时区、价格</span></span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 创建Power数据中心</span></span><br><span class="line">        Datacenter datacenter = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            datacenter = <span class="keyword">new</span> Datacenter(name, characteristics, <span class="keyword">new</span> VmAllocationPolicySimple(hostList), storageList, <span class="number">0</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> datacenter;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 创建代理，可以根据特定需求发展自己的代理协议来提交虚拟机和云任务</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> DatacenterBroker <span class="title">createBroker</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 打印</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printCloudletList</span><span class="params">(List&lt;Cloudlet&gt; list)</span> </span>&#123;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CloudSim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础知识</title>
      <link href="/2020/01/24/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
      <url>/2020/01/24/Java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="Java基础知识"><a href="#Java基础知识" class="headerlink" title="Java基础知识"></a>Java基础知识</h2><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul><li><strong>面向过程：面向过程比面向对象的性能更高</strong>。因为类调用时需要实例化，开销比较大。但是，面向过程没有面向对象易维护、易复用、易拓展。</li><li><strong>面向对象：易维护、易复用、易拓展</strong>。因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活，更加易于维护。</li></ul><a id="more"></a><h3 id="JVM、JDK和JRE"><a href="#JVM、JDK和JRE" class="headerlink" title="JVM、JDK和JRE"></a>JVM、JDK和JRE</h3><h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>Java虚拟机（JVM）是运行Java字节码的虚拟机。JVM有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</p><h5 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h5><blockquote><p>在 Java 中，JVM可以理解的代码就叫做<code>字节码</code>（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以 Java 程序运行时比较高效，而且，由于字节码并不针对一种特定的机器，因此，Java程序无须重新编译便可在多种不同操作系统的计算机上运行。</p></blockquote><h5 id="Java程序从源代码到运行的步骤"><a href="#Java程序从源代码到运行的步骤" class="headerlink" title="Java程序从源代码到运行的步骤"></a>Java程序从源代码到运行的步骤</h5><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f4a6176612532302545372541382538422545352542412538462545382542462539302545382541312538432545382542462538372545372541382538422e706e67.png" alt=""></p><h4 id="JDK和JRE"><a href="#JDK和JRE" class="headerlink" title="JDK和JRE"></a>JDK和JRE</h4><p>JDK是Java Development Kit，是Java SDK。它拥有JRE的一切，还有编译器（javac）和工具（例如javadoc）。<strong>它能够创建和编译程序。</strong></p><p>JRE是Java运行时的环境。它是运行已编译Java程序所需的所有内容的集合，包括Java虚拟机（JVM），Java类库，Java命令等。<strong>但它不能用于创建新程序。</strong></p><h3 id="Java和C-的区别"><a href="#Java和C-的区别" class="headerlink" title="Java和C++的区别"></a>Java和C++的区别</h3><ul><li>都是面向对象的语言，都支持封装、继承和多 态</li><li>Java<strong>不提供指针</strong>来直接访问内存，程序内存会更加安全</li><li>Java的类是<strong>单继承</strong>的，C++支持<strong>多重继承</strong>；Java的接口可以多继承</li><li>Java有自动内存管理机制</li></ul><h3 id="重载和重写的区别"><a href="#重载和重写的区别" class="headerlink" title="重载和重写的区别"></a>重载和重写的区别</h3><h4 id="重载"><a href="#重载" class="headerlink" title="重载"></a>重载</h4><p>发生在同一类中，方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。简单的说，就是<strong>多个方法有相同的名字、不同的参数</strong>，便产生了重载。</p><h4 id="重写"><a href="#重写" class="headerlink" title="重写"></a>重写</h4><p>重写是子类对父类的允许访问的方法的实现过程进行重新编写，发生在子类中，方法名、参数列表必须相同，返回值范围小于等于父类，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。如果父类方法访问修饰符为<code>private</code>则子类不能重写该方法。</p><h3 id="三大特性：封装-继承-多态"><a href="#三大特性：封装-继承-多态" class="headerlink" title="三大特性：封装 继承 多态"></a>三大特性：封装 继承 多态</h3><h4 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h4><p>封装把一个对象的属性私有化，同时提供一些可以被外界访问的属性的方法。</p><h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是使用已存在的类的定义作为基础建立类的技术，新的类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。</p><ul><li>子类拥有父类对象的所有属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问的，只是拥有。</li><li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li><li>子类可以用自己的方式实现父类的方法。</li></ul><h4 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h4><p>多态就是指程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定，即一个引用变量到底会指向哪个类的实例对象，该引用变量发出的方法调用到底是哪个类中实现的方法，必须在由程序运行期间才能决定。</p><p>在Java中可以有两种形式实现多态：<strong>继承</strong>和<strong>接口</strong>。</p><h3 id="接口和抽象类的区别"><a href="#接口和抽象类的区别" class="headerlink" title="接口和抽象类的区别"></a>接口和抽象类的区别</h3><ol><li>接口的方法默认是<code>public</code>，所有方法在接口中不能实现，而抽象类可以有非抽象的方法。</li><li>接口中除了static、final变量，不能有其它变量，而抽象类中则不一定。</li><li>一个类可以实现多个接口，但是只能实现一个抽象类。接口自己本身可以通过<code>extends</code>关键字扩展多个接口。</li><li>接口方法默认修饰符是<code>public</code>，抽象方法可以有<code>public</code>、<code>protected</code>和<code>default</code>这些修饰符（不能使用<code>private</code>关键字修饰）</li></ol><h3 id="String-StringBuffer-StringBuilder的区别"><a href="#String-StringBuffer-StringBuilder的区别" class="headerlink" title="String StringBuffer StringBuilder的区别"></a>String StringBuffer StringBuilder的区别</h3><h4 id="可变性"><a href="#可变性" class="headerlink" title="可变性"></a>可变性</h4><p><code>String</code>类中是使用<code>final</code>关键字修饰字符数组来保存字符串，所以<code>String</code>对象是不可变的。<code>StringBuilder</code>与<code>StringBuffer</code>都继承自<code>AbstractStringBuilder</code>类，在<code>AbstractStringBuilder</code>中没有用<code>final</code>关键字修饰，所以这两种对象是可变的。</p><h4 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h4><p><code>String</code>中的对象是不可变的，也可以理解为常量，线程安全。<code>StringBuffer</code>对方法添加了同步锁或者对调用的方法加了同步锁，所以是<strong>线程安全</strong>的。<code>StringBuilder</code>并没有对方法进行加同步锁，所以是<strong>非线程安全</strong>的。</p><h4 id="性能"><a href="#性能" class="headerlink" title="性能"></a>性能</h4><p>每次对<code>String</code>类型进行改变时，都会生成一个新的<code>String</code>对象，然后将指针指向新的<code>String</code>对象。</p><p><code>StringBuffer</code>每次都会对<code>StringBuffer</code>对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用<code>StringBuilder</code>相比使用<code>StringBuffer</code>能获得10%~15%左右的性能提升，但是要冒线程不安全的风险。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ol><li>操作<strong>少量数据</strong>：适用<code>String</code></li><li><strong>单线程</strong>操作字符串缓冲区下操作大量数据：适用<code>StringBuilder</code></li><li><strong>多线程</strong>操作字符串缓冲区下操作大量数据：适用<code>StringBuffer</code></li></ol><h3 id="自动装箱与拆箱"><a href="#自动装箱与拆箱" class="headerlink" title="自动装箱与拆箱"></a>自动装箱与拆箱</h3><ul><li><strong>装箱</strong>：将基本类型用它们对应的引用类型包装起来；</li><li><strong>拆箱</strong>：将包装类型转换为基本数据类型；</li></ul><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><ol><li><strong>语法形式</strong>：成员变量是<strong>属于类</strong>的，而局部变量是在<strong>方法中定义的变量</strong>或者是<strong>方法的参数</strong>；成员变量可以被<code>public</code>、<code>private</code>、<code>static</code>等修饰符修饰，而局部变量不能被访问控制修饰符及<code>static</code>所修饰；但是它们都能被<code>final</code>修饰符修饰。</li><li><strong>变量在内存中的存储方式</strong>：如果成员变量是使用<code>static</code>修饰的，那么这个成员变量是属于类的；如果没有使用<code>static</code>修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。</li><li><strong>变量在内存中的生存时间</strong>：成员变量是对象的一部分，随着对象的创建而存在；而局部变量会随着方法的调用而自动消失。</li><li>成员变量如果没有被赋初值，则会自动以类型的默认值而赋值（如果被<code>final</code>修饰，则必须显式赋值），而局部变量不会自动赋值。</li></ol><h3 id="构造方法的作用和特性"><a href="#构造方法的作用和特性" class="headerlink" title="构造方法的作用和特性"></a>构造方法的作用和特性</h3><p>构造方法的主要作用是完成对类对象的初始化工作。</p><h4 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h4><ol><li>名字与类名相同。</li><li>没有返回值，但是也不能用<code>void</code>声明构造函数。</li><li>生成类的对象时自动执行，无需调用。</li></ol><h3 id="静态方法和实例方法的不同"><a href="#静态方法和实例方法的不同" class="headerlink" title="静态方法和实例方法的不同"></a>静态方法和实例方法的不同</h3><ol><li>在外部调用<strong>静态方法</strong>时，可以使用<code>类名.方法名</code>的方式，也可以使用<code>对象名.方法名</code>的方式。而实例方法只能后面这种方式，即需要创建新对象而静态方法不需要。</li><li>静态方法在访问本类的成员时，只能允许访问静态成员（即静态成员变量和静态方法），而不允许访问实例成员变量和实例方法。</li></ol><h3 id="与equals"><a href="#与equals" class="headerlink" title="==与equals"></a><code>==</code>与<code>equals</code></h3><p><strong>==</strong>：判断两个对象的地址是否相等，即判断<strong>两个对象是否是同一个对象</strong>。</p><p><strong>equals()</strong>：判断两个对象是否相等，但有两种使用情况：</p><ul><li>如果类没有覆盖<code>equals()</code>方法，则通过<code>equals()</code>比较该类的两个对象时，等价于通过<code>==</code>比较这两个对象。</li><li>如果类覆盖了<code>equals()</code>方法，一般都覆盖<code>equals()</code>方法来比较两个对象的内容是否相等，若相等则直接返回<code>true</code>。</li></ul><h3 id="final关键字"><a href="#final关键字" class="headerlink" title="final关键字"></a>final关键字</h3><p><code>final</code>关键字主要用在三个地方：变量、方法、类。</p><ol><li>如果是基本数据类型的变量，其数值在初始化之后就不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。</li><li>当用<code>final</code>修饰一个类时，表明这个类不能被继承。<code>final</code>类中的所有成员方法都会被隐式的指定为<code>final</code>方法。</li><li>使用<code>final</code>的原因有两个。一个是把方法锁定，以防任何继承类来修改它的含义。所以类中所有的<code>private</code>方法都被隐式的指定为<code>final</code>；第二个原因是效率。</li></ol><h3 id="static关键字"><a href="#static关键字" class="headerlink" title="static关键字"></a>static关键字</h3><p><code>static</code>关键字主要有以下四种使用场景：</p><ol><li><strong>修饰成员变量和成员方法</strong>：被<code>static</code>修饰的成员属于类，不属于单个这个类的某个对象，被类中所有对象共享，可以直接通过类名调用。被<code>static</code>声明的成员变量属于静态成员变量，静态变量存放在Java内存区域的方法区。调用格式：<code>类名.静态变量名</code>和<code>类名.静态方法名()</code>。</li><li><strong>静态代码块</strong>：静态代码块定义在类中方法外，静态代码块在非静态代码块之前执行。该类不管创建多少对象，静态代码块只执行一次。</li><li><strong>静态内部类（<code>static</code>只能修饰内部类）</strong>：非静态内部类在编译完成之后会隐含地保存着一个引用，该引用是指向创建它的外围类，但是静态内部类却没有。没有这个引用意味：1. 它的创建是不需要依赖外围类的创建；2. 它不能使用任何外围类的非<code>static</code>成员变量和方法。</li><li><strong>静态导包（用来导入类中的静态资源）</strong>：格式为<code>import static</code>，这个关键字连用可以指定导入某个类中的指定静态资源，并且不需要使用类名调用类中静态成员，可以直接使用类中静态成员变量和成员方法。</li></ol><h4 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h4><p>静态代码块的格式是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="comment">// 语句体;</span></span><br><span class="line">    i = <span class="number">3</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一个类中的静态代码块可以有多个，位置可以随便放，它不在任何的方法体内，JVM加载类时会执行这些静态的代码块，如果静态代码块有多个，JVM将按照它们在类中的出现的先后顺序依次执行它们，每个代码块只会被执行一次。</p><p>静态代码块对于定义在它之后的静态变量，可以赋值，但是不能访问。</p><h3 id="this和super关键字"><a href="#this和super关键字" class="headerlink" title="this和super关键字"></a>this和super关键字</h3><p><code>this</code>关键字用于引用类的当前实例，此关键字是可选的，使用此关键字可能会使代码更易读或易懂。</p><p><code>super</code>关键字用于从子类访问父类的变量和方法。</p><ul><li>使用<code>super()</code>调用父类中的其它构造方法时，该语句必须处于首行，否则编译器会报错。另外，<code>this</code>调用本类中的其它构造方法时，也要放在首行。</li><li><code>this</code>、<code>super</code>不能用在<code>static</code>方法中。</li></ul><h3 id="异常处理"><a href="#异常处理" class="headerlink" title="异常处理"></a>异常处理</h3><p>在<code>Java</code>中，所有的异常都有一个共同的祖先<code>java.lang</code>包中的<code>Throwable</code>类。<code>Throwable</code>有两个重要的子类：<code>Exception</code>（异常）和<code>Error</code>（错误），二者都是<code>Java</code>异常处理的重要子类，各自包含大量的子类。异常和错误的区别：异常能被程序本身处理，错误是无法处理的。</p><h4 id="Error（错误）"><a href="#Error（错误）" class="headerlink" title="Error（错误）"></a>Error（错误）</h4><p><strong>是程序无法处理的错误</strong>，表示运行应用程序中较严重问题。大多数错误表示代码运行时JVM（Java虚拟机）出现的问题，例如JVM不再有继续执行操作所需的内存资源时，将出现<code>OutOfMemoryError</code>。这些错误表示故障是发生于虚拟机自身或者发生在虚拟机试图执行应用时，如Java虚拟机运行错误（<code>Virtual MachineError</code>）、类定义错误（<code>NoClassDefFoundError</code>）等。这些错误在运行前是不可查的。</p><h4 id="Exception（异常）"><a href="#Exception（异常）" class="headerlink" title="Exception（异常）"></a>Exception（异常）</h4><p><strong>是程序本身可以处理的异常</strong>。<code>Exceptiton</code>类有一个重要的子类<code>RuntimeException</code>。除此之外，还有<code>NullPointerException</code>和<code>ArrayIndexOutOfBoundsException</code>等。</p><h4 id="Throwable类常用方法"><a href="#Throwable类常用方法" class="headerlink" title="Throwable类常用方法"></a>Throwable类常用方法</h4><ul><li><code>public string getMessage()</code>：返回异常发生时的简要描述</li><li><code>public string toString()</code>：返回异常发生时的详细信息</li><li><code>public string getLocalizedMessage()</code>：返回异常对象的本地化信息。如果<code>Throwable</code>的子类有覆盖这个方法，则可以生成本地化信息。如果子类没有覆盖这个方法，则方法返回的信息与<code>getMessage()</code>返回的结果相同</li><li><code>public void printStackTrace()</code>：在控制台上打印<code>Throwable</code>对象封装的异常信息</li></ul><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><strong>try块</strong>：用于捕获异常，其后可以接多个<strong>catch块</strong>或者不接。如果其后没有<strong>catch块</strong>，则必须跟一个<strong>finally块</strong>。</li><li><strong>catch块</strong>：用于处理<code>try</code>捕获到的异常。</li><li><strong>finally块</strong>：无论是否捕获或处理异常，<strong>finally块</strong>里的语句都会被执行。如果在<strong>try块</strong>或者<strong>catch块</strong>中有<code>return</code>语句，则在<code>return</code>返回之前执行<strong>finally语句</strong>。</li></ul><p>有四种特殊情况下，<code>finally</code>块不会执行：</p><ol><li>在<code>finally</code>语句块第一行发生了异常。</li><li>在前面的代码中使用了<code>System.exit()</code>退出程序。</li><li>程序所在的线程死亡。</li><li>关闭CPU。</li></ol><h3 id="hashCode与equals"><a href="#hashCode与equals" class="headerlink" title="hashCode与equals"></a>hashCode与equals</h3><p><code>hashCode()</code>的作用是获取哈希码，也称为散列码；它实际上是返回一个<code>int</code>整数。这个哈希码的作用是确定该对象在哈希表中的索引位置。<code>hashCode()</code>定义在JDK的<code>Object.java</code>中，意味着Java的任何类都包含<code>hashCode()</code>函数。<code>hashCode()</code>在散列表中才有用，在其它情况下没用。在散列表中<code>hashCode()</code>的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p><ol><li>如果两个对象相等，则<code>hashCode</code>也一定是相同的</li><li>如果两个对象相等，则对两个对象分别调用<code>equals()</code>方法都返回<code>true</code></li><li>两个对象有相同的<code>hashCode</code>值，也不一定是相等的</li><li><code>equals</code>方法被覆盖过，则<code>hashCode</code>方法也必须被覆盖</li><li><code>hashCode()</code> 的默认行为是对堆上的对象产生独特值。如果没有重写<code>hashCode()</code>，则该 <code>class</code>的两个对象无论如何都不会相等（即使这两个对象指向相同的数据）</li></ol><h3 id="Collections工具类和Arrays工具类常见方法"><a href="#Collections工具类和Arrays工具类常见方法" class="headerlink" title="Collections工具类和Arrays工具类常见方法"></a>Collections工具类和Arrays工具类常见方法</h3><h4 id="Collections工具类常用方法："><a href="#Collections工具类常用方法：" class="headerlink" title="Collections工具类常用方法："></a>Collections工具类常用方法：</h4><ol><li>排序</li><li>查找，替换操作</li><li>同步控制（不推荐，需要线程安全的集合类型时请考虑使用JUC包的并发集合）</li></ol><h5 id="排序操作"><a href="#排序操作" class="headerlink" title="排序操作"></a>排序操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">reverse</span><span class="params">(List list)</span><span class="comment">// 反转</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shuffle</span><span class="params">(List list)</span> <span class="comment">// 随机排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list)</span> <span class="comment">// 按自然排序的升序排序</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sort</span><span class="params">(List list, Comparator c)</span> <span class="comment">// 定制排序，由Comparator控制排序逻辑</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(List list, <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> <span class="comment">// 交换两个索引位置的元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">rotate</span><span class="params">(List list, <span class="keyword">int</span> distance)</span> <span class="comment">// 旋转。当distance为正数时，将list后distatnce个元素整体移到前面。当distance为负数时，将list的前distance个元素整体移到后面。</span></span></span><br></pre></td></tr></table></figure><h5 id="查找，替换操作"><a href="#查找，替换操作" class="headerlink" title="查找，替换操作"></a>查找，替换操作</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binarySearch</span><span class="params">(List list, Object key)</span> <span class="comment">// 对List进行二分查找，返回索引，注意List必须是有序的</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll)</span><span class="comment">// 根据元素的自然顺序，返回最大元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">max</span><span class="params">(Collection coll, Comparator c)</span> <span class="comment">// 根据定制排序，返回最大元素，排序规则由Comparatator类控制</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fill</span><span class="params">(List list, Object obj)</span> <span class="comment">// 用指定的元素代替指定list中的所有元素</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">frequency</span><span class="params">(Collection c, Object o)</span> <span class="comment">// 统计元素出现个数</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">indexOfSubList</span><span class="params">(List list, List target)</span> <span class="comment">// 统计target在list中第一次出现的索引</span></span></span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">replaceAll</span><span class="params">(List list, Object oldVal, Object newVal)</span> <span class="comment">// 用新元素替换旧元素</span></span></span><br></pre></td></tr></table></figure><h5 id="同步控制"><a href="#同步控制" class="headerlink" title="同步控制"></a>同步控制</h5><p>因为<code>HashSet</code>、<code>TreeSet</code>、<code>ArrayList</code>、<code>LinkedList</code>、<code>HashMap</code>、<code>TreeMap</code>都是线程不安全的。<code>Collections</code>提供了多个<code>synchronizedXxx()</code>静态方法可以把它们包装成线程同步的集合。</p><p><strong>最好不要使用下面这些方法，因为效率非常低</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">synchronizedCollection(Collection&lt;T&gt; c);</span><br><span class="line">synchronizedList(List&lt;T&gt; list);</span><br><span class="line">synchronizedMap(Map&lt;K, V&gt;, m);</span><br><span class="line">synchronizedSet(Set&lt;T&gt; s);</span><br></pre></td></tr></table></figure><h4 id="Arrays类的常见操作"><a href="#Arrays类的常见操作" class="headerlink" title="Arrays类的常见操作"></a>Arrays类的常见操作</h4><ol><li>排序：<code>sort()</code></li><li>查找：<code>binarySearch()</code></li><li>比较：<code>equals()</code></li><li>填充：<code>fill()</code></li><li>转列表：<code>asList()</code></li><li>转字符串：<code>toString()</code></li><li>赋值：<code>copyOf()</code></li></ol><h3 id="Java中的IO流"><a href="#Java中的IO流" class="headerlink" title="Java中的IO流"></a>Java中的IO流</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><ul><li>按照流的流向分，可以分为<strong>输入流</strong>和<strong>输出流</strong>；</li><li>按照操作单元分，可以分为<strong>字节流</strong>和<strong>字符流</strong>；</li><li>按照流的角色分，可以分为<strong>节点流</strong>和<strong>处理流</strong>；</li></ul><p>Java的IO流中的类都是从4个抽象类基类中派生出来的。</p><ul><li><code>InputStream/Reader</code>：所有的输入流的基类，前者是<strong>字节输入流</strong>，后者是<strong>字符输入流</strong>。</li><li><code>OutputStream/Writer</code>：所有的输出流的基类，前者是<strong>字节输出流</strong>，后者是<strong>字符输出流</strong>。</li></ul><h3 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h3><p>如果一个方法接收<code>List&lt;Object&gt;</code>作为形式参数，那么如果尝试将<code>List&lt;String&gt;</code>的对象作为实际参数传进去，就会发现无法通过编译。尽管<code>String</code>是<code>Object</code>的子类，但是实际上会<strong>产生隐含的类型转换问题</strong>，所以编译器是禁止这样的行为的。</p><h4 id="类型擦除"><a href="#类型擦除" class="headerlink" title="类型擦除"></a>类型擦除</h4><p>在生成的Java字节代码中是不包含泛型中的类型信息的。使用泛型的时候加上的类型参数会被编译器在编译的时候去掉，这个过程就叫做<strong>类型擦除</strong>。比如，<code>List&lt;String&gt;</code>和<code>List&lt;Object&gt;</code>等类型在编译之后都会变成<code>List</code>。JVM看到的只有<code>List</code>，而由泛型附加的类型信息对于JVM来说是不可见的。</p><h4 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h4><p>在使用泛型类的时候，既可以指定一个具体的类型，如<code>List&lt;String&gt;</code>就声明了具体类型是<code>String</code>类型；但也可以通过通配符<code>?</code>来表示未知类型，如<code>List&lt;?&gt;</code>就表示了<code>List</code>中包含的元素类型是未知的，也就意味着所有类型都是可以的。</p><p>但注意<code>List&lt;?&gt;</code>并不等同于<code>List&lt;Object&gt;</code>。因为<code>List&lt;Object&gt;</code>确定了<code>List</code>中包含的是<code>Object</code>及其子类，在使用的时候都可以通过<code>Object</code>来进行引用，而<code>List&lt;?&gt;</code>其中包含的元素是不确定的。如果其包含的是<code>String</code>类型的，那往里添加<code>Integer</code>类型的元素就是错误的。</p><p>在某些情况下，可以使用<strong>上下界</strong>来限制未知类型的范围。如通过<code>List&lt;? extends Number&gt;</code>来说明<code>List</code>中可能包含的元素类型是<code>Number</code>及其子类。而<code>List&lt;? super Number&gt;</code>则说明<code>List</code>中包含的是<code>Number</code>及其父类。当引入了上界之后，在使用类型的时候就可以使用上界类中定义的方法。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>墨染霜——曹植</title>
      <link href="/2020/01/22/%E5%A2%A8%E6%9F%93%E9%9C%9C%E2%80%94%E2%80%94%E6%9B%B9%E6%A4%8D/"/>
      <url>/2020/01/22/%E5%A2%A8%E6%9F%93%E9%9C%9C%E2%80%94%E2%80%94%E6%9B%B9%E6%A4%8D/</url>
      
        <content type="html"><![CDATA[<p>昔年风骨皆建安</p><p>点墨琳琅耀星汉</p><p>拂袖长歌醉青衫</p><p>夜听闲棋敲纹盘</p><p>微婉雅韵自悠然</p><a id="more"></a><p>天地初入胸臆缓登台</p><p>援笔千言尽华彩</p><p>青眼景慕庙堂寒</p><p>犹映余晖自烛堪</p><p>深恭敛退情义难</p><p>雨打江山</p><p>半纸盛藻 半枕黄粱 聚散俱无端</p><p>半生锦繁 半世离乱 杯中尽余欢</p><p>今古粲溢流年</p><p>卓尔怎居偏安</p><p>何如飘摇随长风</p><p>百载相传</p><p>为君不易 为臣独难 忠信事不显</p><p>悲歌长吟 悲风弦断 泪下冠缨沾</p><p>忆昔踌躇临轩</p><p>而今凌云志短</p><p>旦暮间参商相槛</p><p>千秋一叹</p><p>昔年征伐非沙场</p><p>俯仰沉浮尽炎凉</p><p>一朝青鸾平步升</p><p>明夕同袍隔阋墙</p><p>九重宫阙降离殃</p><p>迷津漫漫一苇独难航</p><p>若枕相思入他乡</p><p>城头不复汉时月</p><p>金銮青冥两茫茫</p><p>不如怀佩归苍黄</p><p>洛川雪扬</p><p>一步一怅 一字一憾 墨染殿前霜</p><p>一言一人 一生一心 道斯人未忘</p><p>长门火映微光</p><p>冷寂漠然空响</p><p>物是人非事亦休</p><p>七步成殇</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础（二）</title>
      <link href="/2020/01/13/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2020/01/13/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="可空和非可空类型"><a href="#可空和非可空类型" class="headerlink" title="可空和非可空类型"></a>可空和非可空类型</h2><p>在Kotlin中，对于<code>null</code>安全类型是一种消除代码中空引用风险的过程。如果Kotlin编译器发现任何<code>null</code>参数而仍然执行<code>null</code>引用相关语句，则会立即抛出<code>NullPointerException</code>。</p><p>Kotlin类型系统区分可以保持<code>null</code>（可空引用）和不能保持<code>null</code>（非<code>null</code>引用）的引用。通常，<code>String</code>类型是不可为<code>null</code>的。要创建保存<code>null</code>值的字符串，必须要放置一个<code>?</code>来明确定义。例如，<code>String?</code></p><h3 id="可空类型"><a href="#可空类型" class="headerlink" title="可空类型"></a>可空类型</h3><p>通过放置一个<code>?</code>来声明可空类型<code>?</code>在String后面</p><a id="more"></a><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str1: String? = <span class="string">"hello"</span></span><br><span class="line">str1 = <span class="literal">null</span><span class="comment">// ok</span></span><br></pre></td></tr></table></figure><p>这时候<code>str1</code>可以等于<code>null</code>。</p><h3 id="非可空类型"><a href="#非可空类型" class="headerlink" title="非可空类型"></a>非可空类型</h3><p>非可空类型是普通字符串，它们声明为<code>String</code>类型</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> str: String = <span class="literal">null</span><span class="comment">// compile error</span></span><br><span class="line">str = <span class="string">"hello"</span><span class="comment">// compile error Val cannot be reassign</span></span><br><span class="line"><span class="keyword">var</span> str2: String = <span class="string">"hello"</span></span><br><span class="line">str2 = <span class="literal">null</span><span class="comment">// compile error</span></span><br></pre></td></tr></table></figure><p>第一行的错误是没有将<code>str</code>定义为可空类型就令它为<code>null</code>。第二行的错误是使用<code>val</code>定义<code>str</code>，那么之后<code>str</code>的值是不可更改的。第三、四行虽然用<code>var</code>定义<code>str2</code>，但是同样没有定义为可空类型，所以不可令<code>str2 = null</code>。</p><h2 id="智能类型转换"><a href="#智能类型转换" class="headerlink" title="智能类型转换"></a>智能类型转换</h2><p>在没有安全转换的情况下访问可空类型的<code>String</code>时，它将生成编译错误。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> string: String? = <span class="string">"Hello"</span></span><br><span class="line">print(string.length)<span class="comment">//compile error</span></span><br></pre></td></tr></table></figure><p>如上代码会报错，因为没有判断字符串是否为空。</p><p>而使用安全转换为：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> string: String? = <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">if</span> (string != <span class="literal">null</span>) &#123;</span><br><span class="line">    print(string.length)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在判断string不为空后，就可以正常执行。</p><h3 id="使用is或-is来智能转换"><a href="#使用is或-is来智能转换" class="headerlink" title="使用is或!is来智能转换"></a>使用is或!is来智能转换</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> obj: Any = <span class="string">"Hello"</span></span><br><span class="line">  <span class="keyword">if</span> (obj <span class="keyword">is</span> String) &#123;</span><br><span class="line">    println(<span class="string">"字符串长度：<span class="subst">$&#123;obj.length&#125;</span>"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="不安全和安全类型转换"><a href="#不安全和安全类型转换" class="headerlink" title="不安全和安全类型转换"></a>不安全和安全类型转换</h2><h3 id="不安全转换操作符：as"><a href="#不安全转换操作符：as" class="headerlink" title="不安全转换操作符：as"></a>不安全转换操作符：as</h3><p>有时无法转换变量并抛出异常，这称为不安全转换。例如，可以为空的字符串<code>String?</code>不能转换成非null字符串<code>String</code>，这会造成异常。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> obj: Any? = <span class="literal">null</span></span><br><span class="line">  <span class="keyword">val</span> str: String = obj <span class="keyword">as</span> String</span><br><span class="line">  println(str)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上述代码把<code>Any</code>类型转换为字符串类型会造成<code>ClassCastException</code>异常。</p><h3 id="安全转换操作符：as"><a href="#安全转换操作符：as" class="headerlink" title="安全转换操作符：as?"></a>安全转换操作符：as?</h3><p>Kotlin提供一种安全转换操作符：<code>as?</code>。如果无法进行转换，则返回<code>null</code>，而不是抛出异常。例如：</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">val</span> location: Any = <span class="string">"Kotlin"</span></span><br><span class="line">  <span class="keyword">val</span> safeString: String? = location <span class="keyword">as</span>? String</span><br><span class="line">  <span class="keyword">val</span> safeInt: <span class="built_in">Int</span>? = location <span class="keyword">as</span>? <span class="built_in">Int</span></span><br><span class="line">  println(safeString)</span><br><span class="line">  println(safeInt)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>执行代码得到的结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Kotlin</span><br><span class="line">null</span><br></pre></td></tr></table></figure><p>因为<code>Any</code>类型的<code>Kotlin</code>可以转换成<code>String</code>类型但是不能转换成<code>Int</code>类型，所以第二个输入为<code>null</code>。</p><h2 id="Elvis运算符"><a href="#Elvis运算符" class="headerlink" title="Elvis运算符"></a>Elvis运算符</h2><p>Elvis运算符用来返回非<code>null</code>值，即使条件表达式为<code>null</code>。可以用来<strong>检查值的空安全性</strong>。</p><p>假设一个包含空引用的变量<code>str</code>，在程序中使用<code>str</code>之前要检查它的可空性。如果发现变量<code>str</code>不为<code>null</code>，则其属性可以使用，否则就得返回其它非空值。<strong>（总之不能返回<code>null</code>）</strong>。</p><p>Kotlin还提供称为Elvis运算符(<code>?:</code>)的高级运算符，即使条件表达式为空，也返回非空值。</p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> str: String? = <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> str2: String? = <span class="string">"nullable string"</span></span><br><span class="line"><span class="keyword">var</span> len1: <span class="built_in">Int</span> = str?.length ?: -<span class="number">1</span></span><br><span class="line"><span class="keyword">var</span> len2: <span class="built_in">Int</span> = str2?.length ?: -<span class="number">1</span></span><br></pre></td></tr></table></figure><p>通过Elvis运算符就相当于使用传统的<code>if...else</code>语句执行此安全检查。</p><p>上述代码通过判断<code>str</code>是否为空，如果为空，就返回正常的<code>str.length</code>，否则返回<code>?:</code>后的值-1。</p><p>除此之外，Elvis运算符后还可以使用<code>throw</code>和<code>return</code>表达式。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text1 = text1 ?: <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line"><span class="keyword">var</span> text2 = text2 ?: IllegalArgumentException(<span class="string">"text exception"</span>)</span><br></pre></td></tr></table></figure><h2 id="静态属性和静态方法"><a href="#静态属性和静态方法" class="headerlink" title="静态属性和静态方法"></a>静态属性和静态方法</h2><p>Kotlin类不支持静态方法和成员，但是Kotlin支持全局函数和变量，所以可以直接使用全局函数和变量来代替类中静态方法和静态成员变量。</p><p>Kotlin中有一个有趣的语法糖：<code>Objects</code>。它可以解决由于没有<code>static</code>而造成的麻烦。</p><h3 id="静态类"><a href="#静态类" class="headerlink" title="静态类"></a>静态类</h3><p>指类中所有的方法都为静态方法的情况，例如工具类一般是静态类。</p><p><strong>把类名<code>class</code>改成<code>object</code>即可</strong></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">object</span> DateUtil &#123;</span><br><span class="line">    <span class="comment">// 静态方法</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>这里又要引入Kotlin另一个语法糖：<code>Companion Objects</code>。在类的内部可以用<code>companion object{}</code>包裹所需的静态方法</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">companion</span> <span class="keyword">object</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">const</span> <span class="keyword">val</span> TAG = <span class="string">"LoginActivity"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>companion object</code>中定义的成员变量就可以通过类名直接访问。</p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>3.Longest Substring Without Repeating Characters</title>
      <link href="/2020/01/12/3.Longest-Substring-Without-Repeating-Characters/"/>
      <url>/2020/01/12/3.Longest-Substring-Without-Repeating-Characters/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>无重复字符的最长子串</strong></p><p>Given a string, find the length of the <strong>longest substring</strong> without repeating characters.</p><p>Example 1:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: &quot;abcabcbb&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;abc&quot;, with the length of 3.</span><br></pre></td></tr></table></figure><p>Example 2:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: &quot;bbbbb&quot;</span><br><span class="line">Output: 1</span><br><span class="line">Explanation: The answer is &quot;b&quot;, with the length of 1.</span><br></pre></td></tr></table></figure><p>Example 3:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;Input: &quot;pwwkew&quot;</span><br><span class="line">Output: 3</span><br><span class="line">Explanation: The answer is &quot;wke&quot;, with the length of 3. Note that the answer must be a substring, &quot;pwke&quot; is a subsequence and not a substring.</span><br></pre></td></tr></table></figure></blockquote><a id="more"></a><h3 id="方法一：暴力法-Naive-brute-force"><a href="#方法一：暴力法-Naive-brute-force" class="headerlink" title="方法一：暴力法(Naive brute force)"></a>方法一：暴力法(Naive brute force)</h3><p>可以使用暴力法逐个检查所有的子字符串，然后记录长度，最终选择长度最大的。</p><p>因为字符长度为$n$的字符串，会有$n^2$个<code>subString</code>，然后检查每一个<code>subString</code>中是否含有重复字符又得遍历该<code>subString</code>,所以又需要$O(n)$，所以总的时间复杂度就是$O(n^3)$。</p><p>首先写一个对获得不重复子字符串的方法。定义一个HashSet，然后对字符串进行遍历操作，如果HashSet中不含有该元素，就添加到HashSet中；如果有，就返回false。</p><p>然后使用两层循环，去判断是否是不重复子串并记录长度。假设开始和结束的索引分别为i和j，那么就使用i从0~n-1以及j从i+1~n这两个嵌套的循环，就可以枚举出所有的子字符串。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.暴力法</span></span><br><span class="line"><span class="comment"> * 返回最长子穿的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="comment">// n是字符串的长度</span></span><br><span class="line">    <span class="keyword">val</span> n = s.length</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (j <span class="keyword">in</span> i + <span class="number">1</span> until n) &#123;</span><br><span class="line">            <span class="keyword">if</span> (allUnique(s, i, j)) &#123;</span><br><span class="line">                ans = Math.max(ans, j - i)</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">allUnique</span><span class="params">(s: <span class="type">String</span>, start: <span class="type">Int</span>, end: <span class="type">Int</span>)</span></span>: <span class="built_in">Boolean</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> hashSet: HashSet&lt;<span class="built_in">Char</span>&gt; = HashSet();</span><br><span class="line">    <span class="keyword">for</span> (i <span class="keyword">in</span> start until end) &#123;</span><br><span class="line">        <span class="keyword">val</span> ch = s[i]</span><br><span class="line">        <span class="comment">// 如果HashSet中含有该元素，就返回false</span></span><br><span class="line">        <span class="keyword">if</span> (hashSet.contains(ch)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 如果HashSet中不含有该元素，就添加到这个HashSet中</span></span><br><span class="line">        hashSet.add(ch)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n^3)$</p><p>这里使用了三层循环，遍历了三次字符串。所以时间复杂度显然是$O(n^3)$。</p></li><li><p><strong>空间复杂度：</strong>$O(k)$</p><p>因为需要$O(k)$的空间来检查子字符串中是否有重复字符，其中k表示的是HashSet的大小。</p></li></ul><p>但暴力法的效率实在太低，当长度过长时可能会出现<strong>TLE</strong>(Time Limit Exceeded)。不推荐使用。</p><h3 id="方法二：滑动窗口-Sliding-Window"><a href="#方法二：滑动窗口-Sliding-Window" class="headerlink" title="方法二：滑动窗口(Sliding Window)"></a>方法二：滑动窗口(Sliding Window)</h3><p>在暴力法中，枚举出所有子字符串之后，第3步要<strong>从首到尾的元素</strong>去检查每一个子字符串是否有重复元素。</p><p>但其实没有必要遍历一个子字符串的所有元素。</p><p>例如：字符串qwekq，子字符串qwe、qwek等。</p><p>如果子字符串qwe已经检查过是没有重复元素的，那么在检查qwek时，就没有必要从头到尾，将qwe之间再检查一遍。只需要检查新添加的元素k是否与之前的字符串有重复元素即可。</p><p>即，<strong>如果从索引i到j-1之间的子字符串$S_{ij}$已经被检查为没有重复字符，只需要检查$S[j]$对应的字符是否已经存在于子字符串$S_{ij}$中。</strong></p><p><strong>窗口</strong>通常是在数组/字符串中由开始和结束索引定义的一系列元素的集合，即$[i,j)$。滑动窗口是可以将两个边界向某一方向<strong>“滑动”</strong>的窗口。滑动窗口通常用来求解数组和<code>String</code>。</p><p>例如：将$[i,j)$向右滑动1个元素$\Rightarrow[i+1,j+1)$</p><p>所以，这题可以使用HashSet将字符存储在当前窗口$[i,j)$（最初j=i）中，然后向右滑动索引j，如果它不在HashSet中，继续滑动j，直到$S[j]$已经存在于HashSet中。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>一个字符串abcb，求最大子串。</p><p>n等于字符串长度等于4，然后令ans=0，i=0，j=0。</p><ol><li>因为初始的HashSet为空，所以肯定不含有$S[j]$即$S[0]$。所以把$S[0]$添加到HashSet中，然后j++。这时候ans=max(0, j-i)=max(0,1)=1。Set中有[a]。</li><li>$S[1]$为b，HashSet不含有，则把$S[1]$添加到HashSet中，然后j++。这时候ans=max(1,j-i)=max(1,2-0)=2。Set中有[a,b]。</li><li>$S[2]$为c，HashSet中没有，则把$S[2]$添加到HashSet中，然后j++。这时候ans=max(2,3-0)=3。Set为[a,b,c]。</li><li>$S[3]$为b，HashSet中已经含有b，因此<code>set.remove(s[0])</code>，然后i++。即把HashSet的第一个元素a去掉，这时候Set为[b,c]。</li><li>接着进行判断，$S[3]$是b，HashSet中仍然含有b，所以<code>set.remove(s[1])</code>，然后i++。这样就是把HashSet的第二个元素b去掉了。</li><li>接着判断，$S[3]$是b，这时候HashSet已经不包含b了。所以把b添加到Set中，然后j++。这时候j=4，已经不能再进行下一次循环了。这时候的Set是[c,b]，ans=max(3, 4-2)=3。</li><li>所以最终得到的最长子串的长度是3。</li></ol><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 2.滑动窗口</span></span><br><span class="line"><span class="comment"> * 返回最长子串的长度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring2</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = s.length</span><br><span class="line">    <span class="keyword">val</span> <span class="keyword">set</span>: HashSet&lt;<span class="built_in">Char</span>&gt; = HashSet()</span><br><span class="line">    <span class="comment">// 默认长度为0，i和j从0开始向右移</span></span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (i &lt; n &amp;&amp; j &lt; n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">set</span>.contains(s[j])) &#123;</span><br><span class="line">            <span class="keyword">set</span>.add(s[j++])</span><br><span class="line">            print(<span class="keyword">set</span>)</span><br><span class="line">            ans = Math.max(ans, j - i)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">set</span>.remove(s[i++])</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)=O(2n)$</p><p>可以从代码中看出，使用while进行了一次遍历，长度是n。但是因为条件是<code>i &lt; n &amp;&amp; j &lt; n</code>，所以最坏的情况下可能判断了两遍n，即从i遍历到n和由j遍历到n。所以最坏情况的时间复杂度是$O(2n)$。</p></li><li><p><strong>空间复杂度</strong>：$O(k)$</p><p>滑动窗口法仍然需要$O(k)$的空间，其中k的表示Set的大小。</p></li></ul><h3 id="方法三：优化的滑动窗口"><a href="#方法三：优化的滑动窗口" class="headerlink" title="方法三：优化的滑动窗口"></a>方法三：优化的滑动窗口</h3><p>从方法二的例子的步骤分析上就可以看出，<strong>步骤4-6</strong>其实有一些冗余。当发现$S[j]$在$[i,j)$范围有重复字符时，不需要让i=0开始，使用i++逐步增加i，可以直接跳过$[i,j’]$范围内的所有元素，并将i变成j’+1。</p><h4 id="图解（转载至LeetCode：灵魂画师牧码）"><a href="#图解（转载至LeetCode：灵魂画师牧码）" class="headerlink" title="图解（转载至LeetCode：灵魂画师牧码）"></a>图解（转载至LeetCode：灵魂画师牧码）</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2847c2d9fb9a6326fecfcf8831ed1450046f1e10967cde9d8681c42393d745ff-frame_00001.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/159cc7509e4a5acbfaf5c59b4b5cb1674f1a31fb87cc41528ca6e6df6132b1dc-frame_00002.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/a62a6d9c878b4c856db1467b4282b936ee677d02a3b47ac4c67dfb4269a158f6-frame_00003.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/7b672e389b1659d3ff2ba77101cf49de120a21732dd7aed5a707d8b33d6b2fb6-frame_00004.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/ff8f38005f548beb5bd45a2e5e327f71acf069c8ad6e9680caeee655af71533a-frame_00005.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2f054f105ebcbe7a1cf3cce1a4ab8c0d85cef70fe674bb90a1c83e92dc6b1274-frame_00006.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/018b08f276a746262cf64fa1cf0748d815f3cabe9c29c61f4973b6e6dd44e2c8-frame_00007.png" alt=""></p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">lengthOfLongestSubstring3</span><span class="params">(s: <span class="type">String</span>)</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> n = s.length</span><br><span class="line">    <span class="keyword">var</span> ans = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">var</span> j = <span class="number">0</span></span><br><span class="line">    <span class="keyword">val</span> map: HashMap&lt;<span class="built_in">Char</span>, <span class="built_in">Int</span>&gt; = HashMap()</span><br><span class="line">    <span class="keyword">for</span> (j <span class="keyword">in</span> <span class="number">0</span> until n) &#123;</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(s[j])) &#123;</span><br><span class="line">            i = Math.max(map.getValue(s[j]), i)</span><br><span class="line">        &#125;</span><br><span class="line">        ans = Math.max(ans, j - i + <span class="number">1</span>)</span><br><span class="line">        map.put(s[j], j + <span class="number">1</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析"><a href="#复杂度分析" class="headerlink" title="复杂度分析"></a>复杂度分析</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)$</p><p>可以很明显看到，j由0遍历到n，循环了n次。</p></li><li><p><strong>空间复杂度：</strong>$O(k)$</p><p>滑动窗口法仍然需要$O(k)$的空间，其中k的表示Set的大小。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 字符串 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kotlin基础（一）</title>
      <link href="/2020/01/12/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2020/01/12/Kotlin%E5%9F%BA%E7%A1%80%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  println(<span class="string">"Hello World"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>fun main(args: Array&lt;String&gt;)</code>也可以直接写成<code>fun main()</code>。</p><a id="more"></a><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量声明"><a href="#变量声明" class="headerlink" title="变量声明"></a>变量声明</h3><p>在Kotlin中，使用关键字<code>var</code>和<code>val</code>声明变量。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language = <span class="string">"Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> salary = <span class="number">10000</span></span><br></pre></td></tr></table></figure><p>Kotlin中不需要明确指定变量的类型。Kotlin编译器通过<code>initilizer</code>表达式自动识别推断变量的类型。当然，在声明变量时也可以明确指定变量的类型。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> language: String = <span class="string">"Kotlin"</span></span><br><span class="line"><span class="keyword">val</span> salary: <span class="built_in">Int</span> = <span class="number">10000</span></span><br></pre></td></tr></table></figure><h3 id="关键字var和val的区别"><a href="#关键字var和val的区别" class="headerlink" title="关键字var和val的区别"></a>关键字var和val的区别</h3><ul><li>val用来定义常量，即恒定不变的量。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> constant = <span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li>var定义变量，即可变动的量。</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> variable = <span class="number">5</span></span><br></pre></td></tr></table></figure><h4 id="如何分清"><a href="#如何分清" class="headerlink" title="如何分清"></a>如何分清</h4><p>如果不清楚什么时候使用常量什么时候使用变量时，可以优先使用常量val，如果IDE提示错误则改为var。</p><p>当使用val定义为常量时，常量是不能变动的，只能为其赋值一次。所以如果要改变它的值，需要使用var改成变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var str: String = &quot;abc&quot; =&gt; public String str = &quot;abc&quot;</span><br><span class="line">val str: String = &quot;abc&quot; =&gt; public final String str = &quot;abc&quot;</span><br></pre></td></tr></table></figure><h4 id="进阶"><a href="#进阶" class="headerlink" title="进阶"></a>进阶</h4><p>实际上，val表示的是<strong>只读（read-only）</strong>，即不能再将值写入val，并不意味着其是不可变的。</p><p>在Kotlin的类中，val和var用于表示属性是否有getter/setter：</p><ul><li>var：同时有getter和setter</li><li>val：只有getter</li></ul><h3 id="lateinit和lazy"><a href="#lateinit和lazy" class="headerlink" title="lateinit和lazy"></a>lateinit和lazy</h3><p>如果不想在一开始就对一个属性进行初始化，那么可以使用以下两个关键字。</p><ul><li>lateinit</li><li>lazy</li></ul><h4 id="lateint"><a href="#lateint" class="headerlink" title="lateint"></a>lateint</h4><p>通常情况下，声明为非null类型的属性必须初始化，可以使用<code>lateinit</code>修饰符修饰属性。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">lateinit</span> <span class="keyword">var</span> user: User</span><br></pre></td></tr></table></figure><ul><li><code>lateinit</code>只能用于<code>var</code>声明的类变量，并且属性没有自定义<code>getter</code>和<code>setter</code>方法</li><li>属性的类型必须是非空的，并且不能是原始类型</li></ul><h4 id="lazy"><a href="#lazy" class="headerlink" title="lazy"></a>lazy</h4><p><code>lazy()</code>是一个函数，它接收一个<code>lambda</code>并返回一个<code>lazy</code>实例，它可以作为一个实现<code>lazy</code>属性的委托。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> name: String <span class="keyword">by</span> lazy &#123;<span class="string">"Android Developer"</span>&#125;</span><br></pre></td></tr></table></figure><h4 id="对比"><a href="#对比" class="headerlink" title="对比"></a>对比</h4><ul><li><code>lazy</code>只能用于<code>val</code>属性，而<code>lateinit</code>只能用于<code>var</code>属性</li><li><code>lateinit var</code>可以从任何能看到对象的地方进行初始化。如果想要属性在外部被初始化，可以使用<code>lateinit</code></li></ul><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><ul><li>数字类型</li><li>字符类型</li><li>布尔类型</li><li>数组类型</li><li>字符串类型</li></ul><h3 id="数字类型"><a href="#数字类型" class="headerlink" title="数字类型"></a>数字类型</h3><p>分为整数和浮点数。</p><ul><li>Byte</li><li>Short</li><li>Int</li><li>Long</li><li>Float</li><li>Double</li></ul><h3 id="字符类型-Char"><a href="#字符类型-Char" class="headerlink" title="字符类型(Char)"></a>字符类型(Char)</h3><p>使用关键字<code>char</code>表示，使用单引号<code>&#39;&#39;</code>声明。</p><h3 id="布尔数据类型-Boolean"><a href="#布尔数据类型-Boolean" class="headerlink" title="布尔数据类型(Boolean)"></a>布尔数据类型(Boolean)</h3><p>使用关键字<code>Boolean</code>表示，包含<code>true</code>和<code>false</code>。</p><h3 id="数组类型"><a href="#数组类型" class="headerlink" title="数组类型"></a>数组类型</h3><p>Kotlin中的数组用<code>Array</code>表示。使用库函数<code>arrayOf()</code>和<code>Array()</code>构造函数创建数组。<code>Array</code>中有<code>get()</code>、<code>set()</code>函数，<code>size</code>属性等。</p><h4 id="使用arrayOf创建数组"><a href="#使用arrayOf创建数组" class="headerlink" title="使用arrayOf创建数组"></a>使用<code>arrayOf</code>创建数组</h4><p>例如<code>arrayOf(1,2,3)</code>，它创建一个数组<code>[1,2,3]</code>。通过索引值<code>array[index]</code>访问数组的元素，索引从0开始。</p><h4 id="使用Array-创建数组"><a href="#使用Array-创建数组" class="headerlink" title="使用Array()创建数组"></a>使用<code>Array()</code>创建数组</h4><p>使用<code>Array()</code>构造函数创建数组时，需要在<code>Array()</code>构造函数中使用两个参数：</p><ul><li>第一个参数作为数组的大小</li><li>第二个参数作为函数，用于初始化并返回给定索引的数组元素的值</li></ul><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> asc = Array(<span class="number">5</span>, &#123;i -&gt; i * <span class="number">2</span>&#125;) <span class="comment">// asc[0,2,4,6,8]</span></span><br></pre></td></tr></table></figure><h3 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h3><p>使用<code>String</code>表示。</p><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><ul><li><code>toByte()</code></li><li><code>toShort()</code></li><li><code>toInt()</code></li><li><code>toLong()</code></li><li><code>toFloat()</code></li><li><code>toDouble()</code></li><li><code>toChar()</code></li></ul><h2 id="When表达式"><a href="#When表达式" class="headerlink" title="When表达式"></a>When表达式</h2><p>Kotlin中的<code>when</code>表达式相当于<code>switch</code>语句。</p><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">(args: <span class="type">Array</span>&lt;<span class="type">String</span>&gt;)</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> number = <span class="number">4</span></span><br><span class="line">  <span class="keyword">var</span> numberProvided = <span class="keyword">when</span>(number) &#123;</span><br><span class="line">    <span class="number">1</span> -&gt; <span class="string">"One"</span></span><br><span class="line">    <span class="number">2</span> -&gt; <span class="string">"Two"</span></span><br><span class="line">    <span class="number">3</span> -&gt; <span class="string">"Three"</span></span><br><span class="line">    <span class="number">4</span> -&gt; <span class="string">"Four"</span></span><br><span class="line">    <span class="keyword">else</span> -&gt; <span class="string">"invalid number"</span></span><br><span class="line">  &#125;</span><br><span class="line">  println(<span class="string">"You provide <span class="variable">$numberProvided</span>"</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="For循环"><a href="#For循环" class="headerlink" title="For循环"></a>For循环</h2><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (item <span class="keyword">in</span> collection) &#123;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span>..<span class="number">5</span>) &#123;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span> (i <span class="keyword">in</span> <span class="number">1</span> until <span class="number">5</span>) &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin基础 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2.Add Two Numbers</title>
      <link href="/2020/01/11/2.Add-Two-Numbers/"/>
      <url>/2020/01/11/2.Add-Two-Numbers/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>两树相加</strong></p><p>You are given two <strong>non-empty</strong> linked lists representing two non-negative integers. The digits are stored in <strong>reverse order</strong> and each of their nodes contain a single digit. Add the two numbers and return it as a linked list. </p><p>You may assume the two numbers do not contain any leading zero, except the number 0 itself.</p></blockquote><a id="more"></a><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><p>这道题主要考察了两个知识点。第一个就是<strong>链表</strong>，链表的遍历和链表的创建。第二个就是高精度加法的模拟，因为题目中数字的长度<strong>其实可以很长</strong>。</p><h3 id="方法：初等数学"><a href="#方法：初等数学" class="headerlink" title="方法：初等数学"></a>方法：初等数学</h3><p>用初等数学的方法，相当于进行<strong>加法</strong>的计算。</p><p>上图的carry=1的意思是，前一位4+6=10进了1位，所以进位让carry从默认值0变为1。然后3+4+1=8。</p><h4 id="图解（转载至LeetCode：灵魂画师牧码）"><a href="#图解（转载至LeetCode：灵魂画师牧码）" class="headerlink" title="图解（转载至LeetCode：灵魂画师牧码）"></a>图解（转载至LeetCode：灵魂画师牧码）</h4><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2519bd7f7da0f3bd51dd0f06e6363f4f62bfb25472c5ec233cf969e5c1472e33-file_1559748028103.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/400f2a615319c4f0f42c39eb8b8902984922d1e778ca461569ff64460eaa9757-file_1559748028117.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/e0d3266ec83cee00c6a0ff0a8a66de8d129798b24b76a19b7883f2fd1d79c15b-file_1559748087173.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/a5bf6bc2cc15d162bd35eb8fc467fb36887e40b36c26bdc982a11a686b34cb30-file_1559748028113.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/fc6475aca0ec0621003f4888a59086c398ff5fc6ee2e27cbfb9bc91f107383b9-file_1559748028094.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/743afc3cb34954e1f3a9b41924d4af5453832d23772a2e46aa4cd52a2b240bdd-file_1559748028108.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/3323b948431675b9f2ff8b0161eee9178298cbb4403cbcd36dc857f14043cf7a-file_1559748028112.png" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/508d1bb12a372e385c4052d95ca92e06c3a63a805bf12feddd0bb4e7c972f016-file_1559748028116.png" alt=""></p><h4 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h4><ul><li>将进位值carry设置为0</li><li>将p和q分别初始化为$l_1$和$l_2$的头部</li><li>遍历$l_1$和$l_2$直至到达它们的尾端<ul><li>将x设置为结点p的值。如果p已经到达$l_1$的末尾，则将其值设置为0</li><li>将y设置为结点q的值。如果q已经到达$l_2$的末尾，则将其值设置为0</li><li>设定sum=x+y+carry</li><li>carry=sum/10，将carry取整。这里的carry要么为0，要么为1</li><li>创建一个数值为(sum mod 10)的新结点（mod为求余数），将其设置为当前结点的下一个结点，然后将当前结点前进到下一个结点</li><li>同时，将p和q前进到下一个结点</li></ul></li><li>检查carry=1是否成立（可以通过判断carry是否大于0），如果成立，则追加一个为1的新结点</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">dummy = tail = ListNode(0)</span><br><span class="line">while l1 or l2 or carry:</span><br><span class="line">truesum = l1?.val + l2?.val + carry</span><br><span class="line">truetail.next = ListNode(sum % 10)</span><br><span class="line">truetail = tail.next</span><br><span class="line">truecarry = sum /= 10</span><br><span class="line">truel1, l2 = l1?.next, l2?.next</span><br><span class="line">return dummy.next</span><br><span class="line"></span><br><span class="line">Time complexity: O(max(n,m))</span><br><span class="line">Space complexity: O(max(n,m))</span><br></pre></td></tr></table></figure><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> medium._002</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * You are given two non-empty linked lists representing two non-negative integers. The digits are stored in reverse order and each of their nodes contain a single digit. Add the two numbers and return it as a linked list.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * You may assume the two numbers do not contain any leading zero, except the number 0 itself.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Example:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Input: (2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)</span></span><br><span class="line"><span class="comment"> * Output: 7 -&gt; 0 -&gt; 8</span></span><br><span class="line"><span class="comment"> * Explanation: 342 + 465 = 807.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">addTwoNumbers</span><span class="params">(l1: <span class="type">ListNode</span>?, l2: <span class="type">ListNode</span>?)</span></span>: ListNode? &#123;</span><br><span class="line">    <span class="keyword">val</span> head = ListNode(<span class="number">0</span>)</span><br><span class="line">    <span class="keyword">var</span> p = l1</span><br><span class="line">    <span class="keyword">var</span> q = l2</span><br><span class="line">    <span class="keyword">var</span> curr: ListNode? = head</span><br><span class="line">    <span class="comment">// 进位carry初始化为0</span></span><br><span class="line">    <span class="keyword">var</span> carry = <span class="number">0</span></span><br><span class="line">    <span class="keyword">while</span> (p != <span class="literal">null</span> || q != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果p不为空，将x设为结点p的值；如果p已到达l1的末尾，则p=null，则x=0</span></span><br><span class="line">        <span class="keyword">val</span> x = p?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">        <span class="comment">// q同理</span></span><br><span class="line">        <span class="keyword">val</span> y = q?.`<span class="keyword">val</span>` ?: <span class="number">0</span></span><br><span class="line">        <span class="keyword">val</span> sum = x + y + carry</span><br><span class="line">        <span class="comment">// 将carry取整</span></span><br><span class="line">        carry = sum / <span class="number">10</span></span><br><span class="line">        curr!!.next = ListNode(sum % <span class="number">10</span>)</span><br><span class="line">        curr = curr.next</span><br><span class="line">        <span class="keyword">if</span> (p != <span class="literal">null</span>) &#123;</span><br><span class="line">            p = p.next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (q != <span class="literal">null</span>) &#123;</span><br><span class="line">            q = q.next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 检查carry是否等于1</span></span><br><span class="line">    <span class="keyword">if</span> (carry &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        curr!!.next = ListNode(carry)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head.next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 打印链表</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> last</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">printList</span><span class="params">(last: <span class="type">ListNode</span>?)</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> last = last</span><br><span class="line">    <span class="keyword">while</span> (last != <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="comment">// 如果是最后一位，则不输出逗号，</span></span><br><span class="line">        <span class="keyword">if</span> (last.next == <span class="literal">null</span>) &#123;</span><br><span class="line">            print(last.`<span class="keyword">val</span>`)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// 如果不是最后，则输入逗号，分隔</span></span><br><span class="line">            print(last.`<span class="keyword">val</span>`.toString() + <span class="string">","</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        last = last.next</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fun</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// 原测试用例：l1=[2,4,3]，l2=[5,6,4]，输出结果为[7,0,8]</span></span><br><span class="line">    <span class="keyword">val</span> l1 = ListNode(<span class="number">2</span>)</span><br><span class="line">    l1.next = ListNode(<span class="number">4</span>)</span><br><span class="line">    l1.next!!.next = ListNode(<span class="number">3</span>)</span><br><span class="line">    <span class="keyword">val</span> l2 = ListNode(<span class="number">5</span>)</span><br><span class="line">    l2.next = ListNode(<span class="number">6</span>)</span><br><span class="line">    l2.next!!.next = ListNode(<span class="number">4</span>)</span><br><span class="line"><span class="comment">// 测试用例1：l1=[0,1]，l2=[0,1,2]，输出结果应为[0,2,2]</span></span><br><span class="line"><span class="comment">//        ListNode l1 = new ListNode(0);</span></span><br><span class="line"><span class="comment">//        l1.next = new ListNode(1);</span></span><br><span class="line"><span class="comment">//        ListNode l2 = new ListNode(0);</span></span><br><span class="line"><span class="comment">//        l2.next = new ListNode(1);</span></span><br><span class="line"><span class="comment">//        l2.next.next = new ListNode(2);</span></span><br><span class="line"><span class="comment">// 测试用例2：l1=[]，l2=[0,1]，输出结果为[0,1]</span></span><br><span class="line"><span class="comment">//        ListNode l1 = new ListNode();</span></span><br><span class="line"><span class="comment">//        ListNode l2 = new ListNode(0);</span></span><br><span class="line"><span class="comment">//        l2.next = new ListNode(1);</span></span><br><span class="line"><span class="comment">// 测试用例l3：l1=[9,9]，l2=[1]，输出结果为[0,0,1]</span></span><br><span class="line"><span class="comment">//        ListNode l1 = new ListNode(9);</span></span><br><span class="line"><span class="comment">//        l1.next = new ListNode(9);</span></span><br><span class="line"><span class="comment">//        ListNode l2 = new ListNode(1);</span></span><br><span class="line">    printList(addTwoNumbers(l1, l2))</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * ListNode是自己定义的Java中的链表对象</span></span><br><span class="line"><span class="comment"> * 类结构如下</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ListNode</span> </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> `<span class="keyword">val</span>`: <span class="built_in">Int</span></span><br><span class="line">    <span class="keyword">var</span> next: ListNode? = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        `<span class="keyword">val</span>` = <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">constructor</span>(i: <span class="built_in">Int</span>) &#123;</span><br><span class="line">        `<span class="keyword">val</span>` = i</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">fun</span> `<span class="keyword">val</span>`<span class="params">()</span></span>: <span class="built_in">Int</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> `<span class="keyword">val</span>`</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(max(m,n))$</p><p>该算法使用了一次whlie循环，且判断条件是<code>p != null || q != null</code>。假设链表p和q的长度分别为m和n，则该循环最多重复$max(m,n)$次。</p></li><li><p><strong>空间复杂度</strong>：$O(max(m,n))$</p><p>新链表的长度也同样取决于p和q的长度，但由于相加后有可能产生进位，所以长度可能加1。所以长度最多为$max(m,n)+1$。</p><p>如果仅仅是把结果打印出来，那么空间复杂度就是$O(1)$，因为不需要额外的存储。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>1.Two Sum</title>
      <link href="/2020/01/10/1.Two-Sum/"/>
      <url>/2020/01/10/1.Two-Sum/</url>
      
        <content type="html"><![CDATA[<blockquote><p><strong>两树之和</strong></p><p>Give an array of integers, return indices of the two numbers such that they add up to a specific target.</p><p>You may assume that each input would have exactly one solution, and you may not use the same element twice.</p><p>Example:</p><p>Given nums = [2, 7, 11, 15], target = 9,</p><p>Because nums[0] + nums[1] = 2 + 7 = 9,</p><p>return [0, 1].</p></blockquote><a id="more"></a><h3 id="方法一：暴力法"><a href="#方法一：暴力法" class="headerlink" title="方法一：暴力法"></a>方法一：暴力法</h3><p>暴力法就是遍历每个元素x，并查找是否存在一个值与target-x相等的目标元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum1(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= i; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (i != j &amp;&amp; (nums[i] + nums[j] == target)) &#123;</span><br><span class="line">                System.out.println(<span class="string">"Two numbers: "</span> + nums[j] + <span class="string">" and "</span> + nums[i]);</span><br><span class="line">                System.out.println(<span class="string">"Indices of the two numbers: "</span> + j + <span class="string">" and "</span> + i);</span><br><span class="line">                <span class="keyword">return</span> nums;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析："><a href="#复杂度分析：" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n^2)$</p><p>对于每个元素，通过遍历数组的其余部分来寻找它所对应的目标元素，这将耗费$O(n)$的时间。所以两个循环遍历的时间复杂度为$O(n^2)$。</p></li><li><p><strong>空间复杂度：</strong>$O(1)$。</p></li></ul><h3 id="方法二：两遍哈希表"><a href="#方法二：两遍哈希表" class="headerlink" title="方法二：两遍哈希表"></a>方法二：两遍哈希表</h3><p>因为该题是检查数组中是否存在目标元素满足条件。如果满足，则找出该目标元素的索引。所以可以使用<strong>哈希表</strong>来保持数组中的每个元素与其索引相互对应（键值对）。</p><p>使用两次迭代。在第一次迭代中，将每个元素的值和它的索引添加到表中。然后，在第二次迭代中，将检查每个元素所对应的目标元素(target-nums[i])是否存在于表中（该目标元素不能是nums[i]本身）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum2(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Two numbers: "</span> + nums[i] + <span class="string">" and "</span> + complement);</span><br><span class="line">            System.out.println(<span class="string">"Indices of the two numbers: "</span> + i + <span class="string">" and "</span> + map.get(complement));</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;i, map.get(complement)&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-1"><a href="#复杂度分析：-1" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)$</p><p>从代码中可以看到，运行了两次<code>for (int i = 0; i &lt; nums.length; i++)</code>代码，即将n个元素遍历的两次。但是因为哈希表将查找的时间降低到$O(1)$，所以时间复杂度是$O(n)$。</p></li><li><p><strong>空间复杂度：</strong>$O(n)$</p><p>所需的空间是因为定义了一个哈希表存储数组的元素及其索引。所以空间大小取决于哈希表中存储的元素数量，即n个元素。所以是$O(n)$。</p></li></ul><h3 id="方法三：一遍哈希表"><a href="#方法三：一遍哈希表" class="headerlink" title="方法三：一遍哈希表"></a>方法三：一遍哈希表</h3><p>观察方法二的代码，发现其实运行了两遍<code>for (int i = 0; i &lt; nums.length; i++)</code>代码，所以其实可以一次就完成。</p><p>首先创建一个map，然后在数组中进行循环，令complement=target-nums[i]。如果map中含有complement，就已找到目标元素。如果没有找到，那么就把这个元素的索引和值都添加到map中。</p><p>所以，其实一开始的时候是肯定找不到目标元素的，因为map中并没有蒜素。等到map中添加了两个元素和索引之后，map中就有可能含有正好等于差的complement了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">int</span>[] twoSum3(<span class="keyword">int</span>[] nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">    Map&lt;Integer, Integer&gt; map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">int</span> complement = target - nums[i];</span><br><span class="line">        <span class="keyword">if</span> (map.containsKey(complement) &amp;&amp; map.get(complement) != i) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Two numbers: "</span> + complement + <span class="string">" and "</span> + nums[i]);</span><br><span class="line">            System.out.println(<span class="string">"Indices of the two numbers: "</span> + map.get(complement) + <span class="string">" and "</span> + i);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="keyword">int</span>[]&#123;map.get(complement), i&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        map.put(nums[i], i);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"No two sum solution"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="复杂度分析：-2"><a href="#复杂度分析：-2" class="headerlink" title="复杂度分析："></a>复杂度分析：</h4><ul><li><p><strong>时间复杂度：</strong>$O(n)$</p><p>与方法二同理。</p></li><li><p><strong>空间复杂度：</strong>$O(n)$</p><p>空间仍然是需要元素的数量n去用哈希表进行存储。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NP完全性证明</title>
      <link href="/2019/12/24/NP%E5%AE%8C%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/"/>
      <url>/2019/12/24/NP%E5%AE%8C%E5%85%A8%E6%80%A7%E8%AF%81%E6%98%8E/</url>
      
        <content type="html"><![CDATA[<h2 id="NP完全性的证明"><a href="#NP完全性的证明" class="headerlink" title="NP完全性的证明"></a>NP完全性的证明</h2><p><strong>引理</strong>：如果语言L是一种满足对任意$L’\in NPC$都有$L’\le_{p}L$的语言，则L是NP-hardness。此外，如果$L\in NP$，则$L\in NPC$。</p><p><strong>证明</strong>：</p><p>$\because L’\in NPC\\<br>\therefore 对于所有L’’\in NP，都有L’’\le _{p}L’\\<br>根据假设，L’\le _{p}L\\<br>\therefore 根据传递性，L’’\in _{p}L\\<br>\therefore L是NP-hardness\\<br>那么，如果L\in NP，且L是NP-hardness\\<br>\therefore L\in NPC$</p><a id="more"></a><h3 id="证明某种语言L是NP完全问题的方法"><a href="#证明某种语言L是NP完全问题的方法" class="headerlink" title="证明某种语言L是NP完全问题的方法"></a>证明某种语言L是NP完全问题的方法</h3><ol><li>证明$L\in NP$</li><li>选取一种已知的NP完全语言L’</li><li>描述一种可计算函数f(x)的算法，其中f可将L’中每一个实例$x\in \left\{0,1\right\}^*$映射为L中的实例$f(x)$</li><li>证明函数f满足$x\in L’$当前仅当对于所有的$x\in \left\{0,1\right\}^*$都有$f(x)\in L$</li><li>证明计算函数$f(x)$的算法具有多项式运行时间</li></ol><p>第2步~第5步是为了证明L是NP-hardness，然后结合第一步的L是NP问题，就可以得出$L\in NPC$。</p><h2 id="典型NPC问题"><a href="#典型NPC问题" class="headerlink" title="典型NPC问题"></a>典型NPC问题</h2><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/%E6%89%AB%E6%8F%8F%202019%E5%B9%B412%E6%9C%8824%E6%97%A5%2023.33.JPG" alt=""></p><ul><li><strong>SAT</strong>：布尔公式的可满足性问题</li><li><strong>3-CNF-SAT</strong>：3合取范式的布尔公式的可满足性问题</li><li><strong>团问题CLIQUE</strong>：寻找无向图中的最大团</li><li><strong>顶点覆盖问题VERTEX COVER</strong>：在无向图中找出最小规模的顶点覆盖</li><li><strong>哈密顿回路问题HAM-CYCLE</strong>：无向图中是否存在哈密顿回路，即通过每个顶点的简单回路</li><li><strong>旅行商问题TSP</strong>：寻找通过无向图每个顶点一次的最小回路</li><li><strong>子集和问题SUBSET-SUM</strong>：给定正整数集合和正整数t，判断是否存在一个子集的元素和为t</li></ul><h2 id="布尔组合电路"><a href="#布尔组合电路" class="headerlink" title="布尔组合电路"></a>布尔组合电路</h2><p>布尔组合电路由一个或多个布尔组合元素通过线路连接而成，布尔组合电路是不包括回路的。</p><p>一个布尔组合电路的<strong>真值赋值</strong>是指一组布尔输入值。如果一个单输出布尔组合电路具有可满足性赋值，则称该布尔组合电路是可满足的。</p><p>布尔值取自集合$\left\{0,1\right\}$，0代表false，1代表true。</p><p>布尔组合元素称为逻辑门：$\begin{cases}与门\quad AND\\或门\quad OR\\非门\quad NOT\end{cases}$</p><p>For example：</p><ol><li>对此电路的输入赋值$<x_1=1, x_2=1, x_3=0>$，使得电路的输出为1，那么电路是可满足的。</li><li>如果对此电路输入的任何一种赋值都不能使得输出为1，则电路不满足。</li></ol><h3 id="NP完全性证明"><a href="#NP完全性证明" class="headerlink" title="NP完全性证明"></a>NP完全性证明</h3><p>给定一个电路C，通过检查输入的所有可能赋值来确定它是否来自可满足性电路。</p><p>那么，如果有k个输入，就有检查$2^k$种可能，因为$\begin{cases}1\\0\end{cases}$</p><p>所以当电路C的规模为k的多项式时，对每个电路的检查要花费$\Omega(2^k)$的时间，呈多项式关系。</p><p>$\therefore$ 该问题是NP完全的</p><h2 id="布尔可满足性问题SAT"><a href="#布尔可满足性问题SAT" class="headerlink" title="布尔可满足性问题SAT"></a>布尔可满足性问题SAT</h2><p><strong>定理</strong>：布尔公式的可满足性问题是NP完全的。</p><p><strong>证明</strong>：</p><ol><li>证明$SAT\in NP$，即证明对于输入公式$\phi$，由它的一个可满足性赋值所组成的证书可以在多项式时间内得到验证</li><li>证明$CIRCUIT-SAT\le _{p}SAT$从而得出SAT是NP-hard</li><li>根据语言$L\in NP$且$L\in NP-hard$能推出$L\in NPC$，得证</li></ol><h2 id="3-CNF可满足性"><a href="#3-CNF可满足性" class="headerlink" title="3-CNF可满足性"></a>3-CNF可满足性</h2><p>即布尔公式中的一个文字（literal）是指一个变量或非“$\neg$”。</p><h3 id="合取范式"><a href="#合取范式" class="headerlink" title="合取范式"></a>合取范式</h3><p>如果一个布尔公式可以表示为所有子句的“与”，并且每个字句都是一个或多个文字的“或”，则称该布尔公式为合取范式。</p><p>如果每个字句恰好有三个不同的<strong>“文字”</strong>，则该布尔公式为3合取范式，即3-CNF。</p><p>For example：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/%E5%90%88%E5%8F%96.png" alt=""></p><p><strong>定理</strong>：3合取范式形式的布尔公式的可满足性是NP完全的。</p><p><strong>证明</strong>：要证明$3-CNF-SAT\le NP$，仅需证明$SAT\le _{p}3-CNF-SAT$。</p><h2 id="团问题CLIQUE"><a href="#团问题CLIQUE" class="headerlink" title="团问题CLIQUE"></a>团问题CLIQUE</h2><p>无向图G=(V,E)的团(clique)是一个顶点子集$V’\subseteq V$，其中每一对顶点之间都由E中的一条边来连接。</p><p>一个团是G中的一个完全子图，<strong>图的规模是指它所包含的顶点数</strong>。</p><p>团问题就是关于寻找图中规模最大的团的优化问题。</p><p>事实上，团问题的有效算法是不大可能存在的。因为要确定一个具有$|V|$个顶点的无向图G=(V,E)是否包含一个规模为k的团，有一种朴素算法：</p><p>列出V的所有规模为k的子集，对其中的每一个进行检查，看它是否是一个团。这个算法的运行时间是与k有关。如果k是常数，那么该算法的运行时间是多项式时间的。然而，在一般情况下，k可能接近于$|V|/2$。这样的话，运行时间就是超多项式时间。所以，团问题的有效算法是不大可能存在的。</p><h3 id="形式语言定义"><a href="#形式语言定义" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$CLIQUE=\left\{<G,k>:G是一个包含规模为k的团的图\right\}$</p><p><strong>定理</strong>：$CLIQUE\subseteq NP-Complete$</p><p><strong>证明</strong>：首先，证明$CLIQUE\in NP$。然后，证明$CLIQUE\in NP-hard$</p><ol><li>对于一个给定的图G=(V,E)，用图中顶点集$V’\subseteq V$作为G的一个证书。对于任意一对顶点$\mu,\nu\in V’$，通过检查边$(\mu,\nu)$是否属于E，就可以在多项式时间内确定V’是否是团。</li><li>通过证明$3-CNF-SAT\le _{p}CLIQUE$来说明$CLIQUE\in NP-hard$。</li></ol><h2 id="顶点覆盖问题Vertex-Cover"><a href="#顶点覆盖问题Vertex-Cover" class="headerlink" title="顶点覆盖问题Vertex Cover"></a>顶点覆盖问题Vertex Cover</h2><p>无向图G=(V,E)的顶点覆盖是一个子集$V’\subseteq V$，满足如果有$(\mu,\nu)\in E$，则$\mu\in V’$或$\nu\in V’$（或两者同时成立）。</p><p>顶点覆盖的规模是指它所包含的顶点数。顶点覆盖问题就是在一个给定的图中，找出具有最小规模的顶点覆盖。</p><h3 id="形式语言定义-1"><a href="#形式语言定义-1" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$VERTEX-COVER=\left\{<G,k>:图G有一个规模为k的顶点覆盖\right\}$</p><p><strong>定理</strong>：$VC\subseteq NP-Complete$</p><p><strong>证明</strong>：首先，证明$VC\in NP$。然后证明$CLIQUE\le _{p}VC$从而得到$VC\in NP-hard$</p><h2 id="哈密顿回路问题HAM-CYCLE"><a href="#哈密顿回路问题HAM-CYCLE" class="headerlink" title="哈密顿回路问题HAM-CYCLE"></a>哈密顿回路问题HAM-CYCLE</h2><p><strong>定理</strong>：哈密顿回路问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$HAM-CYCLE\in NP$。然后通过证明$VC\le _{p}HAM-CYCLE$从而得到$HAM-CYCLE\in NP-hard$</p><h2 id="旅行商问题TSP"><a href="#旅行商问题TSP" class="headerlink" title="旅行商问题TSP"></a>旅行商问题TSP</h2><h3 id="形式语言定义-2"><a href="#形式语言定义-2" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$TSP=\left\{<G,c,k>:G=(V,E)是一个完全图，c是V*V\rightarrow Z上的一个函数，k\in Z，G中包含一个最大花费为k的旅行回路。\right\}$</p><p><strong>定理</strong>：旅行商问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$TSP\in NP$。然后通过证明$HAM-CYCLE\le _{p}TSP$从而得到$TSP\in NP-hard$</p><h2 id="子集和问题SUBSET-SUM-problem"><a href="#子集和问题SUBSET-SUM-problem" class="headerlink" title="子集和问题SUBSET-SUM problem"></a>子集和问题SUBSET-SUM problem</h2><p>给定一个正整数有限集S和一个整数目标t&gt;0，问是否存在一个子集$S’\subseteq S$，其元素和为t。</p><h3 id="形式语言定义-3"><a href="#形式语言定义-3" class="headerlink" title="形式语言定义"></a>形式语言定义</h3><p>$SUBSET-SUM=\left\{<S,t>:存在一个子集S’\subseteq S，使得t= \sum\limits_{S\in S’}S\right\}$</p><p><strong>定理</strong>：子集和问题是NP-Complete</p><p><strong>证明</strong>：首先，证明$SUBSET-SUM\in NP$。然后，通过证明$3-CNF-SAT\le _{p}SUBSET-SUM$从而得到$SUBSET-SUM\in NP-hard$</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> NP问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fault Tolerance</title>
      <link href="/2019/12/23/Fault%20Tolerance/"/>
      <url>/2019/12/23/Fault%20Tolerance/</url>
      
        <content type="html"><![CDATA[<h2 id="容错性描述"><a href="#容错性描述" class="headerlink" title="容错性描述"></a>容错性描述</h2><p>容错与可靠性（dependability）紧密相关。</p><ul><li><strong>可用性</strong>(availability)说明系统已准备好，马上就可以使用</li><li><strong>可靠性</strong>(reliability)指系统可以无故障地持续运行</li><li><strong>安全性</strong>(safety)指在系统偶然出现故障的情况下，仍然能够正确的操作而不会造成任何灾难</li><li><strong>可维护性</strong>(maintainability)是指发生故障的系统被恢复的难易程度</li></ul><a id="more"></a><h3 id="Terminology"><a href="#Terminology" class="headerlink" title="Terminology"></a>Terminology</h3><ul><li><strong>Fail</strong>：当一个系统不能兑现它的承诺时就被认为是失败了</li><li><strong>Error</strong>：是系统状态的一部分，它可能会导致失败</li><li><strong>Fault</strong>：是造成Error的原因</li></ul><h3 id="Handling-Faults"><a href="#Handling-Faults" class="headerlink" title="Handling Faults"></a>Handling Faults</h3><ul><li>Fault prevention：Prevent the occurrence of a fault</li><li>Fault tolerance：Build a component such that it can mask the occurrence of a fault</li><li>Fault removal：Reduce thte presence, number, or seriousness of a fault</li><li>Fault forecasting：Estimate current presence, future incidence, and consequences of faults</li></ul><h3 id="Failure-Models"><a href="#Failure-Models" class="headerlink" title="Failure Models"></a>Failure Models</h3><ul><li><p>崩溃性故障 Crash failure</p><p>服务器停机，但是在停机之前工作正常</p></li><li><p>遗漏性故障 Omission failure</p><p>服务器不能响应到来的请求</p><ul><li><p>接收故障 Receive omission</p><p>服务器不能接受到来的请求</p></li><li><p>发送故障 Send omission</p><p>服务器不能发送消息</p></li></ul></li><li><p>定时故障 Timing failure</p><p>服务器的响应在指定的时间间隔之外</p></li><li><p>响应故障 Response failure</p><p>服务器的响应不正确</p><ul><li><p>值故障 Value failure</p><p>响应的值错误</p></li><li><p>状态转换故障 State-transition failure</p><p>服务器偏离了正确的控制流</p></li></ul></li><li><p>随意性故障 Arbitrary (or Byzantine) failure</p><p>服务器可能在随意的时间产生随意的响应</p></li></ul><h3 id="冗余掩盖故障-Failure-Masking-by-Redundancy"><a href="#冗余掩盖故障-Failure-Masking-by-Redundancy" class="headerlink" title="冗余掩盖故障 Failure Masking by Redundancy"></a>冗余掩盖故障 Failure Masking by Redundancy</h3><ul><li>信息冗余 Information redundancy</li><li>时间冗余 Time redundancy</li><li>物理冗余 Physical redundancy</li></ul><h2 id="进程恢复-Process-Resilience"><a href="#进程恢复-Process-Resilience" class="headerlink" title="进程恢复 Process Resilience"></a>进程恢复 Process Resilience</h2><h3 id="平等组与等级组"><a href="#平等组与等级组" class="headerlink" title="平等组与等级组"></a>平等组与等级组</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/fair.png" alt=""></p><p><strong>平等组</strong>是对称的，没有单独的失败点。如果一个进程崩溃，组只是简单地变得更小，但是还可以继续。它的缺点是做出决定比较复杂，比如需要进行表决，会导致一些延迟和开销。</p><p><strong>等级组</strong>则相反。某个成员的故障会使整个组崩溃，但是只要它保持运行，就可以独自做出决定，不需要其他进程参加。</p><h3 id="故障掩盖和复制"><a href="#故障掩盖和复制" class="headerlink" title="故障掩盖和复制"></a>故障掩盖和复制</h3><p>如果系统能够经受k个组件的故障并且还能满足规范的要求，那么就被称为<strong>k容错</strong>（k fault tolerant）。</p><p>如果这些进程失败了，那么k+1个组件就能提供k容错。</p><p>另一方面，如果进程发生<strong>拜占庭失败</strong>，继续错误运行并发送出错误或随机的应答，最少需要2k+1个进程才能获得k容错。</p><h2 id="拜占庭问题"><a href="#拜占庭问题" class="headerlink" title="拜占庭问题"></a>拜占庭问题</h2><p>全称是<strong>拜占庭将军问题</strong>（Byzantine Generals Problem），是由莱斯利·兰波特提出的分布式对等网络通信容错问题。在分布式计算中，不同的计算机通过通讯交换信息达成共识而按照同一套协作策略行动。但有时，系统中的成员计算机可能出错而发送错误的信息，用于传递信息的通讯网络也可能导致信息损坏，使得网络中不同的成员关于全体协作的策略得出不同的结论，从而破坏系统一致性。拜占庭问题被认为是容错性问题中最难的问题类型之一。</p><blockquote><p>一组拜占庭将军分别各率领一支军队共同围困一座城市。为了简化问题，将各支军队的行动策略限定为进攻或撤离两种。因为部分军队进攻部分军队撤离可能会造成灾难性后果，因此各位将军必须通过投票来达成一致策略，即所有军队一起进攻或所有军队一起撤离。因为各位将军分处城市不同方向，他们只能通过信使互相联系。在投票过程中每位将军都将自己投票给进攻还是撤退的信息通过信使分别通知其他所有将军，这样一来每位将军根据自己的投票和其他所有将军送来的信息就可以知道共同的投票结果而决定行动策略。</p></blockquote><p>系统的问题在于，将军中可能出现叛徒，他们不仅可能向较为糟糕的策略投票，还可能选择性地发送投票信息。<strong>假如那些忠诚（没有出错）的将军仍然能通过多数决定来决定他们的策略</strong>，那么就达到了<strong>拜占庭容错</strong>。</p><p>上述故事映射到计算机系统里，将军就是计算机，信差就是通信系统。在分布式对等网络中需要按照共同一致策略协作的<strong>成员计算机</strong>即为问题中的<strong>将军</strong>，而各成员赖以进行通讯的<strong>网络链路</strong>即为<strong>信使</strong>。拜占庭将军描述的就是某些成员计算机或网络链路出现错误、甚至被蓄意破坏者控制的情况。</p><h3 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h3><h4 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h4><p>如何让忠诚者（非叛徒）达成一致。</p><p>假设节点总数为N，叛徒数为F，则当<strong>N&gt;=3F+1</strong>时，问题才有解，即<strong>Byzantine Fault Tolerant(BTF)</strong>算法。</p><h4 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h4><p>N=3, F=1, 不满足N&gt;=3F+1</p><ol><li>当提出方案的人<strong>不是叛徒</strong>时，提案人提出一个方案，叛徒就提出相反的方案，剩下一个人收到两个相反的意见，就无法判断谁是叛徒，也无法给出一致的意见。所以如果提案人提出方案，系统中就有N-F份确定的信息和F份不确定的信息，只有$N-F \ge F \Rightarrow N&gt;F$的情况下达成一致。</li><li>当提出方案的人是<strong>叛徒</strong>时，提案人提出方案，发送给另外两人。另外两人收到两份相反的消息，无法判断谁才是叛徒，系统也无法达成一致。因为提出方案的叛徒会尽量发送相反的消息给N-F个忠诚者，那么$\begin{cases}\frac{N-F}{2}个信息1\\ \frac{N-F}{2}个信息0\end{cases}$</li></ol><p>Leslie Lamport证明，当叛徒数不超过<strong>1/3</strong>时，存在有效的算法让忠诚者总能达成一致。然而，如果叛徒数过多，就无法保证能够达成一致。</p><h4 id="假设"><a href="#假设" class="headerlink" title="假设"></a>假设</h4><p>如果叛徒数超过1/3时，有无解决方案？</p><p>设有f个叛徒和g个忠诚者，叛徒可以故意使坏，可以给出错误的结果也可以不响应请求。</p><ol><li>当f个叛徒不响应，则g个忠诚者占多数，仍然能够得到正确结果</li><li>当f个叛徒，每个叛徒都给出一个恶意提案，并且当g个忠诚者中有f个处于离线状态时，则剩下g-f个忠诚者想要占据多数保持正确结果，则必须有$g-f&gt;f \Rightarrow g&gt;2f$，而系统的整体规模：$g+f &gt; 2f+f=3f \Rightarrow g+f&gt;3f$</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 容错 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Timing and Synchronisation</title>
      <link href="/2019/12/23/Timing%20and%20Synchronisation/"/>
      <url>/2019/12/23/Timing%20and%20Synchronisation/</url>
      
        <content type="html"><![CDATA[<h2 id="The-Eight-Fallacies-of-Distributed-Computing"><a href="#The-Eight-Fallacies-of-Distributed-Computing" class="headerlink" title="The Eight Fallacies of Distributed Computing"></a>The Eight Fallacies of Distributed Computing</h2><ul><li>The network is reliable</li><li>Latency is zero</li><li>Bandwidth is infinite</li><li>The network is secure</li><li>Topology doesn’t change</li><li>There is one administrator</li><li>Transport cost is zero</li><li>The network is homogeneous</li><li><font color=red>All blocks are synchronized</font></li></ul><p>第9大悖论即<strong>所有时钟是同步的</strong>。</p><a id="more"></a><h2 id="时钟同步"><a href="#时钟同步" class="headerlink" title="时钟同步"></a>时钟同步</h2><p>In a DS, there is <font color=red>no global agreement on time.</font></p><h3 id="物理时钟"><a href="#物理时钟" class="headerlink" title="物理时钟"></a>物理时钟</h3><p>几乎所有的计算机都有一个计时电路。但它们不是通常意义上的时钟，称为<strong>计时器（timer）</strong>更为掐当。这里还有几个概念：</p><ul><li>有两个计数器与每个石英晶体相关联，一个是<strong>计数器（counter）</strong>，另一个是<strong>保持寄存器（holding register）</strong></li><li>每次的中断称为一个时钟滴答（When counter reaches zero, a <font color=red>timer interrupt</font> or <font color=red>clock tick</font> is generated and counter is reloaded from a holding register）</li><li>时钟偏移：In a DS with <em>n</em> machines, all <em>n</em> crystals will run at slightly different rates, resulting in <font color=red>clock skew</font>.</li></ul><h3 id="时钟同步算法"><a href="#时钟同步算法" class="headerlink" title="时钟同步算法"></a>时钟同步算法</h3><h4 id="Cristian’s-Algorithm"><a href="#Cristian’s-Algorithm" class="headerlink" title="Cristian’s Algorithm"></a>Cristian’s Algorithm</h4><p>Cristian提出让客户与<strong>时间服务器</strong>（time server）联系。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/time.png" alt=""></p><p>如图所示，best estimate of one-way propagation time is <strong><em>(T1-T0-I)/2</em></strong>.</p><p><strong>例题：</strong><br>The client’s clock reads 5:26:08. The server’s clock reads 5:16:44 when they synchronize using Cristian’s algorithm. Assume RTT is 2 seconds. What is the time at the client after synchronization? Note: the time format is HH:MM:SS.</p><p><strong>解答：</strong></p><p>Cristian’s algorithm assumes that the server has an accurate clock. The client requests the time and sets its clock to the server’s time $+\frac{1}{2}(RTT)$. In this case, the RTT is 2 seconds, so the client set time after synchronization: $5:16:44 + \frac{1}{2}*2seconds = 5:16:45$</p><h4 id="Berkeley-Algorithm"><a href="#Berkeley-Algorithm" class="headerlink" title="Berkeley Algorithm"></a>Berkeley Algorithm</h4><p>Berkeley UNIX系统中的时间服务器（实际上是时间守护程序）是主动的，它定期地询问每台机器的时间。基于这些回答，它计算出一个平均时间，并告诉所有其他机器将它们的时钟快拨到一个新的时间，或者拨慢时间。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/bb.png" alt=""></p><p><strong>例题1：</strong></p><p>The client’s clock reads 5:26:00. The server’s clock reads 5:14:00 when they synchronize using the Berkeley algorithm. Assume message delays are negligible. What is the time at the client after synchronisation? Note: the time format is HH:MM:SS.</p><p><strong>解答：</strong></p><p>The Berkeley algorithm averages clocks among the entire group. In this case, the group has two members: the client and the server. The average of the two clocks is $(5:26:00+5:14:00)/2=5:20:00$. Both the client and server will be set at $5:20:00$.</p><p><strong>例题2：</strong></p><p>Consider a network consisting of 5 computers, A (coordinator), B, C, D, and E. At 08:45 the coordinator decides to synchronise the clock of all computers in the network. The time format is HH:MM. At that moment, the clock of the computers in the network shows the following: B(08:43), C(08:49), D(08:42), E(08:46). Apply the Berkeley clock synchronisation algorithm to this situation, show the stages of computation, and explain the outcome of the synchronisation. You may assume that the time needed for computation and for network communication is negligible.</p><p><strong>解答：</strong></p><p>由上图给出的例子作为解释，这里的同步是指由coordinator服务器发起的。coordinator服务器发送请求到所有slave服务器，接收到所有的slave服务器时间后，计算时间的平均值，然后将这个值回填至所有的服务器。其中也包括coordinator服务器。A服务器即coordinator请求时的时间是08:45，B、C、D、E的服务器时间分别是08：43、08：49、08：42、08：46。所以这4台服务器收到请求后分别返回与coordinator的时间差-2、+4、-3、+1。coordinator接收到这两个值后进行计算$(-2+4-3+1)/3=0$。说明时钟走过的时间为0，可忽略。然后$0-(-2)=2，0-4=-4，0-(-3)=3，0-1=-1$。分别将这四个值回填给另外四台服务器。</p><h4 id="Bully-Algorithm"><a href="#Bully-Algorithm" class="headerlink" title="Bully Algorithm"></a>Bully Algorithm</h4><p>当任何一个进程发现协作者不再响应请求时，它就发起一次选举。进程P按如下过程主持一次选举：</p><ol><li>P向所有编号比它大的进程发送一个Election消息；</li><li>如果无人响应，P获胜并称为协作者;</li><li>如果有编号比它大的进程响应，则由响应者接管选举工作。P的工作完成。</li></ol><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Snipaste_2020-01-15_17-08-42.png" alt=""></p><h4 id="网络时间协议"><a href="#网络时间协议" class="headerlink" title="网络时间协议"></a>网络时间协议</h4><p>网络时间协议（network time protocol, NTP）在服务器之间创建了两条连接。换句话说，B也可以探查A的当前时间。</p><p>原则上，对称地应用NTP也可以让B参照A来调整它的时钟。但是，如果已知B的时钟更精确，那么这种调整就不应该了。所以，NTP把服务器分成多个层。含有<strong>参考时钟</strong>（reference clock）的服务器称为<strong>1层服务器</strong>（stratum-1 server）（时钟本身为0层）。</p><p>当A与B联系时，如果它的层比B的层要高，那么它就只调整自己的时间。经过同步化后，A将比B高一层。如果B是k层服务器，且A的初始层已经大于k，那么，经过时间调整后，A就变成（k+1）层服务器。由于NTP的对称性，如果A的层数比B的低，那么B将按照A来调整自己。</p>]]></content>
      
      
      <categories>
          
          <category> 分布式系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 同步 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马尔可夫决策过程</title>
      <link href="/2019/12/20/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/"/>
      <url>/2019/12/20/%E9%A9%AC%E5%B0%94%E5%8F%AF%E5%A4%AB%E5%86%B3%E7%AD%96%E8%BF%87%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="马尔可夫性"><a href="#马尔可夫性" class="headerlink" title="马尔可夫性"></a>马尔可夫性</h2><p>某一状态信息包含了相关的历史，只要当前状态可知，所有的历史信息都不再需要，当前状态就可以决定未来，则认为该状态具有马尔可夫性（Markov Property）。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/1.png" alt=""></p><a id="more"></a><h2 id="马尔可夫过程"><a href="#马尔可夫过程" class="headerlink" title="马尔可夫过程"></a>马尔可夫过程</h2><p>又叫马尔可夫链（Markov Chain）。它是一个无记忆的随机过程，可以用一个元组<S, P>表示，其中S是有限数量的状态集，P是状态转移概率矩阵。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/2.png" alt=""></p><h2 id="马尔可夫奖励过程"><a href="#马尔可夫奖励过程" class="headerlink" title="马尔可夫奖励过程"></a>马尔可夫奖励过程</h2><p>马尔可夫奖励过程（Markov Reward Process）在马尔可夫过程的基础上增加了奖励R和衰减系数V：<S, P, R, V>。R是一个奖励函数。S状态下的奖励是某一时刻（t）处所在状态s下在下一个时刻（t+1）能获得的奖励期望：</p><script type="math/tex; mode=display">R_s = E[R_{t+1}|S_t=s]</script><p>衰减系数（Discount Factor）：$\gamma\in[0, 1]$，避免无限循环。</p><h2 id="马尔可夫决策过程"><a href="#马尔可夫决策过程" class="headerlink" title="马尔可夫决策过程"></a>马尔可夫决策过程</h2><p>Markov Decision Process，MDP</p><p>多了一个行为集合A，元组<S, A, P, R, V>。</p><script type="math/tex; mode=display">P^a_{ss'} = P[S_{t+1}=s'|S_t=s, A_t=a]\\R^a_s=E[R_{t+1}|S_t=s, A=a]</script><p>当给定一个MDP： $<S, R, P,R, \gamma>$和一个策略$\pi$，那么状态序列$S_1，S_2$，是一个马尔可夫过程$<S, P^\pi>$。</p><p>下一个时刻的状态$S_{t+1}$和<strong>当前时刻的状态$S_t$以及动作$a_t$有关</strong>。</p><h3 id="过程"><a href="#过程" class="headerlink" title="过程"></a>过程</h3><script type="math/tex; mode=display">初始化状态agent所处状态s_0\\\Downarrow\\根据policy\quad\pi(a|s)采取动作a_0，a_0\sim\pi(a|s_0)\\\Downarrow\\根据转移概率p(s'|s,a)采取新状态s_1，s_1\sim p(s'|s,a)\\\Downarrow\\得到单步奖励r_1=R^{a_0}_{s_0s_1}\\\Downarrow\\持续，得到终止状态S_T，得到轨迹\gamma=(s_0,a_0,s_1,a_1,\dots,s_T)\\\Downarrow\\轨迹的联合概率：\\p(r)=p(S_0)·\prod^\pi_{t=1}p(a_{t-1}|S_{t-1})·p(S_t|S_{t-1},a_{t-1})\\\Downarrow对于每一条轨迹，累计奖励函数是关于单步奖励的函数\\R=f(r_0,r_1\dots r_{T-1})\\\downarrow\\可以是T步累计奖励函数R=\sum^{T-1}_{t=0}r_t，\\也可以是\gamma折扣奖励函数，R=\sum^{T-1}_{t=0}\gamma^t·r_t\\\Downarrow期望累计奖励是E_R=E_p(r)[\sum^{T-1}_{t=0}\gamma^t·r_t^T]\\\therefore agent的目标策略就是使得期望累计奖励最大的策略\\\pi=\max\limits_{\pi}E_{p(r)}^\pi[\sum^{T-1}_{t=0}\gamma^t·r_t]</script><h3 id="状态state"><a href="#状态state" class="headerlink" title="状态state"></a>状态state</h3><p>agent在每个步骤中所处于的状态集合。</p><h3 id="行为action"><a href="#行为action" class="headerlink" title="行为action"></a>行为action</h3><p>agent在每个步骤中所能执行的动作集合。</p><h3 id="转移概率transition"><a href="#转移概率transition" class="headerlink" title="转移概率transition"></a>转移概率transition</h3><p>agent处于状态s下，执行动作a后，会转移到状态s’的概率。</p><h3 id="奖励reward"><a href="#奖励reward" class="headerlink" title="奖励reward"></a>奖励reward</h3><p>agent处于状态s下，执行动作a后，转移到状态s’后获得的立即奖励值。</p><h3 id="策略Policy"><a href="#策略Policy" class="headerlink" title="策略Policy"></a>策略Policy</h3><p>策略$\pi$是概率的集合或分布，其元素$\pi(a|s)$为对过程中的<strong>某一状态s采取可能的行为a的概率</strong>。</p><p>agent处于状态s下，应执行动作a的概率。</p><p>一个策略定义了个体在各个状态下的各种可能的行为方式以及其概率的大小。</p><h3 id="回报Return"><a href="#回报Return" class="headerlink" title="回报Return"></a>回报Return</h3><p>回报$G_t$为在一个马尔可夫奖励链上<strong>从t时刻开始往后所有的奖励的有衰减的总和</strong>。</p><h3 id="价值函数Value-Function"><a href="#价值函数Value-Function" class="headerlink" title="价值函数Value Function"></a>价值函数Value Function</h3><p>价值函数给出了某一状态或某一行为的长期价值。</p><p>某一状态的价值函数为从该状态开始的马尔可夫链收获的期望。</p><p><strong>Bellman Optimality Equation</strong></p><p>针对V<em>，一个状态的最优价值等于从该状态出发采取的所有行为产生的行为价值中<em>*最大的</em></em>那个行为价值：</p><script type="math/tex; mode=display">V_*(s)=\max_aq_*(s,a)</script><h2 id="值函数"><a href="#值函数" class="headerlink" title="值函数"></a>值函数</h2><h3 id="状态值函数State-Value-Function"><a href="#状态值函数State-Value-Function" class="headerlink" title="状态值函数State Value Function"></a>状态值函数State Value Function</h3><p>$V^\pi(s)$为状态值函数，表示从状态s开始，执行策略$\pi$得到的期望总回报：</p><script type="math/tex; mode=display">V^\pi(s)=E_{r\sim p(r)}[\sum^{T-1}_{t=0}\gamma^t·r_{t+1}|\tau_{s_0}=s]</script><p>其中$\tau_{s_0}$表示轨迹$\gamma$的起始状态。</p><script type="math/tex; mode=display">V^\pi(s)=E_{a\sim\pi}(a|s)E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma V^\pi(s')]\\\downarrow</script><p>Bellman equation，表示当前状态的值函数可以通过下个状态的值函数来计算。</p><h3 id="状态——动作值函数"><a href="#状态——动作值函数" class="headerlink" title="状态——动作值函数"></a>状态——动作值函数</h3><p>也叫Q函数，Q-function。指初始状态为s并进行动作a，然后执行策略$\pi$得到的期望总回报，即state-action value function。</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma·V^\pi(s')]</script><p>也可以写成：</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{s'\sim p(s'|s,a)}[r(s,a,s')+\gamma·E_{a'\sim\pi(a'|s')}[Q^\pi(s',a')]]\\\uparrow\\Q函数的Bellman方程</script><hr><p><strong>基于值函数的策略学习方法</strong></p><p>主要分为<strong>动态规划</strong>和<strong>蒙特卡罗</strong>。</p><h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><p>动态规划又分为<strong>策略迭代（policy iteration）</strong>算法和<strong>值迭代（value iteration）</strong>算法。</p><h3 id="策略迭代"><a href="#策略迭代" class="headerlink" title="策略迭代"></a>策略迭代</h3><ol><li><p>策略评估 policy evaluation</p><p>计算当前策略下，每个状态的值函数。可以通过Bellman方程进行迭代计算$V^\pi(s)$。</p></li><li><p>策略改进 policy improvement</p><p>根据值函数更新策略。</p></li></ol><h3 id="值迭代"><a href="#值迭代" class="headerlink" title="值迭代"></a>值迭代</h3><p>将策略评估与策略改进合并，来直接计算出最优策略。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/3.png" alt=""></p><h2 id="蒙特卡罗"><a href="#蒙特卡罗" class="headerlink" title="蒙特卡罗"></a>蒙特卡罗</h2><p>Q函数。$Q^\pi(s,a)$为初始状态为s，并执行动作a后所能得到的期望总回报。</p><script type="math/tex; mode=display">Q^\pi(s,a)=E_{r\sim p(r)}[G(\tau_{s_0}=s,a_0=a)]</script><p>$\tau_{s_0}=s，a_0=a$表示轨迹$\tau$的起始状态和动作为s，a。</p><h3 id="蒙特卡罗方法"><a href="#蒙特卡罗方法" class="headerlink" title="蒙特卡罗方法"></a>蒙特卡罗方法</h3><p>Q函数通过<strong>采样</strong>进行计算。</p><p>对于一个策略$\pi$，agent从状态s，执行动作a开始，然后通过随机游走的方法探索环境，并计算其总回报。</p><p>在得到Q函数$Q^\pi(s,a)$之后，进行策略改进，在新策略下采样估计Q函数，不断重复。</p><h3 id="epsilon-贪心法"><a href="#epsilon-贪心法" class="headerlink" title="$\epsilon$-贪心法"></a>$\epsilon$-贪心法</h3><script type="math/tex; mode=display">\pi^\epsilon=\begin{cases}\pi(s),按概率1-\epsilon\\随机选择\mathcal{A}中的动作，按概率\epsilon\end{cases}</script><p>将一个仅利用的策略转为带探索的策略，每次选择动作$\pi(s)$的概率为$1-\epsilon+\frac{1}{|\mathcal{A}|}$，其它动作的概率为$\frac{1}{\mathcal{A}}$。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/%E5%90%8C%E7%AD%96%E7%95%A5.png" alt=""></p><h2 id="时序差分学习方法"><a href="#时序差分学习方法" class="headerlink" title="时序差分学习方法"></a>时序差分学习方法</h2><p>蒙特卡罗采样方法一般需要拿到完整的轨迹，才能对策略进行评估并更新模型，因此效率较低。</p><p><strong>时序差分学习（temporal-difference learning）</strong>结合了动态规划和蒙特卡罗方法：模拟一段轨迹，每行动一步（或几步）就利用Bellman方程来评估行动前状态的值。（当每次更新动作数为最大数时，就等价于蒙特卡罗方法）。</p><h3 id="SARSA算法"><a href="#SARSA算法" class="headerlink" title="SARSA算法"></a>SARSA算法</h3><p><strong>State Action Reward State Action</strong></p><p>只需要知道当前状态s和动作a，奖励r(s,a,s’)，下一步的状态s’和动作a’，其采样和优化的策略都是$\pi^\epsilon$，因此是同策略。</p><script type="math/tex; mode=display">Q^\pi(s,a)\longleftarrow Q^\pi(s,a)+\alpha(r(s,a,s')+rQ^\pi(s',a')-Q^\pi(s,a))</script><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/SARSA.png" alt=""></p><h3 id="Q学习算法"><a href="#Q学习算法" class="headerlink" title="Q学习算法"></a>Q学习算法</h3><p><strong>Q-learning</strong></p><script type="math/tex; mode=display">Q(s,a)\longleftarrow Q(s,a)+\alpha(r+\gamma\max_{a'}Q(s',a')-Q(s,a))</script><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Q.png" alt=""></p><p>与SARSA不同，Q-learning不通过$\pi^\epsilon$来选下一步的动作a’，而是<strong>直接选最优的Q函数</strong>。更新后的Q函数是关于策略$\pi$的，而不是策略$\pi^\epsilon$的。</p>]]></content>
      
      
      <categories>
          
          <category> 强化学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马尔可夫 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分图与完美匹配</title>
      <link href="/2019/11/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/"/>
      <url>/2019/11/04/%E4%BA%8C%E5%88%86%E5%9B%BE%E4%B8%8E%E5%AE%8C%E7%BE%8E%E5%8C%B9%E9%85%8D/</url>
      
        <content type="html"><![CDATA[<h2 id="二分图定义"><a href="#二分图定义" class="headerlink" title="二分图定义"></a>二分图定义</h2><p>可以把图中的点分成两部分，使得每部分内部两两点之间没有连边。</p><h2 id="判定是否是二分图"><a href="#判定是否是二分图" class="headerlink" title="判定是否是二分图"></a>判定是否是二分图</h2><p>没有奇数环的图，或者能够黑白染色（染色问题）的图。</p><h2 id="完美匹配"><a href="#完美匹配" class="headerlink" title="完美匹配"></a>完美匹配</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>一个图的最大匹配中的每个点都是匹配点</p><h3 id="Hall定理"><a href="#Hall定理" class="headerlink" title="Hall定理"></a>Hall定理</h3><p>设G是具有二划分（X, Y）的二部图，则G有饱和X的匹配当且仅当对 ∀S ⊆ X ， N ( S ) ≥ |S|，其中 N (S ) 表示 S 的所有邻点之集。</p><a id="more"></a><p>通俗的说，即<strong>选择任意的左部点S个，把所有这S个点关联的K个右部点取出来，一定有|S|&lt;=|K|</strong>。如果满足这个条件，则是二分图。</p><h3 id="Tutte定理"><a href="#Tutte定理" class="headerlink" title="Tutte定理"></a>Tutte定理</h3><blockquote><p>A graph, <em>G</em> = (<em>V</em>, <em>E</em>), has a <a href="https://en.wikipedia.org/wiki/Perfect_matching" target="_blank" rel="noopener">perfect matching</a> <a href="https://en.wikipedia.org/wiki/If_and_only_if" target="_blank" rel="noopener">if and only if</a> for every subset <em>U</em> of <em>V</em>, the <a href="https://en.wikipedia.org/wiki/Glossary_of_graph_theory#Subgraphs" target="_blank" rel="noopener">subgraph</a> induced by <em>V</em> − <em>U</em> has at most |<em>U</em>| <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory" target="_blank" rel="noopener">connected components</a>) with an odd number of <a href="https://en.wikipedia.org/wiki/Vertex_(graph_theory" target="_blank" rel="noopener">vertices</a>).</p></blockquote><p>图G有完美匹配的充分必要条件是<strong>对∀S ⊂ V (G ) ， O (G \ S ) ≤| S |</strong>。</p><p>即图G有完美匹配等价于，对于图G去掉任意一个点集之后，图的奇分支的个数小于等于点集的个数（奇分支：有奇数个点的分支）。</p><p>例如，对于下图，证明其是否有完美匹配。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/eqW4l.jpg" alt=""></p><p>可以在图中挑出一些点，使得点与点之间分隔后的部分有<strong>奇数</strong>个顶点，然后比较挑出的点的数量，与分隔后的部分的数量的大小。如果分隔后部分的数量小于等于挑出点的数量，则有完美匹配。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/oPlVM.jpg" alt=""></p><p>如上图所示，挑出12个红点，这12个红点将图分成了14个部分（每个部分必须含有奇数个顶点）。因为12&lt;14，不满足Tutte定理，所以这个图没有完美匹配。</p>]]></content>
      
      
      <categories>
          
          <category> 图论 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分图 </tag>
            
            <tag> 完美匹配 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Numpy官方快速热门教程（译）</title>
      <link href="/2019/11/02/Numpy%E5%AE%98%E6%96%B9%E5%BF%AB%E9%80%9F%E7%83%AD%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/"/>
      <url>/2019/11/02/Numpy%E5%AE%98%E6%96%B9%E5%BF%AB%E9%80%9F%E7%83%AD%E9%97%A8%E6%95%99%E7%A8%8B%EF%BC%88%E8%AF%91%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Numpy"><a href="#Numpy" class="headerlink" title="Numpy"></a>Numpy</h3><p>Numpy是一个开源的Python科学计算库，它是Python科学计算库的基础库。</p><h3 id="Numpy常用统计函数"><a href="#Numpy常用统计函数" class="headerlink" title="Numpy常用统计函数"></a>Numpy常用统计函数</h3><p><strong>函数在使用时需要指定axis轴的方向</strong>，若不指定，则默认是整个数组</p><ul><li><code>np.num()</code>：返回求和</li><li><code>np.mean()</code>：返回均值</li><li><code>np.max()</code>：返回最大值</li><li><code>np.min()</code>：返回最小值</li><li><code>np.ptp()</code>：数组沿指定轴返回最大值减去最小值，即（max-min）</li><li><code>np.std()</code>：返回标准偏差（standard deviation）</li><li><code>np.var()</code>：返回方差</li><li><code>np.cumsum()</code>：返回累加值</li><li><code>np.cunprod()</code>：返回累乘积值</li></ul><a id="more"></a><h3 id="数组对象"><a href="#数组对象" class="headerlink" title="数组对象"></a>数组对象</h3><p>Numpy的主要操作对象是同类型的多维数组。它是一个由正整数元组索引，元素类型相同的表（通常元素为数字）。在Numpy维度被成为<code>axes</code>，<code>axes</code>的数量称为<code>rank</code>。</p><p>例如，在3D空间的一个点[1,2,1]是一个<code>rank=1</code>的数组，因为它只有一个<code>axes</code>。而这个<code>axes</code>的长度为3。同样的，下面这个例子则是，数组<code>rank=2</code>（2维，2层嵌套的中括号），第一维的长度为2，第二维长度为3。（第1维即中括号最外面的部分，内部又包含2个中括号（相当于2个元素），所以长度为2；第2维即内部的中括号内含有3个元素）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[[<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>],</span><br><span class="line">[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]]</span><br></pre></td></tr></table></figure><p>Numpy的数组类是<code>ndarray</code>，也可称作<code>array</code>。值得注意的是，<code>numpy.array</code>和标准Python库中的<code>array.array</code>是不一样的，它只能处理一维数组，提供更少的功能。</p><h4 id="ndarray对象的一些重要属性"><a href="#ndarray对象的一些重要属性" class="headerlink" title="ndarray对象的一些重要属性"></a><code>ndarray</code>对象的一些重要属性</h4><ul><li><p><code>ndarray.ndim</code></p><blockquote><p>数组的<code>axes</code>（维数）数值的大小，即<code>rank</code>，几维</p></blockquote></li><li><p><code>ndarray.shape</code></p><blockquote><p>数组的维数，这是由每个维度的大小组成的一个元组。对于一个<strong>n行m列</strong>的矩阵，<code>shape</code>是<code>(n,m)</code>。由<code>shape</code>元组的长度得出<code>rank</code>或者维数<code>ndim</code>。</p></blockquote></li><li><p><code>ndarray.size</code></p><blockquote><p>数组元素的个数总和，这等于<code>shape</code>元组数字的乘积。</p></blockquote></li><li><p><code>ndarray.dtype</code></p><blockquote><p>在数组中描述元素类型的一个对象。</p></blockquote></li><li><p><code>ndarray.itemsize</code></p><blockquote><p>数组中每个元素所占字节数。</p></blockquote></li><li><p><code>ndarray.data</code></p><blockquote><p>数据实际元素的缓存区。</p></blockquote></li></ul><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><p>首先导入Numpy库，以<code>np</code>为缩写</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><h4 id="基于list或者tuple"><a href="#基于list或者tuple" class="headerlink" title="基于list或者tuple"></a>基于list或者tuple</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组 # 基于list</span></span><br><span class="line">arr1 = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>])</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr2 = np.array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>], [<span class="number">3</span>, <span class="number">4</span> ,<span class="number">5</span>]])</span><br><span class="line">arr2</span><br><span class="line"></span><br><span class="line"><span class="comment"># 基于tuple</span></span><br><span class="line">arr_tuple = np.array((<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>))</span><br><span class="line">print(arr_tuple)</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]])</span><br><span class="line">[<span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br></pre></td></tr></table></figure><h4 id="基于np-arange"><a href="#基于np-arange" class="headerlink" title="基于np.arange"></a>基于np.arange</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 一维数组</span></span><br><span class="line">arr1 = np.arange(<span class="number">5</span>)</span><br><span class="line">print(arr1)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 二维数组</span></span><br><span class="line">arr2 = np.array([np.arange(<span class="number">3</span>), np.arange(<span class="number">3</span>)])</span><br><span class="line">arr2</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">0</span> <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span>]</span><br><span class="line">array([[<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>]])</span><br></pre></td></tr></table></figure><h4 id="基于arange以及reshape创建多维数组"><a href="#基于arange以及reshape创建多维数组" class="headerlink" title="基于arange以及reshape创建多维数组"></a>基于arange以及reshape创建多维数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建三维数组</span></span><br><span class="line">arr = np.arange(<span class="number">24</span>).reshape(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line">arr</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">array([[[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">        [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]],</span><br><span class="line"></span><br><span class="line">       [[<span class="number">12</span>, <span class="number">13</span>, <span class="number">14</span>, <span class="number">15</span>],</span><br><span class="line">        [<span class="number">16</span>, <span class="number">17</span>, <span class="number">18</span>, <span class="number">19</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">21</span>, <span class="number">22</span>, <span class="number">23</span>]]])</span><br></pre></td></tr></table></figure><p>注意，arange的长度必须与ndarray的维度的乘积要相当，即24 = 2x3x4</p><h3 id="ndarray数组的切片和索引"><a href="#ndarray数组的切片和索引" class="headerlink" title="ndarray数组的切片和索引"></a>ndarray数组的切片和索引</h3><p>一维数组的切片和索引与python的list索引类似。</p><p>二维数组的切片和索引如下图所示</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Snipaste_2019-10-31_20-54-44.png" alt=""></p><h3 id="处理数组形状"><a href="#处理数组形状" class="headerlink" title="处理数组形状"></a>处理数组形状</h3><h4 id="堆叠数组"><a href="#堆叠数组" class="headerlink" title="堆叠数组"></a>堆叠数组</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">c = b*<span class="number">2</span></span><br><span class="line">c</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><ul><li><p>水平叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hstack()</span><br><span class="line">np.hstack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>column_stack()函数以列的方式对数组进行叠加，功能类似hstack()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">column_stack()</span><br><span class="line">np.column_stack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p>垂直叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">vstack()</span><br><span class="line">np.vstack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure><p>row_stack()函数以行的方式对数组进行叠加，功能类似vstack()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">row_stack()</span><br><span class="line">np.row_stack((b,c))</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li><li><p>concatenate()方法，通过设置axis的值来设置叠加方向</p><p>axis=1时，沿水平方向叠加</p><p>axis=0时，沿垂直方向叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">np.concatenate((b,c),axis=<span class="number">1</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>, <span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br><span class="line">np.concatenate((b,c),axis=<span class="number">0</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>],</span><br><span class="line">       [ <span class="number">0</span>,  <span class="number">2</span>, <span class="number">40</span>,  <span class="number">6</span>,  <span class="number">8</span>, <span class="number">10</span>],</span><br><span class="line">       [<span class="number">12</span>, <span class="number">14</span>, <span class="number">16</span>, <span class="number">18</span>, <span class="number">20</span>, <span class="number">22</span>]])</span><br></pre></td></tr></table></figure></li></ul><p>用示意图来表示如下：</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/v2-8e62ce376316c13dd7d5be9f9b66bafa_hd.jpg" alt=""></p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/v2-0da226f02c3a7600abfb285868ebd98b_hd.jpg" alt=""></p><ul><li><p>深度叠加</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">arr_dstack = np.dstack((b,c))</span><br><span class="line">print(arr_dstack.shape)</span><br><span class="line">arr_dstack</span><br><span class="line">(<span class="number">2</span>, <span class="number">6</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">40</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">22</span>]]])</span><br></pre></td></tr></table></figure><p>叠加前，b和c均是shape为(2,6)的二维数组，叠加后，arr_dstack是shape为(2,6,2)的三维数组。</p></li></ul><h4 id="数组拆分"><a href="#数组拆分" class="headerlink" title="数组拆分"></a>数组拆分</h4><p>数组的拆分可以分为横向拆分、纵向拆分和深度拆分。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><ul><li><p>横向拆分（axis=1）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.hsplit(b, <span class="number">2</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]]), array([[ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br><span class="line">np.split(b,<span class="number">2</span>, axis=<span class="number">1</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>], [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>]]), array([[ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>], [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br></pre></td></tr></table></figure></li><li><p>纵向拆分（axis=0）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">np.vsplit(b, <span class="number">2</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]]), array([[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br><span class="line">np.split(b,<span class="number">2</span>,axis=<span class="number">0</span>)</span><br><span class="line">[array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>]]), array([[ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])]</span><br></pre></td></tr></table></figure></li><li><p>深度拆分</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">arr_dstack</span><br><span class="line">array([[[ <span class="number">0</span>,  <span class="number">0</span>],</span><br><span class="line">        [ <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">        [<span class="number">20</span>, <span class="number">40</span>],</span><br><span class="line">        [ <span class="number">3</span>,  <span class="number">6</span>],</span><br><span class="line">        [ <span class="number">4</span>,  <span class="number">8</span>],</span><br><span class="line">        [ <span class="number">5</span>, <span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">       [[ <span class="number">6</span>, <span class="number">12</span>],</span><br><span class="line">        [ <span class="number">7</span>, <span class="number">14</span>],</span><br><span class="line">        [ <span class="number">8</span>, <span class="number">16</span>],</span><br><span class="line">        [ <span class="number">9</span>, <span class="number">18</span>],</span><br><span class="line">        [<span class="number">10</span>, <span class="number">20</span>],</span><br><span class="line">        [<span class="number">11</span>, <span class="number">22</span>]]])</span><br><span class="line">np.dsplit(arr_dstack,<span class="number">2</span>)</span><br><span class="line">[array([[[ <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">1</span>],</span><br><span class="line">         [<span class="number">20</span>],</span><br><span class="line">         [ <span class="number">3</span>],</span><br><span class="line">         [ <span class="number">4</span>],</span><br><span class="line">         [ <span class="number">5</span>]],</span><br><span class="line"></span><br><span class="line">        [[ <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">7</span>],</span><br><span class="line">         [ <span class="number">8</span>],</span><br><span class="line">         [ <span class="number">9</span>],</span><br><span class="line">         [<span class="number">10</span>],</span><br><span class="line">         [<span class="number">11</span>]]]), array([[[ <span class="number">0</span>],</span><br><span class="line">         [ <span class="number">2</span>],</span><br><span class="line">         [<span class="number">40</span>],</span><br><span class="line">         [ <span class="number">6</span>],</span><br><span class="line">         [ <span class="number">8</span>],</span><br><span class="line">         [<span class="number">10</span>]],</span><br><span class="line"></span><br><span class="line">        [[<span class="number">12</span>],</span><br><span class="line">         [<span class="number">14</span>],</span><br><span class="line">         [<span class="number">16</span>],</span><br><span class="line">         [<span class="number">18</span>],</span><br><span class="line">         [<span class="number">20</span>],</span><br><span class="line">         [<span class="number">22</span>]]])]</span><br></pre></td></tr></table></figure><p>拆分的结果就是把原来的三维数组拆分成两个二维数组。</p></li></ul><h4 id="数组类型转换"><a href="#数组类型转换" class="headerlink" title="数组类型转换"></a>数组类型转换</h4><ul><li><p>数组转换成list，使用tolist()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.tolist()</span><br><span class="line">[[<span class="number">0</span>, <span class="number">1</span>, <span class="number">20</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>], [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]]</span><br></pre></td></tr></table></figure></li><li><p>转换成指定类型，使用astype()函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">b.astype(float)</span><br><span class="line">array([[  <span class="number">0.</span>,   <span class="number">1.</span>,  <span class="number">20.</span>,   <span class="number">3.</span>,   <span class="number">4.</span>,   <span class="number">5.</span>],</span><br><span class="line">       [  <span class="number">6.</span>,   <span class="number">7.</span>,   <span class="number">8.</span>,   <span class="number">9.</span>,  <span class="number">10.</span>,  <span class="number">11.</span>]])</span><br></pre></td></tr></table></figure></li></ul><h4 id="形状转换"><a href="#形状转换" class="headerlink" title="形状转换"></a>形状转换</h4><ul><li><p>reshape()和resize()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">b.reshape(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>,  <span class="number">3</span>],</span><br><span class="line">       [ <span class="number">4</span>,  <span class="number">5</span>,  <span class="number">6</span>,  <span class="number">7</span>],</span><br><span class="line">       [ <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br><span class="line">b.resize(<span class="number">4</span>,<span class="number">3</span>)</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>,  <span class="number">2</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure><p>resize()与reshape()的作用相似，但是resize()会改变所作用的数组</p></li><li><p>ravel()和flatten()，可以将多维数组转换成一维数组</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">b.ravel()</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line">b.flatten()</span><br><span class="line">array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9, 10, 11])</span><br><span class="line">b</span><br><span class="line">array([[ 0,  1,  2],</span><br><span class="line">       [ 3,  4,  5],</span><br><span class="line">       [ 6,  7,  8],</span><br><span class="line">       [ 9, 10, 11]])</span><br></pre></td></tr></table></figure><p>两者的区别在于返回拷贝还是返回视图。即flatten()是返回一份拷贝，需要分配新的内存空间，会影原始矩阵；但ravel()返回的是视图，会影响原始矩阵。</p></li><li><p>用tuple指定数组的形状，如下所示：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">b.shape=(<span class="number">2</span>,<span class="number">6</span>)</span><br><span class="line">b</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">1</span>, <span class="number">20</span>,  <span class="number">3</span>,  <span class="number">4</span>,  <span class="number">5</span>],</span><br><span class="line">       [ <span class="number">6</span>,  <span class="number">7</span>,  <span class="number">8</span>,  <span class="number">9</span>, <span class="number">10</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li><li><p>转置</p><p>通过transpose()函数来实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">b.transpose()</span><br><span class="line">array([[ <span class="number">0</span>,  <span class="number">6</span>],</span><br><span class="line">       [ <span class="number">1</span>,  <span class="number">7</span>],</span><br><span class="line">       [<span class="number">20</span>,  <span class="number">8</span>],</span><br><span class="line">       [ <span class="number">3</span>,  <span class="number">9</span>],</span><br><span class="line">       [ <span class="number">4</span>, <span class="number">10</span>],</span><br><span class="line">       [ <span class="number">5</span>, <span class="number">11</span>]])</span><br></pre></td></tr></table></figure></li></ul><h3 id="零碎知识点"><a href="#零碎知识点" class="headerlink" title="零碎知识点"></a>零碎知识点</h3><h4 id="np-reshape函数参数-1的意思"><a href="#np-reshape函数参数-1的意思" class="headerlink" title="np.reshape函数参数-1的意思"></a>np.reshape函数参数-1的意思</h4><p>-1表示暂时不知道需要什么数字，但可以通过其他推导出来。即其实可以忽略-1。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>a = np.array([[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>np.reshape(a, (<span class="number">3</span>,<span class="number">-1</span>))  <span class="comment"># the unspecified value is inferred to be 2</span></span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">       [<span class="number">3</span>, <span class="number">4</span>],</span><br><span class="line">       [<span class="number">5</span>, <span class="number">6</span>]])</span><br></pre></td></tr></table></figure><p>这里的-1即可以忽略，只通过a和3即可推导出-1的实际应为2。</p><p>即把原数组合并在一起成为一个数组，然后分成3行，这样每行就有2列。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 下面是两张2*3大小的照片(不知道有几张照片用-1代替)，如何把所有二维照片给摊平成一维</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image = np.array([[[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>], [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>]], [[<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>], [<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>]]])</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.shape</span><br><span class="line">(<span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>image.reshape((<span class="number">-1</span>, <span class="number">6</span>))</span><br><span class="line">array([[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">       [<span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>]])</span><br></pre></td></tr></table></figure><p>reshape后分成6列，则12/6=2行。</p>]]></content>
      
      
      <categories>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Numpy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IrisFlowers训练集</title>
      <link href="/2019/11/01/IrisFlowers%E8%AE%AD%E7%BB%83%E9%9B%86/"/>
      <url>/2019/11/01/IrisFlowers%E8%AE%AD%E7%BB%83%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/0.jpg" alt=""></p><blockquote><p>“现今程序员的情况好多了，只要有一台便宜的二手电脑，一张Linux光盘和一个互联网帐户，你就已经拥有了把自己提升到任何级别的编程水平所需的全部工具。”<br>“在信息时代，进入编程领域的壁垒完全不存在了。即使有也是自我强加的。如果你想着手去开发一些全新的东西，你不需要数百万美元的资本。你只需要足够的比萨和健怡可乐存在你的冰箱里，有一台便宜的PC用于工作，以及让你坚持下来的奉献精神。<strong>我们睡在地板上。我们跋山涉水</strong>。”<br>－约翰·卡马克 </p></blockquote><p>约翰·卡马克的最后一句话，通俗易懂。又不禁让我想起了那段台词：</p><blockquote><p>这是最好的时代，这是最坏的时代。我们一无所有，我们巍然矗立。</p></blockquote><p>We will build and use a neural network for the Iris classification task. We will use “keras” as a high-level library for managing neural networks.  </p><a id="more"></a><h2 id="Analysis-Code"><a href="#Analysis-Code" class="headerlink" title="Analysis Code"></a>Analysis Code</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> sklearn.model_selection <span class="keyword">import</span> train_test_split</span><br><span class="line"><span class="keyword">from</span> sklearn.datasets <span class="keyword">import</span> load_iris  <span class="comment"># import load_iris function from datasets module</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> keras.models <span class="keyword">import</span> Sequential, Input, Model</span><br><span class="line"><span class="keyword">from</span> keras.utils <span class="keyword">import</span> to_categorical</span><br><span class="line"><span class="keyword">from</span> keras.layers <span class="keyword">import</span> Dense, Dropout, Flatten</span><br><span class="line"><span class="keyword">from</span> keras <span class="keyword">import</span> optimizers</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Load Iris dataset using sklearn (save "bunch" object containing iris dataset and its attributes) -- ##</span></span><br><span class="line"><span class="comment"># 导入Iris数据集</span></span><br><span class="line"><span class="comment"># Iris数据集是sklearn中自带的</span></span><br><span class="line"><span class="comment"># Iris数据集有3个种类，4个属性，每个属性有50个样例</span></span><br><span class="line">iris = load_iris()</span><br><span class="line"><span class="comment"># x代表iris数据集的数据</span></span><br><span class="line">X = iris.data</span><br><span class="line"><span class="comment"># y代表着着iris的目标属性，即花的类型</span></span><br><span class="line">y = iris.target</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Change the labels from categorical to one-hot encoding -- ##</span></span><br><span class="line"><span class="comment"># The output neurons of the NN will be trained to match the one_hot encoded array</span></span><br><span class="line"><span class="comment"># Example: category label 0 out of 3 labels becomes [1 0 0];</span></span><br><span class="line"><span class="comment"># Example: category label 1 out of 3 labels becomes [0 1 0];</span></span><br><span class="line"><span class="comment"># HINT: use: "to_categorical" to redifine the one hot encoded target y_one_hot using the original y.</span></span><br><span class="line"><span class="comment"># for i in range(len(y)):</span></span><br><span class="line"><span class="comment">#     if y[i] == 0:</span></span><br><span class="line"><span class="comment">#         y[i] = 1</span></span><br><span class="line"><span class="comment">#     else:</span></span><br><span class="line"><span class="comment">#         y[i] = 0  </span></span><br><span class="line">y_one_hot = to_categorical(y)</span><br><span class="line">print(X.shape)</span><br><span class="line">print(y_one_hot.shape)</span><br><span class="line"><span class="comment"># y_one_hot = np.reshape(y, (-1, 1))</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Split the dataset for training, validation, and test -- ##</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># x是被划分的样本特征集 </span></span><br><span class="line"><span class="comment"># y_one_hot是被划分的样本标签</span></span><br><span class="line"><span class="comment"># 如果是浮点数，就在0~1之间，表示样本所占比例；如果是整数，就是样本的数量</span></span><br><span class="line">train_and_valid_X, test_X, train_and_valid_y, test_y = train_test_split(X, y_one_hot, test_size=<span class="number">0.1</span>)</span><br><span class="line">train_X, valid_X, train_y, valid_y = train_test_split(train_and_valid_X, train_and_valid_y, test_size=<span class="number">0.2</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># define the neural network</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">baseline_model</span><span class="params">()</span>:</span></span><br><span class="line">    nb_nurons = <span class="number">8</span></span><br><span class="line">    <span class="comment"># nb_Classes = 1  # HINT:  &lt;---- look here</span></span><br><span class="line">    nb_Classes = <span class="number">3</span></span><br><span class="line">    input_dimensions = <span class="number">4</span></span><br><span class="line">    learning_rate = <span class="number">0.002</span></span><br><span class="line">    <span class="comment"># create model</span></span><br><span class="line">    <span class="comment"># keras.models.Sequential是神经网络模型的封装容器。它会提供常见的函数</span></span><br><span class="line">    model = Sequential()</span><br><span class="line">    <span class="comment"># 第一层级 - 添加有 input_dimensions = 4个节点的输入层</span></span><br><span class="line">    <span class="comment"># 激活函数使用ReLU运算</span></span><br><span class="line">    model.add(Dense(nb_nurons, input_dim=input_dimensions, activation=<span class="string">'relu'</span>))</span><br><span class="line">    <span class="comment"># HINT: a 'softmax' activation will output a probability distribution over the output dimensions</span></span><br><span class="line">    <span class="comment"># 激活函数使用softmax函数</span></span><br><span class="line">    model.add(Dense(nb_Classes,</span><br><span class="line">                    activation=<span class="string">'softmax'</span>))</span><br><span class="line">    <span class="comment"># Compile model</span></span><br><span class="line">    <span class="comment"># 实例化一个优化器对象，这里采用RMSprop优化器</span></span><br><span class="line">    opt = optimizers.RMSprop(lr=learning_rate)</span><br><span class="line">    <span class="comment"># HINT: a 'binary_crossentropy' is only useful for at most 2 labels, look for another suitable loss function in Keras</span></span><br><span class="line">    <span class="comment"># compile用于配置训练模型，loss是字符串或目标函数名，optimizer是优化器名或优化器实例，metrics是在训练和测试期间的模型评估标准</span></span><br><span class="line">    <span class="comment"># binary_crossentropy是交叉熵损失函数，一般用于二分类</span></span><br><span class="line">    <span class="comment"># 因为这里要实现3中分类即多分类，所以使用categorical_crossentropy</span></span><br><span class="line">    model.compile(loss=<span class="string">'categorical_crossentropy'</span>, optimizer=opt, metrics=[</span><br><span class="line">        <span class="string">'accuracy'</span>])</span><br><span class="line">    <span class="keyword">return</span> model</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">find_correct_and_incorrect_labels</span><span class="params">(model, test_X, test_y)</span>:</span></span><br><span class="line">    <span class="comment"># Computes for every input in the test dataset a probability distribution over the categories</span></span><br><span class="line">    <span class="comment"># predict是为输入样本生成输出预测，计算是分批进行的</span></span><br><span class="line">    predicted_classes = model.predict(test_X)</span><br><span class="line">    <span class="comment"># argmax是找到样本以最大概率所属的类别作为样本的预测标签</span></span><br><span class="line">    <span class="comment"># HINT: choose the prediction with the highest probability, np.argmax( ..... , axis=1 )</span></span><br><span class="line">    <span class="comment"># np.round是取返回四舍五入后的值，可指定精度，与np.around等效</span></span><br><span class="line">    predicted_classes = np.argmax(predicted_classes, axis=<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># np.where(conditions)满足conditions的条件即输出数组的下标</span></span><br><span class="line">    correctIndex = np.where(predicted_classes == np.argmax(test_y))[<span class="number">0</span>]  <span class="comment"># HINT: replace test_y by np.argmax(test_y,axis=1)</span></span><br><span class="line">    incorrectIndex = np.where(predicted_classes != np.argmax(test_y))[<span class="number">0</span>]  <span class="comment"># HINT: replace test_y by np.argmax(test_y,axis=1)</span></span><br><span class="line">    print(<span class="string">"Found %d correct labels using the model"</span> % len(correctIndex))</span><br><span class="line">    print(<span class="string">"Found %d incorrect labels using the model"</span> % len(incorrectIndex))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_train_performance</span><span class="params">(trained_model)</span>:</span>  </span><br><span class="line">  <span class="comment"># history函数会每轮训练收集损失和准确率，如果有测试集也会收集测试集的数据</span></span><br><span class="line">    print(trained_model.history.keys())</span><br><span class="line">    accuracy = trained_model.history[<span class="string">'accuracy'</span>]</span><br><span class="line">    val_accuracy = trained_model.history[<span class="string">'val_accuracy'</span>]</span><br><span class="line">    loss = trained_model.history[<span class="string">'loss'</span>]</span><br><span class="line">    val_loss = trained_model.history[<span class="string">'val_loss'</span>]</span><br><span class="line">    <span class="comment"># epoch表示完成了1遍训练集中的所有样本</span></span><br><span class="line">    epochs = range(len(accuracy))</span><br><span class="line">    <span class="comment"># 创建一个画板，1为画板的编号，可以不填</span></span><br><span class="line">    f1 = plt.figure(<span class="number">1</span>)</span><br><span class="line">    <span class="comment"># 一个figure对象包含了多个子图，可以使用subplot()函数来绘制子图</span></span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line">    <span class="comment"># axis设置坐标轴</span></span><br><span class="line">    plt.axis((<span class="number">0</span>, len(epochs), <span class="number">0</span>, <span class="number">1.2</span>))</span><br><span class="line">    plt.plot(epochs, accuracy, <span class="string">'bo'</span>, label=<span class="string">'Training accuracy'</span>)</span><br><span class="line">    plt.plot(epochs, val_accuracy, <span class="string">'b'</span>, label=<span class="string">'valid accuracy'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and valid accuracy'</span>)</span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.subplot(<span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line">    plt.axis((<span class="number">0</span>, len(epochs), <span class="number">0</span>, <span class="number">1.2</span>))</span><br><span class="line">    plt.plot(epochs, loss, <span class="string">'bo'</span>, label=<span class="string">'Training loss'</span>)</span><br><span class="line">    plt.plot(epochs, val_loss, <span class="string">'b'</span>, label=<span class="string">'valid loss'</span>)</span><br><span class="line">    plt.title(<span class="string">'Training and valid loss'</span>)</span><br><span class="line">    <span class="comment"># 展示出每个数据对应的图像名称，更好辨认</span></span><br><span class="line">    plt.legend()</span><br><span class="line">    plt.show()</span><br><span class="line">    plt.pause(<span class="number">0.001</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Initialize model -- ##</span></span><br><span class="line">model = baseline_model()</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Test the performmance of the untrained model over the test dataset -- ##</span></span><br><span class="line">find_correct_and_incorrect_labels(model, test_X, test_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Train the model -- ##</span></span><br><span class="line">print(<span class="string">'\nTraining started ...'</span>)</span><br><span class="line">trained_model = model.fit(train_X, train_y, batch_size=<span class="number">10</span>, epochs=<span class="number">150</span>, verbose=<span class="number">0</span>, validation_data=(valid_X, valid_y))</span><br><span class="line">print(<span class="string">'Training finished. \n'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Test the performmance of the trained model over the test dataset -- ##</span></span><br><span class="line">find_correct_and_incorrect_labels(model, test_X, test_y)</span><br><span class="line"></span><br><span class="line"><span class="comment"># -- Plot performance over training episodes -- ##</span></span><br><span class="line">plot_train_performance(trained_model)</span><br></pre></td></tr></table></figure><h2 id="Result"><a href="#Result" class="headerlink" title="Result"></a>Result</h2><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Snipaste_2019-11-01_21-10-25.png" alt=""></p><h2 id="Error"><a href="#Error" class="headerlink" title="Error"></a>Error</h2><p>在按照提示修改代码后，会一直提示以下这个错误，即实际输出的数组形状为与预期数据的形状不同。</p><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/Snipaste_2019-11-01_21-20-09.png" alt=""></p><p>最终通过Stack Overflow上的<a href="https://stackoverflow.com/questions/51456613/valueerror-error-when-checking-target-expected-dense-3-to-have-shape-1-but" target="_blank" rel="noopener">一篇帖子</a>找到了问题所在。</p><p>the following line is wrong</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb_Classes = <span class="number">1</span></span><br></pre></td></tr></table></figure><p>change it to </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nb_Classes = <span class="number">3</span></span><br></pre></td></tr></table></figure><p>Because final layer is of 3 dimension. Beacuse I used <code>categorical_crossentropy</code> and also the terminal shows that actually there are three layers.</p><h2 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h2><h3 id="categorical-crossentropy-函数"><a href="#categorical-crossentropy-函数" class="headerlink" title="categorical_crossentropy()函数"></a>categorical_crossentropy()函数</h3><p>即<strong>分类交叉熵</strong>函数。它用于衡量两个概率分布之间的举例。</p><h3 id="train-test-split"><a href="#train-test-split" class="headerlink" title="train_test_split"></a>train_test_split</h3><p><code>train_test_split</code>是交叉验证中常用的函数，功能是从样本中随机的按比例选取train_data和test_data，形式为：</p><p><code>X_train, X_test, y_train, y_test = cross_validation.train_test_split(train_data, train_target, test_size=0.4, randow_state=0)</code></p><p><code>cross_validation</code>为交叉验证</p><p><strong>参数解释：</strong></p><ul><li>train_data：所划分的样本特征集</li><li>train_target：所要划分的样本结果</li><li>test_size：样本占比，如果是整数的话就是样本的数量</li><li>random_size：随机数的种子</li></ul><p><strong>随机数种子：</strong></p><p>该组随机数的编号，可以在需要重复试验的时候，保证得到一组同样的随机数。比如，如果每次都设置随机数为1，那么得到的随机数组是一样的。如果设置为0或者不填，每次都会不一样。</p><p>随机数的产生取决于种子，随机数和种子之间关系：种子不同，产生不同的随机数；种子相同，即使实例不同也产生相同的随机数。</p><h3 id="ReLU激活函数"><a href="#ReLU激活函数" class="headerlink" title="ReLU激活函数"></a>ReLU激活函数</h3><p><img src= "/img/loading.gif" data-src="https://raw.githubusercontent.com/HurleyJames/ImageHosting/master/20161113161105403.png" alt=""></p><p>ReLU函数是分段线性函数，可以简单表示为<code>ReLU(x) = max(x, 0)</code>，在神经元中输出为：$\max(0, w^Tx+b)$</p><blockquote><p><strong>线性整流函数</strong>（Rectified Linear Unit, <strong>ReLU</strong>），又称修正线性单元，是一种<a href="https://baike.baidu.com/item/人工神经网络" target="_blank" rel="noopener">人工神经网络</a>中常用的激活函数（activation function），通常指代以<a href="https://baike.baidu.com/item/斜坡函数" target="_blank" rel="noopener">斜坡函数</a>及其变种为代表的非线性函数。</p></blockquote><p><strong>优点：</strong></p><ul><li>梯度不饱和。因为梯度计算公式为：1{x&gt;0}，所以在反向传播的过程中，减轻了梯度弥散的问题，神经网络前几层的参数也可以很快更新。</li><li>计算速度快。ReLU函数仅仅需要设置阈值，加快了正向传播的速度。</li></ul><h3 id="RMSprop优化器"><a href="#RMSprop优化器" class="headerlink" title="RMSprop优化器"></a>RMSprop优化器</h3><p>For example:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">keras.optimizers.RMSprop(lr=<span class="number">0.001</span>, rho=<span class="number">0.9</span>, epsilon=<span class="literal">None</span>, decay=<span class="number">0.0</span>)</span><br></pre></td></tr></table></figure><p>建议使用优化器的默认参数（除了学习率lr，它可以被自由调节）。</p><p>RMSprop优化器通常是训练循环神经网络RNN的不错选择。</p><p><strong>参数：</strong></p><ul><li><strong>lr</strong>: float &gt;= 0，学习率</li><li><strong>rho</strong>: float &gt;= 0，RMSProp梯度平方的移动均值的衰减率</li><li><strong>epsilon</strong>: float &gt;= 0，模糊因子。若为None，默认为<code>K.epsilon()</code></li><li><strong>decay</strong>: float &gt;= 0，每次参数更新后学习率衰减值</li></ul><h3 id="Model类类型方法"><a href="#Model类类型方法" class="headerlink" title="Model类类型方法"></a>Model类类型方法</h3><h4 id="compile"><a href="#compile" class="headerlink" title="compile"></a>compile</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">compile(optimizer, loss=<span class="literal">None</span>,  metrics=<span class="literal">None</span>, loss_weights=<span class="literal">None</span>, sample_weight_mode=<span class="literal">None</span>, weighted_metrics=<span class="literal">None</span>, target_tensors=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p><strong>参数：</strong></p><ul><li><strong>optimizer</strong>：字符串（优化器名）或者优化器实例</li><li><strong>loss</strong>：字符串（目标函数名）或目标函数。如果模型具有多个输出，则可以通过传递损失函数的字典或列表，在每个输出上使用不同的损失。 模型将最小化的损失值将是所有单个损失的总和。</li><li><strong>metrics</strong>：在训练和测试期间的模型评估标准。</li><li><strong>loss_weights</strong>：可选的指定标量系数（Python 浮点数）的列表或字典， 用以衡量损失函数对不同的模型输出的贡献。 模型将最小化的误差值是由 <code>loss_weights</code> 系数加权的<em>加权总和</em>误差。 如果是列表，那么它应该是与模型输出相对应的 1:1 映射。 如果是张量，那么应该把输出的名称（字符串）映到标量系数。</li><li><strong>sample_weight_mode</strong>：如果你需要执行按时间步采样权重（2D 权重），请将其设置为 <code>temporal</code>。 默认为 <code>None</code>，为采样权重（1D）。 如果模型有多个输出，则可以通过传递 mode 的字典或列表，以在每个输出上使用不同的 <code>sample_weight_mode</code>。</li><li><strong>weighted_metrics</strong>：在训练和测试期间，由<code>sample_weight</code>或<code>class_weight</code>评估和加权的度量标准列表。</li><li><strong>target_tensors</strong>：默认情况下，Keras 将为模型的目标创建一个占位符，在训练过程中将使用目标数据。 相反，如果你想使用自己的目标张量（反过来说，Keras 在训练期间不会载入这些目标张量的外部 Numpy 数据）， 您可以通过 <code>target_tensors</code> 参数指定它们。 它可以是单个张量（单输出模型），张量列表，或一个映射输出名称到目标张量的字典。</li><li><strong>kwargs</strong>： 当使用 Theano/CNTK 后端时，这些参数被传入 <code>K.function</code>。 当使用 TensorFlow 后端时，这些参数被传递到 <code>tf.Session.run</code>。</li></ul><h4 id="fit"><a href="#fit" class="headerlink" title="fit"></a>fit</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fit(x=<span class="literal">None</span>, y=<span class="literal">None</span>, batch_size=<span class="literal">None</span>, epochs=<span class="number">1</span>, verbose=<span class="number">1</span>, callbacks=<span class="literal">None</span>, validation_split=<span class="number">0.0</span>, validation_data=<span class="literal">None</span>, shuffle=<span class="literal">True</span>, class_weight=<span class="literal">None</span>, sample_weight=<span class="literal">None</span>, initial_epoch=<span class="number">0</span>, steps_per_epoch=<span class="literal">None</span>, validation_steps=<span class="literal">None</span>)</span><br></pre></td></tr></table></figure><p>编译（compile）后的模型就可以开始训练（fit）了，fit的过程可以简单的理解为通过测试数据来确定神经元间连接权重（weight）的过程。</p><p><strong>参数：</strong></p><ul><li><strong>x</strong>：训练数据的Numpy数组（一个输入）或者Numpy数组的列表（如果模型有多个输入）。None是默认。</li><li><strong>y</strong>：目标（标签）数据的Numpy数组（一个输出）或者Numpy数组的列表（如果模型有多个输出）。None是默认。</li><li><strong>batch_size</strong>：整数或者None。每次梯度更新的样本数。如果未指定，则默认为32。</li><li><strong>epochs</strong>：整数。训练模型迭代的最终轮次。</li><li><strong>verbose</strong>：0，1或2。是日志显示模式。0是安静模式，1是进度条，2是每轮一行。</li><li><strong>callbacks</strong>：一系列的<code>keras.callbacks.Callback</code>实例。一系列可以在训练时使用的回调函数。</li><li><strong>validation_split</strong>：0和1之间的浮点数，用于验证集的训练数据的比例。模型将分出一部分不会被训练的验证数据，并将在每一轮结束时评估这些验证数据的误差和任何其他模型指标。</li><li><strong>validatoin_data</strong>：元组 <code>(x_val，y_val)</code> 或元组 <code>(x_val，y_val，val_sample_weights)</code>， 用来评估损失，以及在每轮结束时的任何模型度量指标。 </li><li><strong>shuffle</strong>：布尔值在每轮迭代之前混洗数据）或者字符串（batch）。</li><li><strong>class_weight</strong>：可选的字典，用来映射类索引（整数）到权重（浮点）值，用于加权损失函数（仅在训练期间）。</li><li><strong>sample_weight</strong>：训练样本的可选Numpy权重数组，用于对损失函数进行加权。</li><li><strong>initial_epoch</strong>：整数。开始训练的轮次。</li><li><strong>steps_per_epoch</strong>：整数或None。在声明一个轮次完成并开始下一个轮次之前的总步数。</li><li><strong>validation_steps</strong>：只有在指定了<code>steps_per_epoch</code>时才有用。停止前要验证的总步数。</li></ul><h3 id="np-where-方法"><a href="#np-where-方法" class="headerlink" title="np.where()方法"></a>np.where()方法</h3><ol><li><p><code>np.where(condition, x, y)</code></p><p>当满足条件condition时，输出x，否则输出y。</p></li><li><p><code>np.where(condition)</code></p><p>只有条件condition，没有x和y，则输出满足条件元素的坐标（以tuple的形式给出）。</p></li><li><p>给<code>np.where()</code>函数传递一个条件数组和两个值或者数组，对于条件数组中等价于True的位置，从第一个值或数组中取值进行替换，否则从第二个值或数组中取值进行替换。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">x = np.array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>])</span><br><span class="line">y = np.array([[<span class="number">1</span>, <span class="number">0</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>, <span class="number">0</span>]])</span><br><span class="line">print(np.where(x%<span class="number">2</span> == <span class="number">1</span>, x, -x))</span><br><span class="line">print(np.where(y%<span class="number">2</span> == <span class="number">1</span>, <span class="number">1</span>, <span class="number">-1</span>))</span><br><span class="line">print(np.where(y, [<span class="number">30</span>, <span class="number">40</span>, <span class="number">50</span>], [<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>]))</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 最后一组是当等于0时为false,不为0时为true</span></span><br><span class="line"><span class="comment"># 所以y取1时为true，最后一个取第一组的30；y取0时为false，最后一个取第二组的70</span></span><br><span class="line">[ <span class="number">1</span> <span class="number">-2</span>  <span class="number">3</span> <span class="number">-4</span>  <span class="number">5</span> <span class="number">-6</span>]</span><br><span class="line">[[ <span class="number">1</span> <span class="number">-1</span>  <span class="number">1</span>]</span><br><span class="line"> [<span class="number">-1</span>  <span class="number">1</span> <span class="number">-1</span>]]</span><br><span class="line">[[<span class="number">30</span> <span class="number">70</span> <span class="number">50</span>]</span><br><span class="line"> [<span class="number">30</span> <span class="number">40</span> <span class="number">80</span>]]</span><br></pre></td></tr></table></figure></li></ol><p>np.where()[0]表示行的索引，np.where()[1]表示列的索引</p><h3 id="Epoch、Batchsize、Iteration"><a href="#Epoch、Batchsize、Iteration" class="headerlink" title="Epoch、Batchsize、Iteration"></a>Epoch、Batchsize、Iteration</h3><h4 id="Epoch"><a href="#Epoch" class="headerlink" title="Epoch"></a>Epoch</h4><p>训练时，所有训练数据集都被训练过一次。</p><h4 id="Batchsize"><a href="#Batchsize" class="headerlink" title="Batchsize"></a>Batchsize</h4><p>在训练集中选择一组样本（训练集中的部分样本）用来更新权值。1个batch包含的样本的数目，通常是2的n次幂。常用的包括64，128，256。网络较小时选择256，较大时选择64。</p><h4 id="Iteration"><a href="#Iteration" class="headerlink" title="Iteration"></a>Iteration</h4><p>训练时，1个batch训练图像通过网络训练一次（一次前向传播 + 一次后向传播），每迭代一次权重更新一次；测试时，1个batch测试图像通过网络一次（一次前向传播）。iteration即完成一个epoch所需要的batch个数。</p><h3 id="subplot"><a href="#subplot" class="headerlink" title="subplot()"></a>subplot()</h3><p><code>subplot()</code>是用来绘制子图的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成两行两列，编号为1</span></span><br><span class="line"><span class="comment"># plt.subplot('行', '列', '编号')</span></span><br><span class="line">plt.subplot(<span class="number">2</span>, <span class="number">2</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure><p><strong>Tips:</strong></p><p>行号优先，行优先开始数。</p>]]></content>
      
      
      <categories>
          
          <category> 深度学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> keras </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>未来面前，你我都是孩子</title>
      <link href="/2019/10/14/%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%EF%BC%8C%E4%BD%A0%E6%88%91%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90/"/>
      <url>/2019/10/14/%E6%9C%AA%E6%9D%A5%E9%9D%A2%E5%89%8D%EF%BC%8C%E4%BD%A0%E6%88%91%E9%83%BD%E6%98%AF%E5%AD%A9%E5%AD%90/</url>
      
        <content type="html"><![CDATA[<p>70<strong>后或者</strong>60<strong>后的尾巴基本算是造成如今社会阶级分层的一代。他们或通过刚刚恢复的高考成为当时的天之骄子大学生，或头脑活络下海经商赚得第一桶金，总之他们为后辈们所打下的基础是如今这代人仅凭学习或者工作都无法轻易实现的。但是他们也很苦，因为他们小时候正逢国家最苦难的那个时代。</strong></p><a id="more"></a><p>80<strong>后，如今也许都成家立业。他们也不容易，他们赶上了</strong>08<strong>年金融危机，赶上了</strong>09<strong>年一线城市开始高涨的房价，但他们也许还可以在二线城市也就是如今的新一线城市站住脚跟。</strong></p><p><strong>而</strong>90<strong>后，他们既享受着与生俱来的福利，也面临着当今社会的生存挑战。他们自小就至少温饱不愁，衣食无忧，甚至部分已经可以享受拼爹的福利，但也有更多的人，在当他们走出学校这个象牙塔，迈入社会之时，他们可能才发现这座繁华的城市很欢迎你来，却也很难让你一直驻足下去。</strong>16<strong>年二线城市的房价飞涨，让没有提早上车又没有家庭经济基础的部分这代人，生存变得很艰难。并且伴随着国家政策的调控，连三四线城市的房价都一路攀升，或许有一天你会发现连购买你家乡的房子都捉襟见肘。</strong></p><p><strong>当今在大城市的主要职业里，有两个风口，一个是互联网IT，一个是金融。放大一点的话，房地产和教育也很不错。这些都是薪水十分可观的职业。但一些其他的职业，则仅凭薪水可能很难满足。</strong></p><p><strong>尽管生活很艰辛，阶级固化严重，尽管在仅凭十年二十年甚至一代人，就在经济实力和社会地位上跨越一个阶级并不是很轻松的事情，但是如果有方法的努力，前途仍然光明。承认并清醒地认识到自身的缺陷和不足，眼光长远，在适合自己，适合社会的领域深耕，保持自省的状态，未来可期。</strong></p><p><strong>命运如浮萍，飞砂风中转。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>适配Android7.0以上调取相机拍照并返回照片</title>
      <link href="/2019/04/17/%E9%80%82%E9%85%8DAndroid7.0%E4%BB%A5%E4%B8%8A%E8%B0%83%E5%8F%96%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%85%A7%E7%89%87/"/>
      <url>/2019/04/17/%E9%80%82%E9%85%8DAndroid7.0%E4%BB%A5%E4%B8%8A%E8%B0%83%E5%8F%96%E7%9B%B8%E6%9C%BA%E6%8B%8D%E7%85%A7%E5%B9%B6%E8%BF%94%E5%9B%9E%E7%85%A7%E7%89%87/</url>
      
        <content type="html"><![CDATA[<p>Android调取系统相机拍照获取到拍摄照片或从相册中直接选取照片后展示上传是Android开发中很常见的一个功能，实现的思路主要是：</p><ul><li>自Android 6.0以后对某些涉及用户隐私权限的获取需要动态获取，所以首先是检查权限，如没有权限则动态申请权限，这里我们需要用到的权限是WRITE_EXTERNAL_STORAGE和CAMERA</li><li><p>自Android 7.0后系统禁止应用向外部公开file://URI ，因此需要FileProvider来向外界传递URI</p></li><li><p>获取到拍照后的照片，按照现在的手机拍照文件大小来说不做处理直接展示很容易发生OOM，因此这一步需要对图片做压缩处理</p></li></ul><h3 id="一、动态申请权限"><a href="#一、动态申请权限" class="headerlink" title="一、动态申请权限"></a>一、动态申请权限</h3><p>首先在Mainfest.xml文件中声明权限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.CAMERA"</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 因为拍照需要写入文件 所以需要申请读取内存的权限 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">"android.permission.WRITE_EXTERNAL_STORAGE"</span>/&gt;</span></span><br></pre></td></tr></table></figure><a id="more"></a><p>点击Button模拟拍照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">mBtn.setOnClickListener(view -&gt; &#123;</span><br><span class="line">    <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.M) &#123;</span><br><span class="line">        <span class="comment">//如果版本大于Android 6.0</span></span><br><span class="line">        <span class="keyword">if</span> (! checkPermission()) &#123;</span><br><span class="line">          <span class="comment">//如果没有全部权限，则请求权限</span></span><br><span class="line">          requestPermissions();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        takePhoto();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//检查权限</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">checkPermission</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//是否有权限</span></span><br><span class="line">  <span class="keyword">boolean</span> haveCameraPermission = ContextCompat.checkSelfPermission(mContext, Manifest.permission.CAMERA) == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">  <span class="keyword">boolean</span> haveWritePermission = ContextCompat.checkSelfPermission(mContext, Manifest.permission.WRITE_EXTERNAL_STORAGE) == PackageManager.PERMISSION_GRANTED;</span><br><span class="line">  <span class="keyword">return</span> haveCameraPermission &amp;&amp; haveWritePermission;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RequiresApi</span>(api = Build.VERSION_CODES.M)</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">requestPermissions</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  requestPermissions(<span class="keyword">new</span> String[]&#123;Manifest.permission.CAMERA, Manifest.permission.WRITE_EXTERNAL_STORAGE&#125;, REQUEST_PERMISSION_CODE);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onRequestPermissionsResult</span><span class="params">(<span class="keyword">int</span> requestCode, @NonNull  String[] permissions, @NonNull <span class="keyword">int</span>[] grantResults)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onRequestPermissionsResult(requestCode, permissions, grantResults);</span><br><span class="line">  <span class="keyword">switch</span> (requestCode) &#123;</span><br><span class="line">        <span class="keyword">case</span> REQUEST_PERMISSION_CODE:</span><br><span class="line">        <span class="keyword">boolean</span> allowAllPermission = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; grantResults.length; i++) &#123;</span><br><span class="line">              <span class="comment">//被拒绝授权</span></span><br><span class="line">              <span class="keyword">if</span> (grantResults[<span class="number">0</span>] != PackageManager.PERMISSION_GRANTED) &#123;</span><br><span class="line">                  allowAllPermission = <span class="keyword">false</span>;</span><br><span class="line">                  <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              allowAllPermission = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (allowAllPermission) &#123;</span><br><span class="line">              takePhotoOrPickPhoto();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              Toast.makeText(mContext, <span class="string">"该功能需要授权方可使用"</span>, Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在点击拍照按钮后，调用 <code>ContextCompat.checkSelfPermission( )</code>方法检查是否有权限，方法返回值为0说明已经授权。没授权的情况下，调用<code>requestPermissions( )</code>方法，该方法的第一个参数为一个数组，数组中的值为你要申请的一个或多个权限的值，第二个参数为请求码。</p><p>调用<code>requestPermission( )</code>方法后我们需要在Activity中重写<code>onRequestPermissionsResult()</code>方法，在该方法中会得到回调结果，方法中第一个参数是请求码，第二个参数是我们申请的权限数组，第三个参数数组中每一个值对应申请的每一个权限的返回值，值为0或-1，0代表授权，-1代表拒绝授权。</p><h3 id="二、FileProvider"><a href="#二、FileProvider" class="headerlink" title="二、FileProvider"></a>二、FileProvider</h3><p>在获取所有所需的权限后，我们调取系统相机拍照</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">takePhoto</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="comment">//步骤一：创建存储照片的文件</span></span><br><span class="line">  String path = getFilesDir() + File.separator + <span class="string">"images"</span> + File.separator;</span><br><span class="line">    File file = <span class="keyword">new</span> File(path, <span class="string">"test.jpg"</span>);</span><br><span class="line">    <span class="keyword">if</span>(!file.getParentFile().exists())</span><br><span class="line">        file.getParentFile().mkdirs();</span><br><span class="line">  <span class="keyword">if</span> (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.N) &#123;</span><br><span class="line">    <span class="comment">//步骤二：Android 7.0及以上获取文件 Uri </span></span><br><span class="line">      mUri = FileProvider.getUriForFile(<span class="keyword">this</span>, <span class="string">"com.example.admin.custmerviewapplication"</span>, file);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//步骤三：获取文件Uri</span></span><br><span class="line">     mUri = Uri.fromFile(file);</span><br><span class="line">    &#125;</span><br><span class="line">  <span class="comment">//步骤四：调取系统拍照</span></span><br><span class="line">  Intent intent = <span class="keyword">new</span> Intent(<span class="string">"android.media.action.IMAGE_CAPTURE"</span>);</span><br><span class="line">    intent.putExtra(MediaStore.EXTRA_OUTPUT, mUri);</span><br><span class="line">    startActivityForResult(intent, <span class="number">101</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在Android 7.0之前我们只需要步骤一、三、四即可调取系统相机拍照，在此之后的话直接这么调取会报<code>android.os.FileUriExposedException</code>异常。所以我们需要对Android 7.0及以后的机型适配，采用FileProvider方式。</p><h4 id="1-FileProvider是什么"><a href="#1-FileProvider是什么" class="headerlink" title="1. FileProvider是什么"></a>1. FileProvider是什么</h4><p>FileProvider是ContentProvider的一个子类，用于应用程序之间私有文件的传递。自Android 7.0后系统禁止应用向外部公开file://URI ，因此需要FileProvider来向外界传递URI，传递的形式是content : //Uri，使用时需要在清单文件中注册。</p><h4 id="2-注册清单文件"><a href="#2-注册清单文件" class="headerlink" title="2. 注册清单文件"></a>2. 注册清单文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">manifest</span>&gt;</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="tag">&lt;<span class="name">application</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">        <span class="tag">&lt;<span class="name">provider</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:name</span>=<span class="string">"android.support.v4.content.FileProvider"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:authorities</span>=<span class="string">"com.example.admin.custmerviewapplication"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:exported</span>=<span class="string">"false"</span></span></span><br><span class="line"><span class="tag">            <span class="attr">android:grantUriPermissions</span>=<span class="string">"true"</span>&gt;</span></span><br><span class="line">                 <span class="tag">&lt;<span class="name">meta-data</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:name</span>=<span class="string">"android.support.FILE_PROVIDER_PATHS"</span></span></span><br><span class="line"><span class="tag">                    <span class="attr">android:resource</span>=<span class="string">"@xml/file_paths"</span> /&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">provider</span>&gt;</span></span><br><span class="line">        ...</span><br><span class="line">    <span class="tag">&lt;/<span class="name">application</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">manifest</span>&gt;</span></span><br></pre></td></tr></table></figure><p>解释上面provider标签的意思：</p><p><strong>name</strong> 因为我们使用的是V4包下的FileProvider ，所以name的值就是V4包下FileProvider的相对路径值。当然我们也可以自定义类继承于FileProvider，这时候name的值就是我们自定义类的相对路径了</p><p><strong>authorities</strong> 可以理解为标识符，是我们自己自定义的。我们代码中调用getUriForFile方法获取Uri时第二个参数就是这里我们定义的值</p><p><strong>exported</strong> 代表是否可以输出被外部程序使用，填false就行</p><p><strong>android:grantUriPermissions</strong> 是否允许为文件授予临时权限，必须为true</p><p><strong><meta-data></strong> 标签里配置的内容是用来指定那个文件夹下的文件是可被共享的</p><p><strong>name</strong> 为固定的值android.support.FILE_PROVIDER_PATHS</p><p><strong>path</strong> 是对应的xml文件路径，@xml/file_paths代表在xml文件下的file_paths文件</p><h4 id="3-指定可共享的文件路径"><a href="#3-指定可共享的文件路径" class="headerlink" title="3. 指定可共享的文件路径"></a>3. <strong>指定可共享的文件路径</strong></h4><p>在res目录下新建一个xml文件夹，在文件夹下创建一个名为file_paths的xml文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">paths</span> <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span>&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--files-path  相当于 getFilesDir（）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">files-path</span> <span class="attr">name</span>=<span class="string">"my_images"</span> <span class="attr">path</span>=<span class="string">"images"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--cache-path  相当于 getCacheDir（）--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-path</span> <span class="attr">name</span>=<span class="string">"lalala"</span> <span class="attr">path</span>=<span class="string">"cache_image"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--external-path  相当于 Environment.getExternalStorageDirectory()--&gt;</span></span><br><span class="line">    <span class="tag">&lt; <span class="attr">external-path</span>  <span class="attr">name</span>=<span class="string">"hahaha"</span> <span class="attr">path</span>=<span class="string">"comeOn"</span>/&gt;</span></span><br><span class="line">          <span class="comment">&lt;!--external-files-path  相当于 getExternalFilesDir("") --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">external-files-path</span> <span class="attr">name</span>=<span class="string">"paly"</span> <span class="attr">path</span>=<span class="string">"freeSoft"</span>/&gt;</span></span><br><span class="line">         <span class="comment">&lt;!--external-cache-path  相当于 getExternalCacheDir（） --&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">external-cache-path</span>  <span class="attr">name</span>=<span class="string">"lei"</span> <span class="attr">path</span>=<span class="string">"."</span>/&gt;</span></span><br><span class="line">    ...</span><br><span class="line"><span class="tag">&lt;/<span class="name">paths</span>&gt;</span></span><br></pre></td></tr></table></figure><p>files-path所代表的路径等于getFilesDir()，打印getFileDir( )它的路径是 /data/user/0/包名/files。什么意思呢，<code>&lt;files-path name=&quot;my_images&quot; path=&quot;images&quot;/&gt;</code>的意思就是<code>/data/user/0/包名/files + &quot;/files-path标签中path的值/&quot;</code>路径下的文件是可共享的，在生成Uri时name的值my_images会替代上面的路径<code>/data/user/0/包名/files / images /</code>向外暴露。最终的Uri会是<code>content : //com.example.admin.custmerviewapplication / my_images / test.jpg</code></p><h3 id="三、图片获取并压缩"><a href="#三、图片获取并压缩" class="headerlink" title="三、图片获取并压缩"></a>三、图片获取并压缩</h3><p>我们调用<code>startActivityForResult(intent, 101);</code>进行拍照，拍照结束后会回调onActivityResult( )方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">    <span class="keyword">if</span> (resultCode == RESULT_OK &amp;&amp; requestCode == REQUEST_TAKE_PHOTO_CODE) &#123;</span><br><span class="line">      <span class="comment">//获取系统照片上传</span></span><br><span class="line">        Bitmap bm = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            bm = getBitmapFormUri(mUri);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (FileNotFoundException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        mImageView.setImageBitmap(bm);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过Uri直接获取图片加载到内存然后显示在ImageView很容易发生OOM，所以还需做进一步的图片压缩。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">getBitmapFormUri</span><span class="params">(Uri uri)</span> <span class="keyword">throws</span> FileNotFoundException, IOException </span>&#123;</span><br><span class="line">  InputStream input = getContentResolver().openInputStream(uri);</span><br><span class="line">    <span class="comment">//这一段代码是不加载文件到内存中也得到bitmap的真是宽高，主要是设置inJustDecodeBounds为true</span></span><br><span class="line">    BitmapFactory.Options onlyBoundsOptions = <span class="keyword">new</span> BitmapFactory.Options();</span><br><span class="line">    onlyBoundsOptions.inJustDecodeBounds = <span class="keyword">true</span>;<span class="comment">//不加载到内存</span></span><br><span class="line">    onlyBoundsOptions.inDither = <span class="keyword">true</span>;<span class="comment">//optional</span></span><br><span class="line">    onlyBoundsOptions.inPreferredConfig = Bitmap.Config.RGB_565;<span class="comment">//optional</span></span><br><span class="line">    BitmapFactory.decodeStream(input, <span class="keyword">null</span>, onlyBoundsOptions);</span><br><span class="line">    input.close();</span><br><span class="line">    <span class="keyword">int</span> originalWidth = onlyBoundsOptions.outWidth;</span><br><span class="line">    <span class="keyword">int</span> originalHeight = onlyBoundsOptions.outHeight;</span><br><span class="line">    <span class="keyword">if</span> ((originalWidth == -<span class="number">1</span>) || (originalHeight == -<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    <span class="comment">//图片分辨率以480x800为标准</span></span><br><span class="line">    <span class="keyword">float</span> hh = <span class="number">800f</span>;<span class="comment">//这里设置高度为800f</span></span><br><span class="line">    <span class="keyword">float</span> ww = <span class="number">480f</span>;<span class="comment">//这里设置宽度为480f</span></span><br><span class="line">    <span class="comment">//缩放比，由于是固定比例缩放，只用高或者宽其中一个数据进行计算即可</span></span><br><span class="line">    <span class="keyword">int</span> be = <span class="number">1</span>;<span class="comment">//be=1表示不缩放</span></span><br><span class="line">    <span class="keyword">if</span> (originalWidth &gt; originalHeight &amp;&amp; originalWidth &gt; ww) &#123;</span><br><span class="line">      <span class="comment">//如果宽度大的话根据宽度固定大小缩放</span></span><br><span class="line">        be = (<span class="keyword">int</span>) (originalWidth / ww);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (originalWidth &lt; originalHeight &amp;&amp; originalHeight &gt; hh) &#123;</span><br><span class="line">      <span class="comment">//如果高度高的话根据宽度固定大小缩放</span></span><br><span class="line">      be = (<span class="keyword">int</span>) (originalHeight / hh);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (be &lt;= <span class="number">0</span>)    </span><br><span class="line">      be = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//比例压缩</span></span><br><span class="line">    BitmapFactory.Options bitmapOptions = <span class="keyword">new</span> BitmapFactory.Options();    </span><br><span class="line">    bitmapOptions.inSampleSize = be;</span><br><span class="line">  <span class="comment">//设置缩放比例</span></span><br><span class="line">    bitmapOptions.inDither = <span class="keyword">true</span>;</span><br><span class="line">    bitmapOptions.inPreferredConfig = Bitmap.Config.RGB_565;</span><br><span class="line">    input = getContentResolver().openInputStream(uri);</span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeStream(input, <span class="keyword">null</span>, bitmapOptions);</span><br><span class="line">    input.close();</span><br><span class="line">truetrue<span class="keyword">return</span> compressImage(bitmap);<span class="comment">//再进行质量压缩   </span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> Bitmap <span class="title">compressImage</span><span class="params">(Bitmap image)</span> </span>&#123;</span><br><span class="line">    ByteArrayOutputStream baos = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">    image.compress(Bitmap.CompressFormat.JPEG, <span class="number">100</span>, baos);</span><br><span class="line">    <span class="comment">//质量压缩方法，这里100表示不压缩，把压缩后的数据存放到baos中</span></span><br><span class="line">    <span class="keyword">int</span> options = <span class="number">100</span>;</span><br><span class="line">    <span class="keyword">while</span> (baos.toByteArray().length / <span class="number">1024</span> &gt; <span class="number">100</span>) &#123;</span><br><span class="line">      <span class="comment">//循环判断如果压缩后图片是否大于100kb,大于继续压缩</span></span><br><span class="line">        baos.reset();<span class="comment">//重置baos即清空baos</span></span><br><span class="line">        <span class="comment">//第一个参数 ：图片格式 ，第二个参数： 图片质量，100为最高，0为最差  ，第三个参数：保存压缩后的数据的流</span></span><br><span class="line">        image.compress(Bitmap.CompressFormat.JPEG, options, baos);</span><br><span class="line">      <span class="comment">//这里压缩options，把压缩后的数据存放到baos中</span></span><br><span class="line">        options -= <span class="number">10</span>;<span class="comment">//每次都减少10</span></span><br><span class="line">        <span class="keyword">if</span> (options&lt;=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    ByteArrayInputStream isBm = <span class="keyword">new</span> ByteArrayInputStream(baos.toByteArray());</span><br><span class="line">  <span class="comment">//把压缩后的数据baos存放到ByteArrayInputStream中</span></span><br><span class="line">    Bitmap bitmap = BitmapFactory.decodeStream(isBm, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">  <span class="comment">//把ByteArrayInputStream数据生成图片</span></span><br><span class="line">    <span class="keyword">return</span> bitmap;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>压缩的步骤分为两步，第一步是先得到bitmap的真实宽高计算压缩比例，得到压缩比例后进行初步压缩。第二步将初步压缩的bitmap进行质量压缩得到最终的图片。</p><p>从相册中选取图片步骤和调取相机拍照的步骤一致，只是创建的intent和在onActivtyResult回调时获取的Uri不同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用相册</span></span><br><span class="line">Intent intent = <span class="keyword">new</span> Intent(Intent.ACTION_PICK,android.provider.MediaStore.Images.Media.EXTERNAL_CONTENT_UR）;</span><br><span class="line">startActivityForResult(intent, PICK_IMAGE_CODE);</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onActivityResult</span><span class="params">(<span class="keyword">int</span> requestCode, <span class="keyword">int</span> resultCode, Intent data)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.onActivityResult(requestCode, resultCode, data);</span><br><span class="line">  <span class="comment">//获取图片路径</span></span><br><span class="line">  <span class="keyword">if</span> (requestCode == <span class="number">102</span> &amp;&amp; resultCode == Activity.RESULT_OK &amp;&amp; data != <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="comment">//通过getData获取到Uri</span></span><br><span class="line">      mUri = data.getData();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多媒体技术 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android1.5到Android10.0经历的新特性</title>
      <link href="/2019/02/28/Android1.5%E5%88%B0Android10.0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/"/>
      <url>/2019/02/28/Android1.5%E5%88%B0Android10.0%E7%BB%8F%E5%8E%86%E7%9A%84%E6%96%B0%E7%89%B9%E6%80%A7/</url>
      
        <content type="html"><![CDATA[<h3 id="Android-1-5-Cupcake-纸杯蛋糕"><a href="#Android-1-5-Cupcake-纸杯蛋糕" class="headerlink" title="Android 1.5(Cupcake 纸杯蛋糕)"></a>Android 1.5(Cupcake 纸杯蛋糕)</h3><ul><li>智能虚拟键盘；<strong>使用widgets实现桌面个性化</strong>；在线文件夹(Live Folder)快速浏览在线数据；视频录制和分享；图片上传；</li><li>更快的标准兼容浏览器；Voice search 语音搜索；立体声蓝牙和免提电话</li></ul><a id="more"></a><h3 id="Android-1-6-Donut-甜甜圈"><a href="#Android-1-6-Donut-甜甜圈" class="headerlink" title="Android 1.6(Donut 甜甜圈)"></a>Android 1.6(Donut 甜甜圈)</h3><ul><li>完全重新设计的Android Market，可以显示更多的屏幕截图；手势支持，可以让开发者生成针对某个应用程序的手势库</li><li>支持CDMA网络</li><li>TXT-2-Speech，支持了更多语言的发音，包括英语、法语、德语、意大利语等</li><li><strong>快速搜索框，可直接搜索括联系人，音乐，浏览历史，书签等手机内容</strong></li><li>全新的拍照界面：新版相机程序启动速度快了39%，拍照间的延迟减少了28%</li><li><strong>应用程序耗电查看</strong></li><li>新增面向视觉或听觉困难人群的易用性插件</li><li>Linux内核升级到2.6.29</li><li>支持更多的屏幕分辨率</li></ul><h3 id="Android-2-0-2-0-2-1-Eclair-松饼（闪电泡芙）"><a href="#Android-2-0-2-0-2-1-Eclair-松饼（闪电泡芙）" class="headerlink" title="Android 2.0(2.0~2.1 Eclair 松饼（闪电泡芙）)"></a>Android 2.0(2.0~2.1 Eclair 松饼（闪电泡芙）)</h3><ul><li>加强了网络社交功能，比如Facebook好友整合至联系人功能</li><li>自带的Chrome Lite浏览器现在加入了对双击屏幕进行缩放的支持</li><li>由于文件结构的改动优化，使得整个操作流畅性得到了很大的提升</li><li>强化了语音识别的搜索控制。整个系统多处都支持语音控制，并拥有独立的控制面板</li><li>谷歌地图服务更新，加入了全新的导航系统</li><li>加入了原生微软Exchange邮件服务支持</li><li>提供了多个不同帐户，统一的邮件收件箱</li><li>优化了驾车时的体验，新的“Car Home”应用程序为各功能提供了易于操作的快捷链接，还能方便地使用语音控制功能，便于用户驾车时使用</li></ul><h3 id="Android-2-1"><a href="#Android-2-1" class="headerlink" title="Android 2.1"></a>Android 2.1</h3><ul><li>可以同时绑定多个Google账号</li><li>无线控件里有了VPN设置</li><li>增加了连接到PC设置</li><li>增强了语言和声音的转换功能，并加入了文字到语音转换</li><li>全新的拨号界面，按键更大，更易于操作</li><li>更多桌面Widget</li><li>新的Google地图可以使用谷歌地图导航功能</li><li>新的浏览器版本，加强了稳定性和网页渲染能力</li><li>全局搜索功能加强</li><li>全新的Market程序，搜索更快布局更合理</li></ul><h3 id="Android-2-2-Froyo-冻酸奶"><a href="#Android-2-2-Froyo-冻酸奶" class="headerlink" title="Android 2.2(Froyo 冻酸奶)"></a>Android 2.2(Froyo 冻酸奶)</h3><ul><li>全面支持Flash 10.1</li><li><strong>应用程序自动升级</strong>，让升级更加人性化</li><li><strong>支持应用程序安装在外置内存上</strong></li><li>对系统性能进一步优化，让手机有更多的运行内存</li><li>增加了轨迹球LED指示灯变色这个新功能</li><li>增加了对3D性能的优化，3D性能更加强大</li><li>FM功能也将在新系统中得到全面支持</li></ul><h3 id="Android-2-3-Gingerbread-姜饼"><a href="#Android-2-3-Gingerbread-姜饼" class="headerlink" title="Android 2.3(Gingerbread 姜饼)"></a>Android 2.3(Gingerbread 姜饼)</h3><ul><li><strong>原生支持前置摄像头</strong></li><li>全新虚拟键盘</li><li>全局下载管理</li><li>NFC近场通信</li><li>改善电源管理</li><li>增加官方进程管理</li><li>提升多媒体能力</li><li>提升游戏体验</li><li>用户界面更美观</li></ul><h3 id="Android-3-0到3-1-3-0-Honeycomb-蜂巢"><a href="#Android-3-0到3-1-3-0-Honeycomb-蜂巢" class="headerlink" title="Android 3.0到3.1(3.0 Honeycomb 蜂巢)"></a>Android 3.0到3.1(3.0 Honeycomb 蜂巢)</h3><p>安卓3.0系统主要用于安卓的平板产品</p><h3 id="Android-4-0-Ice-CreamSandwich"><a href="#Android-4-0-Ice-CreamSandwich" class="headerlink" title="Android 4.0(Ice CreamSandwich)"></a>Android 4.0(Ice CreamSandwich)</h3><ul><li><strong>一流的新UI</strong></li><li>开源</li></ul><h3 id="Android-5-0-Lollipop-棒棒糖"><a href="#Android-5-0-Lollipop-棒棒糖" class="headerlink" title="Android 5.0(Lollipop 棒棒糖)"></a>Android 5.0(Lollipop 棒棒糖)</h3><ul><li>通过Android Market购买音乐</li><li>多核处理器优化</li><li><strong>支持现有的智能手机</strong></li><li>为OEM提供了官方的主题引擎</li></ul><h3 id="Android-6-0-Marshmallow-棉花糖"><a href="#Android-6-0-Marshmallow-棉花糖" class="headerlink" title="Android 6.0(Marshmallow 棉花糖)"></a>Android 6.0(Marshmallow 棉花糖)</h3><ul><li>锁屏下语音搜索</li><li><strong>原生指纹识别</strong></li><li><strong>更完整的应用权限管理</strong></li><li>Doze电量管理</li><li>Now on Tap功能</li><li><strong>App Links</strong></li><li><strong>Android Pay</strong></li></ul><h3 id="Android-7-0-Nougat-牛轧糖"><a href="#Android-7-0-Nougat-牛轧糖" class="headerlink" title="Android 7.0(Nougat 牛轧糖)"></a>Android 7.0(Nougat 牛轧糖)</h3><ul><li><strong>分屏多任务</strong></li><li>全新下拉快捷开关页</li><li><strong>通知消息快捷回复</strong></li><li><strong>通知消息归拢</strong></li><li><strong>夜间模式</strong></li><li>流量保护模式</li><li>全新设置样式</li><li>改进的Doze休眠机制</li><li>系统级电话黑名单功能</li><li><strong>双击菜单键快速应用切换</strong></li></ul><h3 id="Android-8-0-Oreo-奥利奥"><a href="#Android-8-0-Oreo-奥利奥" class="headerlink" title="Android 8.0(Oreo 奥利奥)"></a>Android 8.0(Oreo 奥利奥)</h3><ul><li>通知中心</li><li>设置菜单</li><li><strong>PinnedShortcuts</strong>，类似iOS中的3D Touch</li><li><strong>图标形状</strong></li><li>后台限制</li><li>安装限制</li><li><strong>TensorFlowLite</strong></li><li>NotificationDots</li><li>分屏</li><li>SmartTextSelection</li><li><strong>自动保存密码</strong></li><li>GooglePlayProtect，主要用于Google Play中，下载的应用和游戏将会经过它的排查，来看看是否是有害甚至携带病毒的应用</li><li>应用加速</li><li>字体优化</li><li>表情符号</li></ul><h3 id="Android-9-0-Pie-派"><a href="#Android-9-0-Pie-派" class="headerlink" title="Android 9.0(Pie 派)"></a>Android 9.0(Pie 派)</h3><ul><li><strong>全面屏的全面支持</strong></li><li>通知栏的多种通知</li><li>多摄像头的更多画面</li><li>GPS定位之外的WiFi定位</li><li>神经网络</li><li><strong>Material Design 2.0</strong></li><li>全局黑夜模式</li></ul><h3 id="Android-10-0"><a href="#Android-10-0" class="headerlink" title="Android 10.0"></a>Android 10.0</h3><ul><li><strong>暗黑模式</strong>，在 Android Q 中，暗黑模式适用于任何地方，如果应用不支持暗黑模式，那么系统将自动设置一个暗黑模式</li><li>隐私增强</li><li>运营商锁定</li><li>多显示器支持</li><li><strong>原生面部识别</strong></li><li><strong>桌面模式</strong></li><li><strong>原生屏幕录制</strong></li><li><strong>更安全Smart Lock</strong></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搬家前一周</title>
      <link href="/2018/11/22/%E6%90%AC%E5%AE%B6%E5%89%8D%E4%B8%80%E5%91%A8/"/>
      <url>/2018/11/22/%E6%90%AC%E5%AE%B6%E5%89%8D%E4%B8%80%E5%91%A8/</url>
      
        <content type="html"><![CDATA[<p>因为各种原因，我过完这周就要搬离这个我生活了两个多月的小家了。毕竟，在这里也呆了两个多月，也结识了很nice的室友，交通也还算便利，但是，终究要离开了。</p><a id="more"></a><p>并不是说有多么的不舍，因为我还有更重要的事情需要去完成。况且，离开的结局也不是很好，毕竟是自己租期未满就提前走的，押金也无法拿回来，可以勉强算是被房东赶走的，所以并不是多么一个开心的过程。</p><p>我住在13楼。窗外就是大上海，虽然我面对的并不是繁华的市中心，但是毕竟还身处中环以内，那川流不息的车辆还是让我感觉到大城市所独特的气息。</p><p>上班时，坐地铁也就20多分钟，有时挤，有时不挤。相比某些深处外环，每天通勤时间长达三小时以上的工薪族来说，我还勉强算的上幸福。</p><p>工作的压力当然是有的。本以为实习也不会做什么艰巨的任务，主要是以培养为主。但显然这只适用于那么规模较大的公司。对于我所加入的这家创业7年，有过巅峰时期，而现在处于低谷的小公司而言，人手尚且不足，那么实习生也要求能够迅速地上手完成公司的项目。</p><p>这样有好处，当然也有坏处的。好处就是让你迅速上手完成公司项目的话，对人的阅读源码的能力要求比较高，也就是锻炼了实际写代码的能力。但是坏处也是创业公司的通病，因为需要立刻上线产品，所以在很多方面就不是那么的规范。对于有多年经验的老手来说倒是无所谓，但是对于实习生而言，还是尽量加入一家大公司，有着更完善的制度，代码也更加规范，对于今后的成长更加有帮助。</p><p>还是非常感谢这家公司能够让我加入团队。毕竟自己经历过实习，也意识到自己有太多的不足了。很多方面，我都是浅尝辄止，而没有深挖内在的原理。也正是这段实习经历，让我感到在学校里学到的很多基础学科其实大有帮助，只有将基础打牢，才能够更进一步。</p><p>作为一个还处于大四、尚未完全走出象牙塔的学生，我在某些方面仍然非常的稚嫩，包括心理的调整。毕竟身处中国最大的城市，又从事着程序员这种辛苦的职业，再加上自己现在的能力不足，很容易信心不足，产生动摇。但好在我终于挺过来了。</p><p>我觉得我从来不缺对于局势的判断能力，但我缺少的是对于某件事情攻无不克的决心。</p><p>希望今后的自己也能够更加出色吧。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> I said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android属性动画详解（转载）</title>
      <link href="/2018/11/05/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2018/11/05/Android%E5%B1%9E%E6%80%A7%E5%8A%A8%E7%94%BB%E8%AF%A6%E8%A7%A3%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="一、属性动画出现的原因"><a href="#一、属性动画出现的原因" class="headerlink" title="一、属性动画出现的原因"></a>一、属性动画出现的原因</h3><p>属性动画（Property Animation）是Android3.0（API11）之后的版本中才提供的一种全新的动画模式</p><h4 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h4><p>实现动画效果在Android开发中非常常见，所以Android系统提供了两种实现动画的方式：</p><ul><li>逐帧动画（Frame Animation）</li><li>补间动画（Tweened Animation）</li></ul><a id="more"></a><h4 id="缺陷"><a href="#缺陷" class="headerlink" title="缺陷"></a>缺陷</h4><ul><li>补间动画只能够作用在视图View上，即只可以对一个Button、TextView或者LinearLayout或者其它继承自View的组件进行动画操作，但无法对非View的对象进行动画操作</li><li>没有改变View的属性，只是改变视觉效果。补间动画只是改变了View的视觉效果，但不会真正改变View的属性。比如通过补间动画将屏幕左上角的按钮移动到右上角，但是点击屏幕右上角仍然是没有反应的，因为实际上按钮仍然在左上角，补间动画只是将其绘制到了屏幕右上角，改变了视觉效果而已</li><li>动画效果单一。补间动画只能实现平移、旋转、缩放和透明度等简单的动画需求，对于复杂的动画效果，补间动画无法实现</li></ul><h3 id="二、属性动画简介"><a href="#二、属性动画简介" class="headerlink" title="二、属性动画简介"></a>二、属性动画简介</h3><ul><li>作用对象：任意Java对象，不再局限于视图View对象</li><li>实现的动画效果：可以自定义各种动画效果，不再局限于4种基本变换</li></ul><h3 id="三、工作原理"><a href="#三、工作原理" class="headerlink" title="三、工作原理"></a>三、工作原理</h3><ul><li>在一定时间间隔内，通过不断对值进行改变，并不断将该值赋给对象的属性，从而实现该对象在该属性上的动画效果</li><li>具体的工作原理逻辑如下：</li><li>从上述工作原理中可以看出属性动画有两个非常重要的类：ValueAnimator类和ObjectAnimator类</li></ul><h3 id="四、使用方法"><a href="#四、使用方法" class="headerlink" title="四、使用方法"></a>四、使用方法</h3><h4 id="ValueAnimator类"><a href="#ValueAnimator类" class="headerlink" title="ValueAnimator类"></a>ValueAnimator类</h4><ul><li>定义：属性动画机制中，最核心的一个类</li><li>实现动画的原理：通过不断控制值的变化，再不断手动赋给对象的属性，从而实现动画效果</li><li>ValueAnimator类中有3个主要方法：<ul><li><code>ValueAnimator.ofInt(int values)</code></li><li><code>ValueAnimator.ofFloat(float values)</code></li><li><code>ValueAnimator.ofObject(int values)</code></li></ul></li></ul><h4 id="1-valueAnimator-ofInt-int-values"><a href="#1-valueAnimator-ofInt-int-values" class="headerlink" title="1.valueAnimator.ofInt(int values)"></a>1.valueAnimator.ofInt(int values)</h4><p>Java代码设置：<br>在实际开发中，建议使用Java代码实现属性动画，因为大多数情况下，属性的起始值是无法提前确定的（无法使用XML设置）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//步骤1：设置动画属性的初始值和结束值</span></span><br><span class="line">ValueAnimator anim = ValueAnimator.ofInt(<span class="number">0</span>, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//ofInt()的作用有两个</span></span><br><span class="line"><span class="comment">//1.创建动画实例</span></span><br><span class="line"><span class="comment">//2.将传入的多个Int参数进行平滑过渡：此处传入0和3，表示将值从0平滑过渡到3</span></span><br><span class="line"><span class="comment">//如果传入了3个参数a、b、c，则是先从a平滑过渡到b，再从b平滑过渡到c，以此类推</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤2：设置动画的各种播放属性</span></span><br><span class="line"><span class="comment">//设置动画运行的时长</span></span><br><span class="line">anim.setDuration(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//设置动画延迟播放时间</span></span><br><span class="line">anim.setStartDelay(<span class="number">1000</span>);</span><br><span class="line"><span class="comment">//设置动画重复播放次数 = 重放次数 + 1</span></span><br><span class="line"><span class="comment">//动画播放次数 = infinite时，动画无限重复</span></span><br><span class="line">anim.setRepeatCount(<span class="number">0</span>);</span><br><span class="line"><span class="comment">//设置重复播放动画模式</span></span><br><span class="line"><span class="comment">//RESTART（默认）：正序播放</span></span><br><span class="line">anim.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line"><span class="comment">//REVERSE：倒序回放</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//步骤3：将改变的值手动赋值给对象的属性值：</span></span><br><span class="line"><span class="comment">//通过动画的更新监听器，设置值的更新监听器</span></span><br><span class="line"><span class="comment">//即值每次改变、变化一次，该方法就会调用一次</span></span><br><span class="line">anim.addUpdateListener(<span class="keyword">new</span> ValueAnimator.AnimatorUpdateListener() &#123;</span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onAnimationUpdate</span><span class="params">(ValueAnimator animation)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获得改变后的值</span></span><br><span class="line">    <span class="keyword">int</span> currentValue = (Integer) animation.getAnimatedValue();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//步骤4：将改变后的值赋给对象的属性值</span></span><br><span class="line">    View.setProperty(currentValue);</span><br><span class="line">    <span class="comment">//步骤5：刷新视图，即重新绘制，从而实现动画效果</span></span><br><span class="line">    View.requestLaytout();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p><p>XML布局文件设置：<br>步骤1：在路径res/animator文件夹中创建相对应的动画.xml文件<br>步骤2：设置动画参数<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">animator</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xmlns:android</span>=<span class="string">"http://schemas.android.com/apk/res/android"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueFrom</span>=<span class="string">"0"</span>         //初始值</span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueTo</span>=<span class="string">"100"</span>         //结束值</span></span><br><span class="line"><span class="tag">  <span class="attr">android:valueType</span>=<span class="string">"intType"</span>   //变化值类型：<span class="attr">floatType</span> &amp; <span class="attr">intType</span></span></span><br><span class="line"><span class="tag"></span></span><br><span class="line"><span class="tag">  <span class="attr">android:duration</span>=<span class="string">"3000"</span>       //动画持续时间（<span class="attr">ms</span>），必须设置，动画才有效果</span></span><br><span class="line"><span class="tag">  <span class="attr">android:startOffset</span>=<span class="string">"1000"</span>    //动画延迟开始时间（<span class="attr">ms</span>）</span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillBefore</span>=<span class="string">"true"</span>     //动画播放完后，视图是否会停留在动画开始的状态，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillAfter</span>=<span class="string">"false"</span>     //动画播放完后，视图是否会停留在动画结束的状态，优先于<span class="attr">fillBefore</span>值，默认为<span class="attr">false</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:fillEnabled</span>=<span class="string">"true"</span>    //是否使用<span class="attr">fillBefore</span>值，对<span class="attr">fillAfter</span>值无影响，默认为<span class="attr">true</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:repeatMode</span>=<span class="string">"restart"</span>  //选择重复播放动画模式，<span class="attr">restart</span>代表正序播放，<span class="attr">reverse</span>代表倒序回放，默认为<span class="attr">restart</span></span></span><br><span class="line"><span class="tag">  <span class="attr">android:repeatCount</span>=<span class="string">"0"</span>       //重复次数（动画的播放次数=<span class="string">重复次数+1），为infinite时无限重复</span></span></span><br><span class="line"><span class="tag">  //插值器，影响动画的播放速度</span></span><br><span class="line"><span class="tag">  <span class="attr">android:interpolator</span>=<span class="string">@[package:]anim/interpolator_resource</span></span></span><br><span class="line"><span class="tag">/&gt;</span></span><br></pre></td></tr></table></figure><br>步骤3：在Java代码中启动动画<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//载入XML动画</span></span><br><span class="line">Animator animator = AnimatorInflater.loadAnimator(context, R.animator.animation);</span><br><span class="line"><span class="comment">//设置动画对象</span></span><br><span class="line">animator.setTarget(view);</span><br><span class="line"><span class="comment">//启动动画</span></span><br><span class="line">animator.start();</span><br></pre></td></tr></table></figure></p><h4 id="2-valueAnimator-ofInt-float-values"><a href="#2-valueAnimator-ofInt-float-values" class="headerlink" title="2.valueAnimator.ofInt(float values)"></a>2.valueAnimator.ofInt(float values)</h4><p>在使用上与ValueAnimator.ofInt(int values)完全没有区别</p><h4 id="3-valueAnimator-ofObject"><a href="#3-valueAnimator-ofObject" class="headerlink" title="3.valueAnimator.ofObject()"></a>3.valueAnimator.ofObject()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建初始动画时对象 &amp; 结束动画时的对象</span></span><br><span class="line">Object object1 = <span class="keyword">new</span> Object();</span><br><span class="line">Object object2 = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line"><span class="comment">//创建动画对象 &amp; 设置参数</span></span><br><span class="line"><span class="comment">//参数说明</span></span><br><span class="line"><span class="comment">//参数1：自定义的估值器对象（TypeEvaluator类型参数）</span></span><br><span class="line"><span class="comment">//参数2：初始动画的对象</span></span><br><span class="line"><span class="comment">//参数3：结束动画的对象</span></span><br><span class="line">ValueAnimator anim = ValueAnimator.ofObject(<span class="keyword">new</span> objectEvaluator(), object1, object2);</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置动画属性</span></span><br><span class="line">anim.setDuration(<span class="number">3000</span>);</span><br><span class="line"><span class="comment">//启动动画</span></span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><h4 id="ObjectAnimator类"><a href="#ObjectAnimator类" class="headerlink" title="ObjectAnimator类"></a>ObjectAnimator类</h4><h6 id="实现动画的原理"><a href="#实现动画的原理" class="headerlink" title="实现动画的原理"></a>实现动画的原理</h6><p>直接对对象的属性值进行改变操作，从而实现动画效果</p><h6 id="ValueAnimator类与ObjectAnimator类的区别"><a href="#ValueAnimator类与ObjectAnimator类的区别" class="headerlink" title="ValueAnimator类与ObjectAnimator类的区别"></a>ValueAnimator类与ObjectAnimator类的区别</h6><ul><li>ValueAnimator类是先改变值，然后手动赋值给对象的属性从而实现动画；是间接对对象属性进行操作</li><li>ObjectAnimator类是先改变值，然后自动赋值给对象的属性从而实现动画；是直接对对象属性进行操作</li></ul><h6 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h6><p>Java设置<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(Object object, String property, <span class="keyword">float</span> ...values);</span><br><span class="line">anim.setDuration(<span class="number">500</span>);</span><br><span class="line">anim.setStartDelay(<span class="number">500</span>);</span><br><span class="line">anim.setRepeatCount(<span class="number">0</span>);</span><br><span class="line">anim.setRepeatMode(ValueAnimator.RESTART);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>XML设置<br>与ValueAnimator一样  </p><p>a.透明度：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">//动作作用的对象是mButton</span></span><br><span class="line"><span class="comment">//动画作者的对象的属性是透明度alpha</span></span><br><span class="line"><span class="comment">//动画效果是：常规 - 全透明 - 常规</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"alpha"</span>, <span class="number">1f</span>, <span class="number">0f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>b.旋转：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">//动作作用的对象是mButton</span></span><br><span class="line"><span class="comment">//动画作者的对象的属性是旋转rotation</span></span><br><span class="line"><span class="comment">//动画效果是：0 - 360</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"rotation"</span>, <span class="number">0f</span>, <span class="number">360f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>c.平移：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"><span class="comment">//获得当前控件的位置</span></span><br><span class="line"><span class="keyword">float</span> curTranslationX = mButton.getTranslationX();</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画作用的对象的属性是X轴平移，translationX</span></span><br><span class="line"><span class="comment">//在Y轴上平移同理，采用属性translationY</span></span><br><span class="line"><span class="comment">//动画效果：从当前位置平移到x=300，再平移到初始位置</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"translationX"</span>, curTranslationX, <span class="number">300</span>, curTranslationX);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure><br>d.缩放：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mButton = findViewById(R.id.button);</span><br><span class="line"></span><br><span class="line"><span class="comment">//动画作用的对象的属性是X轴缩放，sacleX</span></span><br><span class="line"><span class="comment">//在Y轴上缩放同理，采用属性scaleY</span></span><br><span class="line"><span class="comment">//动画效果：放大到3倍，再缩小到原始大小</span></span><br><span class="line">ObjectAnimator anim = ObjectAnimator.ofFloat(mButton, <span class="string">"scaleX"</span>, <span class="number">1f</span>, <span class="number">3f</span>, <span class="number">1f</span>);</span><br><span class="line">anim.setDuration(<span class="number">5000</span>);</span><br><span class="line">anim.start();</span><br></pre></td></tr></table></figure></p><div class="table-container"><table><thead><tr><th style="text-align:center">属性</th><th style="text-align:center">作用</th><th style="text-align:center">数值类型</th></tr></thead><tbody><tr><td style="text-align:center">Alpha</td><td style="text-align:center">控制View的透明度</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">TranslationX</td><td style="text-align:center">控制X方向的位移</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">TranslationY</td><td style="text-align:center">控制Y方向的位移</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">ScaleX</td><td style="text-align:center">控制X方向的缩放倍数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">ScaleY</td><td style="text-align:center">控制Y方向的缩放倍数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">Rotation</td><td style="text-align:center">控制以屏幕方向为轴的旋转度数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">RotationX</td><td style="text-align:center">控制以X轴为轴的旋转度数</td><td style="text-align:center">float</td></tr><tr><td style="text-align:center">RotationY</td><td style="text-align:center">控制以Y轴为轴的旋转度数</td><td style="text-align:center">float</td></tr></tbody></table></div>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android秋招面试总结（转载）</title>
      <link href="/2018/09/19/Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/"/>
      <url>/2018/09/19/Android%E7%A7%8B%E6%8B%9B%E9%9D%A2%E8%AF%95%E6%80%BB%E7%BB%93%EF%BC%88%E8%BD%AC%E8%BD%BD%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h3 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h3><h4 id="Activity"><a href="#Activity" class="headerlink" title="Activity"></a>Activity</h4><ul><li>Activity的生命周期</li><li>onStart()和onResume()/onPause()和onStop()的区别</li><li>Activity A启动另一个Activity B会回调哪些方法？如果Activity B是完全透明呢？如果启动的是一个Dialog呢？</li><li>谈谈onSaveInstanceState()方法？何时会调用？</li><li>如何避免配置改变时Activity重建？</li><li>优先级低的Activity在内存不足被回收后怎样做可以恢复到销毁前状态？</li><li>说下Activity的四种启动模式？</li><li>谈谈singleTop和singleTask的区别以及应用场景</li><li>onNewIntent()调用时机？</li><li>了解哪些Activity启动模式的标记位？</li><li>如何启动其他应用的Activity？</li><li>Activity的启动过程？</li></ul><h4 id="Fragment"><a href="#Fragment" class="headerlink" title="Fragment"></a>Fragment</h4><ul><li>Fragment的生命周期</li><li>Activity和Fragment的异同</li><li>Activity和Fragment的关系</li><li>何时会考虑使用Fragment</li></ul><h4 id="Service"><a href="#Service" class="headerlink" title="Service"></a>Service</h4><ul><li><p>Service的生命周期</p></li><li><p>Service的两种启动方式？区别在哪</p></li><li><p>一个Activty先start一个Service后，再bind时会回调什么方法？此时如何做才能回调Service的destory()方法？</p></li><li>Service如何和Activity进行通信？</li><li>用过哪些系统Service？</li><li>是否能在Service进行耗时操作？如果非要可以怎么做？</li><li>AlarmManager能实现定时的原理？</li><li>前台服务是什么？和普通服务的不同？如何去开启一个前台服务？</li><li>是否了解ActivityManagerService，谈谈它发挥什么作用？</li><li>如何保证Service不被杀死？</li></ul><h4 id="Broadcast-Receiver"><a href="#Broadcast-Receiver" class="headerlink" title="Broadcast Receiver"></a>Broadcast Receiver</h4><ul><li>广播有几种形式？什么特点？</li><li>广播的两种注册形式？区别在哪？</li></ul><h4 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h4><ul><li>ContentProvider了解多少？</li></ul><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><ul><li>Android中提供哪些数据持久存储的方法？</li><li>Java中的I/O流读写怎么做？</li><li>SharePreferences适用情形？使用中需要注意什么？</li><li>了解SQLite中的事务处理吗？是如何做的？</li><li>使用SQLite做批量操作有什么好的方法吗？</li><li>如果现在要删除SQLite中表的一个字段如何做？</li><li>使用SQLite时会有哪些优化操作?</li></ul><h4 id="IPC"><a href="#IPC" class="headerlink" title="IPC"></a>IPC</h4><ul><li>Android中进程和线程的关系？区别？</li><li>为何需要进行IPC？多进程通信可能会出现什么问题？</li><li>什么是序列化？Serializable接口和Parcelable接口的区别？为何推荐使用后者？</li><li>Android中为何新增Binder来作为主要的IPC方式？</li><li>使用Binder进行数据传输的具体过程？</li><li>Binder框架中ServiceManager的作用？</li><li>Android中有哪些基于Binder的IPC方式？简单对比下？</li><li>是否了解AIDL？原理是什么？如何优化多模块都使用AIDL的情况？</li></ul><h4 id="View"><a href="#View" class="headerlink" title="View"></a>View</h4><ul><li>MotionEvent是什么？包含几种事件？什么条件下会产生？</li><li>scrollTo()和scrollBy()的区别？</li><li>Scroller中最重要的两个方法是什么？主要目的是？</li><li>谈一谈View的事件分发机制？</li><li>如何解决View的滑动冲突？</li><li>谈一谈View的工作原理？</li><li>MeasureSpec是什么？有什么作用？</li><li>自定义View/ViewGroup需要注意什么？</li><li>onTouch()、onTouchEvent()和onClick()关系？</li><li>SurfaceView和View的区别？</li><li>invalidate()和postInvalidate()的区别？</li></ul><h4 id="Drawable等资源"><a href="#Drawable等资源" class="headerlink" title="Drawable等资源"></a>Drawable等资源</h4><ul><li>了解哪些Drawable？适用场景？</li><li>mipmap系列中xxxhdpi、xxhdpi、xhdpi、hdpi、mdpi和ldpi存在怎样的关系？</li><li>dp、dpi、px的区别？</li><li>res目录和assets目录的区别？</li></ul><h4 id="Animation"><a href="#Animation" class="headerlink" title="Animation"></a>Animation</h4><ul><li>Android中有哪几种类型的动画？</li><li>帧动画在使用时需要注意什么？</li><li>View动画和属性动画的区别？</li><li>View动画为何不能真正改变View的位置？而属性动画为何可以？</li><li>属性动画插值器和估值器的作用？</li></ul><h4 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h4><ul><li>Activity、View、Window三者之间的关系</li><li>Window有哪几种类型？</li><li>Activity创建和Dialog创建过程的异同？</li></ul><h4 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h4><ul><li>谈谈消息机制Hander？作用？有哪些要素？流程是怎样的？</li><li>为什么系统不建议在子线程访问UI？</li><li>一个Thread可以有几个Looper？几个Handler？</li><li>如何将一个Thread线程变成Looper线程？Looper线程有哪些特点？</li><li>可以在子线程直接new一个Handler吗？那该怎么做？</li><li>Message可以如何创建？哪种效果更好，为什么？</li><li>这里的ThreadLocal有什么作用？</li><li>主线程中Looper的轮询死循环为何没有阻塞主线程？</li><li>使用Hanlder的postDealy()后消息队列会发生什么变化？</li></ul><h4 id="线程"><a href="#线程" class="headerlink" title="线程"></a>线程</h4><ul><li>Android中还了解哪些方便线程切换的类？</li><li>AsyncTask相比Handler有什么优点？不足呢？</li><li>使用AsyncTask需要注意什么？</li><li>AsyncTask中使用的线程池大小？</li><li>HandlerThread有什么特点？</li><li>快速实现子线程使用Handler</li><li>IntentService的特点？</li><li>为何不用bindService方式创建IntentService？</li><li>线程池的好处、原理、类型？</li><li>ThreadPoolExecutor的工作策略？</li><li>什么是ANR？什么情况会出现ANR？如何避免？在不看代码的情况下如何快速定位出现ANR问题所在？</li></ul><h4 id="Bitmap"><a href="#Bitmap" class="headerlink" title="Bitmap"></a>Bitmap</h4><ul><li>加载图片的时候需要注意什么？</li><li>LRU算法的原理？</li><li>Android中缓存更新策略？</li></ul><h4 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h4><ul><li>项目中如何做性能优化的？</li><li>了解哪些性能优化的工具？</li><li>布局上如何优化？列表呢？</li><li>内存泄漏是什么？为什么会发生？常见哪些内存泄漏的例子？都是怎么解决的？</li><li>内存泄漏和内存溢出的区别？</li><li>什么情况会导致内存溢出？</li></ul><h4 id="Android新特征"><a href="#Android新特征" class="headerlink" title="Android新特征"></a>Android新特征</h4><ul><li>是否了解和使用过谷歌推出的新技术？</li><li>有了解刚发布的Android P的特性吗？</li><li>Kotlin对Java做了哪些优化？</li></ul><h3 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h3><h4 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h4><ul><li>面向对象编程的四大特性及其含义</li><li>String、StringBuffer和StringBuilder的区别</li><li>String a = “”和String a = new String(“”)的关系和异同</li><li>Object的equal()和==的区别</li><li>装箱、拆箱的含义</li><li>int和Integer的区别</li><li>遇见过哪些运行时的异常？异常处理机制？</li><li>什么是反射？有什么作用和应用？</li><li>什么是内部类？有什么作用？静态内部类和非静态内部类的区别？</li><li>final、finally、finalize()分别表示什么含义？</li><li>重写和重载的区别？</li><li>抽象类和接口的异同？</li><li>为什么匿名内部类中使用局部变量要用final修饰？</li><li>Object有哪些公用方法？</li></ul><h4 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h4><ul><li>Java集合框架中有哪些类？都有什么特点？</li><li>集合、数组、泛型的关系，并比较</li><li>ArrayList和LinkedList的区别</li><li>ArrayList和Vector的区别</li><li>HashSet和TreeSet的区别</li><li>HashMap和HashTable的区别</li><li>HashMap在put、get元素的过程？体现了什么数据结构？</li><li>如何解决Hash冲突</li><li>如何保证HashMap线程安全？什么原理？</li><li>HashMap是有序的吗？如何实现有序？</li><li>HashMap是如何扩容的？如何避免扩容？</li><li>hashcode()的作用，与equal()有什么区别？</li></ul><h4 id="并发"><a href="#并发" class="headerlink" title="并发"></a>并发</h4><ul><li>开启一个线程的方法有哪些？销毁一个线程的方法呢？</li><li>同步和非同步、阻塞和非阻塞的概念</li><li>Thread的join()有什么作用？</li><li>线程有哪些状态？</li><li>什么是线程安全？保障线程安全有哪些手段？</li><li>ReentrantLock和synchronized的区别?</li><li>synchronized和volatile的区别？</li><li>synchronized同步代码块还有同步方法本质上锁住的是谁？为什么？</li><li>sleep()和wait()的区别</li></ul><h4 id="Java新动态"><a href="#Java新动态" class="headerlink" title="Java新动态"></a>Java新动态</h4><ul><li>是否了解Java1.x的特性吗？</li><li>谈谈对面向过程编程、面向对象编程还有面向切面编程的理解</li></ul><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h3><h4 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h4><ul><li>五层协议的体系结构分别是什么？每一层都有哪些协议？</li><li>为什么有MAC地址还要IP地址？</li></ul><h4 id="TCP"><a href="#TCP" class="headerlink" title="TCP"></a>TCP</h4><ul><li>TCP和UDP的区别？</li><li>拥塞控制和流量控制都是什么，两者的区别？</li><li>谈谈TCP为什么要三次握手？为什么要四次握手？</li><li>播放视频用TCP还是UDP？为什么？</li></ul><h4 id="HTTP"><a href="#HTTP" class="headerlink" title="HTTP"></a>HTTP</h4><ul><li><p>了解哪些响应状态码？</p></li><li><p>get和post的区别？</p></li><li><p>Http1.0、Http1.1、Http2.0的区别？</p></li><li><p>HTTP和TCP的区别？</p></li><li><p>HTTP和HTTPS的区别？<br>HTTP和Socket的区别？</p></li><li><p>在地址栏输入<a href="http://www.baidu.com会发生什么？" target="_blank" rel="noopener">http://www.baidu.com会发生什么？</a></p><p>A：地址链接会转化为<a href="https://www.baidu.com" target="_blank" rel="noopener">https://www.baidu.com</a></p></li></ul><h3 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h3><ul><li>操作系统中进程和线程的区别？</li><li>死锁的产生和避免？</li></ul><h3 id="数据结构和算法"><a href="#数据结构和算法" class="headerlink" title="数据结构和算法"></a>数据结构和算法</h3><ul><li>怎么理解数据结构？</li><li>什么是斐波那契数列？</li><li>迭代和递归的特点，并比较优缺点</li><li>了解哪些查找算法，时间复杂度都是多少？</li><li>了解哪些排序算法，并比较一下以及适用场景</li><li>快排的基本思路是什么？最差的时间复杂度是多少？如何优化？</li><li>AVL树插入或删除一个节点的过程是怎样的？</li><li>什么是红黑树？</li><li>（手写算法）二分查找</li><li>（手写算法）反转链表</li><li>（手写算法）用两个栈实现队列</li><li>（手写算法）多线程轮流打印问题</li><li>（手写算法）如何判断一个链有环/两条链交叉</li><li>（手写算法）快速从一组无序数中找到第k大的数/前k个大的数</li><li>（手写算法）最长（不）重复子串</li></ul><h3 id="设计模式"><a href="#设计模式" class="headerlink" title="设计模式"></a>设计模式</h3><ul><li>谈谈MVC、MVP和MVVM，好在哪里，不好在哪里？</li><li>如何理解生产者消费者模型？</li><li>是否能从Android中举几个例子说说用到了什么设计模式？</li><li>装饰模式和代理模式有哪些区别？</li><li>实现单例模式有几种方法？懒汉式中双层锁的目的是什么？两次判空的目的是什么？</li><li>谈谈了解的设计模式原则</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li>数据库中的事务了解吗？事务的四大特性？</li><li>如何理解数据库的范式？</li></ul><h3 id="版本"><a href="#版本" class="headerlink" title="版本"></a>版本</h3><ul><li>使用过哪些版本控制工具？git和svn的区别？</li><li>了解git工具吗？用过哪些命令？了解冲突时的git merge和git rebase的区别？</li></ul><h3 id="HR问题"><a href="#HR问题" class="headerlink" title="HR问题"></a>HR问题</h3><ul><li>简单介绍一下自己</li><li>谈谈项目经历，为什么会做，怎么做的，遇到的难点？</li><li>谈谈实习经历，做了什么，有哪些收获？</li><li>谈谈学习Android的经历，有哪些学习方法和技巧？</li><li>是否会考研，为何不考研？</li><li>成绩怎么样？奖学金情况？</li><li>职业规划？</li><li>为什么想来我们公司，为何不留在XXX？</li><li>对公司是否有了解？</li><li>为什么会选择做技术？对女生做开发的看法？</li><li>还投过哪些公司，进展如何？</li><li>家是哪里的？</li><li>平时有哪些兴趣爱好？大学参加了了哪些校园活动？</li><li>有女朋友吗？未来有什么规划？</li><li>评价一下自己的优缺点？用一些词形容你自己，别人都是怎样评价你的？</li><li>觉得自己的优势是什么？</li><li>如何看待加班？</li><li>意向工作城市是哪？是否考虑在XX长期发展？</li><li>对于薪酬有什么想法？</li><li>还有什么问题要问我的吗？</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面试 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>漫长旅途</title>
      <link href="/2018/01/15/%E6%BC%AB%E9%95%BF%E6%97%85%E9%80%94/"/>
      <url>/2018/01/15/%E6%BC%AB%E9%95%BF%E6%97%85%E9%80%94/</url>
      
        <content type="html"><![CDATA[<p>象征着父母的鲸鱼在童年陪我们嬉戏，虽然曾一度消失，但在我们被障碍物挡住的时候再度出现，帮助我们度过困难，其实父母一直在我们身后，就如同我们和爱人跟在自己的孩子身后一样。</p><p>当爱人永远留在了草丛中无法唤醒之后，人生的旅途变得孤单漫长寂寞，最后孩子的挽留也无法阻挡我们逝去的脚步。</p><p>当一生走到尽头的时候，正如作家毕淑敏所说的，人行将就木的时候，一生的轨迹会像微缩电影一样迅速放过，温馨的糖果盒里的童年，生如夏花般美好的青春，独自闯荡的不羁无畏，爱情的火花，得子的喜悦与责任……都如同精心剪裁的电影片段匆匆走过。</p><p>是的，每个人的一生都是短暂的，来时什么都是没有，走时什么也不带走，但当自己一生的电影一放而过时，弥留之际的最后留下的幸福是满足，那此生足矣。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤独者的任务是加倍孤独</title>
      <link href="/2018/01/13/%E5%AD%A4%E7%8B%AC%E8%80%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%8A%A0%E5%80%8D%E5%AD%A4%E7%8B%AC/"/>
      <url>/2018/01/13/%E5%AD%A4%E7%8B%AC%E8%80%85%E7%9A%84%E4%BB%BB%E5%8A%A1%E6%98%AF%E5%8A%A0%E5%80%8D%E5%AD%A4%E7%8B%AC/</url>
      
        <content type="html"><![CDATA[<p>天色稍有嫌疑，就要带上雨伞。</p><p>停电了，打开手机，打开电脑，出于本能的赶走黑暗。</p><p>是的，一直没有变，只是心里清楚，独居的时候，没有谁会来照顾自己。</p><p>需要沦落到赞美孤独的地步吗？</p><p>绝不。</p><p>赞美人性中的孤独，</p><p>等于什么也没有赞美。</p><p>但还可以继续努力吗？ </p><p>可以的。 </p><p>即使独自生活，也要努力照顾好自己。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>月长明——记北齐咸阳王斛律光</title>
      <link href="/2018/01/07/%E6%9C%88%E9%95%BF%E6%98%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%8C%97%E9%BD%90%E5%92%B8%E9%98%B3%E7%8E%8B%E6%96%9B%E5%BE%8B%E5%85%89/"/>
      <url>/2018/01/07/%E6%9C%88%E9%95%BF%E6%98%8E%E2%80%94%E2%80%94%E8%AE%B0%E5%8C%97%E9%BD%90%E5%92%B8%E9%98%B3%E7%8E%8B%E6%96%9B%E5%BE%8B%E5%85%89/</url>
      
        <content type="html"><![CDATA[<p>与诸多良将一样，他亦是年少成名。当年在洹桥的那一箭划破苍穹时，便注定了他必不平凡的命运。</p><p>几番浴血疆场，出生入死，为的就是他心中至死不曾相负的国家。</p><p>从涡河之岸逞强失利的懵懂少年到所过之处闻风丧胆的北齐战神，他一直都是他。</p><p>以自身耀眼的明月光守护着一个国家，无论国之兴衰，无论是成是败。</p><p>可是到了最后，他辅佐的最后一位君主，这个国家的倒数第二位主人，竟同朝堂奸佞一道谋害、背弃他。</p><p>生命的最后一刻，他方才明白，这个国家现在的君主最忌惮的便是他。</p><p>可这又如何呢，在他的心里，对这个国家所做的一切永远都是值得的，无论国家对他如何、对他的家人如何。</p><p>当御用刽子手刘桃枝将弓弦紧累上他脖子的那一刻，这位不可一世的咸阳王竟无半点反抗。只是轻蔑地向身后数人瞟了一眼，拼尽最后一丝力气说出此生的最后一句话：“<strong>我不负国家</strong>”。 </p><p>“不负国家”是对他一生最恰当的结语。凭这四个字，便足以将他摆在我最敬重之人的首位。如今千年光景已逝，为他留下的唯有一块难辨伪真的冰冷碑坟，和苍穹之上的清冷凉月。 </p><p>他是北齐书中最耀眼的明月光，千载之后，洗尽铅华，唯余最初守望家国的明亮。</p>]]></content>
      
      
      <categories>
          
          <category> 清新 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> He said </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
